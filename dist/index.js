var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
/******/ (function () {
    /******/ var __webpack_modules__ = ({
        /***/ 7351: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
                if (k2 === undefined)
                    k2 = k;
                Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
            }) : (function (o, m, k, k2) {
                if (k2 === undefined)
                    k2 = k;
                o[k2] = m[k];
            }));
            var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {
                Object.defineProperty(o, "default", { enumerable: true, value: v });
            }) : function (o, v) {
                o["default"] = v;
            });
            var __importStar = (this && this.__importStar) || function (mod) {
                if (mod && mod.__esModule)
                    return mod;
                var result = {};
                if (mod != null)
                    for (var k in mod)
                        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
                            __createBinding(result, mod, k);
                __setModuleDefault(result, mod);
                return result;
            };
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.issue = exports.issueCommand = void 0;
            var os = __importStar(__nccwpck_require__(2037));
            var utils_1 = __nccwpck_require__(5278);
            /**
             * Commands
             *
             * Command Format:
             *   ::name key=value,key=value::message
             *
             * Examples:
             *   ::warning::This is the message
             *   ::set-env name=MY_VAR::some value
             */
            function issueCommand(command, properties, message) {
                var cmd = new Command(command, properties, message);
                process.stdout.write(cmd.toString() + os.EOL);
            }
            exports.issueCommand = issueCommand;
            function issue(name, message) {
                if (message === void 0) { message = ''; }
                issueCommand(name, {}, message);
            }
            exports.issue = issue;
            var CMD_STRING = '::';
            var Command = /** @class */ (function () {
                function Command(command, properties, message) {
                    if (!command) {
                        command = 'missing.command';
                    }
                    this.command = command;
                    this.properties = properties;
                    this.message = message;
                }
                Command.prototype.toString = function () {
                    var cmdStr = CMD_STRING + this.command;
                    if (this.properties && Object.keys(this.properties).length > 0) {
                        cmdStr += ' ';
                        var first = true;
                        for (var key in this.properties) {
                            if (this.properties.hasOwnProperty(key)) {
                                var val = this.properties[key];
                                if (val) {
                                    if (first) {
                                        first = false;
                                    }
                                    else {
                                        cmdStr += ',';
                                    }
                                    cmdStr += "".concat(key, "=").concat(escapeProperty(val));
                                }
                            }
                        }
                    }
                    cmdStr += "".concat(CMD_STRING).concat(escapeData(this.message));
                    return cmdStr;
                };
                return Command;
            }());
            function escapeData(s) {
                return utils_1.toCommandValue(s)
                    .replace(/%/g, '%25')
                    .replace(/\r/g, '%0D')
                    .replace(/\n/g, '%0A');
            }
            function escapeProperty(s) {
                return utils_1.toCommandValue(s)
                    .replace(/%/g, '%25')
                    .replace(/\r/g, '%0D')
                    .replace(/\n/g, '%0A')
                    .replace(/:/g, '%3A')
                    .replace(/,/g, '%2C');
            }
            //# sourceMappingURL=command.js.map
            /***/ 
        }),
        /***/ 2186: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
                if (k2 === undefined)
                    k2 = k;
                Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
            }) : (function (o, m, k, k2) {
                if (k2 === undefined)
                    k2 = k;
                o[k2] = m[k];
            }));
            var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {
                Object.defineProperty(o, "default", { enumerable: true, value: v });
            }) : function (o, v) {
                o["default"] = v;
            });
            var __importStar = (this && this.__importStar) || function (mod) {
                if (mod && mod.__esModule)
                    return mod;
                var result = {};
                if (mod != null)
                    for (var k in mod)
                        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
                            __createBinding(result, mod, k);
                __setModuleDefault(result, mod);
                return result;
            };
            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
                function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) { try {
                        step(generator.next(value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function rejected(value) { try {
                        step(generator["throw"](value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
            };
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
            var command_1 = __nccwpck_require__(7351);
            var file_command_1 = __nccwpck_require__(717);
            var utils_1 = __nccwpck_require__(5278);
            var os = __importStar(__nccwpck_require__(2037));
            var path = __importStar(__nccwpck_require__(1017));
            var oidc_utils_1 = __nccwpck_require__(8041);
            /**
             * The code to exit an action
             */
            var ExitCode;
            (function (ExitCode) {
                /**
                 * A code indicating that the action was successful
                 */
                ExitCode[ExitCode["Success"] = 0] = "Success";
                /**
                 * A code indicating that the action was a failure
                 */
                ExitCode[ExitCode["Failure"] = 1] = "Failure";
            })(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
            //-----------------------------------------------------------------------
            // Variables
            //-----------------------------------------------------------------------
            /**
             * Sets env variable for this action and future actions in the job
             * @param name the name of the variable to set
             * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
             */
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            function exportVariable(name, val) {
                var convertedVal = utils_1.toCommandValue(val);
                process.env[name] = convertedVal;
                var filePath = process.env['GITHUB_ENV'] || '';
                if (filePath) {
                    return file_command_1.issueFileCommand('ENV', file_command_1.prepareKeyValueMessage(name, val));
                }
                command_1.issueCommand('set-env', { name: name }, convertedVal);
            }
            exports.exportVariable = exportVariable;
            /**
             * Registers a secret which will get masked from logs
             * @param secret value of the secret
             */
            function setSecret(secret) {
                command_1.issueCommand('add-mask', {}, secret);
            }
            exports.setSecret = setSecret;
            /**
             * Prepends inputPath to the PATH (for this action and future actions)
             * @param inputPath
             */
            function addPath(inputPath) {
                var filePath = process.env['GITHUB_PATH'] || '';
                if (filePath) {
                    file_command_1.issueFileCommand('PATH', inputPath);
                }
                else {
                    command_1.issueCommand('add-path', {}, inputPath);
                }
                process.env['PATH'] = "".concat(inputPath).concat(path.delimiter).concat(process.env['PATH']);
            }
            exports.addPath = addPath;
            /**
             * Gets the value of an input.
             * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
             * Returns an empty string if the value is not defined.
             *
             * @param     name     name of the input to get
             * @param     options  optional. See InputOptions.
             * @returns   string
             */
            function getInput(name, options) {
                var val = process.env["INPUT_".concat(name.replace(/ /g, '_').toUpperCase())] || '';
                if (options && options.required && !val) {
                    throw new Error("Input required and not supplied: ".concat(name));
                }
                if (options && options.trimWhitespace === false) {
                    return val;
                }
                return val.trim();
            }
            exports.getInput = getInput;
            /**
             * Gets the values of an multiline input.  Each value is also trimmed.
             *
             * @param     name     name of the input to get
             * @param     options  optional. See InputOptions.
             * @returns   string[]
             *
             */
            function getMultilineInput(name, options) {
                var inputs = getInput(name, options)
                    .split('\n')
                    .filter(function (x) { return x !== ''; });
                if (options && options.trimWhitespace === false) {
                    return inputs;
                }
                return inputs.map(function (input) { return input.trim(); });
            }
            exports.getMultilineInput = getMultilineInput;
            /**
             * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
             * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
             * The return value is also in boolean type.
             * ref: https://yaml.org/spec/1.2/spec.html#id2804923
             *
             * @param     name     name of the input to get
             * @param     options  optional. See InputOptions.
             * @returns   boolean
             */
            function getBooleanInput(name, options) {
                var trueValue = ['true', 'True', 'TRUE'];
                var falseValue = ['false', 'False', 'FALSE'];
                var val = getInput(name, options);
                if (trueValue.includes(val))
                    return true;
                if (falseValue.includes(val))
                    return false;
                throw new TypeError("Input does not meet YAML 1.2 \"Core Schema\" specification: ".concat(name, "\n") +
                    "Support boolean input list: `true | True | TRUE | false | False | FALSE`");
            }
            exports.getBooleanInput = getBooleanInput;
            /**
             * Sets the value of an output.
             *
             * @param     name     name of the output to set
             * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
             */
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            function setOutput(name, value) {
                var filePath = process.env['GITHUB_OUTPUT'] || '';
                if (filePath) {
                    return file_command_1.issueFileCommand('OUTPUT', file_command_1.prepareKeyValueMessage(name, value));
                }
                process.stdout.write(os.EOL);
                command_1.issueCommand('set-output', { name: name }, utils_1.toCommandValue(value));
            }
            exports.setOutput = setOutput;
            /**
             * Enables or disables the echoing of commands into stdout for the rest of the step.
             * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
             *
             */
            function setCommandEcho(enabled) {
                command_1.issue('echo', enabled ? 'on' : 'off');
            }
            exports.setCommandEcho = setCommandEcho;
            //-----------------------------------------------------------------------
            // Results
            //-----------------------------------------------------------------------
            /**
             * Sets the action status to failed.
             * When the action exits it will be with an exit code of 1
             * @param message add error issue message
             */
            function setFailed(message) {
                process.exitCode = ExitCode.Failure;
                error(message);
            }
            exports.setFailed = setFailed;
            //-----------------------------------------------------------------------
            // Logging Commands
            //-----------------------------------------------------------------------
            /**
             * Gets whether Actions Step Debug is on or not
             */
            function isDebug() {
                return process.env['RUNNER_DEBUG'] === '1';
            }
            exports.isDebug = isDebug;
            /**
             * Writes debug message to user log
             * @param message debug message
             */
            function debug(message) {
                command_1.issueCommand('debug', {}, message);
            }
            exports.debug = debug;
            /**
             * Adds an error issue
             * @param message error issue message. Errors will be converted to string via toString()
             * @param properties optional properties to add to the annotation.
             */
            function error(message, properties) {
                if (properties === void 0) { properties = {}; }
                command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
            }
            exports.error = error;
            /**
             * Adds a warning issue
             * @param message warning issue message. Errors will be converted to string via toString()
             * @param properties optional properties to add to the annotation.
             */
            function warning(message, properties) {
                if (properties === void 0) { properties = {}; }
                command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
            }
            exports.warning = warning;
            /**
             * Adds a notice issue
             * @param message notice issue message. Errors will be converted to string via toString()
             * @param properties optional properties to add to the annotation.
             */
            function notice(message, properties) {
                if (properties === void 0) { properties = {}; }
                command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
            }
            exports.notice = notice;
            /**
             * Writes info to log with console.log.
             * @param message info message
             */
            function info(message) {
                process.stdout.write(message + os.EOL);
            }
            exports.info = info;
            /**
             * Begin an output group.
             *
             * Output until the next `groupEnd` will be foldable in this group
             *
             * @param name The name of the output group
             */
            function startGroup(name) {
                command_1.issue('group', name);
            }
            exports.startGroup = startGroup;
            /**
             * End an output group.
             */
            function endGroup() {
                command_1.issue('endgroup');
            }
            exports.endGroup = endGroup;
            /**
             * Wrap an asynchronous function call in a group.
             *
             * Returns the same type as the function itself.
             *
             * @param name The name of the group
             * @param fn The function to wrap in the group
             */
            function group(name, fn) {
                return __awaiter(this, void 0, void 0, function () {
                    var result;
                    return __generator(this, function (_1) {
                        switch (_1.label) {
                            case 0:
                                startGroup(name);
                                _1.label = 1;
                            case 1:
                                _1.trys.push([1, , 3, 4]);
                                return [4 /*yield*/, fn()];
                            case 2:
                                result = _1.sent();
                                return [3 /*break*/, 4];
                            case 3:
                                endGroup();
                                return [7 /*endfinally*/];
                            case 4: return [2 /*return*/, result];
                        }
                    });
                });
            }
            exports.group = group;
            //-----------------------------------------------------------------------
            // Wrapper action state
            //-----------------------------------------------------------------------
            /**
             * Saves state for current action, the state can only be retrieved by this action's post job execution.
             *
             * @param     name     name of the state to store
             * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
             */
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            function saveState(name, value) {
                var filePath = process.env['GITHUB_STATE'] || '';
                if (filePath) {
                    return file_command_1.issueFileCommand('STATE', file_command_1.prepareKeyValueMessage(name, value));
                }
                command_1.issueCommand('save-state', { name: name }, utils_1.toCommandValue(value));
            }
            exports.saveState = saveState;
            /**
             * Gets the value of an state set by this action's main execution.
             *
             * @param     name     name of the state to get
             * @returns   string
             */
            function getState(name) {
                return process.env["STATE_".concat(name)] || '';
            }
            exports.getState = getState;
            function getIDToken(aud) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_1) {
                        switch (_1.label) {
                            case 0: return [4 /*yield*/, oidc_utils_1.OidcClient.getIDToken(aud)];
                            case 1: return [2 /*return*/, _1.sent()];
                        }
                    });
                });
            }
            exports.getIDToken = getIDToken;
            /**
             * Summary exports
             */
            var summary_1 = __nccwpck_require__(1327);
            Object.defineProperty(exports, "summary", ({ enumerable: true, get: function () { return summary_1.summary; } }));
            /**
             * @deprecated use core.summary
             */
            var summary_2 = __nccwpck_require__(1327);
            Object.defineProperty(exports, "markdownSummary", ({ enumerable: true, get: function () { return summary_2.markdownSummary; } }));
            /**
             * Path exports
             */
            var path_utils_1 = __nccwpck_require__(2981);
            Object.defineProperty(exports, "toPosixPath", ({ enumerable: true, get: function () { return path_utils_1.toPosixPath; } }));
            Object.defineProperty(exports, "toWin32Path", ({ enumerable: true, get: function () { return path_utils_1.toWin32Path; } }));
            Object.defineProperty(exports, "toPlatformPath", ({ enumerable: true, get: function () { return path_utils_1.toPlatformPath; } }));
            //# sourceMappingURL=core.js.map
            /***/ 
        }),
        /***/ 717: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            // For internal use, subject to change.
            var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
                if (k2 === undefined)
                    k2 = k;
                Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
            }) : (function (o, m, k, k2) {
                if (k2 === undefined)
                    k2 = k;
                o[k2] = m[k];
            }));
            var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {
                Object.defineProperty(o, "default", { enumerable: true, value: v });
            }) : function (o, v) {
                o["default"] = v;
            });
            var __importStar = (this && this.__importStar) || function (mod) {
                if (mod && mod.__esModule)
                    return mod;
                var result = {};
                if (mod != null)
                    for (var k in mod)
                        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
                            __createBinding(result, mod, k);
                __setModuleDefault(result, mod);
                return result;
            };
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.prepareKeyValueMessage = exports.issueFileCommand = void 0;
            // We use any as a valid input type
            /* eslint-disable @typescript-eslint/no-explicit-any */
            var fs = __importStar(__nccwpck_require__(7147));
            var os = __importStar(__nccwpck_require__(2037));
            var uuid_1 = __nccwpck_require__(5840);
            var utils_1 = __nccwpck_require__(5278);
            function issueFileCommand(command, message) {
                var filePath = process.env["GITHUB_".concat(command)];
                if (!filePath) {
                    throw new Error("Unable to find environment variable for file command ".concat(command));
                }
                if (!fs.existsSync(filePath)) {
                    throw new Error("Missing file at path: ".concat(filePath));
                }
                fs.appendFileSync(filePath, "".concat(utils_1.toCommandValue(message)).concat(os.EOL), {
                    encoding: 'utf8'
                });
            }
            exports.issueFileCommand = issueFileCommand;
            function prepareKeyValueMessage(key, value) {
                var delimiter = "ghadelimiter_".concat(uuid_1.v4());
                var convertedValue = utils_1.toCommandValue(value);
                // These should realistically never happen, but just in case someone finds a
                // way to exploit uuid generation let's not allow keys or values that contain
                // the delimiter.
                if (key.includes(delimiter)) {
                    throw new Error("Unexpected input: name should not contain the delimiter \"".concat(delimiter, "\""));
                }
                if (convertedValue.includes(delimiter)) {
                    throw new Error("Unexpected input: value should not contain the delimiter \"".concat(delimiter, "\""));
                }
                return "".concat(key, "<<").concat(delimiter).concat(os.EOL).concat(convertedValue).concat(os.EOL).concat(delimiter);
            }
            exports.prepareKeyValueMessage = prepareKeyValueMessage;
            //# sourceMappingURL=file-command.js.map
            /***/ 
        }),
        /***/ 8041: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
                function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) { try {
                        step(generator.next(value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function rejected(value) { try {
                        step(generator["throw"](value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
            };
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.OidcClient = void 0;
            var http_client_1 = __nccwpck_require__(6255);
            var auth_1 = __nccwpck_require__(5526);
            var core_1 = __nccwpck_require__(2186);
            var OidcClient = /** @class */ (function () {
                function OidcClient() {
                }
                OidcClient.createHttpClient = function (allowRetry, maxRetry) {
                    if (allowRetry === void 0) { allowRetry = true; }
                    if (maxRetry === void 0) { maxRetry = 10; }
                    var requestOptions = {
                        allowRetries: allowRetry,
                        maxRetries: maxRetry
                    };
                    return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
                };
                OidcClient.getRequestToken = function () {
                    var token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];
                    if (!token) {
                        throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');
                    }
                    return token;
                };
                OidcClient.getIDTokenUrl = function () {
                    var runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];
                    if (!runtimeUrl) {
                        throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');
                    }
                    return runtimeUrl;
                };
                OidcClient.getCall = function (id_token_url) {
                    var _a;
                    return __awaiter(this, void 0, void 0, function () {
                        var httpclient, res, id_token;
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0:
                                    httpclient = OidcClient.createHttpClient();
                                    return [4 /*yield*/, httpclient
                                            .getJson(id_token_url)["catch"](function (error) {
                                            throw new Error("Failed to get ID Token. \n \n        Error Code : ".concat(error.statusCode, "\n \n        Error Message: ").concat(error.message));
                                        })];
                                case 1:
                                    res = _1.sent();
                                    id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
                                    if (!id_token) {
                                        throw new Error('Response json body do not have ID Token field');
                                    }
                                    return [2 /*return*/, id_token];
                            }
                        });
                    });
                };
                OidcClient.getIDToken = function (audience) {
                    return __awaiter(this, void 0, void 0, function () {
                        var id_token_url, encodedAudience, id_token, error_1;
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0:
                                    _1.trys.push([0, 2, , 3]);
                                    id_token_url = OidcClient.getIDTokenUrl();
                                    if (audience) {
                                        encodedAudience = encodeURIComponent(audience);
                                        id_token_url = "".concat(id_token_url, "&audience=").concat(encodedAudience);
                                    }
                                    core_1.debug("ID token url is ".concat(id_token_url));
                                    return [4 /*yield*/, OidcClient.getCall(id_token_url)];
                                case 1:
                                    id_token = _1.sent();
                                    core_1.setSecret(id_token);
                                    return [2 /*return*/, id_token];
                                case 2:
                                    error_1 = _1.sent();
                                    throw new Error("Error message: ".concat(error_1.message));
                                case 3: return [2 /*return*/];
                            }
                        });
                    });
                };
                return OidcClient;
            }());
            exports.OidcClient = OidcClient;
            //# sourceMappingURL=oidc-utils.js.map
            /***/ 
        }),
        /***/ 2981: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
                if (k2 === undefined)
                    k2 = k;
                Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
            }) : (function (o, m, k, k2) {
                if (k2 === undefined)
                    k2 = k;
                o[k2] = m[k];
            }));
            var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {
                Object.defineProperty(o, "default", { enumerable: true, value: v });
            }) : function (o, v) {
                o["default"] = v;
            });
            var __importStar = (this && this.__importStar) || function (mod) {
                if (mod && mod.__esModule)
                    return mod;
                var result = {};
                if (mod != null)
                    for (var k in mod)
                        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
                            __createBinding(result, mod, k);
                __setModuleDefault(result, mod);
                return result;
            };
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;
            var path = __importStar(__nccwpck_require__(1017));
            /**
             * toPosixPath converts the given path to the posix form. On Windows, \\ will be
             * replaced with /.
             *
             * @param pth. Path to transform.
             * @return string Posix path.
             */
            function toPosixPath(pth) {
                return pth.replace(/[\\]/g, '/');
            }
            exports.toPosixPath = toPosixPath;
            /**
             * toWin32Path converts the given path to the win32 form. On Linux, / will be
             * replaced with \\.
             *
             * @param pth. Path to transform.
             * @return string Win32 path.
             */
            function toWin32Path(pth) {
                return pth.replace(/[/]/g, '\\');
            }
            exports.toWin32Path = toWin32Path;
            /**
             * toPlatformPath converts the given path to a platform-specific path. It does
             * this by replacing instances of / and \ with the platform-specific path
             * separator.
             *
             * @param pth The path to platformize.
             * @return string The platform-specific path.
             */
            function toPlatformPath(pth) {
                return pth.replace(/[/\\]/g, path.sep);
            }
            exports.toPlatformPath = toPlatformPath;
            //# sourceMappingURL=path-utils.js.map
            /***/ 
        }),
        /***/ 1327: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
                function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) { try {
                        step(generator.next(value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function rejected(value) { try {
                        step(generator["throw"](value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
            };
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
            var os_1 = __nccwpck_require__(2037);
            var fs_1 = __nccwpck_require__(7147);
            var _1 = fs_1.promises, access = _1.access, appendFile = _1.appendFile, writeFile = _1.writeFile;
            exports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';
            exports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';
            var Summary = /** @class */ (function () {
                function Summary() {
                    this._buffer = '';
                }
                /**
                 * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
                 * Also checks r/w permissions.
                 *
                 * @returns step summary file path
                 */
                Summary.prototype.filePath = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var pathFromEnv, _a_1;
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0:
                                    if (this._filePath) {
                                        return [2 /*return*/, this._filePath];
                                    }
                                    pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
                                    if (!pathFromEnv) {
                                        throw new Error("Unable to find environment variable for $".concat(exports.SUMMARY_ENV_VAR, ". Check if your runtime environment supports job summaries."));
                                    }
                                    _1.label = 1;
                                case 1:
                                    _1.trys.push([1, 3, , 4]);
                                    return [4 /*yield*/, access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK)];
                                case 2:
                                    _1.sent();
                                    return [3 /*break*/, 4];
                                case 3:
                                    _a_1 = _1.sent();
                                    throw new Error("Unable to access summary file: '".concat(pathFromEnv, "'. Check if the file has correct read/write permissions."));
                                case 4:
                                    this._filePath = pathFromEnv;
                                    return [2 /*return*/, this._filePath];
                            }
                        });
                    });
                };
                /**
                 * Wraps content in an HTML tag, adding any HTML attributes
                 *
                 * @param {string} tag HTML tag to wrap
                 * @param {string | null} content content within the tag
                 * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
                 *
                 * @returns {string} content wrapped in HTML element
                 */
                Summary.prototype.wrap = function (tag, content, attrs) {
                    if (attrs === void 0) { attrs = {}; }
                    var htmlAttrs = Object.entries(attrs)
                        .map(function (_1) {
                        var key = _1[0], value = _1[1];
                        return " ".concat(key, "=\"").concat(value, "\"");
                    })
                        .join('');
                    if (!content) {
                        return "<".concat(tag).concat(htmlAttrs, ">");
                    }
                    return "<".concat(tag).concat(htmlAttrs, ">").concat(content, "</").concat(tag, ">");
                };
                /**
                 * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
                 *
                 * @param {SummaryWriteOptions} [options] (optional) options for write operation
                 *
                 * @returns {Promise<Summary>} summary instance
                 */
                Summary.prototype.write = function (options) {
                    return __awaiter(this, void 0, void 0, function () {
                        var overwrite, filePath, writeFunc;
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0:
                                    overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
                                    return [4 /*yield*/, this.filePath()];
                                case 1:
                                    filePath = _1.sent();
                                    writeFunc = overwrite ? writeFile : appendFile;
                                    return [4 /*yield*/, writeFunc(filePath, this._buffer, { encoding: 'utf8' })];
                                case 2:
                                    _1.sent();
                                    return [2 /*return*/, this.emptyBuffer()];
                            }
                        });
                    });
                };
                /**
                 * Clears the summary buffer and wipes the summary file
                 *
                 * @returns {Summary} summary instance
                 */
                Summary.prototype.clear = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_1) {
                            return [2 /*return*/, this.emptyBuffer().write({ overwrite: true })];
                        });
                    });
                };
                /**
                 * Returns the current summary buffer as a string
                 *
                 * @returns {string} string of summary buffer
                 */
                Summary.prototype.stringify = function () {
                    return this._buffer;
                };
                /**
                 * If the summary buffer is empty
                 *
                 * @returns {boolen} true if the buffer is empty
                 */
                Summary.prototype.isEmptyBuffer = function () {
                    return this._buffer.length === 0;
                };
                /**
                 * Resets the summary buffer without writing to summary file
                 *
                 * @returns {Summary} summary instance
                 */
                Summary.prototype.emptyBuffer = function () {
                    this._buffer = '';
                    return this;
                };
                /**
                 * Adds raw text to the summary buffer
                 *
                 * @param {string} text content to add
                 * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
                 *
                 * @returns {Summary} summary instance
                 */
                Summary.prototype.addRaw = function (text, addEOL) {
                    if (addEOL === void 0) { addEOL = false; }
                    this._buffer += text;
                    return addEOL ? this.addEOL() : this;
                };
                /**
                 * Adds the operating system-specific end-of-line marker to the buffer
                 *
                 * @returns {Summary} summary instance
                 */
                Summary.prototype.addEOL = function () {
                    return this.addRaw(os_1.EOL);
                };
                /**
                 * Adds an HTML codeblock to the summary buffer
                 *
                 * @param {string} code content to render within fenced code block
                 * @param {string} lang (optional) language to syntax highlight code
                 *
                 * @returns {Summary} summary instance
                 */
                Summary.prototype.addCodeBlock = function (code, lang) {
                    var attrs = Object.assign({}, (lang && { lang: lang }));
                    var element = this.wrap('pre', this.wrap('code', code), attrs);
                    return this.addRaw(element).addEOL();
                };
                /**
                 * Adds an HTML list to the summary buffer
                 *
                 * @param {string[]} items list of items to render
                 * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
                 *
                 * @returns {Summary} summary instance
                 */
                Summary.prototype.addList = function (items, ordered) {
                    var _this_1 = this;
                    if (ordered === void 0) { ordered = false; }
                    var tag = ordered ? 'ol' : 'ul';
                    var listItems = items.map(function (item) { return _this_1.wrap('li', item); }).join('');
                    var element = this.wrap(tag, listItems);
                    return this.addRaw(element).addEOL();
                };
                /**
                 * Adds an HTML table to the summary buffer
                 *
                 * @param {SummaryTableCell[]} rows table rows
                 *
                 * @returns {Summary} summary instance
                 */
                Summary.prototype.addTable = function (rows) {
                    var _this_1 = this;
                    var tableBody = rows
                        .map(function (row) {
                        var cells = row
                            .map(function (cell) {
                            if (typeof cell === 'string') {
                                return _this_1.wrap('td', cell);
                            }
                            var header = cell.header, data = cell.data, colspan = cell.colspan, rowspan = cell.rowspan;
                            var tag = header ? 'th' : 'td';
                            var attrs = Object.assign(Object.assign({}, (colspan && { colspan: colspan })), (rowspan && { rowspan: rowspan }));
                            return _this_1.wrap(tag, data, attrs);
                        })
                            .join('');
                        return _this_1.wrap('tr', cells);
                    })
                        .join('');
                    var element = this.wrap('table', tableBody);
                    return this.addRaw(element).addEOL();
                };
                /**
                 * Adds a collapsable HTML details element to the summary buffer
                 *
                 * @param {string} label text for the closed state
                 * @param {string} content collapsable content
                 *
                 * @returns {Summary} summary instance
                 */
                Summary.prototype.addDetails = function (label, content) {
                    var element = this.wrap('details', this.wrap('summary', label) + content);
                    return this.addRaw(element).addEOL();
                };
                /**
                 * Adds an HTML image tag to the summary buffer
                 *
                 * @param {string} src path to the image you to embed
                 * @param {string} alt text description of the image
                 * @param {SummaryImageOptions} options (optional) addition image attributes
                 *
                 * @returns {Summary} summary instance
                 */
                Summary.prototype.addImage = function (src, alt, options) {
                    var _1 = options || {}, width = _1.width, height = _1.height;
                    var attrs = Object.assign(Object.assign({}, (width && { width: width })), (height && { height: height }));
                    var element = this.wrap('img', null, Object.assign({ src: src, alt: alt }, attrs));
                    return this.addRaw(element).addEOL();
                };
                /**
                 * Adds an HTML section heading element
                 *
                 * @param {string} text heading text
                 * @param {number | string} [level=1] (optional) the heading level, default: 1
                 *
                 * @returns {Summary} summary instance
                 */
                Summary.prototype.addHeading = function (text, level) {
                    var tag = "h".concat(level);
                    var allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)
                        ? tag
                        : 'h1';
                    var element = this.wrap(allowedTag, text);
                    return this.addRaw(element).addEOL();
                };
                /**
                 * Adds an HTML thematic break (<hr>) to the summary buffer
                 *
                 * @returns {Summary} summary instance
                 */
                Summary.prototype.addSeparator = function () {
                    var element = this.wrap('hr', null);
                    return this.addRaw(element).addEOL();
                };
                /**
                 * Adds an HTML line break (<br>) to the summary buffer
                 *
                 * @returns {Summary} summary instance
                 */
                Summary.prototype.addBreak = function () {
                    var element = this.wrap('br', null);
                    return this.addRaw(element).addEOL();
                };
                /**
                 * Adds an HTML blockquote to the summary buffer
                 *
                 * @param {string} text quote text
                 * @param {string} cite (optional) citation url
                 *
                 * @returns {Summary} summary instance
                 */
                Summary.prototype.addQuote = function (text, cite) {
                    var attrs = Object.assign({}, (cite && { cite: cite }));
                    var element = this.wrap('blockquote', text, attrs);
                    return this.addRaw(element).addEOL();
                };
                /**
                 * Adds an HTML anchor tag to the summary buffer
                 *
                 * @param {string} text link text/content
                 * @param {string} href hyperlink
                 *
                 * @returns {Summary} summary instance
                 */
                Summary.prototype.addLink = function (text, href) {
                    var element = this.wrap('a', text, { href: href });
                    return this.addRaw(element).addEOL();
                };
                return Summary;
            }());
            var _summary = new Summary();
            /**
             * @deprecated use `core.summary`
             */
            exports.markdownSummary = _summary;
            exports.summary = _summary;
            //# sourceMappingURL=summary.js.map
            /***/ 
        }),
        /***/ 5278: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            // We use any as a valid input type
            /* eslint-disable @typescript-eslint/no-explicit-any */
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.toCommandProperties = exports.toCommandValue = void 0;
            /**
             * Sanitizes an input into a string so it can be passed into issueCommand safely
             * @param input input to sanitize into a string
             */
            function toCommandValue(input) {
                if (input === null || input === undefined) {
                    return '';
                }
                else if (typeof input === 'string' || input instanceof String) {
                    return input;
                }
                return JSON.stringify(input);
            }
            exports.toCommandValue = toCommandValue;
            /**
             *
             * @param annotationProperties
             * @returns The command properties to send with the actual annotation command
             * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
             */
            function toCommandProperties(annotationProperties) {
                if (!Object.keys(annotationProperties).length) {
                    return {};
                }
                return {
                    title: annotationProperties.title,
                    file: annotationProperties.file,
                    line: annotationProperties.startLine,
                    endLine: annotationProperties.endLine,
                    col: annotationProperties.startColumn,
                    endColumn: annotationProperties.endColumn
                };
            }
            exports.toCommandProperties = toCommandProperties;
            //# sourceMappingURL=utils.js.map
            /***/ 
        }),
        /***/ 4087: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.Context = void 0;
            var fs_1 = __nccwpck_require__(7147);
            var os_1 = __nccwpck_require__(2037);
            var Context = /** @class */ (function () {
                /**
                 * Hydrate the context from the environment
                 */
                function Context() {
                    var _a, _b, _c;
                    this.payload = {};
                    if (process.env.GITHUB_EVENT_PATH) {
                        if (fs_1.existsSync(process.env.GITHUB_EVENT_PATH)) {
                            this.payload = JSON.parse(fs_1.readFileSync(process.env.GITHUB_EVENT_PATH, { encoding: 'utf8' }));
                        }
                        else {
                            var path = process.env.GITHUB_EVENT_PATH;
                            process.stdout.write("GITHUB_EVENT_PATH ".concat(path, " does not exist").concat(os_1.EOL));
                        }
                    }
                    this.eventName = process.env.GITHUB_EVENT_NAME;
                    this.sha = process.env.GITHUB_SHA;
                    this.ref = process.env.GITHUB_REF;
                    this.workflow = process.env.GITHUB_WORKFLOW;
                    this.action = process.env.GITHUB_ACTION;
                    this.actor = process.env.GITHUB_ACTOR;
                    this.job = process.env.GITHUB_JOB;
                    this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10);
                    this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);
                    this.apiUrl = (_a = process.env.GITHUB_API_URL) !== null && _a !== void 0 ? _a : "https://api.github.com";
                    this.serverUrl = (_b = process.env.GITHUB_SERVER_URL) !== null && _b !== void 0 ? _b : "https://github.com";
                    this.graphqlUrl = (_c = process.env.GITHUB_GRAPHQL_URL) !== null && _c !== void 0 ? _c : "https://api.github.com/graphql";
                }
                Object.defineProperty(Context.prototype, "issue", {
                    get: function () {
                        var payload = this.payload;
                        return Object.assign(Object.assign({}, this.repo), { number: (payload.issue || payload.pull_request || payload).number });
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(Context.prototype, "repo", {
                    get: function () {
                        if (process.env.GITHUB_REPOSITORY) {
                            var _1 = process.env.GITHUB_REPOSITORY.split('/'), owner = _1[0], repo = _1[1];
                            return { owner: owner, repo: repo };
                        }
                        if (this.payload.repository) {
                            return {
                                owner: this.payload.repository.owner.login,
                                repo: this.payload.repository.name
                            };
                        }
                        throw new Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
                    },
                    enumerable: false,
                    configurable: true
                });
                return Context;
            }());
            exports.Context = Context;
            //# sourceMappingURL=context.js.map
            /***/ 
        }),
        /***/ 5438: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
                if (k2 === undefined)
                    k2 = k;
                Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
            }) : (function (o, m, k, k2) {
                if (k2 === undefined)
                    k2 = k;
                o[k2] = m[k];
            }));
            var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {
                Object.defineProperty(o, "default", { enumerable: true, value: v });
            }) : function (o, v) {
                o["default"] = v;
            });
            var __importStar = (this && this.__importStar) || function (mod) {
                if (mod && mod.__esModule)
                    return mod;
                var result = {};
                if (mod != null)
                    for (var k in mod)
                        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
                            __createBinding(result, mod, k);
                __setModuleDefault(result, mod);
                return result;
            };
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.getOctokit = exports.context = void 0;
            var Context = __importStar(__nccwpck_require__(4087));
            var utils_1 = __nccwpck_require__(3030);
            exports.context = new Context.Context();
            /**
             * Returns a hydrated octokit ready to use for GitHub Actions
             *
             * @param     token    the repo PAT or GITHUB_TOKEN
             * @param     options  other options to set
             */
            function getOctokit(token, options) {
                var _1;
                var additionalPlugins = [];
                for (var _2 = 2; _2 < arguments.length; _2++) {
                    additionalPlugins[_2 - 2] = arguments[_2];
                }
                var GitHubWithPlugins = (_1 = utils_1.GitHub).plugin.apply(_1, additionalPlugins);
                return new GitHubWithPlugins(utils_1.getOctokitOptions(token, options));
            }
            exports.getOctokit = getOctokit;
            //# sourceMappingURL=github.js.map
            /***/ 
        }),
        /***/ 7914: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
                if (k2 === undefined)
                    k2 = k;
                Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
            }) : (function (o, m, k, k2) {
                if (k2 === undefined)
                    k2 = k;
                o[k2] = m[k];
            }));
            var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {
                Object.defineProperty(o, "default", { enumerable: true, value: v });
            }) : function (o, v) {
                o["default"] = v;
            });
            var __importStar = (this && this.__importStar) || function (mod) {
                if (mod && mod.__esModule)
                    return mod;
                var result = {};
                if (mod != null)
                    for (var k in mod)
                        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
                            __createBinding(result, mod, k);
                __setModuleDefault(result, mod);
                return result;
            };
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.getApiBaseUrl = exports.getProxyAgent = exports.getAuthString = void 0;
            var httpClient = __importStar(__nccwpck_require__(6255));
            function getAuthString(token, options) {
                if (!token && !options.auth) {
                    throw new Error('Parameter token or opts.auth is required');
                }
                else if (token && options.auth) {
                    throw new Error('Parameters token and opts.auth may not both be specified');
                }
                return typeof options.auth === 'string' ? options.auth : "token ".concat(token);
            }
            exports.getAuthString = getAuthString;
            function getProxyAgent(destinationUrl) {
                var hc = new httpClient.HttpClient();
                return hc.getAgent(destinationUrl);
            }
            exports.getProxyAgent = getProxyAgent;
            function getApiBaseUrl() {
                return process.env['GITHUB_API_URL'] || 'https://api.github.com';
            }
            exports.getApiBaseUrl = getApiBaseUrl;
            //# sourceMappingURL=utils.js.map
            /***/ 
        }),
        /***/ 3030: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
                if (k2 === undefined)
                    k2 = k;
                Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
            }) : (function (o, m, k, k2) {
                if (k2 === undefined)
                    k2 = k;
                o[k2] = m[k];
            }));
            var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {
                Object.defineProperty(o, "default", { enumerable: true, value: v });
            }) : function (o, v) {
                o["default"] = v;
            });
            var __importStar = (this && this.__importStar) || function (mod) {
                if (mod && mod.__esModule)
                    return mod;
                var result = {};
                if (mod != null)
                    for (var k in mod)
                        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
                            __createBinding(result, mod, k);
                __setModuleDefault(result, mod);
                return result;
            };
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.getOctokitOptions = exports.GitHub = exports.defaults = exports.context = void 0;
            var Context = __importStar(__nccwpck_require__(4087));
            var Utils = __importStar(__nccwpck_require__(7914));
            // octokit + plugins
            var core_1 = __nccwpck_require__(6762);
            var plugin_rest_endpoint_methods_1 = __nccwpck_require__(3044);
            var plugin_paginate_rest_1 = __nccwpck_require__(4193);
            exports.context = new Context.Context();
            var baseUrl = Utils.getApiBaseUrl();
            exports.defaults = {
                baseUrl: baseUrl,
                request: {
                    agent: Utils.getProxyAgent(baseUrl)
                }
            };
            exports.GitHub = core_1.Octokit.plugin(plugin_rest_endpoint_methods_1.restEndpointMethods, plugin_paginate_rest_1.paginateRest).defaults(exports.defaults);
            /**
             * Convience function to correctly format Octokit Options to pass into the constructor.
             *
             * @param     token    the repo PAT or GITHUB_TOKEN
             * @param     options  other options to set
             */
            function getOctokitOptions(token, options) {
                var opts = Object.assign({}, options || {}); // Shallow clone - don't mutate the object provided by the caller
                // Auth
                var auth = Utils.getAuthString(token, opts);
                if (auth) {
                    opts.auth = auth;
                }
                return opts;
            }
            exports.getOctokitOptions = getOctokitOptions;
            //# sourceMappingURL=utils.js.map
            /***/ 
        }),
        /***/ 5526: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
                function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) { try {
                        step(generator.next(value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function rejected(value) { try {
                        step(generator["throw"](value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
            };
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;
            var BasicCredentialHandler = /** @class */ (function () {
                function BasicCredentialHandler(username, password) {
                    this.username = username;
                    this.password = password;
                }
                BasicCredentialHandler.prototype.prepareRequest = function (options) {
                    if (!options.headers) {
                        throw Error('The request has no headers');
                    }
                    options.headers['Authorization'] = "Basic ".concat(Buffer.from("".concat(this.username, ":").concat(this.password)).toString('base64'));
                };
                // This handler cannot handle 401
                BasicCredentialHandler.prototype.canHandleAuthentication = function () {
                    return false;
                };
                BasicCredentialHandler.prototype.handleAuthentication = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_1) {
                            throw new Error('not implemented');
                        });
                    });
                };
                return BasicCredentialHandler;
            }());
            exports.BasicCredentialHandler = BasicCredentialHandler;
            var BearerCredentialHandler = /** @class */ (function () {
                function BearerCredentialHandler(token) {
                    this.token = token;
                }
                // currently implements pre-authorization
                // TODO: support preAuth = false where it hooks on 401
                BearerCredentialHandler.prototype.prepareRequest = function (options) {
                    if (!options.headers) {
                        throw Error('The request has no headers');
                    }
                    options.headers['Authorization'] = "Bearer ".concat(this.token);
                };
                // This handler cannot handle 401
                BearerCredentialHandler.prototype.canHandleAuthentication = function () {
                    return false;
                };
                BearerCredentialHandler.prototype.handleAuthentication = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_1) {
                            throw new Error('not implemented');
                        });
                    });
                };
                return BearerCredentialHandler;
            }());
            exports.BearerCredentialHandler = BearerCredentialHandler;
            var PersonalAccessTokenCredentialHandler = /** @class */ (function () {
                function PersonalAccessTokenCredentialHandler(token) {
                    this.token = token;
                }
                // currently implements pre-authorization
                // TODO: support preAuth = false where it hooks on 401
                PersonalAccessTokenCredentialHandler.prototype.prepareRequest = function (options) {
                    if (!options.headers) {
                        throw Error('The request has no headers');
                    }
                    options.headers['Authorization'] = "Basic ".concat(Buffer.from("PAT:".concat(this.token)).toString('base64'));
                };
                // This handler cannot handle 401
                PersonalAccessTokenCredentialHandler.prototype.canHandleAuthentication = function () {
                    return false;
                };
                PersonalAccessTokenCredentialHandler.prototype.handleAuthentication = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_1) {
                            throw new Error('not implemented');
                        });
                    });
                };
                return PersonalAccessTokenCredentialHandler;
            }());
            exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
            //# sourceMappingURL=auth.js.map
            /***/ 
        }),
        /***/ 6255: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            /* eslint-disable @typescript-eslint/no-explicit-any */
            var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
                if (k2 === undefined)
                    k2 = k;
                Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
            }) : (function (o, m, k, k2) {
                if (k2 === undefined)
                    k2 = k;
                o[k2] = m[k];
            }));
            var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {
                Object.defineProperty(o, "default", { enumerable: true, value: v });
            }) : function (o, v) {
                o["default"] = v;
            });
            var __importStar = (this && this.__importStar) || function (mod) {
                if (mod && mod.__esModule)
                    return mod;
                var result = {};
                if (mod != null)
                    for (var k in mod)
                        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
                            __createBinding(result, mod, k);
                __setModuleDefault(result, mod);
                return result;
            };
            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
                function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) { try {
                        step(generator.next(value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function rejected(value) { try {
                        step(generator["throw"](value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
            };
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
            var http = __importStar(__nccwpck_require__(3685));
            var https = __importStar(__nccwpck_require__(5687));
            var pm = __importStar(__nccwpck_require__(9835));
            var tunnel = __importStar(__nccwpck_require__(4294));
            var HttpCodes;
            (function (HttpCodes) {
                HttpCodes[HttpCodes["OK"] = 200] = "OK";
                HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";
                HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";
                HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";
                HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";
                HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";
                HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";
                HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";
                HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";
                HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";
                HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";
                HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";
                HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";
                HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";
                HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";
                HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";
                HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";
                HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
                HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";
                HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";
                HttpCodes[HttpCodes["Gone"] = 410] = "Gone";
                HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";
                HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";
                HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";
                HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";
                HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";
                HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";
            })(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));
            var Headers;
            (function (Headers) {
                Headers["Accept"] = "accept";
                Headers["ContentType"] = "content-type";
            })(Headers = exports.Headers || (exports.Headers = {}));
            var MediaTypes;
            (function (MediaTypes) {
                MediaTypes["ApplicationJson"] = "application/json";
            })(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));
            /**
             * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
             * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
             */
            function getProxyUrl(serverUrl) {
                var proxyUrl = pm.getProxyUrl(new URL(serverUrl));
                return proxyUrl ? proxyUrl.href : '';
            }
            exports.getProxyUrl = getProxyUrl;
            var HttpRedirectCodes = [
                HttpCodes.MovedPermanently,
                HttpCodes.ResourceMoved,
                HttpCodes.SeeOther,
                HttpCodes.TemporaryRedirect,
                HttpCodes.PermanentRedirect
            ];
            var HttpResponseRetryCodes = [
                HttpCodes.BadGateway,
                HttpCodes.ServiceUnavailable,
                HttpCodes.GatewayTimeout
            ];
            var RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];
            var ExponentialBackoffCeiling = 10;
            var ExponentialBackoffTimeSlice = 5;
            var HttpClientError = /** @class */ (function (_super) {
                __extends(HttpClientError, _super);
                function HttpClientError(message, statusCode) {
                    var _this_1 = _super.call(this, message) || this;
                    _this_1.name = 'HttpClientError';
                    _this_1.statusCode = statusCode;
                    Object.setPrototypeOf(_this_1, HttpClientError.prototype);
                    return _this_1;
                }
                return HttpClientError;
            }(Error));
            exports.HttpClientError = HttpClientError;
            var HttpClientResponse = /** @class */ (function () {
                function HttpClientResponse(message) {
                    this.message = message;
                }
                HttpClientResponse.prototype.readBody = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this_1 = this;
                        return __generator(this, function (_1) {
                            return [2 /*return*/, new Promise(function (resolve) { return __awaiter(_this_1, void 0, void 0, function () {
                                    var output;
                                    return __generator(this, function (_1) {
                                        output = Buffer.alloc(0);
                                        this.message.on('data', function (chunk) {
                                            output = Buffer.concat([output, chunk]);
                                        });
                                        this.message.on('end', function () {
                                            resolve(output.toString());
                                        });
                                        return [2 /*return*/];
                                    });
                                }); })];
                        });
                    });
                };
                HttpClientResponse.prototype.readBodyBuffer = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this_1 = this;
                        return __generator(this, function (_1) {
                            return [2 /*return*/, new Promise(function (resolve) { return __awaiter(_this_1, void 0, void 0, function () {
                                    var chunks;
                                    return __generator(this, function (_1) {
                                        chunks = [];
                                        this.message.on('data', function (chunk) {
                                            chunks.push(chunk);
                                        });
                                        this.message.on('end', function () {
                                            resolve(Buffer.concat(chunks));
                                        });
                                        return [2 /*return*/];
                                    });
                                }); })];
                        });
                    });
                };
                return HttpClientResponse;
            }());
            exports.HttpClientResponse = HttpClientResponse;
            function isHttps(requestUrl) {
                var parsedUrl = new URL(requestUrl);
                return parsedUrl.protocol === 'https:';
            }
            exports.isHttps = isHttps;
            var HttpClient = /** @class */ (function () {
                function HttpClient(userAgent, handlers, requestOptions) {
                    this._ignoreSslError = false;
                    this._allowRedirects = true;
                    this._allowRedirectDowngrade = false;
                    this._maxRedirects = 50;
                    this._allowRetries = false;
                    this._maxRetries = 1;
                    this._keepAlive = false;
                    this._disposed = false;
                    this.userAgent = userAgent;
                    this.handlers = handlers || [];
                    this.requestOptions = requestOptions;
                    if (requestOptions) {
                        if (requestOptions.ignoreSslError != null) {
                            this._ignoreSslError = requestOptions.ignoreSslError;
                        }
                        this._socketTimeout = requestOptions.socketTimeout;
                        if (requestOptions.allowRedirects != null) {
                            this._allowRedirects = requestOptions.allowRedirects;
                        }
                        if (requestOptions.allowRedirectDowngrade != null) {
                            this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
                        }
                        if (requestOptions.maxRedirects != null) {
                            this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
                        }
                        if (requestOptions.keepAlive != null) {
                            this._keepAlive = requestOptions.keepAlive;
                        }
                        if (requestOptions.allowRetries != null) {
                            this._allowRetries = requestOptions.allowRetries;
                        }
                        if (requestOptions.maxRetries != null) {
                            this._maxRetries = requestOptions.maxRetries;
                        }
                    }
                }
                HttpClient.prototype.options = function (requestUrl, additionalHeaders) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_1) {
                            return [2 /*return*/, this.request('OPTIONS', requestUrl, null, additionalHeaders || {})];
                        });
                    });
                };
                HttpClient.prototype.get = function (requestUrl, additionalHeaders) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_1) {
                            return [2 /*return*/, this.request('GET', requestUrl, null, additionalHeaders || {})];
                        });
                    });
                };
                HttpClient.prototype.del = function (requestUrl, additionalHeaders) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_1) {
                            return [2 /*return*/, this.request('DELETE', requestUrl, null, additionalHeaders || {})];
                        });
                    });
                };
                HttpClient.prototype.post = function (requestUrl, data, additionalHeaders) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_1) {
                            return [2 /*return*/, this.request('POST', requestUrl, data, additionalHeaders || {})];
                        });
                    });
                };
                HttpClient.prototype.patch = function (requestUrl, data, additionalHeaders) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_1) {
                            return [2 /*return*/, this.request('PATCH', requestUrl, data, additionalHeaders || {})];
                        });
                    });
                };
                HttpClient.prototype.put = function (requestUrl, data, additionalHeaders) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_1) {
                            return [2 /*return*/, this.request('PUT', requestUrl, data, additionalHeaders || {})];
                        });
                    });
                };
                HttpClient.prototype.head = function (requestUrl, additionalHeaders) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_1) {
                            return [2 /*return*/, this.request('HEAD', requestUrl, null, additionalHeaders || {})];
                        });
                    });
                };
                HttpClient.prototype.sendStream = function (verb, requestUrl, stream, additionalHeaders) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_1) {
                            return [2 /*return*/, this.request(verb, requestUrl, stream, additionalHeaders)];
                        });
                    });
                };
                /**
                 * Gets a typed object from an endpoint
                 * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
                 */
                HttpClient.prototype.getJson = function (requestUrl, additionalHeaders) {
                    if (additionalHeaders === void 0) { additionalHeaders = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var res;
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0:
                                    additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
                                    return [4 /*yield*/, this.get(requestUrl, additionalHeaders)];
                                case 1:
                                    res = _1.sent();
                                    return [2 /*return*/, this._processResponse(res, this.requestOptions)];
                            }
                        });
                    });
                };
                HttpClient.prototype.postJson = function (requestUrl, obj, additionalHeaders) {
                    if (additionalHeaders === void 0) { additionalHeaders = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var data, res;
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0:
                                    data = JSON.stringify(obj, null, 2);
                                    additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
                                    additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
                                    return [4 /*yield*/, this.post(requestUrl, data, additionalHeaders)];
                                case 1:
                                    res = _1.sent();
                                    return [2 /*return*/, this._processResponse(res, this.requestOptions)];
                            }
                        });
                    });
                };
                HttpClient.prototype.putJson = function (requestUrl, obj, additionalHeaders) {
                    if (additionalHeaders === void 0) { additionalHeaders = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var data, res;
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0:
                                    data = JSON.stringify(obj, null, 2);
                                    additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
                                    additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
                                    return [4 /*yield*/, this.put(requestUrl, data, additionalHeaders)];
                                case 1:
                                    res = _1.sent();
                                    return [2 /*return*/, this._processResponse(res, this.requestOptions)];
                            }
                        });
                    });
                };
                HttpClient.prototype.patchJson = function (requestUrl, obj, additionalHeaders) {
                    if (additionalHeaders === void 0) { additionalHeaders = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var data, res;
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0:
                                    data = JSON.stringify(obj, null, 2);
                                    additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
                                    additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
                                    return [4 /*yield*/, this.patch(requestUrl, data, additionalHeaders)];
                                case 1:
                                    res = _1.sent();
                                    return [2 /*return*/, this._processResponse(res, this.requestOptions)];
                            }
                        });
                    });
                };
                /**
                 * Makes a raw http request.
                 * All other methods such as get, post, patch, and request ultimately call this.
                 * Prefer get, del, post and patch
                 */
                HttpClient.prototype.request = function (verb, requestUrl, data, headers) {
                    return __awaiter(this, void 0, void 0, function () {
                        var parsedUrl, info, maxTries, numTries, response, authenticationHandler, _1, _2, handler, redirectsRemaining, redirectUrl, parsedRedirectUrl, header;
                        return __generator(this, function (_3) {
                            switch (_3.label) {
                                case 0:
                                    if (this._disposed) {
                                        throw new Error('Client has already been disposed.');
                                    }
                                    parsedUrl = new URL(requestUrl);
                                    info = this._prepareRequest(verb, parsedUrl, headers);
                                    maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)
                                        ? this._maxRetries + 1
                                        : 1;
                                    numTries = 0;
                                    _3.label = 1;
                                case 1: return [4 /*yield*/, this.requestRaw(info, data)];
                                case 2:
                                    response = _3.sent();
                                    // Check if it's an authentication challenge
                                    if (response &&
                                        response.message &&
                                        response.message.statusCode === HttpCodes.Unauthorized) {
                                        authenticationHandler = void 0;
                                        for (_1 = 0, _2 = this.handlers; _1 < _2.length; _1++) {
                                            handler = _2[_1];
                                            if (handler.canHandleAuthentication(response)) {
                                                authenticationHandler = handler;
                                                break;
                                            }
                                        }
                                        if (authenticationHandler) {
                                            return [2 /*return*/, authenticationHandler.handleAuthentication(this, info, data)];
                                        }
                                        else {
                                            // We have received an unauthorized response but have no handlers to handle it.
                                            // Let the response return to the caller.
                                            return [2 /*return*/, response];
                                        }
                                    }
                                    redirectsRemaining = this._maxRedirects;
                                    _3.label = 3;
                                case 3:
                                    if (!(response.message.statusCode &&
                                        HttpRedirectCodes.includes(response.message.statusCode) &&
                                        this._allowRedirects &&
                                        redirectsRemaining > 0)) return [3 /*break*/, 6];
                                    redirectUrl = response.message.headers['location'];
                                    if (!redirectUrl) {
                                        // if there's no location to redirect to, we won't
                                        return [3 /*break*/, 6];
                                    }
                                    parsedRedirectUrl = new URL(redirectUrl);
                                    if (parsedUrl.protocol === 'https:' &&
                                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&
                                        !this._allowRedirectDowngrade) {
                                        throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');
                                    }
                                    // we need to finish reading the response before reassigning response
                                    // which will leak the open socket.
                                    return [4 /*yield*/, response.readBody()];
                                case 4:
                                    // we need to finish reading the response before reassigning response
                                    // which will leak the open socket.
                                    _3.sent();
                                    // strip authorization header if redirected to a different hostname
                                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                                        for (header in headers) {
                                            // header names are case insensitive
                                            if (header.toLowerCase() === 'authorization') {
                                                delete headers[header];
                                            }
                                        }
                                    }
                                    // let's make the request with the new redirectUrl
                                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);
                                    return [4 /*yield*/, this.requestRaw(info, data)];
                                case 5:
                                    response = _3.sent();
                                    redirectsRemaining--;
                                    return [3 /*break*/, 3];
                                case 6:
                                    if (!response.message.statusCode ||
                                        !HttpResponseRetryCodes.includes(response.message.statusCode)) {
                                        // If not a retry code, return immediately instead of retrying
                                        return [2 /*return*/, response];
                                    }
                                    numTries += 1;
                                    if (!(numTries < maxTries)) return [3 /*break*/, 9];
                                    return [4 /*yield*/, response.readBody()];
                                case 7:
                                    _3.sent();
                                    return [4 /*yield*/, this._performExponentialBackoff(numTries)];
                                case 8:
                                    _3.sent();
                                    _3.label = 9;
                                case 9:
                                    if (numTries < maxTries) return [3 /*break*/, 1];
                                    _3.label = 10;
                                case 10: return [2 /*return*/, response];
                            }
                        });
                    });
                };
                /**
                 * Needs to be called if keepAlive is set to true in request options.
                 */
                HttpClient.prototype.dispose = function () {
                    if (this._agent) {
                        this._agent.destroy();
                    }
                    this._disposed = true;
                };
                /**
                 * Raw request.
                 * @param info
                 * @param data
                 */
                HttpClient.prototype.requestRaw = function (info, data) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this_1 = this;
                        return __generator(this, function (_1) {
                            return [2 /*return*/, new Promise(function (resolve, reject) {
                                    function callbackForResult(err, res) {
                                        if (err) {
                                            reject(err);
                                        }
                                        else if (!res) {
                                            // If `err` is not passed, then `res` must be passed.
                                            reject(new Error('Unknown error'));
                                        }
                                        else {
                                            resolve(res);
                                        }
                                    }
                                    _this_1.requestRawWithCallback(info, data, callbackForResult);
                                })];
                        });
                    });
                };
                /**
                 * Raw request with callback.
                 * @param info
                 * @param data
                 * @param onResult
                 */
                HttpClient.prototype.requestRawWithCallback = function (info, data, onResult) {
                    if (typeof data === 'string') {
                        if (!info.options.headers) {
                            info.options.headers = {};
                        }
                        info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');
                    }
                    var callbackCalled = false;
                    function handleResult(err, res) {
                        if (!callbackCalled) {
                            callbackCalled = true;
                            onResult(err, res);
                        }
                    }
                    var req = info.httpModule.request(info.options, function (msg) {
                        var res = new HttpClientResponse(msg);
                        handleResult(undefined, res);
                    });
                    var socket;
                    req.on('socket', function (sock) {
                        socket = sock;
                    });
                    // If we ever get disconnected, we want the socket to timeout eventually
                    req.setTimeout(this._socketTimeout || 3 * 60000, function () {
                        if (socket) {
                            socket.end();
                        }
                        handleResult(new Error("Request timeout: ".concat(info.options.path)));
                    });
                    req.on('error', function (err) {
                        // err has statusCode property
                        // res should have headers
                        handleResult(err);
                    });
                    if (data && typeof data === 'string') {
                        req.write(data, 'utf8');
                    }
                    if (data && typeof data !== 'string') {
                        data.on('close', function () {
                            req.end();
                        });
                        data.pipe(req);
                    }
                    else {
                        req.end();
                    }
                };
                /**
                 * Gets an http agent. This function is useful when you need an http agent that handles
                 * routing through a proxy server - depending upon the url and proxy environment variables.
                 * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
                 */
                HttpClient.prototype.getAgent = function (serverUrl) {
                    var parsedUrl = new URL(serverUrl);
                    return this._getAgent(parsedUrl);
                };
                HttpClient.prototype._prepareRequest = function (method, requestUrl, headers) {
                    var info = {};
                    info.parsedUrl = requestUrl;
                    var usingSsl = info.parsedUrl.protocol === 'https:';
                    info.httpModule = usingSsl ? https : http;
                    var defaultPort = usingSsl ? 443 : 80;
                    info.options = {};
                    info.options.host = info.parsedUrl.hostname;
                    info.options.port = info.parsedUrl.port
                        ? parseInt(info.parsedUrl.port)
                        : defaultPort;
                    info.options.path =
                        (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');
                    info.options.method = method;
                    info.options.headers = this._mergeHeaders(headers);
                    if (this.userAgent != null) {
                        info.options.headers['user-agent'] = this.userAgent;
                    }
                    info.options.agent = this._getAgent(info.parsedUrl);
                    // gives handlers an opportunity to participate
                    if (this.handlers) {
                        for (var _1 = 0, _2 = this.handlers; _1 < _2.length; _1++) {
                            var handler = _2[_1];
                            handler.prepareRequest(info.options);
                        }
                    }
                    return info;
                };
                HttpClient.prototype._mergeHeaders = function (headers) {
                    if (this.requestOptions && this.requestOptions.headers) {
                        return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
                    }
                    return lowercaseKeys(headers || {});
                };
                HttpClient.prototype._getExistingOrDefaultHeader = function (additionalHeaders, header, _default) {
                    var clientHeader;
                    if (this.requestOptions && this.requestOptions.headers) {
                        clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
                    }
                    return additionalHeaders[header] || clientHeader || _default;
                };
                HttpClient.prototype._getAgent = function (parsedUrl) {
                    var agent;
                    var proxyUrl = pm.getProxyUrl(parsedUrl);
                    var useProxy = proxyUrl && proxyUrl.hostname;
                    if (this._keepAlive && useProxy) {
                        agent = this._proxyAgent;
                    }
                    if (this._keepAlive && !useProxy) {
                        agent = this._agent;
                    }
                    // if agent is already assigned use that agent.
                    if (agent) {
                        return agent;
                    }
                    var usingSsl = parsedUrl.protocol === 'https:';
                    var maxSockets = 100;
                    if (this.requestOptions) {
                        maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
                    }
                    // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.
                    if (proxyUrl && proxyUrl.hostname) {
                        var agentOptions = {
                            maxSockets: maxSockets,
                            keepAlive: this._keepAlive,
                            proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {
                                proxyAuth: "".concat(proxyUrl.username, ":").concat(proxyUrl.password)
                            })), { host: proxyUrl.hostname, port: proxyUrl.port })
                        };
                        var tunnelAgent = void 0;
                        var overHttps = proxyUrl.protocol === 'https:';
                        if (usingSsl) {
                            tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
                        }
                        else {
                            tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
                        }
                        agent = tunnelAgent(agentOptions);
                        this._proxyAgent = agent;
                    }
                    // if reusing agent across request and tunneling agent isn't assigned create a new agent
                    if (this._keepAlive && !agent) {
                        var options = { keepAlive: this._keepAlive, maxSockets: maxSockets };
                        agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
                        this._agent = agent;
                    }
                    // if not using private agent and tunnel agent isn't setup then use global agent
                    if (!agent) {
                        agent = usingSsl ? https.globalAgent : http.globalAgent;
                    }
                    if (usingSsl && this._ignoreSslError) {
                        // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
                        // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
                        // we have to cast it to any and change it directly
                        agent.options = Object.assign(agent.options || {}, {
                            rejectUnauthorized: false
                        });
                    }
                    return agent;
                };
                HttpClient.prototype._performExponentialBackoff = function (retryNumber) {
                    return __awaiter(this, void 0, void 0, function () {
                        var ms;
                        return __generator(this, function (_1) {
                            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
                            ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
                            return [2 /*return*/, new Promise(function (resolve) { return setTimeout(function () { return resolve(); }, ms); })];
                        });
                    });
                };
                HttpClient.prototype._processResponse = function (res, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this_1 = this;
                        return __generator(this, function (_1) {
                            return [2 /*return*/, new Promise(function (resolve, reject) { return __awaiter(_this_1, void 0, void 0, function () {
                                    // get the result from the body
                                    function dateTimeDeserializer(key, value) {
                                        if (typeof value === 'string') {
                                            var a = new Date(value);
                                            if (!isNaN(a.valueOf())) {
                                                return a;
                                            }
                                        }
                                        return value;
                                    }
                                    var statusCode, response, obj, contents, err_1, msg, err;
                                    return __generator(this, function (_1) {
                                        switch (_1.label) {
                                            case 0:
                                                statusCode = res.message.statusCode || 0;
                                                response = {
                                                    statusCode: statusCode,
                                                    result: null,
                                                    headers: {}
                                                };
                                                // not found leads to null obj returned
                                                if (statusCode === HttpCodes.NotFound) {
                                                    resolve(response);
                                                }
                                                _1.label = 1;
                                            case 1:
                                                _1.trys.push([1, 3, , 4]);
                                                return [4 /*yield*/, res.readBody()];
                                            case 2:
                                                contents = _1.sent();
                                                if (contents && contents.length > 0) {
                                                    if (options && options.deserializeDates) {
                                                        obj = JSON.parse(contents, dateTimeDeserializer);
                                                    }
                                                    else {
                                                        obj = JSON.parse(contents);
                                                    }
                                                    response.result = obj;
                                                }
                                                response.headers = res.message.headers;
                                                return [3 /*break*/, 4];
                                            case 3:
                                                err_1 = _1.sent();
                                                return [3 /*break*/, 4];
                                            case 4:
                                                // note that 3xx redirects are handled by the http layer.
                                                if (statusCode > 299) {
                                                    msg = void 0;
                                                    // if exception/error in body, attempt to get better error
                                                    if (obj && obj.message) {
                                                        msg = obj.message;
                                                    }
                                                    else if (contents && contents.length > 0) {
                                                        // it may be the case that the exception is in the body message as string
                                                        msg = contents;
                                                    }
                                                    else {
                                                        msg = "Failed request: (".concat(statusCode, ")");
                                                    }
                                                    err = new HttpClientError(msg, statusCode);
                                                    err.result = response.result;
                                                    reject(err);
                                                }
                                                else {
                                                    resolve(response);
                                                }
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        });
                    });
                };
                return HttpClient;
            }());
            exports.HttpClient = HttpClient;
            var lowercaseKeys = function (obj) { return Object.keys(obj).reduce(function (c, k) { return ((c[k.toLowerCase()] = obj[k]), c); }, {}); };
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 9835: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.checkBypass = exports.getProxyUrl = void 0;
            function getProxyUrl(reqUrl) {
                var usingSsl = reqUrl.protocol === 'https:';
                if (checkBypass(reqUrl)) {
                    return undefined;
                }
                var proxyVar = (function () {
                    if (usingSsl) {
                        return process.env['https_proxy'] || process.env['HTTPS_PROXY'];
                    }
                    else {
                        return process.env['http_proxy'] || process.env['HTTP_PROXY'];
                    }
                })();
                if (proxyVar) {
                    try {
                        return new URL(proxyVar);
                    }
                    catch (_a) {
                        if (!proxyVar.startsWith('http://') && !proxyVar.startsWith('https://'))
                            return new URL("http://".concat(proxyVar));
                    }
                }
                else {
                    return undefined;
                }
            }
            exports.getProxyUrl = getProxyUrl;
            function checkBypass(reqUrl) {
                if (!reqUrl.hostname) {
                    return false;
                }
                var reqHost = reqUrl.hostname;
                if (isLoopbackAddress(reqHost)) {
                    return true;
                }
                var noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';
                if (!noProxy) {
                    return false;
                }
                // Determine the request port
                var reqPort;
                if (reqUrl.port) {
                    reqPort = Number(reqUrl.port);
                }
                else if (reqUrl.protocol === 'http:') {
                    reqPort = 80;
                }
                else if (reqUrl.protocol === 'https:') {
                    reqPort = 443;
                }
                // Format the request hostname and hostname with port
                var upperReqHosts = [reqUrl.hostname.toUpperCase()];
                if (typeof reqPort === 'number') {
                    upperReqHosts.push("".concat(upperReqHosts[0], ":").concat(reqPort));
                }
                var _loop_1 = function (upperNoProxyItem) {
                    if (upperNoProxyItem === '*' ||
                        upperReqHosts.some(function (x) { return x === upperNoProxyItem ||
                            x.endsWith(".".concat(upperNoProxyItem)) ||
                            (upperNoProxyItem.startsWith('.') &&
                                x.endsWith("".concat(upperNoProxyItem))); })) {
                        return { value: true };
                    }
                };
                // Compare request host against noproxy
                for (var _1 = 0, _2 = noProxy
                    .split(',')
                    .map(function (x) { return x.trim().toUpperCase(); })
                    .filter(function (x) { return x; }); _1 < _2.length; _1++) {
                    var upperNoProxyItem = _2[_1];
                    var state_1 = _loop_1(upperNoProxyItem);
                    if (typeof state_1 === "object")
                        return state_1.value;
                }
                return false;
            }
            exports.checkBypass = checkBypass;
            function isLoopbackAddress(host) {
                var hostLower = host.toLowerCase();
                return (hostLower === 'localhost' ||
                    hostLower.startsWith('127.') ||
                    hostLower.startsWith('[::1]') ||
                    hostLower.startsWith('[0:0:0:0:0:0:0:1]'));
            }
            //# sourceMappingURL=proxy.js.map
            /***/ 
        }),
        /***/ 334: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
            var REGEX_IS_INSTALLATION = /^ghs_/;
            var REGEX_IS_USER_TO_SERVER = /^ghu_/;
            function auth(token) {
                return __awaiter(this, void 0, void 0, function () {
                    var isApp, isInstallation, isUserToServer, tokenType;
                    return __generator(this, function (_1) {
                        isApp = token.split(/\./).length === 3;
                        isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
                        isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
                        tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
                        return [2 /*return*/, {
                                type: "token",
                                token: token,
                                tokenType: tokenType
                            }];
                    });
                });
            }
            /**
             * Prefix token for usage in the Authorization header
             *
             * @param token OAuth token or JSON Web Token
             */
            function withAuthorizationPrefix(token) {
                if (token.split(/\./).length === 3) {
                    return "bearer ".concat(token);
                }
                return "token ".concat(token);
            }
            function hook(token, request, route, parameters) {
                return __awaiter(this, void 0, void 0, function () {
                    var endpoint;
                    return __generator(this, function (_1) {
                        endpoint = request.endpoint.merge(route, parameters);
                        endpoint.headers.authorization = withAuthorizationPrefix(token);
                        return [2 /*return*/, request(endpoint)];
                    });
                });
            }
            var createTokenAuth = function createTokenAuth(token) {
                if (!token) {
                    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
                }
                if (typeof token !== "string") {
                    throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
                }
                token = token.replace(/^(token|bearer) +/i, "");
                return Object.assign(auth.bind(null, token), {
                    hook: hook.bind(null, token)
                });
            };
            exports.createTokenAuth = createTokenAuth;
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 6762: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var universalUserAgent = __nccwpck_require__(5030);
            var beforeAfterHook = __nccwpck_require__(3682);
            var request = __nccwpck_require__(6234);
            var graphql = __nccwpck_require__(8467);
            var authToken = __nccwpck_require__(334);
            function _objectWithoutPropertiesLoose(source, excluded) {
                if (source == null)
                    return {};
                var target = {};
                var sourceKeys = Object.keys(source);
                var key, i;
                for (i = 0; i < sourceKeys.length; i++) {
                    key = sourceKeys[i];
                    if (excluded.indexOf(key) >= 0)
                        continue;
                    target[key] = source[key];
                }
                return target;
            }
            function _objectWithoutProperties(source, excluded) {
                if (source == null)
                    return {};
                var target = _objectWithoutPropertiesLoose(source, excluded);
                var key, i;
                if (Object.getOwnPropertySymbols) {
                    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
                    for (i = 0; i < sourceSymbolKeys.length; i++) {
                        key = sourceSymbolKeys[i];
                        if (excluded.indexOf(key) >= 0)
                            continue;
                        if (!Object.prototype.propertyIsEnumerable.call(source, key))
                            continue;
                        target[key] = source[key];
                    }
                }
                return target;
            }
            var VERSION = "3.6.0";
            var _excluded = ["authStrategy"];
            var Octokit = /** @class */ (function () {
                function Octokit(options) {
                    if (options === void 0) { options = {}; }
                    var _this_1 = this;
                    var hook = new beforeAfterHook.Collection();
                    var requestDefaults = {
                        baseUrl: request.request.endpoint.DEFAULTS.baseUrl,
                        headers: {},
                        request: Object.assign({}, options.request, {
                            // @ts-ignore internal usage only, no need to type
                            hook: hook.bind(null, "request")
                        }),
                        mediaType: {
                            previews: [],
                            format: ""
                        }
                    }; // prepend default user agent with `options.userAgent` if set
                    requestDefaults.headers["user-agent"] = [options.userAgent, "octokit-core.js/".concat(VERSION, " ").concat(universalUserAgent.getUserAgent())].filter(Boolean).join(" ");
                    if (options.baseUrl) {
                        requestDefaults.baseUrl = options.baseUrl;
                    }
                    if (options.previews) {
                        requestDefaults.mediaType.previews = options.previews;
                    }
                    if (options.timeZone) {
                        requestDefaults.headers["time-zone"] = options.timeZone;
                    }
                    this.request = request.request.defaults(requestDefaults);
                    this.graphql = graphql.withCustomRequest(this.request).defaults(requestDefaults);
                    this.log = Object.assign({
                        debug: function () { },
                        info: function () { },
                        warn: console.warn.bind(console),
                        error: console.error.bind(console)
                    }, options.log);
                    this.hook = hook; // (1) If neither `options.authStrategy` nor `options.auth` are set, the `octokit` instance
                    //     is unauthenticated. The `this.auth()` method is a no-op and no request hook is registered.
                    // (2) If only `options.auth` is set, use the default token authentication strategy.
                    // (3) If `options.authStrategy` is set then use it and pass in `options.auth`. Always pass own request as many strategies accept a custom request instance.
                    // TODO: type `options.auth` based on `options.authStrategy`.
                    if (!options.authStrategy) {
                        if (!options.auth) {
                            // (1)
                            this.auth = function () { return __awaiter(_this_1, void 0, void 0, function () {
                                return __generator(this, function (_1) {
                                    return [2 /*return*/, ({
                                            type: "unauthenticated"
                                        })];
                                });
                            }); };
                        }
                        else {
                            // (2)
                            var auth = authToken.createTokenAuth(options.auth); // @ts-ignore  \_()_/
                            hook.wrap("request", auth.hook);
                            this.auth = auth;
                        }
                    }
                    else {
                        var authStrategy = options.authStrategy, otherOptions = _objectWithoutProperties(options, _excluded);
                        var auth = authStrategy(Object.assign({
                            request: this.request,
                            log: this.log,
                            // we pass the current octokit instance as well as its constructor options
                            // to allow for authentication strategies that return a new octokit instance
                            // that shares the same internal state as the current one. The original
                            // requirement for this was the "event-octokit" authentication strategy
                            // of https://github.com/probot/octokit-auth-probot.
                            octokit: this,
                            octokitOptions: otherOptions
                        }, options.auth)); // @ts-ignore  \_()_/
                        hook.wrap("request", auth.hook);
                        this.auth = auth;
                    } // apply plugins
                    // https://stackoverflow.com/a/16345172
                    var classConstructor = this.constructor;
                    classConstructor.plugins.forEach(function (plugin) {
                        Object.assign(_this_1, plugin(_this_1, options));
                    });
                }
                Octokit.defaults = function (defaults) {
                    var OctokitWithDefaults = /** @class */ (function (_super) {
                        __extends(OctokitWithDefaults, _super);
                        function OctokitWithDefaults() {
                            var args = [];
                            for (var _1 = 0; _1 < arguments.length; _1++) {
                                args[_1] = arguments[_1];
                            }
                            var options = args[0] || {};
                            if (typeof defaults === "function") {
                                _this_1 = _super.call(this, defaults(options)) || this;
                                return _this_1;
                            }
                            return _super.call(this, Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? {
                                userAgent: "".concat(options.userAgent, " ").concat(defaults.userAgent)
                            } : null)) || this;
                        }
                        return OctokitWithDefaults;
                    }(this));
                    return OctokitWithDefaults;
                };
                /**
                 * Attach a plugin (or many) to your Octokit instance.
                 *
                 * @example
                 * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
                 */
                Octokit.plugin = function () {
                    var newPlugins = [];
                    for (var _1 = 0; _1 < arguments.length; _1++) {
                        newPlugins[_1] = arguments[_1];
                    }
                    var _a;
                    var currentPlugins = this.plugins;
                    var NewOctokit = (_a = /** @class */ (function (_super) {
                        __extends(_a, _super);
                        function _a() {
                            return _super !== null && _super.apply(this, arguments) || this;
                        }
                        return _a;
                    }(this)), _a.plugins = currentPlugins.concat(newPlugins.filter(function (plugin) { return !currentPlugins.includes(plugin); })), _a);
                    return NewOctokit;
                };
                return Octokit;
            }());
            Octokit.VERSION = VERSION;
            Octokit.plugins = [];
            exports.Octokit = Octokit;
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 9440: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var isPlainObject = __nccwpck_require__(3287);
            var universalUserAgent = __nccwpck_require__(5030);
            function lowercaseKeys(object) {
                if (!object) {
                    return {};
                }
                return Object.keys(object).reduce(function (newObj, key) {
                    newObj[key.toLowerCase()] = object[key];
                    return newObj;
                }, {});
            }
            function mergeDeep(defaults, options) {
                var result = Object.assign({}, defaults);
                Object.keys(options).forEach(function (key) {
                    var _1, _2;
                    if (isPlainObject.isPlainObject(options[key])) {
                        if (!(key in defaults))
                            Object.assign(result, (_1 = {},
                                _1[key] = options[key],
                                _1));
                        else
                            result[key] = mergeDeep(defaults[key], options[key]);
                    }
                    else {
                        Object.assign(result, (_2 = {},
                            _2[key] = options[key],
                            _2));
                    }
                });
                return result;
            }
            function removeUndefinedProperties(obj) {
                for (var key in obj) {
                    if (obj[key] === undefined) {
                        delete obj[key];
                    }
                }
                return obj;
            }
            function merge(defaults, route, options) {
                if (typeof route === "string") {
                    var _1 = route.split(" "), method = _1[0], url = _1[1];
                    options = Object.assign(url ? {
                        method: method,
                        url: url
                    } : {
                        url: method
                    }, options);
                }
                else {
                    options = Object.assign({}, route);
                } // lowercase header names before merging with defaults to avoid duplicates
                options.headers = lowercaseKeys(options.headers); // remove properties with undefined values before merging
                removeUndefinedProperties(options);
                removeUndefinedProperties(options.headers);
                var mergedOptions = mergeDeep(defaults || {}, options); // mediaType.previews arrays are merged, instead of overwritten
                if (defaults && defaults.mediaType.previews.length) {
                    mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(function (preview) { return !mergedOptions.mediaType.previews.includes(preview); }).concat(mergedOptions.mediaType.previews);
                }
                mergedOptions.mediaType.previews = mergedOptions.mediaType.previews.map(function (preview) { return preview.replace(/-preview/, ""); });
                return mergedOptions;
            }
            function addQueryParameters(url, parameters) {
                var separator = /\?/.test(url) ? "&" : "?";
                var names = Object.keys(parameters);
                if (names.length === 0) {
                    return url;
                }
                return url + separator + names.map(function (name) {
                    if (name === "q") {
                        return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
                    }
                    return "".concat(name, "=").concat(encodeURIComponent(parameters[name]));
                }).join("&");
            }
            var urlVariableRegex = /\{[^}]+\}/g;
            function removeNonChars(variableName) {
                return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
            }
            function extractUrlVariableNames(url) {
                var matches = url.match(urlVariableRegex);
                if (!matches) {
                    return [];
                }
                return matches.map(removeNonChars).reduce(function (a, b) { return a.concat(b); }, []);
            }
            function omit(object, keysToOmit) {
                return Object.keys(object).filter(function (option) { return !keysToOmit.includes(option); }).reduce(function (obj, key) {
                    obj[key] = object[key];
                    return obj;
                }, {});
            }
            // Based on https://github.com/bramstein/url-template, licensed under BSD
            // TODO: create separate package.
            //
            // Copyright (c) 2012-2014, Bram Stein
            // All rights reserved.
            // Redistribution and use in source and binary forms, with or without
            // modification, are permitted provided that the following conditions
            // are met:
            //  1. Redistributions of source code must retain the above copyright
            //     notice, this list of conditions and the following disclaimer.
            //  2. Redistributions in binary form must reproduce the above copyright
            //     notice, this list of conditions and the following disclaimer in the
            //     documentation and/or other materials provided with the distribution.
            //  3. The name of the author may not be used to endorse or promote products
            //     derived from this software without specific prior written permission.
            // THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
            // WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
            // MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
            // EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
            // INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
            // BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
            // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
            // OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
            // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
            // EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
            /* istanbul ignore file */
            function encodeReserved(str) {
                return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {
                    if (!/%[0-9A-Fa-f]/.test(part)) {
                        part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
                    }
                    return part;
                }).join("");
            }
            function encodeUnreserved(str) {
                return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
                    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
                });
            }
            function encodeValue(operator, value, key) {
                value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
                if (key) {
                    return encodeUnreserved(key) + "=" + value;
                }
                else {
                    return value;
                }
            }
            function isDefined(value) {
                return value !== undefined && value !== null;
            }
            function isKeyOperator(operator) {
                return operator === ";" || operator === "&" || operator === "?";
            }
            function getValues(context, operator, key, modifier) {
                var value = context[key], result = [];
                if (isDefined(value) && value !== "") {
                    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
                        value = value.toString();
                        if (modifier && modifier !== "*") {
                            value = value.substring(0, parseInt(modifier, 10));
                        }
                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
                    }
                    else {
                        if (modifier === "*") {
                            if (Array.isArray(value)) {
                                value.filter(isDefined).forEach(function (value) {
                                    result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
                                });
                            }
                            else {
                                Object.keys(value).forEach(function (k) {
                                    if (isDefined(value[k])) {
                                        result.push(encodeValue(operator, value[k], k));
                                    }
                                });
                            }
                        }
                        else {
                            var tmp_1 = [];
                            if (Array.isArray(value)) {
                                value.filter(isDefined).forEach(function (value) {
                                    tmp_1.push(encodeValue(operator, value));
                                });
                            }
                            else {
                                Object.keys(value).forEach(function (k) {
                                    if (isDefined(value[k])) {
                                        tmp_1.push(encodeUnreserved(k));
                                        tmp_1.push(encodeValue(operator, value[k].toString()));
                                    }
                                });
                            }
                            if (isKeyOperator(operator)) {
                                result.push(encodeUnreserved(key) + "=" + tmp_1.join(","));
                            }
                            else if (tmp_1.length !== 0) {
                                result.push(tmp_1.join(","));
                            }
                        }
                    }
                }
                else {
                    if (operator === ";") {
                        if (isDefined(value)) {
                            result.push(encodeUnreserved(key));
                        }
                    }
                    else if (value === "" && (operator === "&" || operator === "?")) {
                        result.push(encodeUnreserved(key) + "=");
                    }
                    else if (value === "") {
                        result.push("");
                    }
                }
                return result;
            }
            function parseUrl(template) {
                return {
                    expand: expand.bind(null, template)
                };
            }
            function expand(template, context) {
                var operators = ["+", "#", ".", "/", ";", "?", "&"];
                return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function (_, expression, literal) {
                    if (expression) {
                        var operator_1 = "";
                        var values_1 = [];
                        if (operators.indexOf(expression.charAt(0)) !== -1) {
                            operator_1 = expression.charAt(0);
                            expression = expression.substr(1);
                        }
                        expression.split(/,/g).forEach(function (variable) {
                            var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
                            values_1.push(getValues(context, operator_1, tmp[1], tmp[2] || tmp[3]));
                        });
                        if (operator_1 && operator_1 !== "+") {
                            var separator = ",";
                            if (operator_1 === "?") {
                                separator = "&";
                            }
                            else if (operator_1 !== "#") {
                                separator = operator_1;
                            }
                            return (values_1.length !== 0 ? operator_1 : "") + values_1.join(separator);
                        }
                        else {
                            return values_1.join(",");
                        }
                    }
                    else {
                        return encodeReserved(literal);
                    }
                });
            }
            function parse(options) {
                // https://fetch.spec.whatwg.org/#methods
                var method = options.method.toUpperCase(); // replace :varname with {varname} to make it RFC 6570 compatible
                var url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
                var headers = Object.assign({}, options.headers);
                var body;
                var parameters = omit(options, ["method", "baseUrl", "url", "headers", "request", "mediaType"]); // extract variable names from URL to calculate remaining variables later
                var urlVariableNames = extractUrlVariableNames(url);
                url = parseUrl(url).expand(parameters);
                if (!/^http/.test(url)) {
                    url = options.baseUrl + url;
                }
                var omittedParameters = Object.keys(options).filter(function (option) { return urlVariableNames.includes(option); }).concat("baseUrl");
                var remainingParameters = omit(parameters, omittedParameters);
                var isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
                if (!isBinaryRequest) {
                    if (options.mediaType.format) {
                        // e.g. application/vnd.github.v3+json => application/vnd.github.v3.raw
                        headers.accept = headers.accept.split(/,/).map(function (preview) { return preview.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, "application/vnd$1$2.".concat(options.mediaType.format)); }).join(",");
                    }
                    if (options.mediaType.previews.length) {
                        var previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
                        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map(function (preview) {
                            var format = options.mediaType.format ? ".".concat(options.mediaType.format) : "+json";
                            return "application/vnd.github.".concat(preview, "-preview").concat(format);
                        }).join(",");
                    }
                } // for GET/HEAD requests, set URL query parameters from remaining parameters
                // for PATCH/POST/PUT/DELETE requests, set request body from remaining parameters
                if (["GET", "HEAD"].includes(method)) {
                    url = addQueryParameters(url, remainingParameters);
                }
                else {
                    if ("data" in remainingParameters) {
                        body = remainingParameters.data;
                    }
                    else {
                        if (Object.keys(remainingParameters).length) {
                            body = remainingParameters;
                        }
                        else {
                            headers["content-length"] = 0;
                        }
                    }
                } // default content-type for JSON if body is set
                if (!headers["content-type"] && typeof body !== "undefined") {
                    headers["content-type"] = "application/json; charset=utf-8";
                } // GitHub expects 'content-length: 0' header for PUT/PATCH requests without body.
                // fetch does not allow to set `content-length` header, but we can set body to an empty string
                if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
                    body = "";
                } // Only return body/request keys if present
                return Object.assign({
                    method: method,
                    url: url,
                    headers: headers
                }, typeof body !== "undefined" ? {
                    body: body
                } : null, options.request ? {
                    request: options.request
                } : null);
            }
            function endpointWithDefaults(defaults, route, options) {
                return parse(merge(defaults, route, options));
            }
            function withDefaults(oldDefaults, newDefaults) {
                var DEFAULTS = merge(oldDefaults, newDefaults);
                var endpoint = endpointWithDefaults.bind(null, DEFAULTS);
                return Object.assign(endpoint, {
                    DEFAULTS: DEFAULTS,
                    defaults: withDefaults.bind(null, DEFAULTS),
                    merge: merge.bind(null, DEFAULTS),
                    parse: parse
                });
            }
            var VERSION = "6.0.12";
            var userAgent = "octokit-endpoint.js/".concat(VERSION, " ").concat(universalUserAgent.getUserAgent()); // DEFAULTS has all properties set that EndpointOptions has, except url.
            // So we use RequestParameters and add method as additional required property.
            var DEFAULTS = {
                method: "GET",
                baseUrl: "https://api.github.com",
                headers: {
                    accept: "application/vnd.github.v3+json",
                    "user-agent": userAgent
                },
                mediaType: {
                    format: "",
                    previews: []
                }
            };
            var endpoint = withDefaults(null, DEFAULTS);
            exports.endpoint = endpoint;
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 8467: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var request = __nccwpck_require__(6234);
            var universalUserAgent = __nccwpck_require__(5030);
            var VERSION = "4.8.0";
            function _buildMessageForResponseErrors(data) {
                return "Request failed due to following response errors:\n" + data.errors.map(function (e) { return " - ".concat(e.message); }).join("\n");
            }
            var GraphqlResponseError = /** @class */ (function (_super) {
                __extends(GraphqlResponseError, _super);
                function GraphqlResponseError(request, headers, response) {
                    var _this_1 = _super.call(this, _buildMessageForResponseErrors(response)) || this;
                    _this_1.request = request;
                    _this_1.headers = headers;
                    _this_1.response = response;
                    _this_1.name = "GraphqlResponseError"; // Expose the errors and response data in their shorthand properties.
                    _this_1.errors = response.errors;
                    _this_1.data = response.data; // Maintains proper stack trace (only available on V8)
                    /* istanbul ignore next */
                    if (Error.captureStackTrace) {
                        Error.captureStackTrace(_this_1, _this_1.constructor);
                    }
                    return _this_1;
                }
                return GraphqlResponseError;
            }(Error));
            var NON_VARIABLE_OPTIONS = ["method", "baseUrl", "url", "headers", "request", "query", "mediaType"];
            var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
            var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
            function graphql(request, query, options) {
                if (options) {
                    if (typeof query === "string" && "query" in options) {
                        return Promise.reject(new Error("[@octokit/graphql] \"query\" cannot be used as variable name"));
                    }
                    for (var key in options) {
                        if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
                            continue;
                        return Promise.reject(new Error("[@octokit/graphql] \"".concat(key, "\" cannot be used as variable name")));
                    }
                }
                var parsedOptions = typeof query === "string" ? Object.assign({
                    query: query
                }, options) : query;
                var requestOptions = Object.keys(parsedOptions).reduce(function (result, key) {
                    if (NON_VARIABLE_OPTIONS.includes(key)) {
                        result[key] = parsedOptions[key];
                        return result;
                    }
                    if (!result.variables) {
                        result.variables = {};
                    }
                    result.variables[key] = parsedOptions[key];
                    return result;
                }, {}); // workaround for GitHub Enterprise baseUrl set with /api/v3 suffix
                // https://github.com/octokit/auth-app.js/issues/111#issuecomment-657610451
                var baseUrl = parsedOptions.baseUrl || request.endpoint.DEFAULTS.baseUrl;
                if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
                    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
                }
                return request(requestOptions).then(function (response) {
                    if (response.data.errors) {
                        var headers = {};
                        for (var _1 = 0, _2 = Object.keys(response.headers); _1 < _2.length; _1++) {
                            var key = _2[_1];
                            headers[key] = response.headers[key];
                        }
                        throw new GraphqlResponseError(requestOptions, headers, response.data);
                    }
                    return response.data.data;
                });
            }
            function withDefaults(request$1, newDefaults) {
                var newRequest = request$1.defaults(newDefaults);
                var newApi = function (query, options) {
                    return graphql(newRequest, query, options);
                };
                return Object.assign(newApi, {
                    defaults: withDefaults.bind(null, newRequest),
                    endpoint: request.request.endpoint
                });
            }
            var graphql$1 = withDefaults(request.request, {
                headers: {
                    "user-agent": "octokit-graphql.js/".concat(VERSION, " ").concat(universalUserAgent.getUserAgent())
                },
                method: "POST",
                url: "/graphql"
            });
            function withCustomRequest(customRequest) {
                return withDefaults(customRequest, {
                    method: "POST",
                    url: "/graphql"
                });
            }
            exports.GraphqlResponseError = GraphqlResponseError;
            exports.graphql = graphql$1;
            exports.withCustomRequest = withCustomRequest;
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 4193: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var VERSION = "2.21.3";
            function ownKeys(object, enumerableOnly) {
                var keys = Object.keys(object);
                if (Object.getOwnPropertySymbols) {
                    var symbols = Object.getOwnPropertySymbols(object);
                    enumerableOnly && (symbols = symbols.filter(function (sym) {
                        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                    })), keys.push.apply(keys, symbols);
                }
                return keys;
            }
            function _objectSpread2(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = null != arguments[i] ? arguments[i] : {};
                    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
                        _defineProperty(target, key, source[key]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
                        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                    });
                }
                return target;
            }
            function _defineProperty(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                }
                else {
                    obj[key] = value;
                }
                return obj;
            }
            /**
             * Some list response that can be paginated have a different response structure
             *
             * They have a `total_count` key in the response (search also has `incomplete_results`,
             * /installation/repositories also has `repository_selection`), as well as a key with
             * the list of the items which name varies from endpoint to endpoint.
             *
             * Octokit normalizes these responses so that paginated results are always returned following
             * the same structure. One challenge is that if the list response has only one page, no Link
             * header is provided, so this header alone is not sufficient to check wether a response is
             * paginated or not.
             *
             * We check if a "total_count" key is present in the response data, but also make sure that
             * a "url" property is not, as the "Get the combined status for a specific ref" endpoint would
             * otherwise match: https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-ref
             */
            function normalizePaginatedListResponse(response) {
                // endpoints can respond with 204 if repository is empty
                if (!response.data) {
                    return _objectSpread2(_objectSpread2({}, response), {}, {
                        data: []
                    });
                }
                var responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
                if (!responseNeedsNormalization)
                    return response; // keep the additional properties intact as there is currently no other way
                // to retrieve the same information.
                var incompleteResults = response.data.incomplete_results;
                var repositorySelection = response.data.repository_selection;
                var totalCount = response.data.total_count;
                delete response.data.incomplete_results;
                delete response.data.repository_selection;
                delete response.data.total_count;
                var namespaceKey = Object.keys(response.data)[0];
                var data = response.data[namespaceKey];
                response.data = data;
                if (typeof incompleteResults !== "undefined") {
                    response.data.incomplete_results = incompleteResults;
                }
                if (typeof repositorySelection !== "undefined") {
                    response.data.repository_selection = repositorySelection;
                }
                response.data.total_count = totalCount;
                return response;
            }
            function iterator(octokit, route, parameters) {
                var _1;
                var options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
                var requestMethod = typeof route === "function" ? route : octokit.request;
                var method = options.method;
                var headers = options.headers;
                var url = options.url;
                return _1 = {},
                    _1[Symbol.asyncIterator] = function () { return ({
                        next: function () {
                            return __awaiter(this, void 0, void 0, function () {
                                var response, normalizedResponse, error_2;
                                return __generator(this, function (_1) {
                                    switch (_1.label) {
                                        case 0:
                                            if (!url)
                                                return [2 /*return*/, {
                                                        done: true
                                                    }];
                                            _1.label = 1;
                                        case 1:
                                            _1.trys.push([1, 3, , 4]);
                                            return [4 /*yield*/, requestMethod({
                                                    method: method,
                                                    url: url,
                                                    headers: headers
                                                })];
                                        case 2:
                                            response = _1.sent();
                                            normalizedResponse = normalizePaginatedListResponse(response);
                                            // '<https://api.github.com/users/aseemk/followers?page=2>; rel="next", <https://api.github.com/users/aseemk/followers?page=2>; rel="last"'
                                            // sets `url` to undefined if "next" URL is not present or `link` header is not set
                                            url = ((normalizedResponse.headers.link || "").match(/<([^>]+)>;\s*rel="next"/) || [])[1];
                                            return [2 /*return*/, {
                                                    value: normalizedResponse
                                                }];
                                        case 3:
                                            error_2 = _1.sent();
                                            if (error_2.status !== 409)
                                                throw error_2;
                                            url = "";
                                            return [2 /*return*/, {
                                                    value: {
                                                        status: 200,
                                                        headers: {},
                                                        data: []
                                                    }
                                                }];
                                        case 4: return [2 /*return*/];
                                    }
                                });
                            });
                        }
                    }); },
                    _1;
            }
            function paginate(octokit, route, parameters, mapFn) {
                if (typeof parameters === "function") {
                    mapFn = parameters;
                    parameters = undefined;
                }
                return gather(octokit, [], iterator(octokit, route, parameters)[Symbol.asyncIterator](), mapFn);
            }
            function gather(octokit, results, iterator, mapFn) {
                return iterator.next().then(function (result) {
                    if (result.done) {
                        return results;
                    }
                    var earlyExit = false;
                    function done() {
                        earlyExit = true;
                    }
                    results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);
                    if (earlyExit) {
                        return results;
                    }
                    return gather(octokit, results, iterator, mapFn);
                });
            }
            var composePaginateRest = Object.assign(paginate, {
                iterator: iterator
            });
            var paginatingEndpoints = ["GET /app/hook/deliveries", "GET /app/installations", "GET /applications/grants", "GET /authorizations", "GET /enterprises/{enterprise}/actions/permissions/organizations", "GET /enterprises/{enterprise}/actions/runner-groups", "GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations", "GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners", "GET /enterprises/{enterprise}/actions/runners", "GET /enterprises/{enterprise}/audit-log", "GET /enterprises/{enterprise}/secret-scanning/alerts", "GET /enterprises/{enterprise}/settings/billing/advanced-security", "GET /events", "GET /gists", "GET /gists/public", "GET /gists/starred", "GET /gists/{gist_id}/comments", "GET /gists/{gist_id}/commits", "GET /gists/{gist_id}/forks", "GET /installation/repositories", "GET /issues", "GET /licenses", "GET /marketplace_listing/plans", "GET /marketplace_listing/plans/{plan_id}/accounts", "GET /marketplace_listing/stubbed/plans", "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts", "GET /networks/{owner}/{repo}/events", "GET /notifications", "GET /organizations", "GET /orgs/{org}/actions/cache/usage-by-repository", "GET /orgs/{org}/actions/permissions/repositories", "GET /orgs/{org}/actions/runner-groups", "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories", "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/runners", "GET /orgs/{org}/actions/runners", "GET /orgs/{org}/actions/secrets", "GET /orgs/{org}/actions/secrets/{secret_name}/repositories", "GET /orgs/{org}/audit-log", "GET /orgs/{org}/blocks", "GET /orgs/{org}/code-scanning/alerts", "GET /orgs/{org}/codespaces", "GET /orgs/{org}/credential-authorizations", "GET /orgs/{org}/dependabot/secrets", "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories", "GET /orgs/{org}/events", "GET /orgs/{org}/external-groups", "GET /orgs/{org}/failed_invitations", "GET /orgs/{org}/hooks", "GET /orgs/{org}/hooks/{hook_id}/deliveries", "GET /orgs/{org}/installations", "GET /orgs/{org}/invitations", "GET /orgs/{org}/invitations/{invitation_id}/teams", "GET /orgs/{org}/issues", "GET /orgs/{org}/members", "GET /orgs/{org}/migrations", "GET /orgs/{org}/migrations/{migration_id}/repositories", "GET /orgs/{org}/outside_collaborators", "GET /orgs/{org}/packages", "GET /orgs/{org}/packages/{package_type}/{package_name}/versions", "GET /orgs/{org}/projects", "GET /orgs/{org}/public_members", "GET /orgs/{org}/repos", "GET /orgs/{org}/secret-scanning/alerts", "GET /orgs/{org}/settings/billing/advanced-security", "GET /orgs/{org}/team-sync/groups", "GET /orgs/{org}/teams", "GET /orgs/{org}/teams/{team_slug}/discussions", "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments", "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions", "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions", "GET /orgs/{org}/teams/{team_slug}/invitations", "GET /orgs/{org}/teams/{team_slug}/members", "GET /orgs/{org}/teams/{team_slug}/projects", "GET /orgs/{org}/teams/{team_slug}/repos", "GET /orgs/{org}/teams/{team_slug}/teams", "GET /projects/columns/{column_id}/cards", "GET /projects/{project_id}/collaborators", "GET /projects/{project_id}/columns", "GET /repos/{owner}/{repo}/actions/artifacts", "GET /repos/{owner}/{repo}/actions/caches", "GET /repos/{owner}/{repo}/actions/runners", "GET /repos/{owner}/{repo}/actions/runs", "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts", "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs", "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs", "GET /repos/{owner}/{repo}/actions/secrets", "GET /repos/{owner}/{repo}/actions/workflows", "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs", "GET /repos/{owner}/{repo}/assignees", "GET /repos/{owner}/{repo}/branches", "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations", "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs", "GET /repos/{owner}/{repo}/code-scanning/alerts", "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances", "GET /repos/{owner}/{repo}/code-scanning/analyses", "GET /repos/{owner}/{repo}/codespaces", "GET /repos/{owner}/{repo}/codespaces/devcontainers", "GET /repos/{owner}/{repo}/codespaces/secrets", "GET /repos/{owner}/{repo}/collaborators", "GET /repos/{owner}/{repo}/comments", "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions", "GET /repos/{owner}/{repo}/commits", "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments", "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls", "GET /repos/{owner}/{repo}/commits/{ref}/check-runs", "GET /repos/{owner}/{repo}/commits/{ref}/check-suites", "GET /repos/{owner}/{repo}/commits/{ref}/status", "GET /repos/{owner}/{repo}/commits/{ref}/statuses", "GET /repos/{owner}/{repo}/contributors", "GET /repos/{owner}/{repo}/dependabot/secrets", "GET /repos/{owner}/{repo}/deployments", "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses", "GET /repos/{owner}/{repo}/environments", "GET /repos/{owner}/{repo}/events", "GET /repos/{owner}/{repo}/forks", "GET /repos/{owner}/{repo}/git/matching-refs/{ref}", "GET /repos/{owner}/{repo}/hooks", "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries", "GET /repos/{owner}/{repo}/invitations", "GET /repos/{owner}/{repo}/issues", "GET /repos/{owner}/{repo}/issues/comments", "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions", "GET /repos/{owner}/{repo}/issues/events", "GET /repos/{owner}/{repo}/issues/{issue_number}/comments", "GET /repos/{owner}/{repo}/issues/{issue_number}/events", "GET /repos/{owner}/{repo}/issues/{issue_number}/labels", "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions", "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline", "GET /repos/{owner}/{repo}/keys", "GET /repos/{owner}/{repo}/labels", "GET /repos/{owner}/{repo}/milestones", "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels", "GET /repos/{owner}/{repo}/notifications", "GET /repos/{owner}/{repo}/pages/builds", "GET /repos/{owner}/{repo}/projects", "GET /repos/{owner}/{repo}/pulls", "GET /repos/{owner}/{repo}/pulls/comments", "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions", "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments", "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits", "GET /repos/{owner}/{repo}/pulls/{pull_number}/files", "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers", "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews", "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments", "GET /repos/{owner}/{repo}/releases", "GET /repos/{owner}/{repo}/releases/{release_id}/assets", "GET /repos/{owner}/{repo}/releases/{release_id}/reactions", "GET /repos/{owner}/{repo}/secret-scanning/alerts", "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations", "GET /repos/{owner}/{repo}/stargazers", "GET /repos/{owner}/{repo}/subscribers", "GET /repos/{owner}/{repo}/tags", "GET /repos/{owner}/{repo}/teams", "GET /repos/{owner}/{repo}/topics", "GET /repositories", "GET /repositories/{repository_id}/environments/{environment_name}/secrets", "GET /search/code", "GET /search/commits", "GET /search/issues", "GET /search/labels", "GET /search/repositories", "GET /search/topics", "GET /search/users", "GET /teams/{team_id}/discussions", "GET /teams/{team_id}/discussions/{discussion_number}/comments", "GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions", "GET /teams/{team_id}/discussions/{discussion_number}/reactions", "GET /teams/{team_id}/invitations", "GET /teams/{team_id}/members", "GET /teams/{team_id}/projects", "GET /teams/{team_id}/repos", "GET /teams/{team_id}/teams", "GET /user/blocks", "GET /user/codespaces", "GET /user/codespaces/secrets", "GET /user/emails", "GET /user/followers", "GET /user/following", "GET /user/gpg_keys", "GET /user/installations", "GET /user/installations/{installation_id}/repositories", "GET /user/issues", "GET /user/keys", "GET /user/marketplace_purchases", "GET /user/marketplace_purchases/stubbed", "GET /user/memberships/orgs", "GET /user/migrations", "GET /user/migrations/{migration_id}/repositories", "GET /user/orgs", "GET /user/packages", "GET /user/packages/{package_type}/{package_name}/versions", "GET /user/public_emails", "GET /user/repos", "GET /user/repository_invitations", "GET /user/starred", "GET /user/subscriptions", "GET /user/teams", "GET /users", "GET /users/{username}/events", "GET /users/{username}/events/orgs/{org}", "GET /users/{username}/events/public", "GET /users/{username}/followers", "GET /users/{username}/following", "GET /users/{username}/gists", "GET /users/{username}/gpg_keys", "GET /users/{username}/keys", "GET /users/{username}/orgs", "GET /users/{username}/packages", "GET /users/{username}/projects", "GET /users/{username}/received_events", "GET /users/{username}/received_events/public", "GET /users/{username}/repos", "GET /users/{username}/starred", "GET /users/{username}/subscriptions"];
            function isPaginatingEndpoint(arg) {
                if (typeof arg === "string") {
                    return paginatingEndpoints.includes(arg);
                }
                else {
                    return false;
                }
            }
            /**
             * @param octokit Octokit instance
             * @param options Options passed to Octokit constructor
             */
            function paginateRest(octokit) {
                return {
                    paginate: Object.assign(paginate.bind(null, octokit), {
                        iterator: iterator.bind(null, octokit)
                    })
                };
            }
            paginateRest.VERSION = VERSION;
            exports.composePaginateRest = composePaginateRest;
            exports.isPaginatingEndpoint = isPaginatingEndpoint;
            exports.paginateRest = paginateRest;
            exports.paginatingEndpoints = paginatingEndpoints;
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 3044: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            function ownKeys(object, enumerableOnly) {
                var keys = Object.keys(object);
                if (Object.getOwnPropertySymbols) {
                    var symbols = Object.getOwnPropertySymbols(object);
                    if (enumerableOnly) {
                        symbols = symbols.filter(function (sym) {
                            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                        });
                    }
                    keys.push.apply(keys, symbols);
                }
                return keys;
            }
            function _objectSpread2(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i] != null ? arguments[i] : {};
                    if (i % 2) {
                        ownKeys(Object(source), true).forEach(function (key) {
                            _defineProperty(target, key, source[key]);
                        });
                    }
                    else if (Object.getOwnPropertyDescriptors) {
                        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                    }
                    else {
                        ownKeys(Object(source)).forEach(function (key) {
                            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                        });
                    }
                }
                return target;
            }
            function _defineProperty(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                }
                else {
                    obj[key] = value;
                }
                return obj;
            }
            var Endpoints = {
                actions: {
                    addCustomLabelsToSelfHostedRunnerForOrg: ["POST /orgs/{org}/actions/runners/{runner_id}/labels"],
                    addCustomLabelsToSelfHostedRunnerForRepo: ["POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
                    addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
                    approveWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"],
                    cancelWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"],
                    createOrUpdateEnvironmentSecret: ["PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
                    createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
                    createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
                    createRegistrationTokenForOrg: ["POST /orgs/{org}/actions/runners/registration-token"],
                    createRegistrationTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/registration-token"],
                    createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
                    createRemoveTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/remove-token"],
                    createWorkflowDispatch: ["POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"],
                    deleteActionsCacheById: ["DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"],
                    deleteActionsCacheByKey: ["DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"],
                    deleteArtifact: ["DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
                    deleteEnvironmentSecret: ["DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
                    deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
                    deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
                    deleteSelfHostedRunnerFromOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}"],
                    deleteSelfHostedRunnerFromRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"],
                    deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
                    deleteWorkflowRunLogs: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
                    disableSelectedRepositoryGithubActionsOrganization: ["DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"],
                    disableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"],
                    downloadArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"],
                    downloadJobLogsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"],
                    downloadWorkflowRunAttemptLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"],
                    downloadWorkflowRunLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
                    enableSelectedRepositoryGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"],
                    enableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"],
                    getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
                    getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
                    getActionsCacheUsageByRepoForOrg: ["GET /orgs/{org}/actions/cache/usage-by-repository"],
                    getActionsCacheUsageForEnterprise: ["GET /enterprises/{enterprise}/actions/cache/usage"],
                    getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
                    getAllowedActionsOrganization: ["GET /orgs/{org}/actions/permissions/selected-actions"],
                    getAllowedActionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions/selected-actions"],
                    getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
                    getEnvironmentPublicKey: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key"],
                    getEnvironmentSecret: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
                    getGithubActionsDefaultWorkflowPermissionsEnterprise: ["GET /enterprises/{enterprise}/actions/permissions/workflow"],
                    getGithubActionsDefaultWorkflowPermissionsOrganization: ["GET /orgs/{org}/actions/permissions/workflow"],
                    getGithubActionsDefaultWorkflowPermissionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions/workflow"],
                    getGithubActionsPermissionsOrganization: ["GET /orgs/{org}/actions/permissions"],
                    getGithubActionsPermissionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions"],
                    getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
                    getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
                    getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
                    getPendingDeploymentsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
                    getRepoPermissions: ["GET /repos/{owner}/{repo}/actions/permissions", {}, {
                            renamed: ["actions", "getGithubActionsPermissionsRepository"]
                        }],
                    getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
                    getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
                    getReviewsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"],
                    getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
                    getSelfHostedRunnerForRepo: ["GET /repos/{owner}/{repo}/actions/runners/{runner_id}"],
                    getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
                    getWorkflowAccessToRepository: ["GET /repos/{owner}/{repo}/actions/permissions/access"],
                    getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
                    getWorkflowRunAttempt: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"],
                    getWorkflowRunUsage: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"],
                    getWorkflowUsage: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"],
                    listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
                    listEnvironmentSecrets: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets"],
                    listJobsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"],
                    listJobsForWorkflowRunAttempt: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"],
                    listLabelsForSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}/labels"],
                    listLabelsForSelfHostedRunnerForRepo: ["GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
                    listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
                    listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
                    listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
                    listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
                    listRunnerApplicationsForRepo: ["GET /repos/{owner}/{repo}/actions/runners/downloads"],
                    listSelectedReposForOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}/repositories"],
                    listSelectedRepositoriesEnabledGithubActionsOrganization: ["GET /orgs/{org}/actions/permissions/repositories"],
                    listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
                    listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
                    listWorkflowRunArtifacts: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"],
                    listWorkflowRuns: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"],
                    listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
                    reRunJobForWorkflowRun: ["POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"],
                    reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
                    reRunWorkflowFailedJobs: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"],
                    removeAllCustomLabelsFromSelfHostedRunnerForOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}/labels"],
                    removeAllCustomLabelsFromSelfHostedRunnerForRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
                    removeCustomLabelFromSelfHostedRunnerForOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"],
                    removeCustomLabelFromSelfHostedRunnerForRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"],
                    removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
                    reviewPendingDeploymentsForRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
                    setAllowedActionsOrganization: ["PUT /orgs/{org}/actions/permissions/selected-actions"],
                    setAllowedActionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"],
                    setCustomLabelsForSelfHostedRunnerForOrg: ["PUT /orgs/{org}/actions/runners/{runner_id}/labels"],
                    setCustomLabelsForSelfHostedRunnerForRepo: ["PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
                    setGithubActionsDefaultWorkflowPermissionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions/workflow"],
                    setGithubActionsDefaultWorkflowPermissionsOrganization: ["PUT /orgs/{org}/actions/permissions/workflow"],
                    setGithubActionsDefaultWorkflowPermissionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/workflow"],
                    setGithubActionsPermissionsOrganization: ["PUT /orgs/{org}/actions/permissions"],
                    setGithubActionsPermissionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions"],
                    setSelectedReposForOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"],
                    setSelectedRepositoriesEnabledGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories"],
                    setWorkflowAccessToRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/access"]
                },
                activity: {
                    checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
                    deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
                    deleteThreadSubscription: ["DELETE /notifications/threads/{thread_id}/subscription"],
                    getFeeds: ["GET /feeds"],
                    getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
                    getThread: ["GET /notifications/threads/{thread_id}"],
                    getThreadSubscriptionForAuthenticatedUser: ["GET /notifications/threads/{thread_id}/subscription"],
                    listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
                    listNotificationsForAuthenticatedUser: ["GET /notifications"],
                    listOrgEventsForAuthenticatedUser: ["GET /users/{username}/events/orgs/{org}"],
                    listPublicEvents: ["GET /events"],
                    listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
                    listPublicEventsForUser: ["GET /users/{username}/events/public"],
                    listPublicOrgEvents: ["GET /orgs/{org}/events"],
                    listReceivedEventsForUser: ["GET /users/{username}/received_events"],
                    listReceivedPublicEventsForUser: ["GET /users/{username}/received_events/public"],
                    listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
                    listRepoNotificationsForAuthenticatedUser: ["GET /repos/{owner}/{repo}/notifications"],
                    listReposStarredByAuthenticatedUser: ["GET /user/starred"],
                    listReposStarredByUser: ["GET /users/{username}/starred"],
                    listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
                    listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
                    listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
                    listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
                    markNotificationsAsRead: ["PUT /notifications"],
                    markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
                    markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
                    setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
                    setThreadSubscription: ["PUT /notifications/threads/{thread_id}/subscription"],
                    starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
                    unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
                },
                apps: {
                    addRepoToInstallation: ["PUT /user/installations/{installation_id}/repositories/{repository_id}", {}, {
                            renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"]
                        }],
                    addRepoToInstallationForAuthenticatedUser: ["PUT /user/installations/{installation_id}/repositories/{repository_id}"],
                    checkToken: ["POST /applications/{client_id}/token"],
                    createFromManifest: ["POST /app-manifests/{code}/conversions"],
                    createInstallationAccessToken: ["POST /app/installations/{installation_id}/access_tokens"],
                    deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
                    deleteInstallation: ["DELETE /app/installations/{installation_id}"],
                    deleteToken: ["DELETE /applications/{client_id}/token"],
                    getAuthenticated: ["GET /app"],
                    getBySlug: ["GET /apps/{app_slug}"],
                    getInstallation: ["GET /app/installations/{installation_id}"],
                    getOrgInstallation: ["GET /orgs/{org}/installation"],
                    getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
                    getSubscriptionPlanForAccount: ["GET /marketplace_listing/accounts/{account_id}"],
                    getSubscriptionPlanForAccountStubbed: ["GET /marketplace_listing/stubbed/accounts/{account_id}"],
                    getUserInstallation: ["GET /users/{username}/installation"],
                    getWebhookConfigForApp: ["GET /app/hook/config"],
                    getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
                    listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
                    listAccountsForPlanStubbed: ["GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"],
                    listInstallationReposForAuthenticatedUser: ["GET /user/installations/{installation_id}/repositories"],
                    listInstallations: ["GET /app/installations"],
                    listInstallationsForAuthenticatedUser: ["GET /user/installations"],
                    listPlans: ["GET /marketplace_listing/plans"],
                    listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
                    listReposAccessibleToInstallation: ["GET /installation/repositories"],
                    listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
                    listSubscriptionsForAuthenticatedUserStubbed: ["GET /user/marketplace_purchases/stubbed"],
                    listWebhookDeliveries: ["GET /app/hook/deliveries"],
                    redeliverWebhookDelivery: ["POST /app/hook/deliveries/{delivery_id}/attempts"],
                    removeRepoFromInstallation: ["DELETE /user/installations/{installation_id}/repositories/{repository_id}", {}, {
                            renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"]
                        }],
                    removeRepoFromInstallationForAuthenticatedUser: ["DELETE /user/installations/{installation_id}/repositories/{repository_id}"],
                    resetToken: ["PATCH /applications/{client_id}/token"],
                    revokeInstallationAccessToken: ["DELETE /installation/token"],
                    scopeToken: ["POST /applications/{client_id}/token/scoped"],
                    suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
                    unsuspendInstallation: ["DELETE /app/installations/{installation_id}/suspended"],
                    updateWebhookConfigForApp: ["PATCH /app/hook/config"]
                },
                billing: {
                    getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
                    getGithubActionsBillingUser: ["GET /users/{username}/settings/billing/actions"],
                    getGithubAdvancedSecurityBillingGhe: ["GET /enterprises/{enterprise}/settings/billing/advanced-security"],
                    getGithubAdvancedSecurityBillingOrg: ["GET /orgs/{org}/settings/billing/advanced-security"],
                    getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
                    getGithubPackagesBillingUser: ["GET /users/{username}/settings/billing/packages"],
                    getSharedStorageBillingOrg: ["GET /orgs/{org}/settings/billing/shared-storage"],
                    getSharedStorageBillingUser: ["GET /users/{username}/settings/billing/shared-storage"]
                },
                checks: {
                    create: ["POST /repos/{owner}/{repo}/check-runs"],
                    createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
                    get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
                    getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
                    listAnnotations: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"],
                    listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
                    listForSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"],
                    listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
                    rerequestRun: ["POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"],
                    rerequestSuite: ["POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"],
                    setSuitesPreferences: ["PATCH /repos/{owner}/{repo}/check-suites/preferences"],
                    update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
                },
                codeScanning: {
                    deleteAnalysis: ["DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"],
                    getAlert: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}", {}, {
                            renamedParameters: {
                                alert_id: "alert_number"
                            }
                        }],
                    getAnalysis: ["GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"],
                    getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
                    listAlertInstances: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"],
                    listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
                    listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
                    listAlertsInstances: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances", {}, {
                            renamed: ["codeScanning", "listAlertInstances"]
                        }],
                    listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
                    updateAlert: ["PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"],
                    uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
                },
                codesOfConduct: {
                    getAllCodesOfConduct: ["GET /codes_of_conduct"],
                    getConductCode: ["GET /codes_of_conduct/{key}"]
                },
                codespaces: {
                    addRepositoryForSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
                    codespaceMachinesForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}/machines"],
                    createForAuthenticatedUser: ["POST /user/codespaces"],
                    createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
                    createOrUpdateSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}"],
                    createWithPrForAuthenticatedUser: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"],
                    createWithRepoForAuthenticatedUser: ["POST /repos/{owner}/{repo}/codespaces"],
                    deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
                    deleteFromOrganization: ["DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"],
                    deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
                    deleteSecretForAuthenticatedUser: ["DELETE /user/codespaces/secrets/{secret_name}"],
                    exportForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/exports"],
                    getExportDetailsForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}/exports/{export_id}"],
                    getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
                    getPublicKeyForAuthenticatedUser: ["GET /user/codespaces/secrets/public-key"],
                    getRepoPublicKey: ["GET /repos/{owner}/{repo}/codespaces/secrets/public-key"],
                    getRepoSecret: ["GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
                    getSecretForAuthenticatedUser: ["GET /user/codespaces/secrets/{secret_name}"],
                    listDevcontainersInRepositoryForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/devcontainers"],
                    listForAuthenticatedUser: ["GET /user/codespaces"],
                    listInOrganization: ["GET /orgs/{org}/codespaces", {}, {
                            renamedParameters: {
                                org_id: "org"
                            }
                        }],
                    listInRepositoryForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces"],
                    listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
                    listRepositoriesForSecretForAuthenticatedUser: ["GET /user/codespaces/secrets/{secret_name}/repositories"],
                    listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
                    removeRepositoryForSecretForAuthenticatedUser: ["DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
                    repoMachinesForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/machines"],
                    setRepositoriesForSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}/repositories"],
                    startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
                    stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
                    stopInOrganization: ["POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"],
                    updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
                },
                dependabot: {
                    addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"],
                    createOrUpdateOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}"],
                    createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
                    deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
                    deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
                    getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
                    getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
                    getRepoPublicKey: ["GET /repos/{owner}/{repo}/dependabot/secrets/public-key"],
                    getRepoSecret: ["GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
                    listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
                    listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
                    listSelectedReposForOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"],
                    removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"],
                    setSelectedReposForOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"]
                },
                dependencyGraph: {
                    createRepositorySnapshot: ["POST /repos/{owner}/{repo}/dependency-graph/snapshots"],
                    diffRange: ["GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"]
                },
                emojis: {
                    get: ["GET /emojis"]
                },
                enterpriseAdmin: {
                    addCustomLabelsToSelfHostedRunnerForEnterprise: ["POST /enterprises/{enterprise}/actions/runners/{runner_id}/labels"],
                    disableSelectedOrganizationGithubActionsEnterprise: ["DELETE /enterprises/{enterprise}/actions/permissions/organizations/{org_id}"],
                    enableSelectedOrganizationGithubActionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions/organizations/{org_id}"],
                    getAllowedActionsEnterprise: ["GET /enterprises/{enterprise}/actions/permissions/selected-actions"],
                    getGithubActionsPermissionsEnterprise: ["GET /enterprises/{enterprise}/actions/permissions"],
                    getServerStatistics: ["GET /enterprise-installation/{enterprise_or_org}/server-statistics"],
                    listLabelsForSelfHostedRunnerForEnterprise: ["GET /enterprises/{enterprise}/actions/runners/{runner_id}/labels"],
                    listSelectedOrganizationsEnabledGithubActionsEnterprise: ["GET /enterprises/{enterprise}/actions/permissions/organizations"],
                    removeAllCustomLabelsFromSelfHostedRunnerForEnterprise: ["DELETE /enterprises/{enterprise}/actions/runners/{runner_id}/labels"],
                    removeCustomLabelFromSelfHostedRunnerForEnterprise: ["DELETE /enterprises/{enterprise}/actions/runners/{runner_id}/labels/{name}"],
                    setAllowedActionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions/selected-actions"],
                    setCustomLabelsForSelfHostedRunnerForEnterprise: ["PUT /enterprises/{enterprise}/actions/runners/{runner_id}/labels"],
                    setGithubActionsPermissionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions"],
                    setSelectedOrganizationsEnabledGithubActionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions/organizations"]
                },
                gists: {
                    checkIsStarred: ["GET /gists/{gist_id}/star"],
                    create: ["POST /gists"],
                    createComment: ["POST /gists/{gist_id}/comments"],
                    "delete": ["DELETE /gists/{gist_id}"],
                    deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
                    fork: ["POST /gists/{gist_id}/forks"],
                    get: ["GET /gists/{gist_id}"],
                    getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
                    getRevision: ["GET /gists/{gist_id}/{sha}"],
                    list: ["GET /gists"],
                    listComments: ["GET /gists/{gist_id}/comments"],
                    listCommits: ["GET /gists/{gist_id}/commits"],
                    listForUser: ["GET /users/{username}/gists"],
                    listForks: ["GET /gists/{gist_id}/forks"],
                    listPublic: ["GET /gists/public"],
                    listStarred: ["GET /gists/starred"],
                    star: ["PUT /gists/{gist_id}/star"],
                    unstar: ["DELETE /gists/{gist_id}/star"],
                    update: ["PATCH /gists/{gist_id}"],
                    updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
                },
                git: {
                    createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
                    createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
                    createRef: ["POST /repos/{owner}/{repo}/git/refs"],
                    createTag: ["POST /repos/{owner}/{repo}/git/tags"],
                    createTree: ["POST /repos/{owner}/{repo}/git/trees"],
                    deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
                    getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
                    getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
                    getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
                    getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
                    getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
                    listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
                    updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
                },
                gitignore: {
                    getAllTemplates: ["GET /gitignore/templates"],
                    getTemplate: ["GET /gitignore/templates/{name}"]
                },
                interactions: {
                    getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
                    getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
                    getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
                    getRestrictionsForYourPublicRepos: ["GET /user/interaction-limits", {}, {
                            renamed: ["interactions", "getRestrictionsForAuthenticatedUser"]
                        }],
                    removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
                    removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
                    removeRestrictionsForRepo: ["DELETE /repos/{owner}/{repo}/interaction-limits"],
                    removeRestrictionsForYourPublicRepos: ["DELETE /user/interaction-limits", {}, {
                            renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"]
                        }],
                    setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
                    setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
                    setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
                    setRestrictionsForYourPublicRepos: ["PUT /user/interaction-limits", {}, {
                            renamed: ["interactions", "setRestrictionsForAuthenticatedUser"]
                        }]
                },
                issues: {
                    addAssignees: ["POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
                    addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
                    checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
                    create: ["POST /repos/{owner}/{repo}/issues"],
                    createComment: ["POST /repos/{owner}/{repo}/issues/{issue_number}/comments"],
                    createLabel: ["POST /repos/{owner}/{repo}/labels"],
                    createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
                    deleteComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"],
                    deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
                    deleteMilestone: ["DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"],
                    get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
                    getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
                    getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
                    getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
                    getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
                    list: ["GET /issues"],
                    listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
                    listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
                    listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
                    listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
                    listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
                    listEventsForTimeline: ["GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"],
                    listForAuthenticatedUser: ["GET /user/issues"],
                    listForOrg: ["GET /orgs/{org}/issues"],
                    listForRepo: ["GET /repos/{owner}/{repo}/issues"],
                    listLabelsForMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"],
                    listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
                    listLabelsOnIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/labels"],
                    listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
                    lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
                    removeAllLabels: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"],
                    removeAssignees: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
                    removeLabel: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"],
                    setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
                    unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
                    update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
                    updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
                    updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
                    updateMilestone: ["PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"]
                },
                licenses: {
                    get: ["GET /licenses/{license}"],
                    getAllCommonlyUsed: ["GET /licenses"],
                    getForRepo: ["GET /repos/{owner}/{repo}/license"]
                },
                markdown: {
                    render: ["POST /markdown"],
                    renderRaw: ["POST /markdown/raw", {
                            headers: {
                                "content-type": "text/plain; charset=utf-8"
                            }
                        }]
                },
                meta: {
                    get: ["GET /meta"],
                    getOctocat: ["GET /octocat"],
                    getZen: ["GET /zen"],
                    root: ["GET /"]
                },
                migrations: {
                    cancelImport: ["DELETE /repos/{owner}/{repo}/import"],
                    deleteArchiveForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/archive"],
                    deleteArchiveForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/archive"],
                    downloadArchiveForOrg: ["GET /orgs/{org}/migrations/{migration_id}/archive"],
                    getArchiveForAuthenticatedUser: ["GET /user/migrations/{migration_id}/archive"],
                    getCommitAuthors: ["GET /repos/{owner}/{repo}/import/authors"],
                    getImportStatus: ["GET /repos/{owner}/{repo}/import"],
                    getLargeFiles: ["GET /repos/{owner}/{repo}/import/large_files"],
                    getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
                    getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
                    listForAuthenticatedUser: ["GET /user/migrations"],
                    listForOrg: ["GET /orgs/{org}/migrations"],
                    listReposForAuthenticatedUser: ["GET /user/migrations/{migration_id}/repositories"],
                    listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
                    listReposForUser: ["GET /user/migrations/{migration_id}/repositories", {}, {
                            renamed: ["migrations", "listReposForAuthenticatedUser"]
                        }],
                    mapCommitAuthor: ["PATCH /repos/{owner}/{repo}/import/authors/{author_id}"],
                    setLfsPreference: ["PATCH /repos/{owner}/{repo}/import/lfs"],
                    startForAuthenticatedUser: ["POST /user/migrations"],
                    startForOrg: ["POST /orgs/{org}/migrations"],
                    startImport: ["PUT /repos/{owner}/{repo}/import"],
                    unlockRepoForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"],
                    unlockRepoForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"],
                    updateImport: ["PATCH /repos/{owner}/{repo}/import"]
                },
                orgs: {
                    blockUser: ["PUT /orgs/{org}/blocks/{username}"],
                    cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
                    checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
                    checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
                    checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
                    convertMemberToOutsideCollaborator: ["PUT /orgs/{org}/outside_collaborators/{username}"],
                    createInvitation: ["POST /orgs/{org}/invitations"],
                    createWebhook: ["POST /orgs/{org}/hooks"],
                    deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
                    get: ["GET /orgs/{org}"],
                    getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
                    getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
                    getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
                    getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
                    getWebhookDelivery: ["GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"],
                    list: ["GET /organizations"],
                    listAppInstallations: ["GET /orgs/{org}/installations"],
                    listBlockedUsers: ["GET /orgs/{org}/blocks"],
                    listCustomRoles: ["GET /organizations/{organization_id}/custom_roles"],
                    listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
                    listForAuthenticatedUser: ["GET /user/orgs"],
                    listForUser: ["GET /users/{username}/orgs"],
                    listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
                    listMembers: ["GET /orgs/{org}/members"],
                    listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
                    listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
                    listPendingInvitations: ["GET /orgs/{org}/invitations"],
                    listPublicMembers: ["GET /orgs/{org}/public_members"],
                    listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
                    listWebhooks: ["GET /orgs/{org}/hooks"],
                    pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
                    redeliverWebhookDelivery: ["POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"],
                    removeMember: ["DELETE /orgs/{org}/members/{username}"],
                    removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
                    removeOutsideCollaborator: ["DELETE /orgs/{org}/outside_collaborators/{username}"],
                    removePublicMembershipForAuthenticatedUser: ["DELETE /orgs/{org}/public_members/{username}"],
                    setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
                    setPublicMembershipForAuthenticatedUser: ["PUT /orgs/{org}/public_members/{username}"],
                    unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
                    update: ["PATCH /orgs/{org}"],
                    updateMembershipForAuthenticatedUser: ["PATCH /user/memberships/orgs/{org}"],
                    updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
                    updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
                },
                packages: {
                    deletePackageForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}"],
                    deletePackageForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}"],
                    deletePackageForUser: ["DELETE /users/{username}/packages/{package_type}/{package_name}"],
                    deletePackageVersionForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
                    deletePackageVersionForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
                    deletePackageVersionForUser: ["DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
                    getAllPackageVersionsForAPackageOwnedByAnOrg: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions", {}, {
                            renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"]
                        }],
                    getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions", {}, {
                            renamed: ["packages", "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"]
                        }],
                    getAllPackageVersionsForPackageOwnedByAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions"],
                    getAllPackageVersionsForPackageOwnedByOrg: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions"],
                    getAllPackageVersionsForPackageOwnedByUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions"],
                    getPackageForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}"],
                    getPackageForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}"],
                    getPackageForUser: ["GET /users/{username}/packages/{package_type}/{package_name}"],
                    getPackageVersionForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
                    getPackageVersionForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
                    getPackageVersionForUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
                    listPackagesForAuthenticatedUser: ["GET /user/packages"],
                    listPackagesForOrganization: ["GET /orgs/{org}/packages"],
                    listPackagesForUser: ["GET /users/{username}/packages"],
                    restorePackageForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/restore{?token}"],
                    restorePackageForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"],
                    restorePackageForUser: ["POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"],
                    restorePackageVersionForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
                    restorePackageVersionForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
                    restorePackageVersionForUser: ["POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"]
                },
                projects: {
                    addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
                    createCard: ["POST /projects/columns/{column_id}/cards"],
                    createColumn: ["POST /projects/{project_id}/columns"],
                    createForAuthenticatedUser: ["POST /user/projects"],
                    createForOrg: ["POST /orgs/{org}/projects"],
                    createForRepo: ["POST /repos/{owner}/{repo}/projects"],
                    "delete": ["DELETE /projects/{project_id}"],
                    deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
                    deleteColumn: ["DELETE /projects/columns/{column_id}"],
                    get: ["GET /projects/{project_id}"],
                    getCard: ["GET /projects/columns/cards/{card_id}"],
                    getColumn: ["GET /projects/columns/{column_id}"],
                    getPermissionForUser: ["GET /projects/{project_id}/collaborators/{username}/permission"],
                    listCards: ["GET /projects/columns/{column_id}/cards"],
                    listCollaborators: ["GET /projects/{project_id}/collaborators"],
                    listColumns: ["GET /projects/{project_id}/columns"],
                    listForOrg: ["GET /orgs/{org}/projects"],
                    listForRepo: ["GET /repos/{owner}/{repo}/projects"],
                    listForUser: ["GET /users/{username}/projects"],
                    moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
                    moveColumn: ["POST /projects/columns/{column_id}/moves"],
                    removeCollaborator: ["DELETE /projects/{project_id}/collaborators/{username}"],
                    update: ["PATCH /projects/{project_id}"],
                    updateCard: ["PATCH /projects/columns/cards/{card_id}"],
                    updateColumn: ["PATCH /projects/columns/{column_id}"]
                },
                pulls: {
                    checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
                    create: ["POST /repos/{owner}/{repo}/pulls"],
                    createReplyForReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"],
                    createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
                    createReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
                    deletePendingReview: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
                    deleteReviewComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
                    dismissReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"],
                    get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
                    getReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
                    getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
                    list: ["GET /repos/{owner}/{repo}/pulls"],
                    listCommentsForReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"],
                    listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
                    listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
                    listRequestedReviewers: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
                    listReviewComments: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
                    listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
                    listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
                    merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
                    removeRequestedReviewers: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
                    requestReviewers: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
                    submitReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"],
                    update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
                    updateBranch: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"],
                    updateReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
                    updateReviewComment: ["PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"]
                },
                rateLimit: {
                    get: ["GET /rate_limit"]
                },
                reactions: {
                    createForCommitComment: ["POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"],
                    createForIssue: ["POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
                    createForIssueComment: ["POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"],
                    createForPullRequestReviewComment: ["POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"],
                    createForRelease: ["POST /repos/{owner}/{repo}/releases/{release_id}/reactions"],
                    createForTeamDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"],
                    createForTeamDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"],
                    deleteForCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"],
                    deleteForIssue: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"],
                    deleteForIssueComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"],
                    deleteForPullRequestComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"],
                    deleteForRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"],
                    deleteForTeamDiscussion: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"],
                    deleteForTeamDiscussionComment: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"],
                    listForCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"],
                    listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
                    listForIssueComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"],
                    listForPullRequestReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"],
                    listForRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}/reactions"],
                    listForTeamDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"],
                    listForTeamDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"]
                },
                repos: {
                    acceptInvitation: ["PATCH /user/repository_invitations/{invitation_id}", {}, {
                            renamed: ["repos", "acceptInvitationForAuthenticatedUser"]
                        }],
                    acceptInvitationForAuthenticatedUser: ["PATCH /user/repository_invitations/{invitation_id}"],
                    addAppAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
                            mapToData: "apps"
                        }],
                    addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
                    addStatusCheckContexts: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
                            mapToData: "contexts"
                        }],
                    addTeamAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
                            mapToData: "teams"
                        }],
                    addUserAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
                            mapToData: "users"
                        }],
                    checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
                    checkVulnerabilityAlerts: ["GET /repos/{owner}/{repo}/vulnerability-alerts"],
                    codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
                    compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
                    compareCommitsWithBasehead: ["GET /repos/{owner}/{repo}/compare/{basehead}"],
                    createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
                    createCommitComment: ["POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
                    createCommitSignatureProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
                    createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
                    createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
                    createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
                    createDeploymentStatus: ["POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
                    createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
                    createForAuthenticatedUser: ["POST /user/repos"],
                    createFork: ["POST /repos/{owner}/{repo}/forks"],
                    createInOrg: ["POST /orgs/{org}/repos"],
                    createOrUpdateEnvironment: ["PUT /repos/{owner}/{repo}/environments/{environment_name}"],
                    createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
                    createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
                    createRelease: ["POST /repos/{owner}/{repo}/releases"],
                    createTagProtection: ["POST /repos/{owner}/{repo}/tags/protection"],
                    createUsingTemplate: ["POST /repos/{template_owner}/{template_repo}/generate"],
                    createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
                    declineInvitation: ["DELETE /user/repository_invitations/{invitation_id}", {}, {
                            renamed: ["repos", "declineInvitationForAuthenticatedUser"]
                        }],
                    declineInvitationForAuthenticatedUser: ["DELETE /user/repository_invitations/{invitation_id}"],
                    "delete": ["DELETE /repos/{owner}/{repo}"],
                    deleteAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
                    deleteAdminBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
                    deleteAnEnvironment: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}"],
                    deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
                    deleteBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection"],
                    deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
                    deleteCommitSignatureProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
                    deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
                    deleteDeployment: ["DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"],
                    deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
                    deleteInvitation: ["DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"],
                    deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
                    deletePullRequestReviewProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
                    deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
                    deleteReleaseAsset: ["DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"],
                    deleteTagProtection: ["DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}"],
                    deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
                    disableAutomatedSecurityFixes: ["DELETE /repos/{owner}/{repo}/automated-security-fixes"],
                    disableLfsForRepo: ["DELETE /repos/{owner}/{repo}/lfs"],
                    disableVulnerabilityAlerts: ["DELETE /repos/{owner}/{repo}/vulnerability-alerts"],
                    downloadArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}", {}, {
                            renamed: ["repos", "downloadZipballArchive"]
                        }],
                    downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
                    downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
                    enableAutomatedSecurityFixes: ["PUT /repos/{owner}/{repo}/automated-security-fixes"],
                    enableLfsForRepo: ["PUT /repos/{owner}/{repo}/lfs"],
                    enableVulnerabilityAlerts: ["PUT /repos/{owner}/{repo}/vulnerability-alerts"],
                    generateReleaseNotes: ["POST /repos/{owner}/{repo}/releases/generate-notes"],
                    get: ["GET /repos/{owner}/{repo}"],
                    getAccessRestrictions: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
                    getAdminBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
                    getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
                    getAllStatusCheckContexts: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"],
                    getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
                    getAppsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"],
                    getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
                    getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
                    getBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection"],
                    getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
                    getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
                    getCollaboratorPermissionLevel: ["GET /repos/{owner}/{repo}/collaborators/{username}/permission"],
                    getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
                    getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
                    getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
                    getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
                    getCommitSignatureProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
                    getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
                    getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
                    getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
                    getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
                    getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
                    getDeploymentStatus: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"],
                    getEnvironment: ["GET /repos/{owner}/{repo}/environments/{environment_name}"],
                    getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
                    getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
                    getPages: ["GET /repos/{owner}/{repo}/pages"],
                    getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
                    getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
                    getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
                    getPullRequestReviewProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
                    getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
                    getReadme: ["GET /repos/{owner}/{repo}/readme"],
                    getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
                    getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
                    getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
                    getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
                    getStatusChecksProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
                    getTeamsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"],
                    getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
                    getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
                    getUsersWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"],
                    getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
                    getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
                    getWebhookConfigForRepo: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/config"],
                    getWebhookDelivery: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"],
                    listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
                    listBranches: ["GET /repos/{owner}/{repo}/branches"],
                    listBranchesForHeadCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"],
                    listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
                    listCommentsForCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
                    listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
                    listCommitStatusesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/statuses"],
                    listCommits: ["GET /repos/{owner}/{repo}/commits"],
                    listContributors: ["GET /repos/{owner}/{repo}/contributors"],
                    listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
                    listDeploymentStatuses: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
                    listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
                    listForAuthenticatedUser: ["GET /user/repos"],
                    listForOrg: ["GET /orgs/{org}/repos"],
                    listForUser: ["GET /users/{username}/repos"],
                    listForks: ["GET /repos/{owner}/{repo}/forks"],
                    listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
                    listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
                    listLanguages: ["GET /repos/{owner}/{repo}/languages"],
                    listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
                    listPublic: ["GET /repositories"],
                    listPullRequestsAssociatedWithCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"],
                    listReleaseAssets: ["GET /repos/{owner}/{repo}/releases/{release_id}/assets"],
                    listReleases: ["GET /repos/{owner}/{repo}/releases"],
                    listTagProtection: ["GET /repos/{owner}/{repo}/tags/protection"],
                    listTags: ["GET /repos/{owner}/{repo}/tags"],
                    listTeams: ["GET /repos/{owner}/{repo}/teams"],
                    listWebhookDeliveries: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"],
                    listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
                    merge: ["POST /repos/{owner}/{repo}/merges"],
                    mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
                    pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
                    redeliverWebhookDelivery: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"],
                    removeAppAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
                            mapToData: "apps"
                        }],
                    removeCollaborator: ["DELETE /repos/{owner}/{repo}/collaborators/{username}"],
                    removeStatusCheckContexts: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
                            mapToData: "contexts"
                        }],
                    removeStatusCheckProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
                    removeTeamAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
                            mapToData: "teams"
                        }],
                    removeUserAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
                            mapToData: "users"
                        }],
                    renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
                    replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
                    requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
                    setAdminBranchProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
                    setAppAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
                            mapToData: "apps"
                        }],
                    setStatusCheckContexts: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
                            mapToData: "contexts"
                        }],
                    setTeamAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
                            mapToData: "teams"
                        }],
                    setUserAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
                            mapToData: "users"
                        }],
                    testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
                    transfer: ["POST /repos/{owner}/{repo}/transfer"],
                    update: ["PATCH /repos/{owner}/{repo}"],
                    updateBranchProtection: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection"],
                    updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
                    updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
                    updateInvitation: ["PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"],
                    updatePullRequestReviewProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
                    updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
                    updateReleaseAsset: ["PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"],
                    updateStatusCheckPotection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks", {}, {
                            renamed: ["repos", "updateStatusCheckProtection"]
                        }],
                    updateStatusCheckProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
                    updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
                    updateWebhookConfigForRepo: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"],
                    uploadReleaseAsset: ["POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}", {
                            baseUrl: "https://uploads.github.com"
                        }]
                },
                search: {
                    code: ["GET /search/code"],
                    commits: ["GET /search/commits"],
                    issuesAndPullRequests: ["GET /search/issues"],
                    labels: ["GET /search/labels"],
                    repos: ["GET /search/repositories"],
                    topics: ["GET /search/topics"],
                    users: ["GET /search/users"]
                },
                secretScanning: {
                    getAlert: ["GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"],
                    listAlertsForEnterprise: ["GET /enterprises/{enterprise}/secret-scanning/alerts"],
                    listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
                    listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
                    listLocationsForAlert: ["GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"],
                    updateAlert: ["PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"]
                },
                teams: {
                    addOrUpdateMembershipForUserInOrg: ["PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"],
                    addOrUpdateProjectPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
                    addOrUpdateRepoPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
                    checkPermissionsForProjectInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
                    checkPermissionsForRepoInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
                    create: ["POST /orgs/{org}/teams"],
                    createDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
                    createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
                    deleteDiscussionCommentInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
                    deleteDiscussionInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
                    deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
                    getByName: ["GET /orgs/{org}/teams/{team_slug}"],
                    getDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
                    getDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
                    getMembershipForUserInOrg: ["GET /orgs/{org}/teams/{team_slug}/memberships/{username}"],
                    list: ["GET /orgs/{org}/teams"],
                    listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
                    listDiscussionCommentsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
                    listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
                    listForAuthenticatedUser: ["GET /user/teams"],
                    listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
                    listPendingInvitationsInOrg: ["GET /orgs/{org}/teams/{team_slug}/invitations"],
                    listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
                    listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
                    removeMembershipForUserInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"],
                    removeProjectInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
                    removeRepoInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
                    updateDiscussionCommentInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
                    updateDiscussionInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
                    updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
                },
                users: {
                    addEmailForAuthenticated: ["POST /user/emails", {}, {
                            renamed: ["users", "addEmailForAuthenticatedUser"]
                        }],
                    addEmailForAuthenticatedUser: ["POST /user/emails"],
                    block: ["PUT /user/blocks/{username}"],
                    checkBlocked: ["GET /user/blocks/{username}"],
                    checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
                    checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
                    createGpgKeyForAuthenticated: ["POST /user/gpg_keys", {}, {
                            renamed: ["users", "createGpgKeyForAuthenticatedUser"]
                        }],
                    createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
                    createPublicSshKeyForAuthenticated: ["POST /user/keys", {}, {
                            renamed: ["users", "createPublicSshKeyForAuthenticatedUser"]
                        }],
                    createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
                    deleteEmailForAuthenticated: ["DELETE /user/emails", {}, {
                            renamed: ["users", "deleteEmailForAuthenticatedUser"]
                        }],
                    deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
                    deleteGpgKeyForAuthenticated: ["DELETE /user/gpg_keys/{gpg_key_id}", {}, {
                            renamed: ["users", "deleteGpgKeyForAuthenticatedUser"]
                        }],
                    deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
                    deletePublicSshKeyForAuthenticated: ["DELETE /user/keys/{key_id}", {}, {
                            renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"]
                        }],
                    deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
                    follow: ["PUT /user/following/{username}"],
                    getAuthenticated: ["GET /user"],
                    getByUsername: ["GET /users/{username}"],
                    getContextForUser: ["GET /users/{username}/hovercard"],
                    getGpgKeyForAuthenticated: ["GET /user/gpg_keys/{gpg_key_id}", {}, {
                            renamed: ["users", "getGpgKeyForAuthenticatedUser"]
                        }],
                    getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
                    getPublicSshKeyForAuthenticated: ["GET /user/keys/{key_id}", {}, {
                            renamed: ["users", "getPublicSshKeyForAuthenticatedUser"]
                        }],
                    getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
                    list: ["GET /users"],
                    listBlockedByAuthenticated: ["GET /user/blocks", {}, {
                            renamed: ["users", "listBlockedByAuthenticatedUser"]
                        }],
                    listBlockedByAuthenticatedUser: ["GET /user/blocks"],
                    listEmailsForAuthenticated: ["GET /user/emails", {}, {
                            renamed: ["users", "listEmailsForAuthenticatedUser"]
                        }],
                    listEmailsForAuthenticatedUser: ["GET /user/emails"],
                    listFollowedByAuthenticated: ["GET /user/following", {}, {
                            renamed: ["users", "listFollowedByAuthenticatedUser"]
                        }],
                    listFollowedByAuthenticatedUser: ["GET /user/following"],
                    listFollowersForAuthenticatedUser: ["GET /user/followers"],
                    listFollowersForUser: ["GET /users/{username}/followers"],
                    listFollowingForUser: ["GET /users/{username}/following"],
                    listGpgKeysForAuthenticated: ["GET /user/gpg_keys", {}, {
                            renamed: ["users", "listGpgKeysForAuthenticatedUser"]
                        }],
                    listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
                    listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
                    listPublicEmailsForAuthenticated: ["GET /user/public_emails", {}, {
                            renamed: ["users", "listPublicEmailsForAuthenticatedUser"]
                        }],
                    listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
                    listPublicKeysForUser: ["GET /users/{username}/keys"],
                    listPublicSshKeysForAuthenticated: ["GET /user/keys", {}, {
                            renamed: ["users", "listPublicSshKeysForAuthenticatedUser"]
                        }],
                    listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
                    setPrimaryEmailVisibilityForAuthenticated: ["PATCH /user/email/visibility", {}, {
                            renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"]
                        }],
                    setPrimaryEmailVisibilityForAuthenticatedUser: ["PATCH /user/email/visibility"],
                    unblock: ["DELETE /user/blocks/{username}"],
                    unfollow: ["DELETE /user/following/{username}"],
                    updateAuthenticated: ["PATCH /user"]
                }
            };
            var VERSION = "5.16.2";
            function endpointsToMethods(octokit, endpointsMap) {
                var newMethods = {};
                for (var _1 = 0, _2 = Object.entries(endpointsMap); _1 < _2.length; _1++) {
                    var _3 = _2[_1], scope = _3[0], endpoints = _3[1];
                    for (var _4 = 0, _5 = Object.entries(endpoints); _4 < _5.length; _4++) {
                        var _6 = _5[_4], methodName = _6[0], endpoint = _6[1];
                        var route = endpoint[0], defaults = endpoint[1], decorations = endpoint[2];
                        var _7 = route.split(/ /), method = _7[0], url = _7[1];
                        var endpointDefaults = Object.assign({
                            method: method,
                            url: url
                        }, defaults);
                        if (!newMethods[scope]) {
                            newMethods[scope] = {};
                        }
                        var scopeMethods = newMethods[scope];
                        if (decorations) {
                            scopeMethods[methodName] = decorate(octokit, scope, methodName, endpointDefaults, decorations);
                            continue;
                        }
                        scopeMethods[methodName] = octokit.request.defaults(endpointDefaults);
                    }
                }
                return newMethods;
            }
            function decorate(octokit, scope, methodName, defaults, decorations) {
                var requestWithDefaults = octokit.request.defaults(defaults);
                /* istanbul ignore next */
                function withDecorations() {
                    var _1, _2, _3;
                    var args = [];
                    for (var _4 = 0; _4 < arguments.length; _4++) {
                        args[_4] = arguments[_4];
                    }
                    // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488
                    var options = (_1 = requestWithDefaults.endpoint).merge.apply(_1, args); // There are currently no other decorations than `.mapToData`
                    if (decorations.mapToData) {
                        options = Object.assign({}, options, (_2 = {
                                data: options[decorations.mapToData]
                            },
                            _2[decorations.mapToData] = undefined,
                            _2));
                        return requestWithDefaults(options);
                    }
                    if (decorations.renamed) {
                        var _5 = decorations.renamed, newScope = _5[0], newMethodName = _5[1];
                        octokit.log.warn("octokit.".concat(scope, ".").concat(methodName, "() has been renamed to octokit.").concat(newScope, ".").concat(newMethodName, "()"));
                    }
                    if (decorations.deprecated) {
                        octokit.log.warn(decorations.deprecated);
                    }
                    if (decorations.renamedParameters) {
                        // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488
                        var options_1 = (_3 = requestWithDefaults.endpoint).merge.apply(_3, args);
                        for (var _6 = 0, _7 = Object.entries(decorations.renamedParameters); _6 < _7.length; _6++) {
                            var _8 = _7[_6], name_1 = _8[0], alias = _8[1];
                            if (name_1 in options_1) {
                                octokit.log.warn("\"".concat(name_1, "\" parameter is deprecated for \"octokit.").concat(scope, ".").concat(methodName, "()\". Use \"").concat(alias, "\" instead"));
                                if (!(alias in options_1)) {
                                    options_1[alias] = options_1[name_1];
                                }
                                delete options_1[name_1];
                            }
                        }
                        return requestWithDefaults(options_1);
                    } // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488
                    return requestWithDefaults.apply(void 0, args);
                }
                return Object.assign(withDecorations, requestWithDefaults);
            }
            function restEndpointMethods(octokit) {
                var api = endpointsToMethods(octokit, Endpoints);
                return {
                    rest: api
                };
            }
            restEndpointMethods.VERSION = VERSION;
            function legacyRestEndpointMethods(octokit) {
                var api = endpointsToMethods(octokit, Endpoints);
                return _objectSpread2(_objectSpread2({}, api), {}, {
                    rest: api
                });
            }
            legacyRestEndpointMethods.VERSION = VERSION;
            exports.legacyRestEndpointMethods = legacyRestEndpointMethods;
            exports.restEndpointMethods = restEndpointMethods;
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 537: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            function _interopDefault(ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }
            var deprecation = __nccwpck_require__(8932);
            var once = _interopDefault(__nccwpck_require__(1223));
            var logOnceCode = once(function (deprecation) { return console.warn(deprecation); });
            var logOnceHeaders = once(function (deprecation) { return console.warn(deprecation); });
            /**
             * Error with extra properties to help with debugging
             */
            var RequestError = /** @class */ (function (_super) {
                __extends(RequestError, _super);
                function RequestError(message, statusCode, options) {
                    var _this_1 = _super.call(this, message) || this;
                    /* istanbul ignore next */
                    if (Error.captureStackTrace) {
                        Error.captureStackTrace(_this_1, _this_1.constructor);
                    }
                    _this_1.name = "HttpError";
                    _this_1.status = statusCode;
                    var headers;
                    if ("headers" in options && typeof options.headers !== "undefined") {
                        headers = options.headers;
                    }
                    if ("response" in options) {
                        _this_1.response = options.response;
                        headers = options.response.headers;
                    } // redact request credentials without mutating original request options
                    var requestCopy = Object.assign({}, options.request);
                    if (options.request.headers.authorization) {
                        requestCopy.headers = Object.assign({}, options.request.headers, {
                            authorization: options.request.headers.authorization.replace(/ .*$/, " [REDACTED]")
                        });
                    }
                    requestCopy.url = requestCopy.url // client_id & client_secret can be passed as URL query parameters to increase rate limit
                        // see https://developer.github.com/v3/#increasing-the-unauthenticated-rate-limit-for-oauth-applications
                        .replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]") // OAuth tokens can be passed as URL query parameters, although it is not recommended
                        // see https://developer.github.com/v3/#oauth2-token-sent-in-a-header
                        .replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
                    _this_1.request = requestCopy; // deprecations
                    Object.defineProperty(_this_1, "code", {
                        get: function () {
                            logOnceCode(new deprecation.Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`."));
                            return statusCode;
                        }
                    });
                    Object.defineProperty(_this_1, "headers", {
                        get: function () {
                            logOnceHeaders(new deprecation.Deprecation("[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."));
                            return headers || {};
                        }
                    });
                    return _this_1;
                }
                return RequestError;
            }(Error));
            exports.RequestError = RequestError;
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 6234: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            function _interopDefault(ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }
            var endpoint = __nccwpck_require__(9440);
            var universalUserAgent = __nccwpck_require__(5030);
            var isPlainObject = __nccwpck_require__(3287);
            var nodeFetch = _interopDefault(__nccwpck_require__(467));
            var requestError = __nccwpck_require__(537);
            var VERSION = "5.6.3";
            function getBufferResponse(response) {
                return response.arrayBuffer();
            }
            function fetchWrapper(requestOptions) {
                var _this_1 = this;
                var log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
                if (isPlainObject.isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) {
                    requestOptions.body = JSON.stringify(requestOptions.body);
                }
                var headers = {};
                var status;
                var url;
                var fetch = requestOptions.request && requestOptions.request.fetch || nodeFetch;
                return fetch(requestOptions.url, Object.assign({
                    method: requestOptions.method,
                    body: requestOptions.body,
                    headers: requestOptions.headers,
                    redirect: requestOptions.redirect
                }, // `requestOptions.request.agent` type is incompatible
                // see https://github.com/octokit/types.ts/pull/264
                requestOptions.request)).then(function (response) { return __awaiter(_this_1, void 0, void 0, function () {
                    var _1, _2, keyAndValue, matches, deprecationLink, _3, _4, _5, data, error;
                    var _6, _7;
                    return __generator(this, function (_8) {
                        switch (_8.label) {
                            case 0:
                                url = response.url;
                                status = response.status;
                                for (_1 = 0, _2 = response.headers; _1 < _2.length; _1++) {
                                    keyAndValue = _2[_1];
                                    headers[keyAndValue[0]] = keyAndValue[1];
                                }
                                if ("deprecation" in headers) {
                                    matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
                                    deprecationLink = matches && matches.pop();
                                    log.warn("[@octokit/request] \"".concat(requestOptions.method, " ").concat(requestOptions.url, "\" is deprecated. It is scheduled to be removed on ").concat(headers.sunset).concat(deprecationLink ? ". See ".concat(deprecationLink) : ""));
                                }
                                if (status === 204 || status === 205) {
                                    return [2 /*return*/];
                                } // GitHub API returns 200 for HEAD requests
                                if (requestOptions.method === "HEAD") {
                                    if (status < 400) {
                                        return [2 /*return*/];
                                    }
                                    throw new requestError.RequestError(response.statusText, status, {
                                        response: {
                                            url: url,
                                            status: status,
                                            headers: headers,
                                            data: undefined
                                        },
                                        request: requestOptions
                                    });
                                }
                                if (!(status === 304)) return [3 /*break*/, 2];
                                _4 = (_3 = requestError.RequestError).bind;
                                _5 = [void 0, "Not modified", status];
                                _6 = {};
                                _7 = {
                                    url: url,
                                    status: status,
                                    headers: headers
                                };
                                return [4 /*yield*/, getResponseData(response)];
                            case 1: throw new (_4.apply(_3, _5.concat([(_6.response = (_7.data = _8.sent(),
                                    _7),
                                    _6.request = requestOptions,
                                    _6)])))();
                            case 2:
                                if (!(status >= 400)) return [3 /*break*/, 4];
                                return [4 /*yield*/, getResponseData(response)];
                            case 3:
                                data = _8.sent();
                                error = new requestError.RequestError(toErrorMessage(data), status, {
                                    response: {
                                        url: url,
                                        status: status,
                                        headers: headers,
                                        data: data
                                    },
                                    request: requestOptions
                                });
                                throw error;
                            case 4: return [2 /*return*/, getResponseData(response)];
                        }
                    });
                }); }).then(function (data) {
                    return {
                        status: status,
                        url: url,
                        headers: headers,
                        data: data
                    };
                })["catch"](function (error) {
                    if (error instanceof requestError.RequestError)
                        throw error;
                    throw new requestError.RequestError(error.message, 500, {
                        request: requestOptions
                    });
                });
            }
            function getResponseData(response) {
                return __awaiter(this, void 0, void 0, function () {
                    var contentType;
                    return __generator(this, function (_1) {
                        contentType = response.headers.get("content-type");
                        if (/application\/json/.test(contentType)) {
                            return [2 /*return*/, response.json()];
                        }
                        if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
                            return [2 /*return*/, response.text()];
                        }
                        return [2 /*return*/, getBufferResponse(response)];
                    });
                });
            }
            function toErrorMessage(data) {
                if (typeof data === "string")
                    return data; // istanbul ignore else - just in case
                if ("message" in data) {
                    if (Array.isArray(data.errors)) {
                        return "".concat(data.message, ": ").concat(data.errors.map(JSON.stringify).join(", "));
                    }
                    return data.message;
                } // istanbul ignore next - just in case
                return "Unknown error: ".concat(JSON.stringify(data));
            }
            function withDefaults(oldEndpoint, newDefaults) {
                var endpoint = oldEndpoint.defaults(newDefaults);
                var newApi = function (route, parameters) {
                    var endpointOptions = endpoint.merge(route, parameters);
                    if (!endpointOptions.request || !endpointOptions.request.hook) {
                        return fetchWrapper(endpoint.parse(endpointOptions));
                    }
                    var request = function (route, parameters) {
                        return fetchWrapper(endpoint.parse(endpoint.merge(route, parameters)));
                    };
                    Object.assign(request, {
                        endpoint: endpoint,
                        defaults: withDefaults.bind(null, endpoint)
                    });
                    return endpointOptions.request.hook(request, endpointOptions);
                };
                return Object.assign(newApi, {
                    endpoint: endpoint,
                    defaults: withDefaults.bind(null, endpoint)
                });
            }
            var request = withDefaults(endpoint.endpoint, {
                headers: {
                    "user-agent": "octokit-request.js/".concat(VERSION, " ").concat(universalUserAgent.getUserAgent())
                }
            });
            exports.request = request;
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 198: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var ansiStyles = __nccwpck_require__(2068);
            var _1 = __nccwpck_require__(628), stdoutColor = _1.stdout, stderrColor = _1.stderr;
            var _2 = __nccwpck_require__(7625), stringReplaceAll = _2.stringReplaceAll, stringEncaseCRLFWithFirstIndex = _2.stringEncaseCRLFWithFirstIndex;
            var isArray = Array.isArray;
            // `supportsColor.level`  `ansiStyles.color[name]` mapping
            var levelMapping = [
                'ansi',
                'ansi',
                'ansi256',
                'ansi16m'
            ];
            var styles = Object.create(null);
            var applyOptions = function (object, options) {
                if (options === void 0) { options = {}; }
                if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
                    throw new Error('The `level` option should be an integer from 0 to 3');
                }
                // Detect level if not set manually
                var colorLevel = stdoutColor ? stdoutColor.level : 0;
                object.level = options.level === undefined ? colorLevel : options.level;
            };
            var ChalkClass = /** @class */ (function () {
                function ChalkClass(options) {
                    // eslint-disable-next-line no-constructor-return
                    return chalkFactory(options);
                }
                return ChalkClass;
            }());
            var chalkFactory = function (options) {
                var chalk = {};
                applyOptions(chalk, options);
                chalk.template = function () {
                    var arguments_ = [];
                    for (var _1 = 0; _1 < arguments.length; _1++) {
                        arguments_[_1] = arguments[_1];
                    }
                    return chalkTag.apply(void 0, __spreadArray([chalk.template], arguments_, false));
                };
                Object.setPrototypeOf(chalk, Chalk.prototype);
                Object.setPrototypeOf(chalk.template, chalk);
                chalk.template.constructor = function () {
                    throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
                };
                chalk.template.Instance = ChalkClass;
                return chalk.template;
            };
            function Chalk(options) {
                return chalkFactory(options);
            }
            var _loop_2 = function (styleName, style) {
                styles[styleName] = {
                    get: function () {
                        var builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
                        Object.defineProperty(this, styleName, { value: builder });
                        return builder;
                    }
                };
            };
            for (var _3 = 0, _4 = Object.entries(ansiStyles); _3 < _4.length; _3++) {
                var _5 = _4[_3], styleName = _5[0], style = _5[1];
                _loop_2(styleName, style);
            }
            styles.visible = {
                get: function () {
                    var builder = createBuilder(this, this._styler, true);
                    Object.defineProperty(this, 'visible', { value: builder });
                    return builder;
                }
            };
            var usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];
            var _loop_3 = function (model) {
                styles[model] = {
                    get: function () {
                        var level = this.level;
                        return function () {
                            var _1;
                            var arguments_ = [];
                            for (var _2 = 0; _2 < arguments.length; _2++) {
                                arguments_[_2] = arguments[_2];
                            }
                            var styler = createStyler((_1 = ansiStyles.color[levelMapping[level]])[model].apply(_1, arguments_), ansiStyles.color.close, this._styler);
                            return createBuilder(this, styler, this._isEmpty);
                        };
                    }
                };
            };
            for (var _6 = 0, usedModels_1 = usedModels; _6 < usedModels_1.length; _6++) {
                var model = usedModels_1[_6];
                _loop_3(model);
            }
            var _loop_4 = function (model) {
                var bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
                styles[bgModel] = {
                    get: function () {
                        var level = this.level;
                        return function () {
                            var _1;
                            var arguments_ = [];
                            for (var _2 = 0; _2 < arguments.length; _2++) {
                                arguments_[_2] = arguments[_2];
                            }
                            var styler = createStyler((_1 = ansiStyles.bgColor[levelMapping[level]])[model].apply(_1, arguments_), ansiStyles.bgColor.close, this._styler);
                            return createBuilder(this, styler, this._isEmpty);
                        };
                    }
                };
            };
            for (var _7 = 0, usedModels_2 = usedModels; _7 < usedModels_2.length; _7++) {
                var model = usedModels_2[_7];
                _loop_4(model);
            }
            var proto = Object.defineProperties(function () { }, __assign(__assign({}, styles), { level: {
                    enumerable: true,
                    get: function () {
                        return this._generator.level;
                    },
                    set: function (level) {
                        this._generator.level = level;
                    }
                } }));
            var createStyler = function (open, close, parent) {
                var openAll;
                var closeAll;
                if (parent === undefined) {
                    openAll = open;
                    closeAll = close;
                }
                else {
                    openAll = parent.openAll + open;
                    closeAll = close + parent.closeAll;
                }
                return {
                    open: open,
                    close: close,
                    openAll: openAll,
                    closeAll: closeAll,
                    parent: parent
                };
            };
            var createBuilder = function (self, _styler, _isEmpty) {
                var builder = function () {
                    var arguments_ = [];
                    for (var _1 = 0; _1 < arguments.length; _1++) {
                        arguments_[_1] = arguments[_1];
                    }
                    if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
                        // Called as a template literal, for example: chalk.red`2 + 3 = {bold ${2+3}}`
                        return applyStyle(builder, chalkTag.apply(void 0, __spreadArray([builder], arguments_, false)));
                    }
                    // Single argument is hot path, implicit coercion is faster than anything
                    // eslint-disable-next-line no-implicit-coercion
                    return applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));
                };
                // We alter the prototype because we must return a function, but there is
                // no way to create a function with a different prototype
                Object.setPrototypeOf(builder, proto);
                builder._generator = self;
                builder._styler = _styler;
                builder._isEmpty = _isEmpty;
                return builder;
            };
            var applyStyle = function (self, string) {
                if (self.level <= 0 || !string) {
                    return self._isEmpty ? '' : string;
                }
                var styler = self._styler;
                if (styler === undefined) {
                    return string;
                }
                var openAll = styler.openAll, closeAll = styler.closeAll;
                if (string.indexOf('\u001B') !== -1) {
                    while (styler !== undefined) {
                        // Replace any instances already present with a re-opening code
                        // otherwise only the part of the string until said closing code
                        // will be colored, and the rest will simply be 'plain'.
                        string = stringReplaceAll(string, styler.close, styler.open);
                        styler = styler.parent;
                    }
                }
                // We can move both next actions out of loop, because remaining actions in loop won't have
                // any/visible effect on parts we add here. Close the styling before a linebreak and reopen
                // after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
                var lfIndex = string.indexOf('\n');
                if (lfIndex !== -1) {
                    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
                }
                return openAll + string + closeAll;
            };
            var template;
            var chalkTag = function (chalk) {
                var strings = [];
                for (var _1 = 1; _1 < arguments.length; _1++) {
                    strings[_1 - 1] = arguments[_1];
                }
                var firstString = strings[0];
                if (!isArray(firstString) || !isArray(firstString.raw)) {
                    // If chalk() was called by itself or with a string,
                    // return the string itself as a string.
                    return strings.join(' ');
                }
                var arguments_ = strings.slice(1);
                var parts = [firstString.raw[0]];
                for (var i = 1; i < firstString.length; i++) {
                    parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'), String(firstString.raw[i]));
                }
                if (template === undefined) {
                    template = __nccwpck_require__(767);
                }
                return template(chalk, parts.join(''));
            };
            Object.defineProperties(Chalk.prototype, styles);
            var chalk = Chalk(); // eslint-disable-line new-cap
            chalk.supportsColor = stdoutColor;
            chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 }); // eslint-disable-line new-cap
            chalk.stderr.supportsColor = stderrColor;
            module.exports = chalk;
            /***/ 
        }),
        /***/ 767: 
        /***/ (function (module) {
            "use strict";
            var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
            var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
            var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
            var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
            var ESCAPES = new Map([
                ['n', '\n'],
                ['r', '\r'],
                ['t', '\t'],
                ['b', '\b'],
                ['f', '\f'],
                ['v', '\v'],
                ['0', '\0'],
                ['\\', '\\'],
                ['e', '\u001B'],
                ['a', '\u0007']
            ]);
            function unescape(c) {
                var u = c[0] === 'u';
                var bracket = c[1] === '{';
                if ((u && !bracket && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
                    return String.fromCharCode(parseInt(c.slice(1), 16));
                }
                if (u && bracket) {
                    return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
                }
                return ESCAPES.get(c) || c;
            }
            function parseArguments(name, arguments_) {
                var results = [];
                var chunks = arguments_.trim().split(/\s*,\s*/g);
                var matches;
                for (var _1 = 0, chunks_1 = chunks; _1 < chunks_1.length; _1++) {
                    var chunk = chunks_1[_1];
                    var number = Number(chunk);
                    if (!Number.isNaN(number)) {
                        results.push(number);
                    }
                    else if ((matches = chunk.match(STRING_REGEX))) {
                        results.push(matches[2].replace(ESCAPE_REGEX, function (m, escape, character) { return escape ? unescape(escape) : character; }));
                    }
                    else {
                        throw new Error("Invalid Chalk template style argument: ".concat(chunk, " (in style '").concat(name, "')"));
                    }
                }
                return results;
            }
            function parseStyle(style) {
                STYLE_REGEX.lastIndex = 0;
                var results = [];
                var matches;
                while ((matches = STYLE_REGEX.exec(style)) !== null) {
                    var name_2 = matches[1];
                    if (matches[2]) {
                        var args = parseArguments(name_2, matches[2]);
                        results.push([name_2].concat(args));
                    }
                    else {
                        results.push([name_2]);
                    }
                }
                return results;
            }
            function buildStyle(chalk, styles) {
                var enabled = {};
                for (var _1 = 0, styles_1 = styles; _1 < styles_1.length; _1++) {
                    var layer = styles_1[_1];
                    for (var _2 = 0, _3 = layer.styles; _2 < _3.length; _2++) {
                        var style = _3[_2];
                        enabled[style[0]] = layer.inverse ? null : style.slice(1);
                    }
                }
                var current = chalk;
                for (var _4 = 0, _5 = Object.entries(enabled); _4 < _5.length; _4++) {
                    var _6 = _5[_4], styleName = _6[0], styles_2 = _6[1];
                    if (!Array.isArray(styles_2)) {
                        continue;
                    }
                    if (!(styleName in current)) {
                        throw new Error("Unknown Chalk style: ".concat(styleName));
                    }
                    current = styles_2.length > 0 ? current[styleName].apply(current, styles_2) : current[styleName];
                }
                return current;
            }
            module.exports = function (chalk, temporary) {
                var styles = [];
                var chunks = [];
                var chunk = [];
                // eslint-disable-next-line max-params
                temporary.replace(TEMPLATE_REGEX, function (m, escapeCharacter, inverse, style, close, character) {
                    if (escapeCharacter) {
                        chunk.push(unescape(escapeCharacter));
                    }
                    else if (style) {
                        var string = chunk.join('');
                        chunk = [];
                        chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
                        styles.push({ inverse: inverse, styles: parseStyle(style) });
                    }
                    else if (close) {
                        if (styles.length === 0) {
                            throw new Error('Found extraneous } in Chalk template literal');
                        }
                        chunks.push(buildStyle(chalk, styles)(chunk.join('')));
                        chunk = [];
                        styles.pop();
                    }
                    else {
                        chunk.push(character);
                    }
                });
                chunks.push(chunk.join(''));
                if (styles.length > 0) {
                    var errMessage = "Chalk template literal is missing ".concat(styles.length, " closing bracket").concat(styles.length === 1 ? '' : 's', " (`}`)");
                    throw new Error(errMessage);
                }
                return chunks.join('');
            };
            /***/ 
        }),
        /***/ 7625: 
        /***/ (function (module) {
            "use strict";
            var stringReplaceAll = function (string, substring, replacer) {
                var index = string.indexOf(substring);
                if (index === -1) {
                    return string;
                }
                var substringLength = substring.length;
                var endIndex = 0;
                var returnValue = '';
                do {
                    returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
                    endIndex = index + substringLength;
                    index = string.indexOf(substring, endIndex);
                } while (index !== -1);
                returnValue += string.substr(endIndex);
                return returnValue;
            };
            var stringEncaseCRLFWithFirstIndex = function (string, prefix, postfix, index) {
                var endIndex = 0;
                var returnValue = '';
                do {
                    var gotCR = string[index - 1] === '\r';
                    returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
                    endIndex = index + 1;
                    index = string.indexOf('\n', endIndex);
                } while (index !== -1);
                returnValue += string.substr(endIndex);
                return returnValue;
            };
            module.exports = {
                stringReplaceAll: stringReplaceAll,
                stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex
            };
            /***/ 
        }),
        /***/ 3326: 
        /***/ (function (module) {
            "use strict";
            module.exports = function (flag, argv) {
                if (argv === void 0) { argv = process.argv; }
                var prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
                var position = argv.indexOf(prefix + flag);
                var terminatorPosition = argv.indexOf('--');
                return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
            };
            /***/ 
        }),
        /***/ 628: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var os = __nccwpck_require__(2037);
            var tty = __nccwpck_require__(6224);
            var hasFlag = __nccwpck_require__(3326);
            var env = process.env;
            var forceColor;
            if (hasFlag('no-color') ||
                hasFlag('no-colors') ||
                hasFlag('color=false') ||
                hasFlag('color=never')) {
                forceColor = 0;
            }
            else if (hasFlag('color') ||
                hasFlag('colors') ||
                hasFlag('color=true') ||
                hasFlag('color=always')) {
                forceColor = 1;
            }
            if ('FORCE_COLOR' in env) {
                if (env.FORCE_COLOR === 'true') {
                    forceColor = 1;
                }
                else if (env.FORCE_COLOR === 'false') {
                    forceColor = 0;
                }
                else {
                    forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
                }
            }
            function translateLevel(level) {
                if (level === 0) {
                    return false;
                }
                return {
                    level: level,
                    hasBasic: true,
                    has256: level >= 2,
                    has16m: level >= 3
                };
            }
            function supportsColor(haveStream, streamIsTTY) {
                if (forceColor === 0) {
                    return 0;
                }
                if (hasFlag('color=16m') ||
                    hasFlag('color=full') ||
                    hasFlag('color=truecolor')) {
                    return 3;
                }
                if (hasFlag('color=256')) {
                    return 2;
                }
                if (haveStream && !streamIsTTY && forceColor === undefined) {
                    return 0;
                }
                var min = forceColor || 0;
                if (env.TERM === 'dumb') {
                    return min;
                }
                if (process.platform === 'win32') {
                    // Windows 10 build 10586 is the first Windows release that supports 256 colors.
                    // Windows 10 build 14931 is the first release that supports 16m/TrueColor.
                    var osRelease = os.release().split('.');
                    if (Number(osRelease[0]) >= 10 &&
                        Number(osRelease[2]) >= 10586) {
                        return Number(osRelease[2]) >= 14931 ? 3 : 2;
                    }
                    return 1;
                }
                if ('CI' in env) {
                    if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(function (sign) { return sign in env; }) || env.CI_NAME === 'codeship') {
                        return 1;
                    }
                    return min;
                }
                if ('TEAMCITY_VERSION' in env) {
                    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
                }
                if (env.COLORTERM === 'truecolor') {
                    return 3;
                }
                if ('TERM_PROGRAM' in env) {
                    var version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
                    switch (env.TERM_PROGRAM) {
                        case 'iTerm.app':
                            return version >= 3 ? 3 : 2;
                        case 'Apple_Terminal':
                            return 2;
                        // No default
                    }
                }
                if (/-256(color)?$/i.test(env.TERM)) {
                    return 2;
                }
                if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
                    return 1;
                }
                if ('COLORTERM' in env) {
                    return 1;
                }
                return min;
            }
            function getSupportLevel(stream) {
                var level = supportsColor(stream, stream && stream.isTTY);
                return translateLevel(level);
            }
            module.exports = {
                supportsColor: getSupportLevel,
                stdout: translateLevel(supportsColor(true, tty.isatty(1))),
                stderr: translateLevel(supportsColor(true, tty.isatty(2)))
            };
            /***/ 
        }),
        /***/ 2426: 
        /***/ (function (module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
            var core_1 = __nccwpck_require__(2685);
            var draft7_1 = __nccwpck_require__(691);
            var discriminator_1 = __nccwpck_require__(4025);
            var draft7MetaSchema = __nccwpck_require__(98);
            var META_SUPPORT_DATA = ["/properties"];
            var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
            var Ajv = /** @class */ (function (_super) {
                __extends(Ajv, _super);
                function Ajv() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                Ajv.prototype._addVocabularies = function () {
                    var _this_1 = this;
                    _super.prototype._addVocabularies.call(this);
                    draft7_1["default"].forEach(function (v) { return _this_1.addVocabulary(v); });
                    if (this.opts.discriminator)
                        this.addKeyword(discriminator_1["default"]);
                };
                Ajv.prototype._addDefaultMetaSchema = function () {
                    _super.prototype._addDefaultMetaSchema.call(this);
                    if (!this.opts.meta)
                        return;
                    var metaSchema = this.opts.$data
                        ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)
                        : draft7MetaSchema;
                    this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
                    this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
                };
                Ajv.prototype.defaultMeta = function () {
                    return (this.opts.defaultMeta =
                        _super.prototype.defaultMeta.call(this) || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
                };
                return Ajv;
            }(core_1["default"]));
            module.exports = exports = Ajv;
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports["default"] = Ajv;
            var validate_1 = __nccwpck_require__(8955);
            Object.defineProperty(exports, "KeywordCxt", ({ enumerable: true, get: function () { return validate_1.KeywordCxt; } }));
            var codegen_1 = __nccwpck_require__(9179);
            Object.defineProperty(exports, "_", ({ enumerable: true, get: function () { return codegen_1._; } }));
            Object.defineProperty(exports, "str", ({ enumerable: true, get: function () { return codegen_1.str; } }));
            Object.defineProperty(exports, "stringify", ({ enumerable: true, get: function () { return codegen_1.stringify; } }));
            Object.defineProperty(exports, "nil", ({ enumerable: true, get: function () { return codegen_1.nil; } }));
            Object.defineProperty(exports, "Name", ({ enumerable: true, get: function () { return codegen_1.Name; } }));
            Object.defineProperty(exports, "CodeGen", ({ enumerable: true, get: function () { return codegen_1.CodeGen; } }));
            var validation_error_1 = __nccwpck_require__(7616);
            Object.defineProperty(exports, "ValidationError", ({ enumerable: true, get: function () { return validation_error_1["default"]; } }));
            var ref_error_1 = __nccwpck_require__(8190);
            Object.defineProperty(exports, "MissingRefError", ({ enumerable: true, get: function () { return ref_error_1["default"]; } }));
            //# sourceMappingURL=ajv.js.map
            /***/ 
        }),
        /***/ 8358: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
            var _CodeOrName = /** @class */ (function () {
                function _CodeOrName() {
                }
                return _CodeOrName;
            }());
            exports._CodeOrName = _CodeOrName;
            exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
            var Name = /** @class */ (function (_super) {
                __extends(Name, _super);
                function Name(s) {
                    var _this_1 = _super.call(this) || this;
                    if (!exports.IDENTIFIER.test(s))
                        throw new Error("CodeGen: name must be a valid identifier");
                    _this_1.str = s;
                    return _this_1;
                }
                Name.prototype.toString = function () {
                    return this.str;
                };
                Name.prototype.emptyStr = function () {
                    return false;
                };
                Object.defineProperty(Name.prototype, "names", {
                    get: function () {
                        var _1;
                        return _1 = {}, _1[this.str] = 1, _1;
                    },
                    enumerable: false,
                    configurable: true
                });
                return Name;
            }(_CodeOrName));
            exports.Name = Name;
            var _Code = /** @class */ (function (_super) {
                __extends(_Code, _super);
                function _Code(code) {
                    var _this_1 = _super.call(this) || this;
                    _this_1._items = typeof code === "string" ? [code] : code;
                    return _this_1;
                }
                _Code.prototype.toString = function () {
                    return this.str;
                };
                _Code.prototype.emptyStr = function () {
                    if (this._items.length > 1)
                        return false;
                    var item = this._items[0];
                    return item === "" || item === '""';
                };
                Object.defineProperty(_Code.prototype, "str", {
                    get: function () {
                        var _a;
                        return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce(function (s, c) { return "".concat(s).concat(c); }, "")));
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(_Code.prototype, "names", {
                    get: function () {
                        var _a;
                        return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce(function (names, c) {
                            if (c instanceof Name)
                                names[c.str] = (names[c.str] || 0) + 1;
                            return names;
                        }, {})));
                    },
                    enumerable: false,
                    configurable: true
                });
                return _Code;
            }(_CodeOrName));
            exports._Code = _Code;
            exports.nil = new _Code("");
            function _(strs) {
                var args = [];
                for (var _1 = 1; _1 < arguments.length; _1++) {
                    args[_1 - 1] = arguments[_1];
                }
                var code = [strs[0]];
                var i = 0;
                while (i < args.length) {
                    addCodeArg(code, args[i]);
                    code.push(strs[++i]);
                }
                return new _Code(code);
            }
            exports._ = _;
            var plus = new _Code("+");
            function str(strs) {
                var args = [];
                for (var _1 = 1; _1 < arguments.length; _1++) {
                    args[_1 - 1] = arguments[_1];
                }
                var expr = [safeStringify(strs[0])];
                var i = 0;
                while (i < args.length) {
                    expr.push(plus);
                    addCodeArg(expr, args[i]);
                    expr.push(plus, safeStringify(strs[++i]));
                }
                optimize(expr);
                return new _Code(expr);
            }
            exports.str = str;
            function addCodeArg(code, arg) {
                if (arg instanceof _Code)
                    code.push.apply(code, arg._items);
                else if (arg instanceof Name)
                    code.push(arg);
                else
                    code.push(interpolate(arg));
            }
            exports.addCodeArg = addCodeArg;
            function optimize(expr) {
                var i = 1;
                while (i < expr.length - 1) {
                    if (expr[i] === plus) {
                        var res = mergeExprItems(expr[i - 1], expr[i + 1]);
                        if (res !== undefined) {
                            expr.splice(i - 1, 3, res);
                            continue;
                        }
                        expr[i++] = "+";
                    }
                    i++;
                }
            }
            function mergeExprItems(a, b) {
                if (b === '""')
                    return a;
                if (a === '""')
                    return b;
                if (typeof a == "string") {
                    if (b instanceof Name || a[a.length - 1] !== '"')
                        return;
                    if (typeof b != "string")
                        return "".concat(a.slice(0, -1)).concat(b, "\"");
                    if (b[0] === '"')
                        return a.slice(0, -1) + b.slice(1);
                    return;
                }
                if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
                    return "\"".concat(a).concat(b.slice(1));
                return;
            }
            function strConcat(c1, c2) {
                return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str(__makeTemplateObject(["", "", ""], ["", "", ""]), c1, c2);
            }
            exports.strConcat = strConcat;
            // TODO do not allow arrays here
            function interpolate(x) {
                return typeof x == "number" || typeof x == "boolean" || x === null
                    ? x
                    : safeStringify(Array.isArray(x) ? x.join(",") : x);
            }
            function stringify(x) {
                return new _Code(safeStringify(x));
            }
            exports.stringify = stringify;
            function safeStringify(x) {
                return JSON.stringify(x)
                    .replace(/\u2028/g, "\\u2028")
                    .replace(/\u2029/g, "\\u2029");
            }
            exports.safeStringify = safeStringify;
            function getProperty(key) {
                return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(".".concat(key)) : _(__makeTemplateObject(["[", "]"], ["[", "]"]), key);
            }
            exports.getProperty = getProperty;
            //Does best effort to format the name properly
            function getEsmExportName(key) {
                if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
                    return new _Code("".concat(key));
                }
                throw new Error("CodeGen: invalid export name: ".concat(key, ", use explicit $id name mapping"));
            }
            exports.getEsmExportName = getEsmExportName;
            function regexpCode(rx) {
                return new _Code(rx.toString());
            }
            exports.regexpCode = regexpCode;
            //# sourceMappingURL=code.js.map
            /***/ 
        }),
        /***/ 9179: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
            var code_1 = __nccwpck_require__(8358);
            var scope_1 = __nccwpck_require__(2893);
            var code_2 = __nccwpck_require__(8358);
            Object.defineProperty(exports, "_", ({ enumerable: true, get: function () { return code_2._; } }));
            Object.defineProperty(exports, "str", ({ enumerable: true, get: function () { return code_2.str; } }));
            Object.defineProperty(exports, "strConcat", ({ enumerable: true, get: function () { return code_2.strConcat; } }));
            Object.defineProperty(exports, "nil", ({ enumerable: true, get: function () { return code_2.nil; } }));
            Object.defineProperty(exports, "getProperty", ({ enumerable: true, get: function () { return code_2.getProperty; } }));
            Object.defineProperty(exports, "stringify", ({ enumerable: true, get: function () { return code_2.stringify; } }));
            Object.defineProperty(exports, "regexpCode", ({ enumerable: true, get: function () { return code_2.regexpCode; } }));
            Object.defineProperty(exports, "Name", ({ enumerable: true, get: function () { return code_2.Name; } }));
            var scope_2 = __nccwpck_require__(2893);
            Object.defineProperty(exports, "Scope", ({ enumerable: true, get: function () { return scope_2.Scope; } }));
            Object.defineProperty(exports, "ValueScope", ({ enumerable: true, get: function () { return scope_2.ValueScope; } }));
            Object.defineProperty(exports, "ValueScopeName", ({ enumerable: true, get: function () { return scope_2.ValueScopeName; } }));
            Object.defineProperty(exports, "varKinds", ({ enumerable: true, get: function () { return scope_2.varKinds; } }));
            exports.operators = {
                GT: new code_1._Code(">"),
                GTE: new code_1._Code(">="),
                LT: new code_1._Code("<"),
                LTE: new code_1._Code("<="),
                EQ: new code_1._Code("==="),
                NEQ: new code_1._Code("!=="),
                NOT: new code_1._Code("!"),
                OR: new code_1._Code("||"),
                AND: new code_1._Code("&&"),
                ADD: new code_1._Code("+")
            };
            var Node = /** @class */ (function () {
                function Node() {
                }
                Node.prototype.optimizeNodes = function () {
                    return this;
                };
                Node.prototype.optimizeNames = function (_names, _constants) {
                    return this;
                };
                return Node;
            }());
            var Def = /** @class */ (function (_super) {
                __extends(Def, _super);
                function Def(varKind, name, rhs) {
                    var _this_1 = _super.call(this) || this;
                    _this_1.varKind = varKind;
                    _this_1.name = name;
                    _this_1.rhs = rhs;
                    return _this_1;
                }
                Def.prototype.render = function (_1) {
                    var es5 = _1.es5, _n = _1._n;
                    var varKind = es5 ? scope_1.varKinds["var"] : this.varKind;
                    var rhs = this.rhs === undefined ? "" : " = ".concat(this.rhs);
                    return "".concat(varKind, " ").concat(this.name).concat(rhs, ";") + _n;
                };
                Def.prototype.optimizeNames = function (names, constants) {
                    if (!names[this.name.str])
                        return;
                    if (this.rhs)
                        this.rhs = optimizeExpr(this.rhs, names, constants);
                    return this;
                };
                Object.defineProperty(Def.prototype, "names", {
                    get: function () {
                        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
                    },
                    enumerable: false,
                    configurable: true
                });
                return Def;
            }(Node));
            var Assign = /** @class */ (function (_super) {
                __extends(Assign, _super);
                function Assign(lhs, rhs, sideEffects) {
                    var _this_1 = _super.call(this) || this;
                    _this_1.lhs = lhs;
                    _this_1.rhs = rhs;
                    _this_1.sideEffects = sideEffects;
                    return _this_1;
                }
                Assign.prototype.render = function (_1) {
                    var _n = _1._n;
                    return "".concat(this.lhs, " = ").concat(this.rhs, ";") + _n;
                };
                Assign.prototype.optimizeNames = function (names, constants) {
                    if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
                        return;
                    this.rhs = optimizeExpr(this.rhs, names, constants);
                    return this;
                };
                Object.defineProperty(Assign.prototype, "names", {
                    get: function () {
                        var names = this.lhs instanceof code_1.Name ? {} : __assign({}, this.lhs.names);
                        return addExprNames(names, this.rhs);
                    },
                    enumerable: false,
                    configurable: true
                });
                return Assign;
            }(Node));
            var AssignOp = /** @class */ (function (_super) {
                __extends(AssignOp, _super);
                function AssignOp(lhs, op, rhs, sideEffects) {
                    var _this_1 = _super.call(this, lhs, rhs, sideEffects) || this;
                    _this_1.op = op;
                    return _this_1;
                }
                AssignOp.prototype.render = function (_1) {
                    var _n = _1._n;
                    return "".concat(this.lhs, " ").concat(this.op, "= ").concat(this.rhs, ";") + _n;
                };
                return AssignOp;
            }(Assign));
            var Label = /** @class */ (function (_super) {
                __extends(Label, _super);
                function Label(label) {
                    var _this_1 = _super.call(this) || this;
                    _this_1.label = label;
                    _this_1.names = {};
                    return _this_1;
                }
                Label.prototype.render = function (_1) {
                    var _n = _1._n;
                    return "".concat(this.label, ":") + _n;
                };
                return Label;
            }(Node));
            var Break = /** @class */ (function (_super) {
                __extends(Break, _super);
                function Break(label) {
                    var _this_1 = _super.call(this) || this;
                    _this_1.label = label;
                    _this_1.names = {};
                    return _this_1;
                }
                Break.prototype.render = function (_1) {
                    var _n = _1._n;
                    var label = this.label ? " ".concat(this.label) : "";
                    return "break".concat(label, ";") + _n;
                };
                return Break;
            }(Node));
            var Throw = /** @class */ (function (_super) {
                __extends(Throw, _super);
                function Throw(error) {
                    var _this_1 = _super.call(this) || this;
                    _this_1.error = error;
                    return _this_1;
                }
                Throw.prototype.render = function (_1) {
                    var _n = _1._n;
                    return "throw ".concat(this.error, ";") + _n;
                };
                Object.defineProperty(Throw.prototype, "names", {
                    get: function () {
                        return this.error.names;
                    },
                    enumerable: false,
                    configurable: true
                });
                return Throw;
            }(Node));
            var AnyCode = /** @class */ (function (_super) {
                __extends(AnyCode, _super);
                function AnyCode(code) {
                    var _this_1 = _super.call(this) || this;
                    _this_1.code = code;
                    return _this_1;
                }
                AnyCode.prototype.render = function (_1) {
                    var _n = _1._n;
                    return "".concat(this.code, ";") + _n;
                };
                AnyCode.prototype.optimizeNodes = function () {
                    return "".concat(this.code) ? this : undefined;
                };
                AnyCode.prototype.optimizeNames = function (names, constants) {
                    this.code = optimizeExpr(this.code, names, constants);
                    return this;
                };
                Object.defineProperty(AnyCode.prototype, "names", {
                    get: function () {
                        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
                    },
                    enumerable: false,
                    configurable: true
                });
                return AnyCode;
            }(Node));
            var ParentNode = /** @class */ (function (_super) {
                __extends(ParentNode, _super);
                function ParentNode(nodes) {
                    if (nodes === void 0) { nodes = []; }
                    var _this_1 = _super.call(this) || this;
                    _this_1.nodes = nodes;
                    return _this_1;
                }
                ParentNode.prototype.render = function (opts) {
                    return this.nodes.reduce(function (code, n) { return code + n.render(opts); }, "");
                };
                ParentNode.prototype.optimizeNodes = function () {
                    var nodes = this.nodes;
                    var i = nodes.length;
                    while (i--) {
                        var n = nodes[i].optimizeNodes();
                        if (Array.isArray(n))
                            nodes.splice.apply(nodes, __spreadArray([i, 1], n, false));
                        else if (n)
                            nodes[i] = n;
                        else
                            nodes.splice(i, 1);
                    }
                    return nodes.length > 0 ? this : undefined;
                };
                ParentNode.prototype.optimizeNames = function (names, constants) {
                    var nodes = this.nodes;
                    var i = nodes.length;
                    while (i--) {
                        // iterating backwards improves 1-pass optimization
                        var n = nodes[i];
                        if (n.optimizeNames(names, constants))
                            continue;
                        subtractNames(names, n.names);
                        nodes.splice(i, 1);
                    }
                    return nodes.length > 0 ? this : undefined;
                };
                Object.defineProperty(ParentNode.prototype, "names", {
                    get: function () {
                        return this.nodes.reduce(function (names, n) { return addNames(names, n.names); }, {});
                    },
                    enumerable: false,
                    configurable: true
                });
                return ParentNode;
            }(Node));
            var BlockNode = /** @class */ (function (_super) {
                __extends(BlockNode, _super);
                function BlockNode() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                BlockNode.prototype.render = function (opts) {
                    return "{" + opts._n + _super.prototype.render.call(this, opts) + "}" + opts._n;
                };
                return BlockNode;
            }(ParentNode));
            var Root = /** @class */ (function (_super) {
                __extends(Root, _super);
                function Root() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return Root;
            }(ParentNode));
            var Else = /** @class */ (function (_super) {
                __extends(Else, _super);
                function Else() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return Else;
            }(BlockNode));
            Else.kind = "else";
            var If = /** @class */ (function (_super) {
                __extends(If, _super);
                function If(condition, nodes) {
                    var _this_1 = _super.call(this, nodes) || this;
                    _this_1.condition = condition;
                    return _this_1;
                }
                If.prototype.render = function (opts) {
                    var code = "if(".concat(this.condition, ")") + _super.prototype.render.call(this, opts);
                    if (this["else"])
                        code += "else " + this["else"].render(opts);
                    return code;
                };
                If.prototype.optimizeNodes = function () {
                    _super.prototype.optimizeNodes.call(this);
                    var cond = this.condition;
                    if (cond === true)
                        return this.nodes; // else is ignored here
                    var e = this["else"];
                    if (e) {
                        var ns = e.optimizeNodes();
                        e = this["else"] = Array.isArray(ns) ? new Else(ns) : ns;
                    }
                    if (e) {
                        if (cond === false)
                            return e instanceof If ? e : e.nodes;
                        if (this.nodes.length)
                            return this;
                        return new If(not(cond), e instanceof If ? [e] : e.nodes);
                    }
                    if (cond === false || !this.nodes.length)
                        return undefined;
                    return this;
                };
                If.prototype.optimizeNames = function (names, constants) {
                    var _a;
                    this["else"] = (_a = this["else"]) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
                    if (!(_super.prototype.optimizeNames.call(this, names, constants) || this["else"]))
                        return;
                    this.condition = optimizeExpr(this.condition, names, constants);
                    return this;
                };
                Object.defineProperty(If.prototype, "names", {
                    get: function () {
                        var names = _super.prototype.names;
                        addExprNames(names, this.condition);
                        if (this["else"])
                            addNames(names, this["else"].names);
                        return names;
                    },
                    enumerable: false,
                    configurable: true
                });
                return If;
            }(BlockNode));
            If.kind = "if";
            var For = /** @class */ (function (_super) {
                __extends(For, _super);
                function For() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return For;
            }(BlockNode));
            For.kind = "for";
            var ForLoop = /** @class */ (function (_super) {
                __extends(ForLoop, _super);
                function ForLoop(iteration) {
                    var _this_1 = _super.call(this) || this;
                    _this_1.iteration = iteration;
                    return _this_1;
                }
                ForLoop.prototype.render = function (opts) {
                    return "for(".concat(this.iteration, ")") + _super.prototype.render.call(this, opts);
                };
                ForLoop.prototype.optimizeNames = function (names, constants) {
                    if (!_super.prototype.optimizeNames.call(this, names, constants))
                        return;
                    this.iteration = optimizeExpr(this.iteration, names, constants);
                    return this;
                };
                Object.defineProperty(ForLoop.prototype, "names", {
                    get: function () {
                        return addNames(_super.prototype.names, this.iteration.names);
                    },
                    enumerable: false,
                    configurable: true
                });
                return ForLoop;
            }(For));
            var ForRange = /** @class */ (function (_super) {
                __extends(ForRange, _super);
                function ForRange(varKind, name, from, to) {
                    var _this_1 = _super.call(this) || this;
                    _this_1.varKind = varKind;
                    _this_1.name = name;
                    _this_1.from = from;
                    _this_1.to = to;
                    return _this_1;
                }
                ForRange.prototype.render = function (opts) {
                    var varKind = opts.es5 ? scope_1.varKinds["var"] : this.varKind;
                    var _1 = this, name = _1.name, from = _1.from, to = _1.to;
                    return "for(".concat(varKind, " ").concat(name, "=").concat(from, "; ").concat(name, "<").concat(to, "; ").concat(name, "++)") + _super.prototype.render.call(this, opts);
                };
                Object.defineProperty(ForRange.prototype, "names", {
                    get: function () {
                        var names = addExprNames(_super.prototype.names, this.from);
                        return addExprNames(names, this.to);
                    },
                    enumerable: false,
                    configurable: true
                });
                return ForRange;
            }(For));
            var ForIter = /** @class */ (function (_super) {
                __extends(ForIter, _super);
                function ForIter(loop, varKind, name, iterable) {
                    var _this_1 = _super.call(this) || this;
                    _this_1.loop = loop;
                    _this_1.varKind = varKind;
                    _this_1.name = name;
                    _this_1.iterable = iterable;
                    return _this_1;
                }
                ForIter.prototype.render = function (opts) {
                    return "for(".concat(this.varKind, " ").concat(this.name, " ").concat(this.loop, " ").concat(this.iterable, ")") + _super.prototype.render.call(this, opts);
                };
                ForIter.prototype.optimizeNames = function (names, constants) {
                    if (!_super.prototype.optimizeNames.call(this, names, constants))
                        return;
                    this.iterable = optimizeExpr(this.iterable, names, constants);
                    return this;
                };
                Object.defineProperty(ForIter.prototype, "names", {
                    get: function () {
                        return addNames(_super.prototype.names, this.iterable.names);
                    },
                    enumerable: false,
                    configurable: true
                });
                return ForIter;
            }(For));
            var Func = /** @class */ (function (_super) {
                __extends(Func, _super);
                function Func(name, args, async) {
                    var _this_1 = _super.call(this) || this;
                    _this_1.name = name;
                    _this_1.args = args;
                    _this_1.async = async;
                    return _this_1;
                }
                Func.prototype.render = function (opts) {
                    var _async = this.async ? "async " : "";
                    return "".concat(_async, "function ").concat(this.name, "(").concat(this.args, ")") + _super.prototype.render.call(this, opts);
                };
                return Func;
            }(BlockNode));
            Func.kind = "func";
            var Return = /** @class */ (function (_super) {
                __extends(Return, _super);
                function Return() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                Return.prototype.render = function (opts) {
                    return "return " + _super.prototype.render.call(this, opts);
                };
                return Return;
            }(ParentNode));
            Return.kind = "return";
            var Try = /** @class */ (function (_super) {
                __extends(Try, _super);
                function Try() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                Try.prototype.render = function (opts) {
                    var code = "try" + _super.prototype.render.call(this, opts);
                    if (this["catch"])
                        code += this["catch"].render(opts);
                    if (this["finally"])
                        code += this["finally"].render(opts);
                    return code;
                };
                Try.prototype.optimizeNodes = function () {
                    var _a, _b;
                    _super.prototype.optimizeNodes.call(this);
                    (_a = this["catch"]) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
                    (_b = this["finally"]) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
                    return this;
                };
                Try.prototype.optimizeNames = function (names, constants) {
                    var _a, _b;
                    _super.prototype.optimizeNames.call(this, names, constants);
                    (_a = this["catch"]) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
                    (_b = this["finally"]) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
                    return this;
                };
                Object.defineProperty(Try.prototype, "names", {
                    get: function () {
                        var names = _super.prototype.names;
                        if (this["catch"])
                            addNames(names, this["catch"].names);
                        if (this["finally"])
                            addNames(names, this["finally"].names);
                        return names;
                    },
                    enumerable: false,
                    configurable: true
                });
                return Try;
            }(BlockNode));
            var Catch = /** @class */ (function (_super) {
                __extends(Catch, _super);
                function Catch(error) {
                    var _this_1 = _super.call(this) || this;
                    _this_1.error = error;
                    return _this_1;
                }
                Catch.prototype.render = function (opts) {
                    return "catch(".concat(this.error, ")") + _super.prototype.render.call(this, opts);
                };
                return Catch;
            }(BlockNode));
            Catch.kind = "catch";
            var Finally = /** @class */ (function (_super) {
                __extends(Finally, _super);
                function Finally() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                Finally.prototype.render = function (opts) {
                    return "finally" + _super.prototype.render.call(this, opts);
                };
                return Finally;
            }(BlockNode));
            Finally.kind = "finally";
            var CodeGen = /** @class */ (function () {
                function CodeGen(extScope, opts) {
                    if (opts === void 0) { opts = {}; }
                    this._values = {};
                    this._blockStarts = [];
                    this._constants = {};
                    this.opts = __assign(__assign({}, opts), { _n: opts.lines ? "\n" : "" });
                    this._extScope = extScope;
                    this._scope = new scope_1.Scope({ parent: extScope });
                    this._nodes = [new Root()];
                }
                CodeGen.prototype.toString = function () {
                    return this._root.render(this.opts);
                };
                // returns unique name in the internal scope
                CodeGen.prototype.name = function (prefix) {
                    return this._scope.name(prefix);
                };
                // reserves unique name in the external scope
                CodeGen.prototype.scopeName = function (prefix) {
                    return this._extScope.name(prefix);
                };
                // reserves unique name in the external scope and assigns value to it
                CodeGen.prototype.scopeValue = function (prefixOrName, value) {
                    var name = this._extScope.value(prefixOrName, value);
                    var vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
                    vs.add(name);
                    return name;
                };
                CodeGen.prototype.getScopeValue = function (prefix, keyOrRef) {
                    return this._extScope.getValue(prefix, keyOrRef);
                };
                // return code that assigns values in the external scope to the names that are used internally
                // (same names that were returned by gen.scopeName or gen.scopeValue)
                CodeGen.prototype.scopeRefs = function (scopeName) {
                    return this._extScope.scopeRefs(scopeName, this._values);
                };
                CodeGen.prototype.scopeCode = function () {
                    return this._extScope.scopeCode(this._values);
                };
                CodeGen.prototype._def = function (varKind, nameOrPrefix, rhs, constant) {
                    var name = this._scope.toName(nameOrPrefix);
                    if (rhs !== undefined && constant)
                        this._constants[name.str] = rhs;
                    this._leafNode(new Def(varKind, name, rhs));
                    return name;
                };
                // `const` declaration (`var` in es5 mode)
                CodeGen.prototype["const"] = function (nameOrPrefix, rhs, _constant) {
                    return this._def(scope_1.varKinds["const"], nameOrPrefix, rhs, _constant);
                };
                // `let` declaration with optional assignment (`var` in es5 mode)
                CodeGen.prototype.let = function (nameOrPrefix, rhs, _constant) {
                    return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
                };
                // `var` declaration with optional assignment
                CodeGen.prototype["var"] = function (nameOrPrefix, rhs, _constant) {
                    return this._def(scope_1.varKinds["var"], nameOrPrefix, rhs, _constant);
                };
                // assignment code
                CodeGen.prototype.assign = function (lhs, rhs, sideEffects) {
                    return this._leafNode(new Assign(lhs, rhs, sideEffects));
                };
                // `+=` code
                CodeGen.prototype.add = function (lhs, rhs) {
                    return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
                };
                // appends passed SafeExpr to code or executes Block
                CodeGen.prototype.code = function (c) {
                    if (typeof c == "function")
                        c();
                    else if (c !== code_1.nil)
                        this._leafNode(new AnyCode(c));
                    return this;
                };
                // returns code for object literal for the passed argument list of key-value pairs
                CodeGen.prototype.object = function () {
                    var keyValues = [];
                    for (var _1 = 0; _1 < arguments.length; _1++) {
                        keyValues[_1] = arguments[_1];
                    }
                    var code = ["{"];
                    for (var _2 = 0, keyValues_1 = keyValues; _2 < keyValues_1.length; _2++) {
                        var _3 = keyValues_1[_2], key = _3[0], value = _3[1];
                        if (code.length > 1)
                            code.push(",");
                        code.push(key);
                        if (key !== value || this.opts.es5) {
                            code.push(":");
                            (0, code_1.addCodeArg)(code, value);
                        }
                    }
                    code.push("}");
                    return new code_1._Code(code);
                };
                // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
                CodeGen.prototype["if"] = function (condition, thenBody, elseBody) {
                    this._blockNode(new If(condition));
                    if (thenBody && elseBody) {
                        this.code(thenBody)["else"]().code(elseBody).endIf();
                    }
                    else if (thenBody) {
                        this.code(thenBody).endIf();
                    }
                    else if (elseBody) {
                        throw new Error('CodeGen: "else" body without "then" body');
                    }
                    return this;
                };
                // `else if` clause - invalid without `if` or after `else` clauses
                CodeGen.prototype.elseIf = function (condition) {
                    return this._elseNode(new If(condition));
                };
                // `else` clause - only valid after `if` or `else if` clauses
                CodeGen.prototype["else"] = function () {
                    return this._elseNode(new Else());
                };
                // end `if` statement (needed if gen.if was used only with condition)
                CodeGen.prototype.endIf = function () {
                    return this._endBlockNode(If, Else);
                };
                CodeGen.prototype._for = function (node, forBody) {
                    this._blockNode(node);
                    if (forBody)
                        this.code(forBody).endFor();
                    return this;
                };
                // a generic `for` clause (or statement if `forBody` is passed)
                CodeGen.prototype["for"] = function (iteration, forBody) {
                    return this._for(new ForLoop(iteration), forBody);
                };
                // `for` statement for a range of values
                CodeGen.prototype.forRange = function (nameOrPrefix, from, to, forBody, varKind) {
                    if (varKind === void 0) { varKind = this.opts.es5 ? scope_1.varKinds["var"] : scope_1.varKinds.let; }
                    var name = this._scope.toName(nameOrPrefix);
                    return this._for(new ForRange(varKind, name, from, to), function () { return forBody(name); });
                };
                // `for-of` statement (in es5 mode replace with a normal for loop)
                CodeGen.prototype.forOf = function (nameOrPrefix, iterable, forBody, varKind) {
                    var _this_1 = this;
                    if (varKind === void 0) { varKind = scope_1.varKinds["const"]; }
                    var name = this._scope.toName(nameOrPrefix);
                    if (this.opts.es5) {
                        var arr_1 = iterable instanceof code_1.Name ? iterable : this["var"]("_arr", iterable);
                        return this.forRange("_i", 0, (0, code_1._)(__makeTemplateObject(["", ".length"], ["", ".length"]), arr_1), function (i) {
                            _this_1["var"](name, (0, code_1._)(__makeTemplateObject(["", "[", "]"], ["", "[", "]"]), arr_1, i));
                            forBody(name);
                        });
                    }
                    return this._for(new ForIter("of", varKind, name, iterable), function () { return forBody(name); });
                };
                // `for-in` statement.
                // With option `ownProperties` replaced with a `for-of` loop for object keys
                CodeGen.prototype.forIn = function (nameOrPrefix, obj, forBody, varKind) {
                    if (varKind === void 0) { varKind = this.opts.es5 ? scope_1.varKinds["var"] : scope_1.varKinds["const"]; }
                    if (this.opts.ownProperties) {
                        return this.forOf(nameOrPrefix, (0, code_1._)(__makeTemplateObject(["Object.keys(", ")"], ["Object.keys(", ")"]), obj), forBody);
                    }
                    var name = this._scope.toName(nameOrPrefix);
                    return this._for(new ForIter("in", varKind, name, obj), function () { return forBody(name); });
                };
                // end `for` loop
                CodeGen.prototype.endFor = function () {
                    return this._endBlockNode(For);
                };
                // `label` statement
                CodeGen.prototype.label = function (label) {
                    return this._leafNode(new Label(label));
                };
                // `break` statement
                CodeGen.prototype["break"] = function (label) {
                    return this._leafNode(new Break(label));
                };
                // `return` statement
                CodeGen.prototype["return"] = function (value) {
                    var node = new Return();
                    this._blockNode(node);
                    this.code(value);
                    if (node.nodes.length !== 1)
                        throw new Error('CodeGen: "return" should have one node');
                    return this._endBlockNode(Return);
                };
                // `try` statement
                CodeGen.prototype["try"] = function (tryBody, catchCode, finallyCode) {
                    if (!catchCode && !finallyCode)
                        throw new Error('CodeGen: "try" without "catch" and "finally"');
                    var node = new Try();
                    this._blockNode(node);
                    this.code(tryBody);
                    if (catchCode) {
                        var error = this.name("e");
                        this._currNode = node["catch"] = new Catch(error);
                        catchCode(error);
                    }
                    if (finallyCode) {
                        this._currNode = node["finally"] = new Finally();
                        this.code(finallyCode);
                    }
                    return this._endBlockNode(Catch, Finally);
                };
                // `throw` statement
                CodeGen.prototype["throw"] = function (error) {
                    return this._leafNode(new Throw(error));
                };
                // start self-balancing block
                CodeGen.prototype.block = function (body, nodeCount) {
                    this._blockStarts.push(this._nodes.length);
                    if (body)
                        this.code(body).endBlock(nodeCount);
                    return this;
                };
                // end the current self-balancing block
                CodeGen.prototype.endBlock = function (nodeCount) {
                    var len = this._blockStarts.pop();
                    if (len === undefined)
                        throw new Error("CodeGen: not in self-balancing block");
                    var toClose = this._nodes.length - len;
                    if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {
                        throw new Error("CodeGen: wrong number of nodes: ".concat(toClose, " vs ").concat(nodeCount, " expected"));
                    }
                    this._nodes.length = len;
                    return this;
                };
                // `function` heading (or definition if funcBody is passed)
                CodeGen.prototype.func = function (name, args, async, funcBody) {
                    if (args === void 0) { args = code_1.nil; }
                    this._blockNode(new Func(name, args, async));
                    if (funcBody)
                        this.code(funcBody).endFunc();
                    return this;
                };
                // end function definition
                CodeGen.prototype.endFunc = function () {
                    return this._endBlockNode(Func);
                };
                CodeGen.prototype.optimize = function (n) {
                    if (n === void 0) { n = 1; }
                    while (n-- > 0) {
                        this._root.optimizeNodes();
                        this._root.optimizeNames(this._root.names, this._constants);
                    }
                };
                CodeGen.prototype._leafNode = function (node) {
                    this._currNode.nodes.push(node);
                    return this;
                };
                CodeGen.prototype._blockNode = function (node) {
                    this._currNode.nodes.push(node);
                    this._nodes.push(node);
                };
                CodeGen.prototype._endBlockNode = function (N1, N2) {
                    var n = this._currNode;
                    if (n instanceof N1 || (N2 && n instanceof N2)) {
                        this._nodes.pop();
                        return this;
                    }
                    throw new Error("CodeGen: not in block \"".concat(N2 ? "".concat(N1.kind, "/").concat(N2.kind) : N1.kind, "\""));
                };
                CodeGen.prototype._elseNode = function (node) {
                    var n = this._currNode;
                    if (!(n instanceof If)) {
                        throw new Error('CodeGen: "else" without "if"');
                    }
                    this._currNode = n["else"] = node;
                    return this;
                };
                Object.defineProperty(CodeGen.prototype, "_root", {
                    get: function () {
                        return this._nodes[0];
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(CodeGen.prototype, "_currNode", {
                    get: function () {
                        var ns = this._nodes;
                        return ns[ns.length - 1];
                    },
                    set: function (node) {
                        var ns = this._nodes;
                        ns[ns.length - 1] = node;
                    },
                    enumerable: false,
                    configurable: true
                });
                return CodeGen;
            }());
            exports.CodeGen = CodeGen;
            function addNames(names, from) {
                for (var n in from)
                    names[n] = (names[n] || 0) + (from[n] || 0);
                return names;
            }
            function addExprNames(names, from) {
                return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
            }
            function optimizeExpr(expr, names, constants) {
                if (expr instanceof code_1.Name)
                    return replaceName(expr);
                if (!canOptimize(expr))
                    return expr;
                return new code_1._Code(expr._items.reduce(function (items, c) {
                    if (c instanceof code_1.Name)
                        c = replaceName(c);
                    if (c instanceof code_1._Code)
                        items.push.apply(items, c._items);
                    else
                        items.push(c);
                    return items;
                }, []));
                function replaceName(n) {
                    var c = constants[n.str];
                    if (c === undefined || names[n.str] !== 1)
                        return n;
                    delete names[n.str];
                    return c;
                }
                function canOptimize(e) {
                    return (e instanceof code_1._Code &&
                        e._items.some(function (c) { return c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined; }));
                }
            }
            function subtractNames(names, from) {
                for (var n in from)
                    names[n] = (names[n] || 0) - (from[n] || 0);
            }
            function not(x) {
                return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)(__makeTemplateObject(["!", ""], ["!", ""]), par(x));
            }
            exports.not = not;
            var andCode = mappend(exports.operators.AND);
            // boolean AND (&&) expression with the passed arguments
            function and() {
                var args = [];
                for (var _1 = 0; _1 < arguments.length; _1++) {
                    args[_1] = arguments[_1];
                }
                return args.reduce(andCode);
            }
            exports.and = and;
            var orCode = mappend(exports.operators.OR);
            // boolean OR (||) expression with the passed arguments
            function or() {
                var args = [];
                for (var _1 = 0; _1 < arguments.length; _1++) {
                    args[_1] = arguments[_1];
                }
                return args.reduce(orCode);
            }
            exports.or = or;
            function mappend(op) {
                return function (x, y) { return (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)(__makeTemplateObject(["", " ", " ", ""], ["", " ", " ", ""]), par(x), op, par(y))); };
            }
            function par(x) {
                return x instanceof code_1.Name ? x : (0, code_1._)(__makeTemplateObject(["(", ")"], ["(", ")"]), x);
            }
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 2893: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
            var code_1 = __nccwpck_require__(8358);
            var ValueError = /** @class */ (function (_super) {
                __extends(ValueError, _super);
                function ValueError(name) {
                    var _this_1 = _super.call(this, "CodeGen: \"code\" for ".concat(name, " not defined")) || this;
                    _this_1.value = name.value;
                    return _this_1;
                }
                return ValueError;
            }(Error));
            var UsedValueState;
            (function (UsedValueState) {
                UsedValueState[UsedValueState["Started"] = 0] = "Started";
                UsedValueState[UsedValueState["Completed"] = 1] = "Completed";
            })(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));
            exports.varKinds = {
                "const": new code_1.Name("const"),
                let: new code_1.Name("let"),
                "var": new code_1.Name("var")
            };
            var Scope = /** @class */ (function () {
                function Scope(_1) {
                    var _2 = _1 === void 0 ? {} : _1, prefixes = _2.prefixes, parent = _2.parent;
                    this._names = {};
                    this._prefixes = prefixes;
                    this._parent = parent;
                }
                Scope.prototype.toName = function (nameOrPrefix) {
                    return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
                };
                Scope.prototype.name = function (prefix) {
                    return new code_1.Name(this._newName(prefix));
                };
                Scope.prototype._newName = function (prefix) {
                    var ng = this._names[prefix] || this._nameGroup(prefix);
                    return "".concat(prefix).concat(ng.index++);
                };
                Scope.prototype._nameGroup = function (prefix) {
                    var _a, _b;
                    if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {
                        throw new Error("CodeGen: prefix \"".concat(prefix, "\" is not allowed in this scope"));
                    }
                    return (this._names[prefix] = { prefix: prefix, index: 0 });
                };
                return Scope;
            }());
            exports.Scope = Scope;
            var ValueScopeName = /** @class */ (function (_super) {
                __extends(ValueScopeName, _super);
                function ValueScopeName(prefix, nameStr) {
                    var _this_1 = _super.call(this, nameStr) || this;
                    _this_1.prefix = prefix;
                    return _this_1;
                }
                ValueScopeName.prototype.setValue = function (value, _1) {
                    var property = _1.property, itemIndex = _1.itemIndex;
                    this.value = value;
                    this.scopePath = (0, code_1._)(__makeTemplateObject([".", "[", "]"], [".", "[", "]"]), new code_1.Name(property), itemIndex);
                };
                return ValueScopeName;
            }(code_1.Name));
            exports.ValueScopeName = ValueScopeName;
            var line = (0, code_1._)(__makeTemplateObject(["\n"], ["\\n"]));
            var ValueScope = /** @class */ (function (_super) {
                __extends(ValueScope, _super);
                function ValueScope(opts) {
                    var _this_1 = _super.call(this, opts) || this;
                    _this_1._values = {};
                    _this_1._scope = opts.scope;
                    _this_1.opts = __assign(__assign({}, opts), { _n: opts.lines ? line : code_1.nil });
                    return _this_1;
                }
                ValueScope.prototype.get = function () {
                    return this._scope;
                };
                ValueScope.prototype.name = function (prefix) {
                    return new ValueScopeName(prefix, this._newName(prefix));
                };
                ValueScope.prototype.value = function (nameOrPrefix, value) {
                    var _a;
                    if (value.ref === undefined)
                        throw new Error("CodeGen: ref must be passed in value");
                    var name = this.toName(nameOrPrefix);
                    var prefix = name.prefix;
                    var valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
                    var vs = this._values[prefix];
                    if (vs) {
                        var _name = vs.get(valueKey);
                        if (_name)
                            return _name;
                    }
                    else {
                        vs = this._values[prefix] = new Map();
                    }
                    vs.set(valueKey, name);
                    var s = this._scope[prefix] || (this._scope[prefix] = []);
                    var itemIndex = s.length;
                    s[itemIndex] = value.ref;
                    name.setValue(value, { property: prefix, itemIndex: itemIndex });
                    return name;
                };
                ValueScope.prototype.getValue = function (prefix, keyOrRef) {
                    var vs = this._values[prefix];
                    if (!vs)
                        return;
                    return vs.get(keyOrRef);
                };
                ValueScope.prototype.scopeRefs = function (scopeName, values) {
                    if (values === void 0) { values = this._values; }
                    return this._reduceValues(values, function (name) {
                        if (name.scopePath === undefined)
                            throw new Error("CodeGen: name \"".concat(name, "\" has no value"));
                        return (0, code_1._)(__makeTemplateObject(["", "", ""], ["", "", ""]), scopeName, name.scopePath);
                    });
                };
                ValueScope.prototype.scopeCode = function (values, usedValues, getCode) {
                    if (values === void 0) { values = this._values; }
                    return this._reduceValues(values, function (name) {
                        if (name.value === undefined)
                            throw new Error("CodeGen: name \"".concat(name, "\" has no value"));
                        return name.value.code;
                    }, usedValues, getCode);
                };
                ValueScope.prototype._reduceValues = function (values, valueCode, usedValues, getCode) {
                    var _this_1 = this;
                    if (usedValues === void 0) { usedValues = {}; }
                    var code = code_1.nil;
                    var _loop_5 = function (prefix) {
                        var vs = values[prefix];
                        if (!vs)
                            return "continue";
                        var nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());
                        vs.forEach(function (name) {
                            if (nameSet.has(name))
                                return;
                            nameSet.set(name, UsedValueState.Started);
                            var c = valueCode(name);
                            if (c) {
                                var def = _this_1.opts.es5 ? exports.varKinds["var"] : exports.varKinds["const"];
                                code = (0, code_1._)(__makeTemplateObject(["", "", " ", " = ", ";", ""], ["", "", " ", " = ", ";", ""]), code, def, name, c, _this_1.opts._n);
                            }
                            else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {
                                code = (0, code_1._)(__makeTemplateObject(["", "", "", ""], ["", "", "", ""]), code, c, _this_1.opts._n);
                            }
                            else {
                                throw new ValueError(name);
                            }
                            nameSet.set(name, UsedValueState.Completed);
                        });
                    };
                    for (var prefix in values) {
                        _loop_5(prefix);
                    }
                    return code;
                };
                return ValueScope;
            }(Scope));
            exports.ValueScope = ValueScope;
            //# sourceMappingURL=scope.js.map
            /***/ 
        }),
        /***/ 6150: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
            var codegen_1 = __nccwpck_require__(9179);
            var util_1 = __nccwpck_require__(3439);
            var names_1 = __nccwpck_require__(50);
            exports.keywordError = {
                message: function (_1) {
                    var keyword = _1.keyword;
                    return (0, codegen_1.str)(__makeTemplateObject(["must pass \"", "\" keyword validation"], ["must pass \"", "\" keyword validation"]), keyword);
                }
            };
            exports.keyword$DataError = {
                message: function (_1) {
                    var keyword = _1.keyword, schemaType = _1.schemaType;
                    return schemaType
                        ? (0, codegen_1.str)(__makeTemplateObject(["\"", "\" keyword must be ", " ($data)"], ["\"", "\" keyword must be ", " ($data)"]), keyword, schemaType) : (0, codegen_1.str)(__makeTemplateObject(["\"", "\" keyword is invalid ($data)"], ["\"", "\" keyword is invalid ($data)"]), keyword);
                }
            };
            function reportError(cxt, error, errorPaths, overrideAllErrors) {
                if (error === void 0) { error = exports.keywordError; }
                var it = cxt.it;
                var gen = it.gen, compositeRule = it.compositeRule, allErrors = it.allErrors;
                var errObj = errorObjectCode(cxt, error, errorPaths);
                if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {
                    addError(gen, errObj);
                }
                else {
                    returnErrors(it, (0, codegen_1._)(__makeTemplateObject(["[", "]"], ["[", "]"]), errObj));
                }
            }
            exports.reportError = reportError;
            function reportExtraError(cxt, error, errorPaths) {
                if (error === void 0) { error = exports.keywordError; }
                var it = cxt.it;
                var gen = it.gen, compositeRule = it.compositeRule, allErrors = it.allErrors;
                var errObj = errorObjectCode(cxt, error, errorPaths);
                addError(gen, errObj);
                if (!(compositeRule || allErrors)) {
                    returnErrors(it, names_1["default"].vErrors);
                }
            }
            exports.reportExtraError = reportExtraError;
            function resetErrorsCount(gen, errsCount) {
                gen.assign(names_1["default"].errors, errsCount);
                gen["if"]((0, codegen_1._)(__makeTemplateObject(["", " !== null"], ["", " !== null"]), names_1["default"].vErrors), function () { return gen["if"](errsCount, function () { return gen.assign((0, codegen_1._)(__makeTemplateObject(["", ".length"], ["", ".length"]), names_1["default"].vErrors), errsCount); }, function () { return gen.assign(names_1["default"].vErrors, null); }); });
            }
            exports.resetErrorsCount = resetErrorsCount;
            function extendErrors(_1) {
                var gen = _1.gen, keyword = _1.keyword, schemaValue = _1.schemaValue, data = _1.data, errsCount = _1.errsCount, it = _1.it;
                /* istanbul ignore if */
                if (errsCount === undefined)
                    throw new Error("ajv implementation error");
                var err = gen.name("err");
                gen.forRange("i", errsCount, names_1["default"].errors, function (i) {
                    gen["const"](err, (0, codegen_1._)(__makeTemplateObject(["", "[", "]"], ["", "[", "]"]), names_1["default"].vErrors, i));
                    gen["if"]((0, codegen_1._)(__makeTemplateObject(["", ".instancePath === undefined"], ["", ".instancePath === undefined"]), err), function () { return gen.assign((0, codegen_1._)(__makeTemplateObject(["", ".instancePath"], ["", ".instancePath"]), err), (0, codegen_1.strConcat)(names_1["default"].instancePath, it.errorPath)); });
                    gen.assign((0, codegen_1._)(__makeTemplateObject(["", ".schemaPath"], ["", ".schemaPath"]), err), (0, codegen_1.str)(__makeTemplateObject(["", "/", ""], ["", "/", ""]), it.errSchemaPath, keyword));
                    if (it.opts.verbose) {
                        gen.assign((0, codegen_1._)(__makeTemplateObject(["", ".schema"], ["", ".schema"]), err), schemaValue);
                        gen.assign((0, codegen_1._)(__makeTemplateObject(["", ".data"], ["", ".data"]), err), data);
                    }
                });
            }
            exports.extendErrors = extendErrors;
            function addError(gen, errObj) {
                var err = gen["const"]("err", errObj);
                gen["if"]((0, codegen_1._)(__makeTemplateObject(["", " === null"], ["", " === null"]), names_1["default"].vErrors), function () { return gen.assign(names_1["default"].vErrors, (0, codegen_1._)(__makeTemplateObject(["[", "]"], ["[", "]"]), err)); }, (0, codegen_1._)(__makeTemplateObject(["", ".push(", ")"], ["", ".push(", ")"]), names_1["default"].vErrors, err));
                gen.code((0, codegen_1._)(__makeTemplateObject(["", "++"], ["", "++"]), names_1["default"].errors));
            }
            function returnErrors(it, errs) {
                var gen = it.gen, validateName = it.validateName, schemaEnv = it.schemaEnv;
                if (schemaEnv.$async) {
                    gen["throw"]((0, codegen_1._)(__makeTemplateObject(["new ", "(", ")"], ["new ", "(", ")"]), it.ValidationError, errs));
                }
                else {
                    gen.assign((0, codegen_1._)(__makeTemplateObject(["", ".errors"], ["", ".errors"]), validateName), errs);
                    gen["return"](false);
                }
            }
            var E = {
                keyword: new codegen_1.Name("keyword"),
                schemaPath: new codegen_1.Name("schemaPath"),
                params: new codegen_1.Name("params"),
                propertyName: new codegen_1.Name("propertyName"),
                message: new codegen_1.Name("message"),
                schema: new codegen_1.Name("schema"),
                parentSchema: new codegen_1.Name("parentSchema")
            };
            function errorObjectCode(cxt, error, errorPaths) {
                var createErrors = cxt.it.createErrors;
                if (createErrors === false)
                    return (0, codegen_1._)(__makeTemplateObject(["{}"], ["{}"]));
                return errorObject(cxt, error, errorPaths);
            }
            function errorObject(cxt, error, errorPaths) {
                if (errorPaths === void 0) { errorPaths = {}; }
                var gen = cxt.gen, it = cxt.it;
                var keyValues = [
                    errorInstancePath(it, errorPaths),
                    errorSchemaPath(cxt, errorPaths),
                ];
                extraErrorProps(cxt, error, keyValues);
                return gen.object.apply(gen, keyValues);
            }
            function errorInstancePath(_1, _2) {
                var errorPath = _1.errorPath;
                var instancePath = _2.instancePath;
                var instPath = instancePath
                    ? (0, codegen_1.str)(__makeTemplateObject(["", "", ""], ["", "", ""]), errorPath, (0, util_1.getErrorPath)(instancePath, util_1.Type.Str)) : errorPath;
                return [names_1["default"].instancePath, (0, codegen_1.strConcat)(names_1["default"].instancePath, instPath)];
            }
            function errorSchemaPath(_1, _2) {
                var keyword = _1.keyword, errSchemaPath = _1.it.errSchemaPath;
                var schemaPath = _2.schemaPath, parentSchema = _2.parentSchema;
                var schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)(__makeTemplateObject(["", "/", ""], ["", "/", ""]), errSchemaPath, keyword);
                if (schemaPath) {
                    schPath = (0, codegen_1.str)(__makeTemplateObject(["", "", ""], ["", "", ""]), schPath, (0, util_1.getErrorPath)(schemaPath, util_1.Type.Str));
                }
                return [E.schemaPath, schPath];
            }
            function extraErrorProps(cxt, _1, keyValues) {
                var params = _1.params, message = _1.message;
                var keyword = cxt.keyword, data = cxt.data, schemaValue = cxt.schemaValue, it = cxt.it;
                var opts = it.opts, propertyName = it.propertyName, topSchemaRef = it.topSchemaRef, schemaPath = it.schemaPath;
                keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)(__makeTemplateObject(["{}"], ["{}"]))]);
                if (opts.messages) {
                    keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
                }
                if (opts.verbose) {
                    keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)(__makeTemplateObject(["", "", ""], ["", "", ""]), topSchemaRef, schemaPath)], [names_1["default"].data, data]);
                }
                if (propertyName)
                    keyValues.push([E.propertyName, propertyName]);
            }
            //# sourceMappingURL=errors.js.map
            /***/ 
        }),
        /***/ 813: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
            var codegen_1 = __nccwpck_require__(9179);
            var validation_error_1 = __nccwpck_require__(7616);
            var names_1 = __nccwpck_require__(50);
            var resolve_1 = __nccwpck_require__(6646);
            var util_1 = __nccwpck_require__(3439);
            var validate_1 = __nccwpck_require__(8955);
            var SchemaEnv = /** @class */ (function () {
                function SchemaEnv(env) {
                    var _a;
                    this.refs = {};
                    this.dynamicAnchors = {};
                    var schema;
                    if (typeof env.schema == "object")
                        schema = env.schema;
                    this.schema = env.schema;
                    this.schemaId = env.schemaId;
                    this.root = env.root || this;
                    this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
                    this.schemaPath = env.schemaPath;
                    this.localRefs = env.localRefs;
                    this.meta = env.meta;
                    this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
                    this.refs = {};
                }
                return SchemaEnv;
            }());
            exports.SchemaEnv = SchemaEnv;
            // let codeSize = 0
            // let nodeCount = 0
            // Compiles schema in SchemaEnv
            function compileSchema(sch) {
                // TODO refactor - remove compilations
                var _sch = getCompilingSchema.call(this, sch);
                if (_sch)
                    return _sch;
                var rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails
                var _1 = this.opts.code, es5 = _1.es5, lines = _1.lines;
                var ownProperties = this.opts.ownProperties;
                var gen = new codegen_1.CodeGen(this.scope, { es5: es5, lines: lines, ownProperties: ownProperties });
                var _ValidationError;
                if (sch.$async) {
                    _ValidationError = gen.scopeValue("Error", {
                        ref: validation_error_1["default"],
                        code: (0, codegen_1._)(__makeTemplateObject(["require(\"ajv/dist/runtime/validation_error\").default"], ["require(\"ajv/dist/runtime/validation_error\").default"]))
                    });
                }
                var validateName = gen.scopeName("validate");
                sch.validateName = validateName;
                var schemaCxt = {
                    gen: gen,
                    allErrors: this.opts.allErrors,
                    data: names_1["default"].data,
                    parentData: names_1["default"].parentData,
                    parentDataProperty: names_1["default"].parentDataProperty,
                    dataNames: [names_1["default"].data],
                    dataPathArr: [codegen_1.nil],
                    dataLevel: 0,
                    dataTypes: [],
                    definedProperties: new Set(),
                    topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true
                        ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }
                        : { ref: sch.schema }),
                    validateName: validateName,
                    ValidationError: _ValidationError,
                    schema: sch.schema,
                    schemaEnv: sch,
                    rootId: rootId,
                    baseId: sch.baseId || rootId,
                    schemaPath: codegen_1.nil,
                    errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
                    errorPath: (0, codegen_1._)(__makeTemplateObject(["\"\""], ["\"\""])),
                    opts: this.opts,
                    self: this
                };
                var sourceCode;
                try {
                    this._compilations.add(sch);
                    (0, validate_1.validateFunctionCode)(schemaCxt);
                    gen.optimize(this.opts.code.optimize);
                    // gen.optimize(1)
                    var validateCode = gen.toString();
                    sourceCode = "".concat(gen.scopeRefs(names_1["default"].scope), "return ").concat(validateCode);
                    // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))
                    if (this.opts.code.process)
                        sourceCode = this.opts.code.process(sourceCode, sch);
                    // console.log("\n\n\n *** \n", sourceCode)
                    var makeValidate = new Function("".concat(names_1["default"].self), "".concat(names_1["default"].scope), sourceCode);
                    var validate = makeValidate(this, this.scope.get());
                    this.scope.value(validateName, { ref: validate });
                    validate.errors = null;
                    validate.schema = sch.schema;
                    validate.schemaEnv = sch;
                    if (sch.$async)
                        validate.$async = true;
                    if (this.opts.code.source === true) {
                        validate.source = { validateName: validateName, validateCode: validateCode, scopeValues: gen._values };
                    }
                    if (this.opts.unevaluated) {
                        var props = schemaCxt.props, items = schemaCxt.items;
                        validate.evaluated = {
                            props: props instanceof codegen_1.Name ? undefined : props,
                            items: items instanceof codegen_1.Name ? undefined : items,
                            dynamicProps: props instanceof codegen_1.Name,
                            dynamicItems: items instanceof codegen_1.Name
                        };
                        if (validate.source)
                            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
                    }
                    sch.validate = validate;
                    return sch;
                }
                catch (e) {
                    delete sch.validate;
                    delete sch.validateName;
                    if (sourceCode)
                        this.logger.error("Error compiling schema, function code:", sourceCode);
                    // console.log("\n\n\n *** \n", sourceCode, this.opts)
                    throw e;
                }
                finally {
                    this._compilations["delete"](sch);
                }
            }
            exports.compileSchema = compileSchema;
            function resolveRef(root, baseId, ref) {
                var _a;
                ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
                var schOrFunc = root.refs[ref];
                if (schOrFunc)
                    return schOrFunc;
                var _sch = resolve.call(this, root, ref);
                if (_sch === undefined) {
                    var schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv
                    var schemaId = this.opts.schemaId;
                    if (schema)
                        _sch = new SchemaEnv({ schema: schema, schemaId: schemaId, root: root, baseId: baseId });
                }
                if (_sch === undefined)
                    return;
                return (root.refs[ref] = inlineOrCompile.call(this, _sch));
            }
            exports.resolveRef = resolveRef;
            function inlineOrCompile(sch) {
                if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
                    return sch.schema;
                return sch.validate ? sch : compileSchema.call(this, sch);
            }
            // Index of schema compilation in the currently compiled list
            function getCompilingSchema(schEnv) {
                for (var _1 = 0, _2 = this._compilations; _1 < _2.length; _1++) {
                    var sch = _2[_1];
                    if (sameSchemaEnv(sch, schEnv))
                        return sch;
                }
            }
            exports.getCompilingSchema = getCompilingSchema;
            function sameSchemaEnv(s1, s2) {
                return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
            }
            // resolve and compile the references ($ref)
            // TODO returns AnySchemaObject (if the schema can be inlined) or validation function
            function resolve(root, // information about the root schema for the current schema
            ref // reference to resolve
            ) {
                var sch;
                while (typeof (sch = this.refs[ref]) == "string")
                    ref = sch;
                return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
            }
            // Resolve schema, its root and baseId
            function resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it
            ref // reference to resolve
            ) {
                var p = this.opts.uriResolver.parse(ref);
                var refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
                var baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);
                // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests
                if (Object.keys(root.schema).length > 0 && refPath === baseId) {
                    return getJsonPointer.call(this, p, root);
                }
                var id = (0, resolve_1.normalizeId)(refPath);
                var schOrRef = this.refs[id] || this.schemas[id];
                if (typeof schOrRef == "string") {
                    var sch = resolveSchema.call(this, root, schOrRef);
                    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
                        return;
                    return getJsonPointer.call(this, p, sch);
                }
                if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
                    return;
                if (!schOrRef.validate)
                    compileSchema.call(this, schOrRef);
                if (id === (0, resolve_1.normalizeId)(ref)) {
                    var schema = schOrRef.schema;
                    var schemaId = this.opts.schemaId;
                    var schId = schema[schemaId];
                    if (schId)
                        baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
                    return new SchemaEnv({ schema: schema, schemaId: schemaId, root: root, baseId: baseId });
                }
                return getJsonPointer.call(this, p, schOrRef);
            }
            exports.resolveSchema = resolveSchema;
            var PREVENT_SCOPE_CHANGE = new Set([
                "properties",
                "patternProperties",
                "enum",
                "dependencies",
                "definitions",
            ]);
            function getJsonPointer(parsedRef, _1) {
                var baseId = _1.baseId, schema = _1.schema, root = _1.root;
                var _a;
                if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
                    return;
                for (var _2 = 0, _3 = parsedRef.fragment.slice(1).split("/"); _2 < _3.length; _2++) {
                    var part = _3[_2];
                    if (typeof schema === "boolean")
                        return;
                    var partSchema = schema[(0, util_1.unescapeFragment)(part)];
                    if (partSchema === undefined)
                        return;
                    schema = partSchema;
                    // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?
                    var schId = typeof schema === "object" && schema[this.opts.schemaId];
                    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
                        baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
                    }
                }
                var env;
                if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
                    var $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
                    env = resolveSchema.call(this, root, $ref);
                }
                // even though resolution failed we need to return SchemaEnv to throw exception
                // so that compileAsync loads missing schema.
                var schemaId = this.opts.schemaId;
                env = env || new SchemaEnv({ schema: schema, schemaId: schemaId, root: root, baseId: baseId });
                if (env.schema !== env.root.schema)
                    return env;
                return undefined;
            }
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 50: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var codegen_1 = __nccwpck_require__(9179);
            var names = {
                // validation function arguments
                data: new codegen_1.Name("data"),
                // args passed from referencing schema
                valCxt: new codegen_1.Name("valCxt"),
                instancePath: new codegen_1.Name("instancePath"),
                parentData: new codegen_1.Name("parentData"),
                parentDataProperty: new codegen_1.Name("parentDataProperty"),
                rootData: new codegen_1.Name("rootData"),
                dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
                // function scoped variables
                vErrors: new codegen_1.Name("vErrors"),
                errors: new codegen_1.Name("errors"),
                "this": new codegen_1.Name("this"),
                // "globals"
                self: new codegen_1.Name("self"),
                scope: new codegen_1.Name("scope"),
                // JTD serialize/parse name for JSON string and position
                json: new codegen_1.Name("json"),
                jsonPos: new codegen_1.Name("jsonPos"),
                jsonLen: new codegen_1.Name("jsonLen"),
                jsonPart: new codegen_1.Name("jsonPart")
            };
            exports["default"] = names;
            //# sourceMappingURL=names.js.map
            /***/ 
        }),
        /***/ 8190: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var resolve_1 = __nccwpck_require__(6646);
            var MissingRefError = /** @class */ (function (_super) {
                __extends(MissingRefError, _super);
                function MissingRefError(resolver, baseId, ref, msg) {
                    var _this_1 = _super.call(this, msg || "can't resolve reference ".concat(ref, " from id ").concat(baseId)) || this;
                    _this_1.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
                    _this_1.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, _this_1.missingRef));
                    return _this_1;
                }
                return MissingRefError;
            }(Error));
            exports["default"] = MissingRefError;
            //# sourceMappingURL=ref_error.js.map
            /***/ 
        }),
        /***/ 6646: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
            var util_1 = __nccwpck_require__(3439);
            var equal = __nccwpck_require__(8206);
            var traverse = __nccwpck_require__(2533);
            // TODO refactor to use keyword definitions
            var SIMPLE_INLINED = new Set([
                "type",
                "format",
                "pattern",
                "maxLength",
                "minLength",
                "maxProperties",
                "minProperties",
                "maxItems",
                "minItems",
                "maximum",
                "minimum",
                "uniqueItems",
                "multipleOf",
                "required",
                "enum",
                "const",
            ]);
            function inlineRef(schema, limit) {
                if (limit === void 0) { limit = true; }
                if (typeof schema == "boolean")
                    return true;
                if (limit === true)
                    return !hasRef(schema);
                if (!limit)
                    return false;
                return countKeys(schema) <= limit;
            }
            exports.inlineRef = inlineRef;
            var REF_KEYWORDS = new Set([
                "$ref",
                "$recursiveRef",
                "$recursiveAnchor",
                "$dynamicRef",
                "$dynamicAnchor",
            ]);
            function hasRef(schema) {
                for (var key in schema) {
                    if (REF_KEYWORDS.has(key))
                        return true;
                    var sch = schema[key];
                    if (Array.isArray(sch) && sch.some(hasRef))
                        return true;
                    if (typeof sch == "object" && hasRef(sch))
                        return true;
                }
                return false;
            }
            function countKeys(schema) {
                var count = 0;
                for (var key in schema) {
                    if (key === "$ref")
                        return Infinity;
                    count++;
                    if (SIMPLE_INLINED.has(key))
                        continue;
                    if (typeof schema[key] == "object") {
                        (0, util_1.eachItem)(schema[key], function (sch) { return (count += countKeys(sch)); });
                    }
                    if (count === Infinity)
                        return Infinity;
                }
                return count;
            }
            function getFullPath(resolver, id, normalize) {
                if (id === void 0) { id = ""; }
                if (normalize !== false)
                    id = normalizeId(id);
                var p = resolver.parse(id);
                return _getFullPath(resolver, p);
            }
            exports.getFullPath = getFullPath;
            function _getFullPath(resolver, p) {
                var serialized = resolver.serialize(p);
                return serialized.split("#")[0] + "#";
            }
            exports._getFullPath = _getFullPath;
            var TRAILING_SLASH_HASH = /#\/?$/;
            function normalizeId(id) {
                return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
            }
            exports.normalizeId = normalizeId;
            function resolveUrl(resolver, baseId, id) {
                id = normalizeId(id);
                return resolver.resolve(baseId, id);
            }
            exports.resolveUrl = resolveUrl;
            var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
            function getSchemaRefs(schema, baseId) {
                var _this_1 = this;
                if (typeof schema == "boolean")
                    return {};
                var _1 = this.opts, schemaId = _1.schemaId, uriResolver = _1.uriResolver;
                var schId = normalizeId(schema[schemaId] || baseId);
                var baseIds = { "": schId };
                var pathPrefix = getFullPath(uriResolver, schId, false);
                var localRefs = {};
                var schemaRefs = new Set();
                traverse(schema, { allKeys: true }, function (sch, jsonPtr, _, parentJsonPtr) {
                    if (parentJsonPtr === undefined)
                        return;
                    var fullPath = pathPrefix + jsonPtr;
                    var baseId = baseIds[parentJsonPtr];
                    if (typeof sch[schemaId] == "string")
                        baseId = addRef.call(_this_1, sch[schemaId]);
                    addAnchor.call(_this_1, sch.$anchor);
                    addAnchor.call(_this_1, sch.$dynamicAnchor);
                    baseIds[jsonPtr] = baseId;
                    function addRef(ref) {
                        // eslint-disable-next-line @typescript-eslint/unbound-method
                        var _resolve = this.opts.uriResolver.resolve;
                        ref = normalizeId(baseId ? _resolve(baseId, ref) : ref);
                        if (schemaRefs.has(ref))
                            throw ambiguos(ref);
                        schemaRefs.add(ref);
                        var schOrRef = this.refs[ref];
                        if (typeof schOrRef == "string")
                            schOrRef = this.refs[schOrRef];
                        if (typeof schOrRef == "object") {
                            checkAmbiguosRef(sch, schOrRef.schema, ref);
                        }
                        else if (ref !== normalizeId(fullPath)) {
                            if (ref[0] === "#") {
                                checkAmbiguosRef(sch, localRefs[ref], ref);
                                localRefs[ref] = sch;
                            }
                            else {
                                this.refs[ref] = fullPath;
                            }
                        }
                        return ref;
                    }
                    function addAnchor(anchor) {
                        if (typeof anchor == "string") {
                            if (!ANCHOR.test(anchor))
                                throw new Error("invalid anchor \"".concat(anchor, "\""));
                            addRef.call(this, "#".concat(anchor));
                        }
                    }
                });
                return localRefs;
                function checkAmbiguosRef(sch1, sch2, ref) {
                    if (sch2 !== undefined && !equal(sch1, sch2))
                        throw ambiguos(ref);
                }
                function ambiguos(ref) {
                    return new Error("reference \"".concat(ref, "\" resolves to more than one schema"));
                }
            }
            exports.getSchemaRefs = getSchemaRefs;
            //# sourceMappingURL=resolve.js.map
            /***/ 
        }),
        /***/ 1785: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.getRules = exports.isJSONType = void 0;
            var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
            var jsonTypes = new Set(_jsonTypes);
            function isJSONType(x) {
                return typeof x == "string" && jsonTypes.has(x);
            }
            exports.isJSONType = isJSONType;
            function getRules() {
                var groups = {
                    number: { type: "number", rules: [] },
                    string: { type: "string", rules: [] },
                    array: { type: "array", rules: [] },
                    object: { type: "object", rules: [] }
                };
                return {
                    types: __assign(__assign({}, groups), { integer: true, boolean: true, "null": true }),
                    rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
                    post: { rules: [] },
                    all: {},
                    keywords: {}
                };
            }
            exports.getRules = getRules;
            //# sourceMappingURL=rules.js.map
            /***/ 
        }),
        /***/ 3439: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
            var codegen_1 = __nccwpck_require__(9179);
            var code_1 = __nccwpck_require__(8358);
            // TODO refactor to use Set
            function toHash(arr) {
                var hash = {};
                for (var _1 = 0, arr_2 = arr; _1 < arr_2.length; _1++) {
                    var item = arr_2[_1];
                    hash[item] = true;
                }
                return hash;
            }
            exports.toHash = toHash;
            function alwaysValidSchema(it, schema) {
                if (typeof schema == "boolean")
                    return schema;
                if (Object.keys(schema).length === 0)
                    return true;
                checkUnknownRules(it, schema);
                return !schemaHasRules(schema, it.self.RULES.all);
            }
            exports.alwaysValidSchema = alwaysValidSchema;
            function checkUnknownRules(it, schema) {
                if (schema === void 0) { schema = it.schema; }
                var opts = it.opts, self = it.self;
                if (!opts.strictSchema)
                    return;
                if (typeof schema === "boolean")
                    return;
                var rules = self.RULES.keywords;
                for (var key in schema) {
                    if (!rules[key])
                        checkStrictMode(it, "unknown keyword: \"".concat(key, "\""));
                }
            }
            exports.checkUnknownRules = checkUnknownRules;
            function schemaHasRules(schema, rules) {
                if (typeof schema == "boolean")
                    return !schema;
                for (var key in schema)
                    if (rules[key])
                        return true;
                return false;
            }
            exports.schemaHasRules = schemaHasRules;
            function schemaHasRulesButRef(schema, RULES) {
                if (typeof schema == "boolean")
                    return !schema;
                for (var key in schema)
                    if (key !== "$ref" && RULES.all[key])
                        return true;
                return false;
            }
            exports.schemaHasRulesButRef = schemaHasRulesButRef;
            function schemaRefOrVal(_1, schema, keyword, $data) {
                var topSchemaRef = _1.topSchemaRef, schemaPath = _1.schemaPath;
                if (!$data) {
                    if (typeof schema == "number" || typeof schema == "boolean")
                        return schema;
                    if (typeof schema == "string")
                        return (0, codegen_1._)(__makeTemplateObject(["", ""], ["", ""]), schema);
                }
                return (0, codegen_1._)(__makeTemplateObject(["", "", "", ""], ["", "", "", ""]), topSchemaRef, schemaPath, (0, codegen_1.getProperty)(keyword));
            }
            exports.schemaRefOrVal = schemaRefOrVal;
            function unescapeFragment(str) {
                return unescapeJsonPointer(decodeURIComponent(str));
            }
            exports.unescapeFragment = unescapeFragment;
            function escapeFragment(str) {
                return encodeURIComponent(escapeJsonPointer(str));
            }
            exports.escapeFragment = escapeFragment;
            function escapeJsonPointer(str) {
                if (typeof str == "number")
                    return "".concat(str);
                return str.replace(/~/g, "~0").replace(/\//g, "~1");
            }
            exports.escapeJsonPointer = escapeJsonPointer;
            function unescapeJsonPointer(str) {
                return str.replace(/~1/g, "/").replace(/~0/g, "~");
            }
            exports.unescapeJsonPointer = unescapeJsonPointer;
            function eachItem(xs, f) {
                if (Array.isArray(xs)) {
                    for (var _1 = 0, xs_1 = xs; _1 < xs_1.length; _1++) {
                        var x = xs_1[_1];
                        f(x);
                    }
                }
                else {
                    f(xs);
                }
            }
            exports.eachItem = eachItem;
            function makeMergeEvaluated(_1) {
                var mergeNames = _1.mergeNames, mergeToName = _1.mergeToName, mergeValues = _1.mergeValues, resultToName = _1.resultToName;
                return function (gen, from, to, toName) {
                    var res = to === undefined
                        ? from
                        : to instanceof codegen_1.Name
                            ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)
                            : from instanceof codegen_1.Name
                                ? (mergeToName(gen, to, from), from)
                                : mergeValues(from, to);
                    return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
                };
            }
            exports.mergeEvaluated = {
                props: makeMergeEvaluated({
                    mergeNames: function (gen, from, to) { return gen["if"]((0, codegen_1._)(__makeTemplateObject(["", " !== true && ", " !== undefined"], ["", " !== true && ", " !== undefined"]), to, from), function () {
                        gen["if"]((0, codegen_1._)(__makeTemplateObject(["", " === true"], ["", " === true"]), from), function () { return gen.assign(to, true); }, function () { return gen.assign(to, (0, codegen_1._)(__makeTemplateObject(["", " || {}"], ["", " || {}"]), to)).code((0, codegen_1._)(__makeTemplateObject(["Object.assign(", ", ", ")"], ["Object.assign(", ", ", ")"]), to, from)); });
                    }); },
                    mergeToName: function (gen, from, to) { return gen["if"]((0, codegen_1._)(__makeTemplateObject(["", " !== true"], ["", " !== true"]), to), function () {
                        if (from === true) {
                            gen.assign(to, true);
                        }
                        else {
                            gen.assign(to, (0, codegen_1._)(__makeTemplateObject(["", " || {}"], ["", " || {}"]), to));
                            setEvaluated(gen, to, from);
                        }
                    }); },
                    mergeValues: function (from, to) { return (from === true ? true : __assign(__assign({}, from), to)); },
                    resultToName: evaluatedPropsToName
                }),
                items: makeMergeEvaluated({
                    mergeNames: function (gen, from, to) { return gen["if"]((0, codegen_1._)(__makeTemplateObject(["", " !== true && ", " !== undefined"], ["", " !== true && ", " !== undefined"]), to, from), function () { return gen.assign(to, (0, codegen_1._)(__makeTemplateObject(["", " === true ? true : ", " > ", " ? ", " : ", ""], ["", " === true ? true : ", " > ", " ? ", " : ", ""]), from, to, from, to, from)); }); },
                    mergeToName: function (gen, from, to) { return gen["if"]((0, codegen_1._)(__makeTemplateObject(["", " !== true"], ["", " !== true"]), to), function () { return gen.assign(to, from === true ? true : (0, codegen_1._)(__makeTemplateObject(["", " > ", " ? ", " : ", ""], ["", " > ", " ? ", " : ", ""]), to, from, to, from)); }); },
                    mergeValues: function (from, to) { return (from === true ? true : Math.max(from, to)); },
                    resultToName: function (gen, items) { return gen["var"]("items", items); }
                })
            };
            function evaluatedPropsToName(gen, ps) {
                if (ps === true)
                    return gen["var"]("props", true);
                var props = gen["var"]("props", (0, codegen_1._)(__makeTemplateObject(["{}"], ["{}"])));
                if (ps !== undefined)
                    setEvaluated(gen, props, ps);
                return props;
            }
            exports.evaluatedPropsToName = evaluatedPropsToName;
            function setEvaluated(gen, props, ps) {
                Object.keys(ps).forEach(function (p) { return gen.assign((0, codegen_1._)(__makeTemplateObject(["", "", ""], ["", "", ""]), props, (0, codegen_1.getProperty)(p)), true); });
            }
            exports.setEvaluated = setEvaluated;
            var snippets = {};
            function useFunc(gen, f) {
                return gen.scopeValue("func", {
                    ref: f,
                    code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
                });
            }
            exports.useFunc = useFunc;
            var Type;
            (function (Type) {
                Type[Type["Num"] = 0] = "Num";
                Type[Type["Str"] = 1] = "Str";
            })(Type = exports.Type || (exports.Type = {}));
            function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
                // let path
                if (dataProp instanceof codegen_1.Name) {
                    var isNumber = dataPropType === Type.Num;
                    return jsPropertySyntax
                        ? isNumber
                            ? (0, codegen_1._)(__makeTemplateObject(["\"[\" + ", " + \"]\""], ["\"[\" + ", " + \"]\""]), dataProp) : (0, codegen_1._)(__makeTemplateObject(["\"['\" + ", " + \"']\""], ["\"['\" + ", " + \"']\""]), dataProp)
                        : isNumber
                            ? (0, codegen_1._)(__makeTemplateObject(["\"/\" + ", ""], ["\"/\" + ", ""]), dataProp) : (0, codegen_1._)(__makeTemplateObject(["\"/\" + ", ".replace(/~/g, \"~0\").replace(/\\//g, \"~1\")"], ["\"/\" + ", ".replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")"]), dataProp); // TODO maybe use global escapePointer
                }
                return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
            }
            exports.getErrorPath = getErrorPath;
            function checkStrictMode(it, msg, mode) {
                if (mode === void 0) { mode = it.opts.strictSchema; }
                if (!mode)
                    return;
                msg = "strict mode: ".concat(msg);
                if (mode === true)
                    throw new Error(msg);
                it.self.logger.warn(msg);
            }
            exports.checkStrictMode = checkStrictMode;
            //# sourceMappingURL=util.js.map
            /***/ 
        }),
        /***/ 3627: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
            function schemaHasRulesForType(_1, type) {
                var schema = _1.schema, self = _1.self;
                var group = self.RULES.types[type];
                return group && group !== true && shouldUseGroup(schema, group);
            }
            exports.schemaHasRulesForType = schemaHasRulesForType;
            function shouldUseGroup(schema, group) {
                return group.rules.some(function (rule) { return shouldUseRule(schema, rule); });
            }
            exports.shouldUseGroup = shouldUseGroup;
            function shouldUseRule(schema, rule) {
                var _a;
                return (schema[rule.keyword] !== undefined ||
                    ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some(function (kwd) { return schema[kwd] !== undefined; })));
            }
            exports.shouldUseRule = shouldUseRule;
            //# sourceMappingURL=applicability.js.map
            /***/ 
        }),
        /***/ 6214: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
            var errors_1 = __nccwpck_require__(6150);
            var codegen_1 = __nccwpck_require__(9179);
            var names_1 = __nccwpck_require__(50);
            var boolError = {
                message: "boolean schema is false"
            };
            function topBoolOrEmptySchema(it) {
                var gen = it.gen, schema = it.schema, validateName = it.validateName;
                if (schema === false) {
                    falseSchemaError(it, false);
                }
                else if (typeof schema == "object" && schema.$async === true) {
                    gen["return"](names_1["default"].data);
                }
                else {
                    gen.assign((0, codegen_1._)(__makeTemplateObject(["", ".errors"], ["", ".errors"]), validateName), null);
                    gen["return"](true);
                }
            }
            exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
            function boolOrEmptySchema(it, valid) {
                var gen = it.gen, schema = it.schema;
                if (schema === false) {
                    gen["var"](valid, false); // TODO var
                    falseSchemaError(it);
                }
                else {
                    gen["var"](valid, true); // TODO var
                }
            }
            exports.boolOrEmptySchema = boolOrEmptySchema;
            function falseSchemaError(it, overrideAllErrors) {
                var gen = it.gen, data = it.data;
                // TODO maybe some other interface should be used for non-keyword validation errors...
                var cxt = {
                    gen: gen,
                    keyword: "false schema",
                    data: data,
                    schema: false,
                    schemaCode: false,
                    schemaValue: false,
                    params: {},
                    it: it
                };
                (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);
            }
            //# sourceMappingURL=boolSchema.js.map
            /***/ 
        }),
        /***/ 7725: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
            var rules_1 = __nccwpck_require__(1785);
            var applicability_1 = __nccwpck_require__(3627);
            var errors_1 = __nccwpck_require__(6150);
            var codegen_1 = __nccwpck_require__(9179);
            var util_1 = __nccwpck_require__(3439);
            var DataType;
            (function (DataType) {
                DataType[DataType["Correct"] = 0] = "Correct";
                DataType[DataType["Wrong"] = 1] = "Wrong";
            })(DataType = exports.DataType || (exports.DataType = {}));
            function getSchemaTypes(schema) {
                var types = getJSONTypes(schema.type);
                var hasNull = types.includes("null");
                if (hasNull) {
                    if (schema.nullable === false)
                        throw new Error("type: null contradicts nullable: false");
                }
                else {
                    if (!types.length && schema.nullable !== undefined) {
                        throw new Error('"nullable" cannot be used without "type"');
                    }
                    if (schema.nullable === true)
                        types.push("null");
                }
                return types;
            }
            exports.getSchemaTypes = getSchemaTypes;
            function getJSONTypes(ts) {
                var types = Array.isArray(ts) ? ts : ts ? [ts] : [];
                if (types.every(rules_1.isJSONType))
                    return types;
                throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
            }
            exports.getJSONTypes = getJSONTypes;
            function coerceAndCheckDataType(it, types) {
                var gen = it.gen, data = it.data, opts = it.opts;
                var coerceTo = coerceToTypes(types, opts.coerceTypes);
                var checkTypes = types.length > 0 &&
                    !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
                if (checkTypes) {
                    var wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
                    gen["if"](wrongType, function () {
                        if (coerceTo.length)
                            coerceData(it, types, coerceTo);
                        else
                            reportTypeError(it);
                    });
                }
                return checkTypes;
            }
            exports.coerceAndCheckDataType = coerceAndCheckDataType;
            var COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
            function coerceToTypes(types, coerceTypes) {
                return coerceTypes
                    ? types.filter(function (t) { return COERCIBLE.has(t) || (coerceTypes === "array" && t === "array"); })
                    : [];
            }
            function coerceData(it, types, coerceTo) {
                var gen = it.gen, data = it.data, opts = it.opts;
                var dataType = gen.let("dataType", (0, codegen_1._)(__makeTemplateObject(["typeof ", ""], ["typeof ", ""]), data));
                var coerced = gen.let("coerced", (0, codegen_1._)(__makeTemplateObject(["undefined"], ["undefined"])));
                if (opts.coerceTypes === "array") {
                    gen["if"]((0, codegen_1._)(__makeTemplateObject(["", " == 'object' && Array.isArray(", ") && ", ".length == 1"], ["", " == 'object' && Array.isArray(", ") && ", ".length == 1"]), dataType, data, data), function () { return gen
                        .assign(data, (0, codegen_1._)(__makeTemplateObject(["", "[0]"], ["", "[0]"]), data))
                        .assign(dataType, (0, codegen_1._)(__makeTemplateObject(["typeof ", ""], ["typeof ", ""]), data))["if"](checkDataTypes(types, data, opts.strictNumbers), function () { return gen.assign(coerced, data); }); });
                }
                gen["if"]((0, codegen_1._)(__makeTemplateObject(["", " !== undefined"], ["", " !== undefined"]), coerced));
                for (var _1 = 0, coerceTo_1 = coerceTo; _1 < coerceTo_1.length; _1++) {
                    var t = coerceTo_1[_1];
                    if (COERCIBLE.has(t) || (t === "array" && opts.coerceTypes === "array")) {
                        coerceSpecificType(t);
                    }
                }
                gen["else"]();
                reportTypeError(it);
                gen.endIf();
                gen["if"]((0, codegen_1._)(__makeTemplateObject(["", " !== undefined"], ["", " !== undefined"]), coerced), function () {
                    gen.assign(data, coerced);
                    assignParentData(it, coerced);
                });
                function coerceSpecificType(t) {
                    switch (t) {
                        case "string":
                            gen
                                .elseIf((0, codegen_1._)(__makeTemplateObject(["", " == \"number\" || ", " == \"boolean\""], ["", " == \"number\" || ", " == \"boolean\""]), dataType, dataType))
                                .assign(coerced, (0, codegen_1._)(__makeTemplateObject(["\"\" + ", ""], ["\"\" + ", ""]), data))
                                .elseIf((0, codegen_1._)(__makeTemplateObject(["", " === null"], ["", " === null"]), data))
                                .assign(coerced, (0, codegen_1._)(__makeTemplateObject(["\"\""], ["\"\""])));
                            return;
                        case "number":
                            gen
                                .elseIf((0, codegen_1._)(__makeTemplateObject(["", " == \"boolean\" || ", " === null\n              || (", " == \"string\" && ", " && ", " == +", ")"], ["", " == \"boolean\" || ", " === null\n              || (", " == \"string\" && ", " && ", " == +", ")"]), dataType, data, dataType, data, data, data))
                                .assign(coerced, (0, codegen_1._)(__makeTemplateObject(["+", ""], ["+", ""]), data));
                            return;
                        case "integer":
                            gen
                                .elseIf((0, codegen_1._)(__makeTemplateObject(["", " === \"boolean\" || ", " === null\n              || (", " === \"string\" && ", " && ", " == +", " && !(", " % 1))"], ["", " === \"boolean\" || ", " === null\n              || (", " === \"string\" && ", " && ", " == +", " && !(", " % 1))"]), dataType, data, dataType, data, data, data, data))
                                .assign(coerced, (0, codegen_1._)(__makeTemplateObject(["+", ""], ["+", ""]), data));
                            return;
                        case "boolean":
                            gen
                                .elseIf((0, codegen_1._)(__makeTemplateObject(["", " === \"false\" || ", " === 0 || ", " === null"], ["", " === \"false\" || ", " === 0 || ", " === null"]), data, data, data))
                                .assign(coerced, false)
                                .elseIf((0, codegen_1._)(__makeTemplateObject(["", " === \"true\" || ", " === 1"], ["", " === \"true\" || ", " === 1"]), data, data))
                                .assign(coerced, true);
                            return;
                        case "null":
                            gen.elseIf((0, codegen_1._)(__makeTemplateObject(["", " === \"\" || ", " === 0 || ", " === false"], ["", " === \"\" || ", " === 0 || ", " === false"]), data, data, data));
                            gen.assign(coerced, null);
                            return;
                        case "array":
                            gen
                                .elseIf((0, codegen_1._)(__makeTemplateObject(["", " === \"string\" || ", " === \"number\"\n              || ", " === \"boolean\" || ", " === null"], ["", " === \"string\" || ", " === \"number\"\n              || ", " === \"boolean\" || ", " === null"]), dataType, dataType, dataType, data))
                                .assign(coerced, (0, codegen_1._)(__makeTemplateObject(["[", "]"], ["[", "]"]), data));
                    }
                }
            }
            function assignParentData(_1, expr) {
                var gen = _1.gen, parentData = _1.parentData, parentDataProperty = _1.parentDataProperty;
                // TODO use gen.property
                gen["if"]((0, codegen_1._)(__makeTemplateObject(["", " !== undefined"], ["", " !== undefined"]), parentData), function () { return gen.assign((0, codegen_1._)(__makeTemplateObject(["", "[", "]"], ["", "[", "]"]), parentData, parentDataProperty), expr); });
            }
            function checkDataType(dataType, data, strictNums, correct) {
                if (correct === void 0) { correct = DataType.Correct; }
                var EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
                var cond;
                switch (dataType) {
                    case "null":
                        return (0, codegen_1._)(__makeTemplateObject(["", " ", " null"], ["", " ", " null"]), data, EQ);
                    case "array":
                        cond = (0, codegen_1._)(__makeTemplateObject(["Array.isArray(", ")"], ["Array.isArray(", ")"]), data);
                        break;
                    case "object":
                        cond = (0, codegen_1._)(__makeTemplateObject(["", " && typeof ", " == \"object\" && !Array.isArray(", ")"], ["", " && typeof ", " == \"object\" && !Array.isArray(", ")"]), data, data, data);
                        break;
                    case "integer":
                        cond = numCond((0, codegen_1._)(__makeTemplateObject(["!(", " % 1) && !isNaN(", ")"], ["!(", " % 1) && !isNaN(", ")"]), data, data));
                        break;
                    case "number":
                        cond = numCond();
                        break;
                    default:
                        return (0, codegen_1._)(__makeTemplateObject(["typeof ", " ", " ", ""], ["typeof ", " ", " ", ""]), data, EQ, dataType);
                }
                return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
                function numCond(_cond) {
                    if (_cond === void 0) { _cond = codegen_1.nil; }
                    return (0, codegen_1.and)((0, codegen_1._)(__makeTemplateObject(["typeof ", " == \"number\""], ["typeof ", " == \"number\""]), data), _cond, strictNums ? (0, codegen_1._)(__makeTemplateObject(["isFinite(", ")"], ["isFinite(", ")"]), data) : codegen_1.nil);
                }
            }
            exports.checkDataType = checkDataType;
            function checkDataTypes(dataTypes, data, strictNums, correct) {
                if (dataTypes.length === 1) {
                    return checkDataType(dataTypes[0], data, strictNums, correct);
                }
                var cond;
                var types = (0, util_1.toHash)(dataTypes);
                if (types.array && types.object) {
                    var notObj = (0, codegen_1._)(__makeTemplateObject(["typeof ", " != \"object\""], ["typeof ", " != \"object\""]), data);
                    cond = types["null"] ? notObj : (0, codegen_1._)(__makeTemplateObject(["!", " || ", ""], ["!", " || ", ""]), data, notObj);
                    delete types["null"];
                    delete types.array;
                    delete types.object;
                }
                else {
                    cond = codegen_1.nil;
                }
                if (types.number)
                    delete types.integer;
                for (var t in types)
                    cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
                return cond;
            }
            exports.checkDataTypes = checkDataTypes;
            var typeError = {
                message: function (_1) {
                    var schema = _1.schema;
                    return "must be ".concat(schema);
                },
                params: function (_1) {
                    var schema = _1.schema, schemaValue = _1.schemaValue;
                    return typeof schema == "string" ? (0, codegen_1._)(__makeTemplateObject(["{type: ", "}"], ["{type: ", "}"]), schema) : (0, codegen_1._)(__makeTemplateObject(["{type: ", "}"], ["{type: ", "}"]), schemaValue);
                }
            };
            function reportTypeError(it) {
                var cxt = getTypeErrorContext(it);
                (0, errors_1.reportError)(cxt, typeError);
            }
            exports.reportTypeError = reportTypeError;
            function getTypeErrorContext(it) {
                var gen = it.gen, data = it.data, schema = it.schema;
                var schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
                return {
                    gen: gen,
                    keyword: "type",
                    data: data,
                    schema: schema.type,
                    schemaCode: schemaCode,
                    schemaValue: schemaCode,
                    parentSchema: schema,
                    params: {},
                    it: it
                };
            }
            //# sourceMappingURL=dataType.js.map
            /***/ 
        }),
        /***/ 9593: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.assignDefaults = void 0;
            var codegen_1 = __nccwpck_require__(9179);
            var util_1 = __nccwpck_require__(3439);
            function assignDefaults(it, ty) {
                var _1 = it.schema, properties = _1.properties, items = _1.items;
                if (ty === "object" && properties) {
                    for (var key in properties) {
                        assignDefault(it, key, properties[key]["default"]);
                    }
                }
                else if (ty === "array" && Array.isArray(items)) {
                    items.forEach(function (sch, i) { return assignDefault(it, i, sch["default"]); });
                }
            }
            exports.assignDefaults = assignDefaults;
            function assignDefault(it, prop, defaultValue) {
                var gen = it.gen, compositeRule = it.compositeRule, data = it.data, opts = it.opts;
                if (defaultValue === undefined)
                    return;
                var childData = (0, codegen_1._)(__makeTemplateObject(["", "", ""], ["", "", ""]), data, (0, codegen_1.getProperty)(prop));
                if (compositeRule) {
                    (0, util_1.checkStrictMode)(it, "default is ignored for: ".concat(childData));
                    return;
                }
                var condition = (0, codegen_1._)(__makeTemplateObject(["", " === undefined"], ["", " === undefined"]), childData);
                if (opts.useDefaults === "empty") {
                    condition = (0, codegen_1._)(__makeTemplateObject(["", " || ", " === null || ", " === \"\""], ["", " || ", " === null || ", " === \"\""]), condition, childData, childData);
                }
                // `${childData} === undefined` +
                // (opts.useDefaults === "empty" ? ` || ${childData} === null || ${childData} === ""` : "")
                gen["if"](condition, (0, codegen_1._)(__makeTemplateObject(["", " = ", ""], ["", " = ", ""]), childData, (0, codegen_1.stringify)(defaultValue)));
            }
            //# sourceMappingURL=defaults.js.map
            /***/ 
        }),
        /***/ 8955: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
            var boolSchema_1 = __nccwpck_require__(6214);
            var dataType_1 = __nccwpck_require__(7725);
            var applicability_1 = __nccwpck_require__(3627);
            var dataType_2 = __nccwpck_require__(7725);
            var defaults_1 = __nccwpck_require__(9593);
            var keyword_1 = __nccwpck_require__(8732);
            var subschema_1 = __nccwpck_require__(3896);
            var codegen_1 = __nccwpck_require__(9179);
            var names_1 = __nccwpck_require__(50);
            var resolve_1 = __nccwpck_require__(6646);
            var util_1 = __nccwpck_require__(3439);
            var errors_1 = __nccwpck_require__(6150);
            // schema compilation - generates validation function, subschemaCode (below) is used for subschemas
            function validateFunctionCode(it) {
                if (isSchemaObj(it)) {
                    checkKeywords(it);
                    if (schemaCxtHasRules(it)) {
                        topSchemaObjCode(it);
                        return;
                    }
                }
                validateFunction(it, function () { return (0, boolSchema_1.topBoolOrEmptySchema)(it); });
            }
            exports.validateFunctionCode = validateFunctionCode;
            function validateFunction(_1, body) {
                var gen = _1.gen, validateName = _1.validateName, schema = _1.schema, schemaEnv = _1.schemaEnv, opts = _1.opts;
                if (opts.code.es5) {
                    gen.func(validateName, (0, codegen_1._)(__makeTemplateObject(["", ", ", ""], ["", ", ", ""]), names_1["default"].data, names_1["default"].valCxt), schemaEnv.$async, function () {
                        gen.code((0, codegen_1._)(__makeTemplateObject(["\"use strict\"; ", ""], ["\"use strict\"; ", ""]), funcSourceUrl(schema, opts)));
                        destructureValCxtES5(gen, opts);
                        gen.code(body);
                    });
                }
                else {
                    gen.func(validateName, (0, codegen_1._)(__makeTemplateObject(["", ", ", ""], ["", ", ", ""]), names_1["default"].data, destructureValCxt(opts)), schemaEnv.$async, function () { return gen.code(funcSourceUrl(schema, opts)).code(body); });
                }
            }
            function destructureValCxt(opts) {
                return (0, codegen_1._)(__makeTemplateObject(["{", "=\"\", ", ", ", ", ", "=", "", "}={}"], ["{", "=\"\", ", ", ", ", ", "=", "", "}={}"]), names_1["default"].instancePath, names_1["default"].parentData, names_1["default"].parentDataProperty, names_1["default"].rootData, names_1["default"].data, opts.dynamicRef ? (0, codegen_1._)(__makeTemplateObject([", ", "={}"], [", ", "={}"]), names_1["default"].dynamicAnchors) : codegen_1.nil);
            }
            function destructureValCxtES5(gen, opts) {
                gen["if"](names_1["default"].valCxt, function () {
                    gen["var"](names_1["default"].instancePath, (0, codegen_1._)(__makeTemplateObject(["", ".", ""], ["", ".", ""]), names_1["default"].valCxt, names_1["default"].instancePath));
                    gen["var"](names_1["default"].parentData, (0, codegen_1._)(__makeTemplateObject(["", ".", ""], ["", ".", ""]), names_1["default"].valCxt, names_1["default"].parentData));
                    gen["var"](names_1["default"].parentDataProperty, (0, codegen_1._)(__makeTemplateObject(["", ".", ""], ["", ".", ""]), names_1["default"].valCxt, names_1["default"].parentDataProperty));
                    gen["var"](names_1["default"].rootData, (0, codegen_1._)(__makeTemplateObject(["", ".", ""], ["", ".", ""]), names_1["default"].valCxt, names_1["default"].rootData));
                    if (opts.dynamicRef)
                        gen["var"](names_1["default"].dynamicAnchors, (0, codegen_1._)(__makeTemplateObject(["", ".", ""], ["", ".", ""]), names_1["default"].valCxt, names_1["default"].dynamicAnchors));
                }, function () {
                    gen["var"](names_1["default"].instancePath, (0, codegen_1._)(__makeTemplateObject(["\"\""], ["\"\""])));
                    gen["var"](names_1["default"].parentData, (0, codegen_1._)(__makeTemplateObject(["undefined"], ["undefined"])));
                    gen["var"](names_1["default"].parentDataProperty, (0, codegen_1._)(__makeTemplateObject(["undefined"], ["undefined"])));
                    gen["var"](names_1["default"].rootData, names_1["default"].data);
                    if (opts.dynamicRef)
                        gen["var"](names_1["default"].dynamicAnchors, (0, codegen_1._)(__makeTemplateObject(["{}"], ["{}"])));
                });
            }
            function topSchemaObjCode(it) {
                var schema = it.schema, opts = it.opts, gen = it.gen;
                validateFunction(it, function () {
                    if (opts.$comment && schema.$comment)
                        commentKeyword(it);
                    checkNoDefault(it);
                    gen.let(names_1["default"].vErrors, null);
                    gen.let(names_1["default"].errors, 0);
                    if (opts.unevaluated)
                        resetEvaluated(it);
                    typeAndKeywords(it);
                    returnResults(it);
                });
                return;
            }
            function resetEvaluated(it) {
                // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated
                var gen = it.gen, validateName = it.validateName;
                it.evaluated = gen["const"]("evaluated", (0, codegen_1._)(__makeTemplateObject(["", ".evaluated"], ["", ".evaluated"]), validateName));
                gen["if"]((0, codegen_1._)(__makeTemplateObject(["", ".dynamicProps"], ["", ".dynamicProps"]), it.evaluated), function () { return gen.assign((0, codegen_1._)(__makeTemplateObject(["", ".props"], ["", ".props"]), it.evaluated), (0, codegen_1._)(__makeTemplateObject(["undefined"], ["undefined"]))); });
                gen["if"]((0, codegen_1._)(__makeTemplateObject(["", ".dynamicItems"], ["", ".dynamicItems"]), it.evaluated), function () { return gen.assign((0, codegen_1._)(__makeTemplateObject(["", ".items"], ["", ".items"]), it.evaluated), (0, codegen_1._)(__makeTemplateObject(["undefined"], ["undefined"]))); });
            }
            function funcSourceUrl(schema, opts) {
                var schId = typeof schema == "object" && schema[opts.schemaId];
                return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)(__makeTemplateObject(["/*# sourceURL=", " */"], ["/*# sourceURL=", " */"]), schId) : codegen_1.nil;
            }
            // schema compilation - this function is used recursively to generate code for sub-schemas
            function subschemaCode(it, valid) {
                if (isSchemaObj(it)) {
                    checkKeywords(it);
                    if (schemaCxtHasRules(it)) {
                        subSchemaObjCode(it, valid);
                        return;
                    }
                }
                (0, boolSchema_1.boolOrEmptySchema)(it, valid);
            }
            function schemaCxtHasRules(_1) {
                var schema = _1.schema, self = _1.self;
                if (typeof schema == "boolean")
                    return !schema;
                for (var key in schema)
                    if (self.RULES.all[key])
                        return true;
                return false;
            }
            function isSchemaObj(it) {
                return typeof it.schema != "boolean";
            }
            function subSchemaObjCode(it, valid) {
                var schema = it.schema, gen = it.gen, opts = it.opts;
                if (opts.$comment && schema.$comment)
                    commentKeyword(it);
                updateContext(it);
                checkAsyncSchema(it);
                var errsCount = gen["const"]("_errs", names_1["default"].errors);
                typeAndKeywords(it, errsCount);
                // TODO var
                gen["var"](valid, (0, codegen_1._)(__makeTemplateObject(["", " === ", ""], ["", " === ", ""]), errsCount, names_1["default"].errors));
            }
            function checkKeywords(it) {
                (0, util_1.checkUnknownRules)(it);
                checkRefsAndKeywords(it);
            }
            function typeAndKeywords(it, errsCount) {
                if (it.opts.jtd)
                    return schemaKeywords(it, [], false, errsCount);
                var types = (0, dataType_1.getSchemaTypes)(it.schema);
                var checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
                schemaKeywords(it, types, !checkedTypes, errsCount);
            }
            function checkRefsAndKeywords(it) {
                var schema = it.schema, errSchemaPath = it.errSchemaPath, opts = it.opts, self = it.self;
                if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
                    self.logger.warn("$ref: keywords ignored in schema at path \"".concat(errSchemaPath, "\""));
                }
            }
            function checkNoDefault(it) {
                var schema = it.schema, opts = it.opts;
                if (schema["default"] !== undefined && opts.useDefaults && opts.strictSchema) {
                    (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
                }
            }
            function updateContext(it) {
                var schId = it.schema[it.opts.schemaId];
                if (schId)
                    it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
            }
            function checkAsyncSchema(it) {
                if (it.schema.$async && !it.schemaEnv.$async)
                    throw new Error("async schema in sync schema");
            }
            function commentKeyword(_1) {
                var gen = _1.gen, schemaEnv = _1.schemaEnv, schema = _1.schema, errSchemaPath = _1.errSchemaPath, opts = _1.opts;
                var msg = schema.$comment;
                if (opts.$comment === true) {
                    gen.code((0, codegen_1._)(__makeTemplateObject(["", ".logger.log(", ")"], ["", ".logger.log(", ")"]), names_1["default"].self, msg));
                }
                else if (typeof opts.$comment == "function") {
                    var schemaPath = (0, codegen_1.str)(__makeTemplateObject(["", "/$comment"], ["", "/$comment"]), errSchemaPath);
                    var rootName = gen.scopeValue("root", { ref: schemaEnv.root });
                    gen.code((0, codegen_1._)(__makeTemplateObject(["", ".opts.$comment(", ", ", ", ", ".schema)"], ["", ".opts.$comment(", ", ", ", ", ".schema)"]), names_1["default"].self, msg, schemaPath, rootName));
                }
            }
            function returnResults(it) {
                var gen = it.gen, schemaEnv = it.schemaEnv, validateName = it.validateName, ValidationError = it.ValidationError, opts = it.opts;
                if (schemaEnv.$async) {
                    // TODO assign unevaluated
                    gen["if"]((0, codegen_1._)(__makeTemplateObject(["", " === 0"], ["", " === 0"]), names_1["default"].errors), function () { return gen["return"](names_1["default"].data); }, function () { return gen["throw"]((0, codegen_1._)(__makeTemplateObject(["new ", "(", ")"], ["new ", "(", ")"]), ValidationError, names_1["default"].vErrors)); });
                }
                else {
                    gen.assign((0, codegen_1._)(__makeTemplateObject(["", ".errors"], ["", ".errors"]), validateName), names_1["default"].vErrors);
                    if (opts.unevaluated)
                        assignEvaluated(it);
                    gen["return"]((0, codegen_1._)(__makeTemplateObject(["", " === 0"], ["", " === 0"]), names_1["default"].errors));
                }
            }
            function assignEvaluated(_1) {
                var gen = _1.gen, evaluated = _1.evaluated, props = _1.props, items = _1.items;
                if (props instanceof codegen_1.Name)
                    gen.assign((0, codegen_1._)(__makeTemplateObject(["", ".props"], ["", ".props"]), evaluated), props);
                if (items instanceof codegen_1.Name)
                    gen.assign((0, codegen_1._)(__makeTemplateObject(["", ".items"], ["", ".items"]), evaluated), items);
            }
            function schemaKeywords(it, types, typeErrors, errsCount) {
                var gen = it.gen, schema = it.schema, data = it.data, allErrors = it.allErrors, opts = it.opts, self = it.self;
                var RULES = self.RULES;
                if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
                    gen.block(function () { return keywordCode(it, "$ref", RULES.all.$ref.definition); }); // TODO typecast
                    return;
                }
                if (!opts.jtd)
                    checkStrictTypes(it, types);
                gen.block(function () {
                    for (var _1 = 0, _2 = RULES.rules; _1 < _2.length; _1++) {
                        var group = _2[_1];
                        groupKeywords(group);
                    }
                    groupKeywords(RULES.post);
                });
                function groupKeywords(group) {
                    if (!(0, applicability_1.shouldUseGroup)(schema, group))
                        return;
                    if (group.type) {
                        gen["if"]((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
                        iterateKeywords(it, group);
                        if (types.length === 1 && types[0] === group.type && typeErrors) {
                            gen["else"]();
                            (0, dataType_2.reportTypeError)(it);
                        }
                        gen.endIf();
                    }
                    else {
                        iterateKeywords(it, group);
                    }
                    // TODO make it "ok" call?
                    if (!allErrors)
                        gen["if"]((0, codegen_1._)(__makeTemplateObject(["", " === ", ""], ["", " === ", ""]), names_1["default"].errors, errsCount || 0));
                }
            }
            function iterateKeywords(it, group) {
                var gen = it.gen, schema = it.schema, useDefaults = it.opts.useDefaults;
                if (useDefaults)
                    (0, defaults_1.assignDefaults)(it, group.type);
                gen.block(function () {
                    for (var _1 = 0, _2 = group.rules; _1 < _2.length; _1++) {
                        var rule = _2[_1];
                        if ((0, applicability_1.shouldUseRule)(schema, rule)) {
                            keywordCode(it, rule.keyword, rule.definition, group.type);
                        }
                    }
                });
            }
            function checkStrictTypes(it, types) {
                if (it.schemaEnv.meta || !it.opts.strictTypes)
                    return;
                checkContextTypes(it, types);
                if (!it.opts.allowUnionTypes)
                    checkMultipleTypes(it, types);
                checkKeywordTypes(it, it.dataTypes);
            }
            function checkContextTypes(it, types) {
                if (!types.length)
                    return;
                if (!it.dataTypes.length) {
                    it.dataTypes = types;
                    return;
                }
                types.forEach(function (t) {
                    if (!includesType(it.dataTypes, t)) {
                        strictTypesError(it, "type \"".concat(t, "\" not allowed by context \"").concat(it.dataTypes.join(","), "\""));
                    }
                });
                narrowSchemaTypes(it, types);
            }
            function checkMultipleTypes(it, ts) {
                if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
                    strictTypesError(it, "use allowUnionTypes to allow union type keyword");
                }
            }
            function checkKeywordTypes(it, ts) {
                var rules = it.self.RULES.all;
                for (var keyword in rules) {
                    var rule = rules[keyword];
                    if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
                        var type = rule.definition.type;
                        if (type.length && !type.some(function (t) { return hasApplicableType(ts, t); })) {
                            strictTypesError(it, "missing type \"".concat(type.join(","), "\" for keyword \"").concat(keyword, "\""));
                        }
                    }
                }
            }
            function hasApplicableType(schTs, kwdT) {
                return schTs.includes(kwdT) || (kwdT === "number" && schTs.includes("integer"));
            }
            function includesType(ts, t) {
                return ts.includes(t) || (t === "integer" && ts.includes("number"));
            }
            function narrowSchemaTypes(it, withTypes) {
                var ts = [];
                for (var _1 = 0, _2 = it.dataTypes; _1 < _2.length; _1++) {
                    var t = _2[_1];
                    if (includesType(withTypes, t))
                        ts.push(t);
                    else if (withTypes.includes("integer") && t === "number")
                        ts.push("integer");
                }
                it.dataTypes = ts;
            }
            function strictTypesError(it, msg) {
                var schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
                msg += " at \"".concat(schemaPath, "\" (strictTypes)");
                (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
            }
            var KeywordCxt = /** @class */ (function () {
                function KeywordCxt(it, def, keyword) {
                    (0, keyword_1.validateKeywordUsage)(it, def, keyword);
                    this.gen = it.gen;
                    this.allErrors = it.allErrors;
                    this.keyword = keyword;
                    this.data = it.data;
                    this.schema = it.schema[keyword];
                    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
                    this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
                    this.schemaType = def.schemaType;
                    this.parentSchema = it.schema;
                    this.params = {};
                    this.it = it;
                    this.def = def;
                    if (this.$data) {
                        this.schemaCode = it.gen["const"]("vSchema", getData(this.$data, it));
                    }
                    else {
                        this.schemaCode = this.schemaValue;
                        if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
                            throw new Error("".concat(keyword, " value must be ").concat(JSON.stringify(def.schemaType)));
                        }
                    }
                    if ("code" in def ? def.trackErrors : def.errors !== false) {
                        this.errsCount = it.gen["const"]("_errs", names_1["default"].errors);
                    }
                }
                KeywordCxt.prototype.result = function (condition, successAction, failAction) {
                    this.failResult((0, codegen_1.not)(condition), successAction, failAction);
                };
                KeywordCxt.prototype.failResult = function (condition, successAction, failAction) {
                    this.gen["if"](condition);
                    if (failAction)
                        failAction();
                    else
                        this.error();
                    if (successAction) {
                        this.gen["else"]();
                        successAction();
                        if (this.allErrors)
                            this.gen.endIf();
                    }
                    else {
                        if (this.allErrors)
                            this.gen.endIf();
                        else
                            this.gen["else"]();
                    }
                };
                KeywordCxt.prototype.pass = function (condition, failAction) {
                    this.failResult((0, codegen_1.not)(condition), undefined, failAction);
                };
                KeywordCxt.prototype.fail = function (condition) {
                    if (condition === undefined) {
                        this.error();
                        if (!this.allErrors)
                            this.gen["if"](false); // this branch will be removed by gen.optimize
                        return;
                    }
                    this.gen["if"](condition);
                    this.error();
                    if (this.allErrors)
                        this.gen.endIf();
                    else
                        this.gen["else"]();
                };
                KeywordCxt.prototype.fail$data = function (condition) {
                    if (!this.$data)
                        return this.fail(condition);
                    var schemaCode = this.schemaCode;
                    this.fail((0, codegen_1._)(__makeTemplateObject(["", " !== undefined && (", ")"], ["", " !== undefined && (", ")"]), schemaCode, (0, codegen_1.or)(this.invalid$data(), condition)));
                };
                KeywordCxt.prototype.error = function (append, errorParams, errorPaths) {
                    if (errorParams) {
                        this.setParams(errorParams);
                        this._error(append, errorPaths);
                        this.setParams({});
                        return;
                    }
                    this._error(append, errorPaths);
                };
                KeywordCxt.prototype._error = function (append, errorPaths) {
                    ;
                    (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
                };
                KeywordCxt.prototype.$dataError = function () {
                    (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
                };
                KeywordCxt.prototype.reset = function () {
                    if (this.errsCount === undefined)
                        throw new Error('add "trackErrors" to keyword definition');
                    (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
                };
                KeywordCxt.prototype.ok = function (cond) {
                    if (!this.allErrors)
                        this.gen["if"](cond);
                };
                KeywordCxt.prototype.setParams = function (obj, assign) {
                    if (assign)
                        Object.assign(this.params, obj);
                    else
                        this.params = obj;
                };
                KeywordCxt.prototype.block$data = function (valid, codeBlock, $dataValid) {
                    var _this_1 = this;
                    if ($dataValid === void 0) { $dataValid = codegen_1.nil; }
                    this.gen.block(function () {
                        _this_1.check$data(valid, $dataValid);
                        codeBlock();
                    });
                };
                KeywordCxt.prototype.check$data = function (valid, $dataValid) {
                    if (valid === void 0) { valid = codegen_1.nil; }
                    if ($dataValid === void 0) { $dataValid = codegen_1.nil; }
                    if (!this.$data)
                        return;
                    var _1 = this, gen = _1.gen, schemaCode = _1.schemaCode, schemaType = _1.schemaType, def = _1.def;
                    gen["if"]((0, codegen_1.or)((0, codegen_1._)(__makeTemplateObject(["", " === undefined"], ["", " === undefined"]), schemaCode), $dataValid));
                    if (valid !== codegen_1.nil)
                        gen.assign(valid, true);
                    if (schemaType.length || def.validateSchema) {
                        gen.elseIf(this.invalid$data());
                        this.$dataError();
                        if (valid !== codegen_1.nil)
                            gen.assign(valid, false);
                    }
                    gen["else"]();
                };
                KeywordCxt.prototype.invalid$data = function () {
                    var _1 = this, gen = _1.gen, schemaCode = _1.schemaCode, schemaType = _1.schemaType, def = _1.def, it = _1.it;
                    return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
                    function wrong$DataType() {
                        if (schemaType.length) {
                            /* istanbul ignore if */
                            if (!(schemaCode instanceof codegen_1.Name))
                                throw new Error("ajv implementation error");
                            var st = Array.isArray(schemaType) ? schemaType : [schemaType];
                            return (0, codegen_1._)(__makeTemplateObject(["", ""], ["", ""]), (0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong));
                        }
                        return codegen_1.nil;
                    }
                    function invalid$DataSchema() {
                        if (def.validateSchema) {
                            var validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema }); // TODO value.code for standalone
                            return (0, codegen_1._)(__makeTemplateObject(["!", "(", ")"], ["!", "(", ")"]), validateSchemaRef, schemaCode);
                        }
                        return codegen_1.nil;
                    }
                };
                KeywordCxt.prototype.subschema = function (appl, valid) {
                    var subschema = (0, subschema_1.getSubschema)(this.it, appl);
                    (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
                    (0, subschema_1.extendSubschemaMode)(subschema, appl);
                    var nextContext = __assign(__assign(__assign({}, this.it), subschema), { items: undefined, props: undefined });
                    subschemaCode(nextContext, valid);
                    return nextContext;
                };
                KeywordCxt.prototype.mergeEvaluated = function (schemaCxt, toName) {
                    var _1 = this, it = _1.it, gen = _1.gen;
                    if (!it.opts.unevaluated)
                        return;
                    if (it.props !== true && schemaCxt.props !== undefined) {
                        it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
                    }
                    if (it.items !== true && schemaCxt.items !== undefined) {
                        it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
                    }
                };
                KeywordCxt.prototype.mergeValidEvaluated = function (schemaCxt, valid) {
                    var _this_1 = this;
                    var _1 = this, it = _1.it, gen = _1.gen;
                    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
                        gen["if"](valid, function () { return _this_1.mergeEvaluated(schemaCxt, codegen_1.Name); });
                        return true;
                    }
                };
                return KeywordCxt;
            }());
            exports.KeywordCxt = KeywordCxt;
            function keywordCode(it, keyword, def, ruleType) {
                var cxt = new KeywordCxt(it, def, keyword);
                if ("code" in def) {
                    def.code(cxt, ruleType);
                }
                else if (cxt.$data && def.validate) {
                    (0, keyword_1.funcKeywordCode)(cxt, def);
                }
                else if ("macro" in def) {
                    (0, keyword_1.macroKeywordCode)(cxt, def);
                }
                else if (def.compile || def.validate) {
                    (0, keyword_1.funcKeywordCode)(cxt, def);
                }
            }
            var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
            var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
            function getData($data, _1) {
                var dataLevel = _1.dataLevel, dataNames = _1.dataNames, dataPathArr = _1.dataPathArr;
                var jsonPointer;
                var data;
                if ($data === "")
                    return names_1["default"].rootData;
                if ($data[0] === "/") {
                    if (!JSON_POINTER.test($data))
                        throw new Error("Invalid JSON-pointer: ".concat($data));
                    jsonPointer = $data;
                    data = names_1["default"].rootData;
                }
                else {
                    var matches = RELATIVE_JSON_POINTER.exec($data);
                    if (!matches)
                        throw new Error("Invalid JSON-pointer: ".concat($data));
                    var up = +matches[1];
                    jsonPointer = matches[2];
                    if (jsonPointer === "#") {
                        if (up >= dataLevel)
                            throw new Error(errorMsg("property/index", up));
                        return dataPathArr[dataLevel - up];
                    }
                    if (up > dataLevel)
                        throw new Error(errorMsg("data", up));
                    data = dataNames[dataLevel - up];
                    if (!jsonPointer)
                        return data;
                }
                var expr = data;
                var segments = jsonPointer.split("/");
                for (var _2 = 0, segments_1 = segments; _2 < segments_1.length; _2++) {
                    var segment = segments_1[_2];
                    if (segment) {
                        data = (0, codegen_1._)(__makeTemplateObject(["", "", ""], ["", "", ""]), data, (0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment)));
                        expr = (0, codegen_1._)(__makeTemplateObject(["", " && ", ""], ["", " && ", ""]), expr, data);
                    }
                }
                return expr;
                function errorMsg(pointerType, up) {
                    return "Cannot access ".concat(pointerType, " ").concat(up, " levels up, current level is ").concat(dataLevel);
                }
            }
            exports.getData = getData;
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 8732: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
            var codegen_1 = __nccwpck_require__(9179);
            var names_1 = __nccwpck_require__(50);
            var code_1 = __nccwpck_require__(4205);
            var errors_1 = __nccwpck_require__(6150);
            function macroKeywordCode(cxt, def) {
                var gen = cxt.gen, keyword = cxt.keyword, schema = cxt.schema, parentSchema = cxt.parentSchema, it = cxt.it;
                var macroSchema = def.macro.call(it.self, schema, parentSchema, it);
                var schemaRef = useKeyword(gen, keyword, macroSchema);
                if (it.opts.validateSchema !== false)
                    it.self.validateSchema(macroSchema, true);
                var valid = gen.name("valid");
                cxt.subschema({
                    schema: macroSchema,
                    schemaPath: codegen_1.nil,
                    errSchemaPath: "".concat(it.errSchemaPath, "/").concat(keyword),
                    topSchemaRef: schemaRef,
                    compositeRule: true
                }, valid);
                cxt.pass(valid, function () { return cxt.error(true); });
            }
            exports.macroKeywordCode = macroKeywordCode;
            function funcKeywordCode(cxt, def) {
                var _a;
                var gen = cxt.gen, keyword = cxt.keyword, schema = cxt.schema, parentSchema = cxt.parentSchema, $data = cxt.$data, it = cxt.it;
                checkAsyncKeyword(it, def);
                var validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
                var validateRef = useKeyword(gen, keyword, validate);
                var valid = gen.let("valid");
                cxt.block$data(valid, validateKeyword);
                cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
                function validateKeyword() {
                    if (def.errors === false) {
                        assignValid();
                        if (def.modifying)
                            modifyData(cxt);
                        reportErrs(function () { return cxt.error(); });
                    }
                    else {
                        var ruleErrs_1 = def.async ? validateAsync() : validateSync();
                        if (def.modifying)
                            modifyData(cxt);
                        reportErrs(function () { return addErrs(cxt, ruleErrs_1); });
                    }
                }
                function validateAsync() {
                    var ruleErrs = gen.let("ruleErrs", null);
                    gen["try"](function () { return assignValid((0, codegen_1._)(__makeTemplateObject(["await "], ["await "]))); }, function (e) { return gen.assign(valid, false)["if"]((0, codegen_1._)(__makeTemplateObject(["", " instanceof ", ""], ["", " instanceof ", ""]), e, it.ValidationError), function () { return gen.assign(ruleErrs, (0, codegen_1._)(__makeTemplateObject(["", ".errors"], ["", ".errors"]), e)); }, function () { return gen["throw"](e); }); });
                    return ruleErrs;
                }
                function validateSync() {
                    var validateErrs = (0, codegen_1._)(__makeTemplateObject(["", ".errors"], ["", ".errors"]), validateRef);
                    gen.assign(validateErrs, null);
                    assignValid(codegen_1.nil);
                    return validateErrs;
                }
                function assignValid(_await) {
                    if (_await === void 0) { _await = def.async ? (0, codegen_1._)(__makeTemplateObject(["await "], ["await "])) : codegen_1.nil; }
                    var passCxt = it.opts.passContext ? names_1["default"]["this"] : names_1["default"].self;
                    var passSchema = !(("compile" in def && !$data) || def.schema === false);
                    gen.assign(valid, (0, codegen_1._)(__makeTemplateObject(["", "", ""], ["", "", ""]), _await, (0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)), def.modifying);
                }
                function reportErrs(errors) {
                    var _a;
                    gen["if"]((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);
                }
            }
            exports.funcKeywordCode = funcKeywordCode;
            function modifyData(cxt) {
                var gen = cxt.gen, data = cxt.data, it = cxt.it;
                gen["if"](it.parentData, function () { return gen.assign(data, (0, codegen_1._)(__makeTemplateObject(["", "[", "]"], ["", "[", "]"]), it.parentData, it.parentDataProperty)); });
            }
            function addErrs(cxt, errs) {
                var gen = cxt.gen;
                gen["if"]((0, codegen_1._)(__makeTemplateObject(["Array.isArray(", ")"], ["Array.isArray(", ")"]), errs), function () {
                    gen
                        .assign(names_1["default"].vErrors, (0, codegen_1._)(__makeTemplateObject(["", " === null ? ", " : ", ".concat(", ")"], ["", " === null ? ", " : ", ".concat(", ")"]), names_1["default"].vErrors, errs, names_1["default"].vErrors, errs))
                        .assign(names_1["default"].errors, (0, codegen_1._)(__makeTemplateObject(["", ".length"], ["", ".length"]), names_1["default"].vErrors));
                    (0, errors_1.extendErrors)(cxt);
                }, function () { return cxt.error(); });
            }
            function checkAsyncKeyword(_1, def) {
                var schemaEnv = _1.schemaEnv;
                if (def.async && !schemaEnv.$async)
                    throw new Error("async keyword in sync schema");
            }
            function useKeyword(gen, keyword, result) {
                if (result === undefined)
                    throw new Error("keyword \"".concat(keyword, "\" failed to compile"));
                return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
            }
            function validSchemaType(schema, schemaType, allowUndefined) {
                if (allowUndefined === void 0) { allowUndefined = false; }
                // TODO add tests
                return (!schemaType.length ||
                    schemaType.some(function (st) { return st === "array"
                        ? Array.isArray(schema)
                        : st === "object"
                            ? schema && typeof schema == "object" && !Array.isArray(schema)
                            : typeof schema == st || (allowUndefined && typeof schema == "undefined"); }));
            }
            exports.validSchemaType = validSchemaType;
            function validateKeywordUsage(_1, def, keyword) {
                var schema = _1.schema, opts = _1.opts, self = _1.self, errSchemaPath = _1.errSchemaPath;
                /* istanbul ignore if */
                if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
                    throw new Error("ajv implementation error");
                }
                var deps = def.dependencies;
                if (deps === null || deps === void 0 ? void 0 : deps.some(function (kwd) { return !Object.prototype.hasOwnProperty.call(schema, kwd); })) {
                    throw new Error("parent schema must have dependencies of ".concat(keyword, ": ").concat(deps.join(",")));
                }
                if (def.validateSchema) {
                    var valid = def.validateSchema(schema[keyword]);
                    if (!valid) {
                        var msg = "keyword \"".concat(keyword, "\" value is invalid at path \"").concat(errSchemaPath, "\": ") +
                            self.errorsText(def.validateSchema.errors);
                        if (opts.validateSchema === "log")
                            self.logger.error(msg);
                        else
                            throw new Error(msg);
                    }
                }
            }
            exports.validateKeywordUsage = validateKeywordUsage;
            //# sourceMappingURL=keyword.js.map
            /***/ 
        }),
        /***/ 3896: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
            var codegen_1 = __nccwpck_require__(9179);
            var util_1 = __nccwpck_require__(3439);
            function getSubschema(it, _1) {
                var keyword = _1.keyword, schemaProp = _1.schemaProp, schema = _1.schema, schemaPath = _1.schemaPath, errSchemaPath = _1.errSchemaPath, topSchemaRef = _1.topSchemaRef;
                if (keyword !== undefined && schema !== undefined) {
                    throw new Error('both "keyword" and "schema" passed, only one allowed');
                }
                if (keyword !== undefined) {
                    var sch = it.schema[keyword];
                    return schemaProp === undefined
                        ? {
                            schema: sch,
                            schemaPath: (0, codegen_1._)(__makeTemplateObject(["", "", ""], ["", "", ""]), it.schemaPath, (0, codegen_1.getProperty)(keyword)),
                            errSchemaPath: "".concat(it.errSchemaPath, "/").concat(keyword)
                        }
                        : {
                            schema: sch[schemaProp],
                            schemaPath: (0, codegen_1._)(__makeTemplateObject(["", "", "", ""], ["", "", "", ""]), it.schemaPath, (0, codegen_1.getProperty)(keyword), (0, codegen_1.getProperty)(schemaProp)),
                            errSchemaPath: "".concat(it.errSchemaPath, "/").concat(keyword, "/").concat((0, util_1.escapeFragment)(schemaProp))
                        };
                }
                if (schema !== undefined) {
                    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
                        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
                    }
                    return {
                        schema: schema,
                        schemaPath: schemaPath,
                        topSchemaRef: topSchemaRef,
                        errSchemaPath: errSchemaPath
                    };
                }
                throw new Error('either "keyword" or "schema" must be passed');
            }
            exports.getSubschema = getSubschema;
            function extendSubschemaData(subschema, it, _1) {
                var dataProp = _1.dataProp, dpType = _1.dataPropType, data = _1.data, dataTypes = _1.dataTypes, propertyName = _1.propertyName;
                if (data !== undefined && dataProp !== undefined) {
                    throw new Error('both "data" and "dataProp" passed, only one allowed');
                }
                var gen = it.gen;
                if (dataProp !== undefined) {
                    var errorPath = it.errorPath, dataPathArr = it.dataPathArr, opts = it.opts;
                    var nextData = gen.let("data", (0, codegen_1._)(__makeTemplateObject(["", "", ""], ["", "", ""]), it.data, (0, codegen_1.getProperty)(dataProp)), true);
                    dataContextProps(nextData);
                    subschema.errorPath = (0, codegen_1.str)(__makeTemplateObject(["", "", ""], ["", "", ""]), errorPath, (0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax));
                    subschema.parentDataProperty = (0, codegen_1._)(__makeTemplateObject(["", ""], ["", ""]), dataProp);
                    subschema.dataPathArr = __spreadArray(__spreadArray([], dataPathArr, true), [subschema.parentDataProperty], false);
                }
                if (data !== undefined) {
                    var nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true); // replaceable if used once?
                    dataContextProps(nextData);
                    if (propertyName !== undefined)
                        subschema.propertyName = propertyName;
                    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr
                }
                if (dataTypes)
                    subschema.dataTypes = dataTypes;
                function dataContextProps(_nextData) {
                    subschema.data = _nextData;
                    subschema.dataLevel = it.dataLevel + 1;
                    subschema.dataTypes = [];
                    it.definedProperties = new Set();
                    subschema.parentData = it.data;
                    subschema.dataNames = __spreadArray(__spreadArray([], it.dataNames, true), [_nextData], false);
                }
            }
            exports.extendSubschemaData = extendSubschemaData;
            function extendSubschemaMode(subschema, _1) {
                var jtdDiscriminator = _1.jtdDiscriminator, jtdMetadata = _1.jtdMetadata, compositeRule = _1.compositeRule, createErrors = _1.createErrors, allErrors = _1.allErrors;
                if (compositeRule !== undefined)
                    subschema.compositeRule = compositeRule;
                if (createErrors !== undefined)
                    subschema.createErrors = createErrors;
                if (allErrors !== undefined)
                    subschema.allErrors = allErrors;
                subschema.jtdDiscriminator = jtdDiscriminator; // not inherited
                subschema.jtdMetadata = jtdMetadata; // not inherited
            }
            exports.extendSubschemaMode = extendSubschemaMode;
            //# sourceMappingURL=subschema.js.map
            /***/ 
        }),
        /***/ 2685: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
            var validate_1 = __nccwpck_require__(8955);
            Object.defineProperty(exports, "KeywordCxt", ({ enumerable: true, get: function () { return validate_1.KeywordCxt; } }));
            var codegen_1 = __nccwpck_require__(9179);
            Object.defineProperty(exports, "_", ({ enumerable: true, get: function () { return codegen_1._; } }));
            Object.defineProperty(exports, "str", ({ enumerable: true, get: function () { return codegen_1.str; } }));
            Object.defineProperty(exports, "stringify", ({ enumerable: true, get: function () { return codegen_1.stringify; } }));
            Object.defineProperty(exports, "nil", ({ enumerable: true, get: function () { return codegen_1.nil; } }));
            Object.defineProperty(exports, "Name", ({ enumerable: true, get: function () { return codegen_1.Name; } }));
            Object.defineProperty(exports, "CodeGen", ({ enumerable: true, get: function () { return codegen_1.CodeGen; } }));
            var validation_error_1 = __nccwpck_require__(7616);
            var ref_error_1 = __nccwpck_require__(8190);
            var rules_1 = __nccwpck_require__(1785);
            var compile_1 = __nccwpck_require__(813);
            var codegen_2 = __nccwpck_require__(9179);
            var resolve_1 = __nccwpck_require__(6646);
            var dataType_1 = __nccwpck_require__(7725);
            var util_1 = __nccwpck_require__(3439);
            var $dataRefSchema = __nccwpck_require__(4775);
            var uri_1 = __nccwpck_require__(661);
            var defaultRegExp = function (str, flags) { return new RegExp(str, flags); };
            defaultRegExp.code = "new RegExp";
            var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
            var EXT_SCOPE_NAMES = new Set([
                "validate",
                "serialize",
                "parse",
                "wrapper",
                "root",
                "schema",
                "keyword",
                "pattern",
                "formats",
                "validate$data",
                "func",
                "obj",
                "Error",
            ]);
            var removedOptions = {
                errorDataPath: "",
                format: "`validateFormats: false` can be used instead.",
                nullable: '"nullable" keyword is supported by default.',
                jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
                extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
                missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
                processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
                sourceCode: "Use option `code: {source: true}`",
                strictDefaults: "It is default now, see option `strict`.",
                strictKeywords: "It is default now, see option `strict`.",
                uniqueItems: '"uniqueItems" keyword is always validated.',
                unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
                cache: "Map is used as cache, schema object as key.",
                serialize: "Map is used as cache, schema object as key.",
                ajvErrors: "It is default now."
            };
            var deprecatedOptions = {
                ignoreKeywordsWithRef: "",
                jsPropertySyntax: "",
                unicode: '"minLength"/"maxLength" account for unicode characters by default.'
            };
            var MAX_EXPRESSION = 200;
            // eslint-disable-next-line complexity
            function requiredOptions(o) {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
                var s = o.strict;
                var _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
                var optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
                var regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
                var uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1["default"];
                return {
                    strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
                    strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
                    strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
                    strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
                    strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
                    code: o.code ? __assign(__assign({}, o.code), { optimize: optimize, regExp: regExp }) : { optimize: optimize, regExp: regExp },
                    loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
                    loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
                    meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
                    messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
                    inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
                    schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
                    addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
                    validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
                    validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
                    unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
                    int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
                    uriResolver: uriResolver
                };
            }
            var Ajv = /** @class */ (function () {
                function Ajv(opts) {
                    if (opts === void 0) { opts = {}; }
                    this.schemas = {};
                    this.refs = {};
                    this.formats = {};
                    this._compilations = new Set();
                    this._loading = {};
                    this._cache = new Map();
                    opts = this.opts = __assign(__assign({}, opts), requiredOptions(opts));
                    var _1 = this.opts.code, es5 = _1.es5, lines = _1.lines;
                    this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5: es5, lines: lines });
                    this.logger = getLogger(opts.logger);
                    var formatOpt = opts.validateFormats;
                    opts.validateFormats = false;
                    this.RULES = (0, rules_1.getRules)();
                    checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
                    checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
                    this._metaOpts = getMetaSchemaOptions.call(this);
                    if (opts.formats)
                        addInitialFormats.call(this);
                    this._addVocabularies();
                    this._addDefaultMetaSchema();
                    if (opts.keywords)
                        addInitialKeywords.call(this, opts.keywords);
                    if (typeof opts.meta == "object")
                        this.addMetaSchema(opts.meta);
                    addInitialSchemas.call(this);
                    opts.validateFormats = formatOpt;
                }
                Ajv.prototype._addVocabularies = function () {
                    this.addKeyword("$async");
                };
                Ajv.prototype._addDefaultMetaSchema = function () {
                    var _1 = this.opts, $data = _1.$data, meta = _1.meta, schemaId = _1.schemaId;
                    var _dataRefSchema = $dataRefSchema;
                    if (schemaId === "id") {
                        _dataRefSchema = __assign({}, $dataRefSchema);
                        _dataRefSchema.id = _dataRefSchema.$id;
                        delete _dataRefSchema.$id;
                    }
                    if (meta && $data)
                        this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
                };
                Ajv.prototype.defaultMeta = function () {
                    var _1 = this.opts, meta = _1.meta, schemaId = _1.schemaId;
                    return (this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : undefined);
                };
                Ajv.prototype.validate = function (schemaKeyRef, // key, ref or schema object
                data // to be validated
                ) {
                    var v;
                    if (typeof schemaKeyRef == "string") {
                        v = this.getSchema(schemaKeyRef);
                        if (!v)
                            throw new Error("no schema with key or ref \"".concat(schemaKeyRef, "\""));
                    }
                    else {
                        v = this.compile(schemaKeyRef);
                    }
                    var valid = v(data);
                    if (!("$async" in v))
                        this.errors = v.errors;
                    return valid;
                };
                Ajv.prototype.compile = function (schema, _meta) {
                    var sch = this._addSchema(schema, _meta);
                    return (sch.validate || this._compileSchemaEnv(sch));
                };
                Ajv.prototype.compileAsync = function (schema, meta) {
                    if (typeof this.opts.loadSchema != "function") {
                        throw new Error("options.loadSchema should be a function");
                    }
                    var loadSchema = this.opts.loadSchema;
                    return runCompileAsync.call(this, schema, meta);
                    function runCompileAsync(_schema, _meta) {
                        return __awaiter(this, void 0, void 0, function () {
                            var sch;
                            return __generator(this, function (_1) {
                                switch (_1.label) {
                                    case 0: return [4 /*yield*/, loadMetaSchema.call(this, _schema.$schema)];
                                    case 1:
                                        _1.sent();
                                        sch = this._addSchema(_schema, _meta);
                                        return [2 /*return*/, sch.validate || _compileAsync.call(this, sch)];
                                }
                            });
                        });
                    }
                    function loadMetaSchema($ref) {
                        return __awaiter(this, void 0, void 0, function () {
                            return __generator(this, function (_1) {
                                switch (_1.label) {
                                    case 0:
                                        if (!($ref && !this.getSchema($ref))) return [3 /*break*/, 2];
                                        return [4 /*yield*/, runCompileAsync.call(this, { $ref: $ref }, true)];
                                    case 1:
                                        _1.sent();
                                        _1.label = 2;
                                    case 2: return [2 /*return*/];
                                }
                            });
                        });
                    }
                    function _compileAsync(sch) {
                        return __awaiter(this, void 0, void 0, function () {
                            var e_1;
                            return __generator(this, function (_1) {
                                switch (_1.label) {
                                    case 0:
                                        _1.trys.push([0, 1, , 3]);
                                        return [2 /*return*/, this._compileSchemaEnv(sch)];
                                    case 1:
                                        e_1 = _1.sent();
                                        if (!(e_1 instanceof ref_error_1["default"]))
                                            throw e_1;
                                        checkLoaded.call(this, e_1);
                                        return [4 /*yield*/, loadMissingSchema.call(this, e_1.missingSchema)];
                                    case 2:
                                        _1.sent();
                                        return [2 /*return*/, _compileAsync.call(this, sch)];
                                    case 3: return [2 /*return*/];
                                }
                            });
                        });
                    }
                    function checkLoaded(_1) {
                        var ref = _1.missingSchema, missingRef = _1.missingRef;
                        if (this.refs[ref]) {
                            throw new Error("AnySchema ".concat(ref, " is loaded but ").concat(missingRef, " cannot be resolved"));
                        }
                    }
                    function loadMissingSchema(ref) {
                        return __awaiter(this, void 0, void 0, function () {
                            var _schema;
                            return __generator(this, function (_1) {
                                switch (_1.label) {
                                    case 0: return [4 /*yield*/, _loadSchema.call(this, ref)];
                                    case 1:
                                        _schema = _1.sent();
                                        if (!!this.refs[ref]) return [3 /*break*/, 3];
                                        return [4 /*yield*/, loadMetaSchema.call(this, _schema.$schema)];
                                    case 2:
                                        _1.sent();
                                        _1.label = 3;
                                    case 3:
                                        if (!this.refs[ref])
                                            this.addSchema(_schema, ref, meta);
                                        return [2 /*return*/];
                                }
                            });
                        });
                    }
                    function _loadSchema(ref) {
                        return __awaiter(this, void 0, void 0, function () {
                            var p;
                            return __generator(this, function (_1) {
                                switch (_1.label) {
                                    case 0:
                                        p = this._loading[ref];
                                        if (p)
                                            return [2 /*return*/, p];
                                        _1.label = 1;
                                    case 1:
                                        _1.trys.push([1, , 3, 4]);
                                        return [4 /*yield*/, (this._loading[ref] = loadSchema(ref))];
                                    case 2: return [2 /*return*/, _1.sent()];
                                    case 3:
                                        delete this._loading[ref];
                                        return [7 /*endfinally*/];
                                    case 4: return [2 /*return*/];
                                }
                            });
                        });
                    }
                };
                // Adds schema to the instance
                Ajv.prototype.addSchema = function (schema, // If array is passed, `key` will be ignored
                key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
                _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
                _validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.
                ) {
                    if (_validateSchema === void 0) { _validateSchema = this.opts.validateSchema; }
                    if (Array.isArray(schema)) {
                        for (var _1 = 0, schema_1 = schema; _1 < schema_1.length; _1++) {
                            var sch = schema_1[_1];
                            this.addSchema(sch, undefined, _meta, _validateSchema);
                        }
                        return this;
                    }
                    var id;
                    if (typeof schema === "object") {
                        var schemaId = this.opts.schemaId;
                        id = schema[schemaId];
                        if (id !== undefined && typeof id != "string") {
                            throw new Error("schema ".concat(schemaId, " must be string"));
                        }
                    }
                    key = (0, resolve_1.normalizeId)(key || id);
                    this._checkUnique(key);
                    this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
                    return this;
                };
                // Add schema that will be used to validate other schemas
                // options in META_IGNORE_OPTIONS are alway set to false
                Ajv.prototype.addMetaSchema = function (schema, key, // schema key
                _validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema
                ) {
                    if (_validateSchema === void 0) { _validateSchema = this.opts.validateSchema; }
                    this.addSchema(schema, key, true, _validateSchema);
                    return this;
                };
                //  Validate schema against its meta-schema
                Ajv.prototype.validateSchema = function (schema, throwOrLogError) {
                    if (typeof schema == "boolean")
                        return true;
                    var $schema;
                    $schema = schema.$schema;
                    if ($schema !== undefined && typeof $schema != "string") {
                        throw new Error("$schema must be a string");
                    }
                    $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
                    if (!$schema) {
                        this.logger.warn("meta-schema not available");
                        this.errors = null;
                        return true;
                    }
                    var valid = this.validate($schema, schema);
                    if (!valid && throwOrLogError) {
                        var message = "schema is invalid: " + this.errorsText();
                        if (this.opts.validateSchema === "log")
                            this.logger.error(message);
                        else
                            throw new Error(message);
                    }
                    return valid;
                };
                // Get compiled schema by `key` or `ref`.
                // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
                Ajv.prototype.getSchema = function (keyRef) {
                    var sch;
                    while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
                        keyRef = sch;
                    if (sch === undefined) {
                        var schemaId = this.opts.schemaId;
                        var root = new compile_1.SchemaEnv({ schema: {}, schemaId: schemaId });
                        sch = compile_1.resolveSchema.call(this, root, keyRef);
                        if (!sch)
                            return;
                        this.refs[keyRef] = sch;
                    }
                    return (sch.validate || this._compileSchemaEnv(sch));
                };
                // Remove cached schema(s).
                // If no parameter is passed all schemas but meta-schemas are removed.
                // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
                // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
                Ajv.prototype.removeSchema = function (schemaKeyRef) {
                    if (schemaKeyRef instanceof RegExp) {
                        this._removeAllSchemas(this.schemas, schemaKeyRef);
                        this._removeAllSchemas(this.refs, schemaKeyRef);
                        return this;
                    }
                    switch (typeof schemaKeyRef) {
                        case "undefined":
                            this._removeAllSchemas(this.schemas);
                            this._removeAllSchemas(this.refs);
                            this._cache.clear();
                            return this;
                        case "string": {
                            var sch = getSchEnv.call(this, schemaKeyRef);
                            if (typeof sch == "object")
                                this._cache["delete"](sch.schema);
                            delete this.schemas[schemaKeyRef];
                            delete this.refs[schemaKeyRef];
                            return this;
                        }
                        case "object": {
                            var cacheKey = schemaKeyRef;
                            this._cache["delete"](cacheKey);
                            var id = schemaKeyRef[this.opts.schemaId];
                            if (id) {
                                id = (0, resolve_1.normalizeId)(id);
                                delete this.schemas[id];
                                delete this.refs[id];
                            }
                            return this;
                        }
                        default:
                            throw new Error("ajv.removeSchema: invalid parameter");
                    }
                };
                // add "vocabulary" - a collection of keywords
                Ajv.prototype.addVocabulary = function (definitions) {
                    for (var _1 = 0, definitions_1 = definitions; _1 < definitions_1.length; _1++) {
                        var def = definitions_1[_1];
                        this.addKeyword(def);
                    }
                    return this;
                };
                Ajv.prototype.addKeyword = function (kwdOrDef, def // deprecated
                ) {
                    var _this_1 = this;
                    var keyword;
                    if (typeof kwdOrDef == "string") {
                        keyword = kwdOrDef;
                        if (typeof def == "object") {
                            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
                            def.keyword = keyword;
                        }
                    }
                    else if (typeof kwdOrDef == "object" && def === undefined) {
                        def = kwdOrDef;
                        keyword = def.keyword;
                        if (Array.isArray(keyword) && !keyword.length) {
                            throw new Error("addKeywords: keyword must be string or non-empty array");
                        }
                    }
                    else {
                        throw new Error("invalid addKeywords parameters");
                    }
                    checkKeyword.call(this, keyword, def);
                    if (!def) {
                        (0, util_1.eachItem)(keyword, function (kwd) { return addRule.call(_this_1, kwd); });
                        return this;
                    }
                    keywordMetaschema.call(this, def);
                    var definition = __assign(__assign({}, def), { type: (0, dataType_1.getJSONTypes)(def.type), schemaType: (0, dataType_1.getJSONTypes)(def.schemaType) });
                    (0, util_1.eachItem)(keyword, definition.type.length === 0
                        ? function (k) { return addRule.call(_this_1, k, definition); }
                        : function (k) { return definition.type.forEach(function (t) { return addRule.call(_this_1, k, definition, t); }); });
                    return this;
                };
                Ajv.prototype.getKeyword = function (keyword) {
                    var rule = this.RULES.all[keyword];
                    return typeof rule == "object" ? rule.definition : !!rule;
                };
                // Remove keyword
                Ajv.prototype.removeKeyword = function (keyword) {
                    // TODO return type should be Ajv
                    var RULES = this.RULES;
                    delete RULES.keywords[keyword];
                    delete RULES.all[keyword];
                    for (var _1 = 0, _2 = RULES.rules; _1 < _2.length; _1++) {
                        var group = _2[_1];
                        var i = group.rules.findIndex(function (rule) { return rule.keyword === keyword; });
                        if (i >= 0)
                            group.rules.splice(i, 1);
                    }
                    return this;
                };
                // Add format
                Ajv.prototype.addFormat = function (name, format) {
                    if (typeof format == "string")
                        format = new RegExp(format);
                    this.formats[name] = format;
                    return this;
                };
                Ajv.prototype.errorsText = function (errors, // optional array of validation errors
                _1 // optional options with properties `separator` and `dataVar`
                ) {
                    if (errors === void 0) { errors = this.errors; }
                    var // optional array of validation errors
                    _2 = _1 === void 0 ? {} : _1 // optional options with properties `separator` and `dataVar`
                    , _3 = _2.separator, separator = _3 === void 0 ? ", " : _3, _4 = _2.dataVar, dataVar = _4 === void 0 ? "data" : _4;
                    if (!errors || errors.length === 0)
                        return "No errors";
                    return errors
                        .map(function (e) { return "".concat(dataVar).concat(e.instancePath, " ").concat(e.message); })
                        .reduce(function (text, msg) { return text + separator + msg; });
                };
                Ajv.prototype.$dataMetaSchema = function (metaSchema, keywordsJsonPointers) {
                    var rules = this.RULES.all;
                    metaSchema = JSON.parse(JSON.stringify(metaSchema));
                    for (var _1 = 0, keywordsJsonPointers_1 = keywordsJsonPointers; _1 < keywordsJsonPointers_1.length; _1++) {
                        var jsonPointer = keywordsJsonPointers_1[_1];
                        var segments = jsonPointer.split("/").slice(1); // first segment is an empty string
                        var keywords = metaSchema;
                        for (var _2 = 0, segments_2 = segments; _2 < segments_2.length; _2++) {
                            var seg = segments_2[_2];
                            keywords = keywords[seg];
                        }
                        for (var key in rules) {
                            var rule = rules[key];
                            if (typeof rule != "object")
                                continue;
                            var $data = rule.definition.$data;
                            var schema = keywords[key];
                            if ($data && schema)
                                keywords[key] = schemaOrData(schema);
                        }
                    }
                    return metaSchema;
                };
                Ajv.prototype._removeAllSchemas = function (schemas, regex) {
                    for (var keyRef in schemas) {
                        var sch = schemas[keyRef];
                        if (!regex || regex.test(keyRef)) {
                            if (typeof sch == "string") {
                                delete schemas[keyRef];
                            }
                            else if (sch && !sch.meta) {
                                this._cache["delete"](sch.schema);
                                delete schemas[keyRef];
                            }
                        }
                    }
                };
                Ajv.prototype._addSchema = function (schema, meta, baseId, validateSchema, addSchema) {
                    if (validateSchema === void 0) { validateSchema = this.opts.validateSchema; }
                    if (addSchema === void 0) { addSchema = this.opts.addUsedSchema; }
                    var id;
                    var schemaId = this.opts.schemaId;
                    if (typeof schema == "object") {
                        id = schema[schemaId];
                    }
                    else {
                        if (this.opts.jtd)
                            throw new Error("schema must be object");
                        else if (typeof schema != "boolean")
                            throw new Error("schema must be object or boolean");
                    }
                    var sch = this._cache.get(schema);
                    if (sch !== undefined)
                        return sch;
                    baseId = (0, resolve_1.normalizeId)(id || baseId);
                    var localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
                    sch = new compile_1.SchemaEnv({ schema: schema, schemaId: schemaId, meta: meta, baseId: baseId, localRefs: localRefs });
                    this._cache.set(sch.schema, sch);
                    if (addSchema && !baseId.startsWith("#")) {
                        // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)
                        if (baseId)
                            this._checkUnique(baseId);
                        this.refs[baseId] = sch;
                    }
                    if (validateSchema)
                        this.validateSchema(schema, true);
                    return sch;
                };
                Ajv.prototype._checkUnique = function (id) {
                    if (this.schemas[id] || this.refs[id]) {
                        throw new Error("schema with key or id \"".concat(id, "\" already exists"));
                    }
                };
                Ajv.prototype._compileSchemaEnv = function (sch) {
                    if (sch.meta)
                        this._compileMetaSchema(sch);
                    else
                        compile_1.compileSchema.call(this, sch);
                    /* istanbul ignore if */
                    if (!sch.validate)
                        throw new Error("ajv implementation error");
                    return sch.validate;
                };
                Ajv.prototype._compileMetaSchema = function (sch) {
                    var currentOpts = this.opts;
                    this.opts = this._metaOpts;
                    try {
                        compile_1.compileSchema.call(this, sch);
                    }
                    finally {
                        this.opts = currentOpts;
                    }
                };
                return Ajv;
            }());
            exports["default"] = Ajv;
            Ajv.ValidationError = validation_error_1["default"];
            Ajv.MissingRefError = ref_error_1["default"];
            function checkOptions(checkOpts, options, msg, log) {
                if (log === void 0) { log = "error"; }
                for (var key in checkOpts) {
                    var opt = key;
                    if (opt in options)
                        this.logger[log]("".concat(msg, ": option ").concat(key, ". ").concat(checkOpts[opt]));
                }
            }
            function getSchEnv(keyRef) {
                keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line
                return this.schemas[keyRef] || this.refs[keyRef];
            }
            function addInitialSchemas() {
                var optsSchemas = this.opts.schemas;
                if (!optsSchemas)
                    return;
                if (Array.isArray(optsSchemas))
                    this.addSchema(optsSchemas);
                else
                    for (var key in optsSchemas)
                        this.addSchema(optsSchemas[key], key);
            }
            function addInitialFormats() {
                for (var name_3 in this.opts.formats) {
                    var format = this.opts.formats[name_3];
                    if (format)
                        this.addFormat(name_3, format);
                }
            }
            function addInitialKeywords(defs) {
                if (Array.isArray(defs)) {
                    this.addVocabulary(defs);
                    return;
                }
                this.logger.warn("keywords option as map is deprecated, pass array");
                for (var keyword in defs) {
                    var def = defs[keyword];
                    if (!def.keyword)
                        def.keyword = keyword;
                    this.addKeyword(def);
                }
            }
            function getMetaSchemaOptions() {
                var metaOpts = __assign({}, this.opts);
                for (var _1 = 0, META_IGNORE_OPTIONS_1 = META_IGNORE_OPTIONS; _1 < META_IGNORE_OPTIONS_1.length; _1++) {
                    var opt = META_IGNORE_OPTIONS_1[_1];
                    delete metaOpts[opt];
                }
                return metaOpts;
            }
            var noLogs = { log: function () { }, warn: function () { }, error: function () { } };
            function getLogger(logger) {
                if (logger === false)
                    return noLogs;
                if (logger === undefined)
                    return console;
                if (logger.log && logger.warn && logger.error)
                    return logger;
                throw new Error("logger must implement log, warn and error methods");
            }
            var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
            function checkKeyword(keyword, def) {
                var RULES = this.RULES;
                (0, util_1.eachItem)(keyword, function (kwd) {
                    if (RULES.keywords[kwd])
                        throw new Error("Keyword ".concat(kwd, " is already defined"));
                    if (!KEYWORD_NAME.test(kwd))
                        throw new Error("Keyword ".concat(kwd, " has invalid name"));
                });
                if (!def)
                    return;
                if (def.$data && !("code" in def || "validate" in def)) {
                    throw new Error('$data keyword must have "code" or "validate" function');
                }
            }
            function addRule(keyword, definition, dataType) {
                var _this_1 = this;
                var _a;
                var post = definition === null || definition === void 0 ? void 0 : definition.post;
                if (dataType && post)
                    throw new Error('keyword with "post" flag cannot have "type"');
                var RULES = this.RULES;
                var ruleGroup = post ? RULES.post : RULES.rules.find(function (_1) {
                    var t = _1.type;
                    return t === dataType;
                });
                if (!ruleGroup) {
                    ruleGroup = { type: dataType, rules: [] };
                    RULES.rules.push(ruleGroup);
                }
                RULES.keywords[keyword] = true;
                if (!definition)
                    return;
                var rule = {
                    keyword: keyword,
                    definition: __assign(__assign({}, definition), { type: (0, dataType_1.getJSONTypes)(definition.type), schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType) })
                };
                if (definition.before)
                    addBeforeRule.call(this, ruleGroup, rule, definition.before);
                else
                    ruleGroup.rules.push(rule);
                RULES.all[keyword] = rule;
                (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach(function (kwd) { return _this_1.addKeyword(kwd); });
            }
            function addBeforeRule(ruleGroup, rule, before) {
                var i = ruleGroup.rules.findIndex(function (_rule) { return _rule.keyword === before; });
                if (i >= 0) {
                    ruleGroup.rules.splice(i, 0, rule);
                }
                else {
                    ruleGroup.rules.push(rule);
                    this.logger.warn("rule ".concat(before, " is not defined"));
                }
            }
            function keywordMetaschema(def) {
                var metaSchema = def.metaSchema;
                if (metaSchema === undefined)
                    return;
                if (def.$data && this.opts.$data)
                    metaSchema = schemaOrData(metaSchema);
                def.validateSchema = this.compile(metaSchema, true);
            }
            var $dataRef = {
                $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
            };
            function schemaOrData(schema) {
                return { anyOf: [schema, $dataRef] };
            }
            //# sourceMappingURL=core.js.map
            /***/ 
        }),
        /***/ 3809: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            // https://github.com/ajv-validator/ajv/issues/889
            var equal = __nccwpck_require__(8206);
            equal.code = 'require("ajv/dist/runtime/equal").default';
            exports["default"] = equal;
            //# sourceMappingURL=equal.js.map
            /***/ 
        }),
        /***/ 2470: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            // https://mathiasbynens.be/notes/javascript-encoding
            // https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
            function ucs2length(str) {
                var len = str.length;
                var length = 0;
                var pos = 0;
                var value;
                while (pos < len) {
                    length++;
                    value = str.charCodeAt(pos++);
                    if (value >= 0xd800 && value <= 0xdbff && pos < len) {
                        // high surrogate, and there is a next character
                        value = str.charCodeAt(pos);
                        if ((value & 0xfc00) === 0xdc00)
                            pos++; // low surrogate
                    }
                }
                return length;
            }
            exports["default"] = ucs2length;
            ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
            //# sourceMappingURL=ucs2length.js.map
            /***/ 
        }),
        /***/ 661: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var uri = __nccwpck_require__(20);
            uri.code = 'require("ajv/dist/runtime/uri").default';
            exports["default"] = uri;
            //# sourceMappingURL=uri.js.map
            /***/ 
        }),
        /***/ 7616: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var ValidationError = /** @class */ (function (_super) {
                __extends(ValidationError, _super);
                function ValidationError(errors) {
                    var _this_1 = _super.call(this, "validation failed") || this;
                    _this_1.errors = errors;
                    _this_1.ajv = _this_1.validation = true;
                    return _this_1;
                }
                return ValidationError;
            }(Error));
            exports["default"] = ValidationError;
            //# sourceMappingURL=validation_error.js.map
            /***/ 
        }),
        /***/ 4720: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.validateAdditionalItems = void 0;
            var codegen_1 = __nccwpck_require__(9179);
            var util_1 = __nccwpck_require__(3439);
            var error = {
                message: function (_1) {
                    var len = _1.params.len;
                    return (0, codegen_1.str)(__makeTemplateObject(["must NOT have more than ", " items"], ["must NOT have more than ", " items"]), len);
                },
                params: function (_1) {
                    var len = _1.params.len;
                    return (0, codegen_1._)(__makeTemplateObject(["{limit: ", "}"], ["{limit: ", "}"]), len);
                }
            };
            var def = {
                keyword: "additionalItems",
                type: "array",
                schemaType: ["boolean", "object"],
                before: "uniqueItems",
                error: error,
                code: function (cxt) {
                    var parentSchema = cxt.parentSchema, it = cxt.it;
                    var items = parentSchema.items;
                    if (!Array.isArray(items)) {
                        (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
                        return;
                    }
                    validateAdditionalItems(cxt, items);
                }
            };
            function validateAdditionalItems(cxt, items) {
                var gen = cxt.gen, schema = cxt.schema, data = cxt.data, keyword = cxt.keyword, it = cxt.it;
                it.items = true;
                var len = gen["const"]("len", (0, codegen_1._)(__makeTemplateObject(["", ".length"], ["", ".length"]), data));
                if (schema === false) {
                    cxt.setParams({ len: items.length });
                    cxt.pass((0, codegen_1._)(__makeTemplateObject(["", " <= ", ""], ["", " <= ", ""]), len, items.length));
                }
                else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
                    var valid_1 = gen["var"]("valid", (0, codegen_1._)(__makeTemplateObject(["", " <= ", ""], ["", " <= ", ""]), len, items.length)); // TODO var
                    gen["if"]((0, codegen_1.not)(valid_1), function () { return validateItems(valid_1); });
                    cxt.ok(valid_1);
                }
                function validateItems(valid) {
                    gen.forRange("i", items.length, len, function (i) {
                        cxt.subschema({ keyword: keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
                        if (!it.allErrors)
                            gen["if"]((0, codegen_1.not)(valid), function () { return gen["break"](); });
                    });
                }
            }
            exports.validateAdditionalItems = validateAdditionalItems;
            exports["default"] = def;
            //# sourceMappingURL=additionalItems.js.map
            /***/ 
        }),
        /***/ 3481: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var code_1 = __nccwpck_require__(4205);
            var codegen_1 = __nccwpck_require__(9179);
            var names_1 = __nccwpck_require__(50);
            var util_1 = __nccwpck_require__(3439);
            var error = {
                message: "must NOT have additional properties",
                params: function (_1) {
                    var params = _1.params;
                    return (0, codegen_1._)(__makeTemplateObject(["{additionalProperty: ", "}"], ["{additionalProperty: ", "}"]), params.additionalProperty);
                }
            };
            var def = {
                keyword: "additionalProperties",
                type: ["object"],
                schemaType: ["boolean", "object"],
                allowUndefined: true,
                trackErrors: true,
                error: error,
                code: function (cxt) {
                    var gen = cxt.gen, schema = cxt.schema, parentSchema = cxt.parentSchema, data = cxt.data, errsCount = cxt.errsCount, it = cxt.it;
                    /* istanbul ignore if */
                    if (!errsCount)
                        throw new Error("ajv implementation error");
                    var allErrors = it.allErrors, opts = it.opts;
                    it.props = true;
                    if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
                        return;
                    var props = (0, code_1.allSchemaProperties)(parentSchema.properties);
                    var patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
                    checkAdditionalProperties();
                    cxt.ok((0, codegen_1._)(__makeTemplateObject(["", " === ", ""], ["", " === ", ""]), errsCount, names_1["default"].errors));
                    function checkAdditionalProperties() {
                        gen.forIn("key", data, function (key) {
                            if (!props.length && !patProps.length)
                                additionalPropertyCode(key);
                            else
                                gen["if"](isAdditional(key), function () { return additionalPropertyCode(key); });
                        });
                    }
                    function isAdditional(key) {
                        var definedProp;
                        if (props.length > 8) {
                            // TODO maybe an option instead of hard-coded 8?
                            var propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
                            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
                        }
                        else if (props.length) {
                            definedProp = (0, codegen_1.or).apply(void 0, props.map(function (p) { return (0, codegen_1._)(__makeTemplateObject(["", " === ", ""], ["", " === ", ""]), key, p); }));
                        }
                        else {
                            definedProp = codegen_1.nil;
                        }
                        if (patProps.length) {
                            definedProp = (0, codegen_1.or).apply(void 0, __spreadArray([definedProp], patProps.map(function (p) { return (0, codegen_1._)(__makeTemplateObject(["", ".test(", ")"], ["", ".test(", ")"]), (0, code_1.usePattern)(cxt, p), key); }), false));
                        }
                        return (0, codegen_1.not)(definedProp);
                    }
                    function deleteAdditional(key) {
                        gen.code((0, codegen_1._)(__makeTemplateObject(["delete ", "[", "]"], ["delete ", "[", "]"]), data, key));
                    }
                    function additionalPropertyCode(key) {
                        if (opts.removeAdditional === "all" || (opts.removeAdditional && schema === false)) {
                            deleteAdditional(key);
                            return;
                        }
                        if (schema === false) {
                            cxt.setParams({ additionalProperty: key });
                            cxt.error();
                            if (!allErrors)
                                gen["break"]();
                            return;
                        }
                        if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
                            var valid = gen.name("valid");
                            if (opts.removeAdditional === "failing") {
                                applyAdditionalSchema(key, valid, false);
                                gen["if"]((0, codegen_1.not)(valid), function () {
                                    cxt.reset();
                                    deleteAdditional(key);
                                });
                            }
                            else {
                                applyAdditionalSchema(key, valid);
                                if (!allErrors)
                                    gen["if"]((0, codegen_1.not)(valid), function () { return gen["break"](); });
                            }
                        }
                    }
                    function applyAdditionalSchema(key, valid, errors) {
                        var subschema = {
                            keyword: "additionalProperties",
                            dataProp: key,
                            dataPropType: util_1.Type.Str
                        };
                        if (errors === false) {
                            Object.assign(subschema, {
                                compositeRule: true,
                                createErrors: false,
                                allErrors: false
                            });
                        }
                        cxt.subschema(subschema, valid);
                    }
                }
            };
            exports["default"] = def;
            //# sourceMappingURL=additionalProperties.js.map
            /***/ 
        }),
        /***/ 8406: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var util_1 = __nccwpck_require__(3439);
            var def = {
                keyword: "allOf",
                schemaType: "array",
                code: function (cxt) {
                    var gen = cxt.gen, schema = cxt.schema, it = cxt.it;
                    /* istanbul ignore if */
                    if (!Array.isArray(schema))
                        throw new Error("ajv implementation error");
                    var valid = gen.name("valid");
                    schema.forEach(function (sch, i) {
                        if ((0, util_1.alwaysValidSchema)(it, sch))
                            return;
                        var schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
                        cxt.ok(valid);
                        cxt.mergeEvaluated(schCxt);
                    });
                }
            };
            exports["default"] = def;
            //# sourceMappingURL=allOf.js.map
            /***/ 
        }),
        /***/ 8168: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var code_1 = __nccwpck_require__(4205);
            var def = {
                keyword: "anyOf",
                schemaType: "array",
                trackErrors: true,
                code: code_1.validateUnion,
                error: { message: "must match a schema in anyOf" }
            };
            exports["default"] = def;
            //# sourceMappingURL=anyOf.js.map
            /***/ 
        }),
        /***/ 9535: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var codegen_1 = __nccwpck_require__(9179);
            var util_1 = __nccwpck_require__(3439);
            var error = {
                message: function (_1) {
                    var _2 = _1.params, min = _2.min, max = _2.max;
                    return max === undefined
                        ? (0, codegen_1.str)(__makeTemplateObject(["must contain at least ", " valid item(s)"], ["must contain at least ", " valid item(s)"]), min) : (0, codegen_1.str)(__makeTemplateObject(["must contain at least ", " and no more than ", " valid item(s)"], ["must contain at least ", " and no more than ", " valid item(s)"]), min, max);
                },
                params: function (_1) {
                    var _2 = _1.params, min = _2.min, max = _2.max;
                    return max === undefined ? (0, codegen_1._)(__makeTemplateObject(["{minContains: ", "}"], ["{minContains: ", "}"]), min) : (0, codegen_1._)(__makeTemplateObject(["{minContains: ", ", maxContains: ", "}"], ["{minContains: ", ", maxContains: ", "}"]), min, max);
                }
            };
            var def = {
                keyword: "contains",
                type: "array",
                schemaType: ["object", "boolean"],
                before: "uniqueItems",
                trackErrors: true,
                error: error,
                code: function (cxt) {
                    var gen = cxt.gen, schema = cxt.schema, parentSchema = cxt.parentSchema, data = cxt.data, it = cxt.it;
                    var min;
                    var max;
                    var minContains = parentSchema.minContains, maxContains = parentSchema.maxContains;
                    if (it.opts.next) {
                        min = minContains === undefined ? 1 : minContains;
                        max = maxContains;
                    }
                    else {
                        min = 1;
                    }
                    var len = gen["const"]("len", (0, codegen_1._)(__makeTemplateObject(["", ".length"], ["", ".length"]), data));
                    cxt.setParams({ min: min, max: max });
                    if (max === undefined && min === 0) {
                        (0, util_1.checkStrictMode)(it, "\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored");
                        return;
                    }
                    if (max !== undefined && min > max) {
                        (0, util_1.checkStrictMode)(it, "\"minContains\" > \"maxContains\" is always invalid");
                        cxt.fail();
                        return;
                    }
                    if ((0, util_1.alwaysValidSchema)(it, schema)) {
                        var cond = (0, codegen_1._)(__makeTemplateObject(["", " >= ", ""], ["", " >= ", ""]), len, min);
                        if (max !== undefined)
                            cond = (0, codegen_1._)(__makeTemplateObject(["", " && ", " <= ", ""], ["", " && ", " <= ", ""]), cond, len, max);
                        cxt.pass(cond);
                        return;
                    }
                    it.items = true;
                    var valid = gen.name("valid");
                    if (max === undefined && min === 1) {
                        validateItems(valid, function () { return gen["if"](valid, function () { return gen["break"](); }); });
                    }
                    else if (min === 0) {
                        gen.let(valid, true);
                        if (max !== undefined)
                            gen["if"]((0, codegen_1._)(__makeTemplateObject(["", ".length > 0"], ["", ".length > 0"]), data), validateItemsWithCount);
                    }
                    else {
                        gen.let(valid, false);
                        validateItemsWithCount();
                    }
                    cxt.result(valid, function () { return cxt.reset(); });
                    function validateItemsWithCount() {
                        var schValid = gen.name("_valid");
                        var count = gen.let("count", 0);
                        validateItems(schValid, function () { return gen["if"](schValid, function () { return checkLimits(count); }); });
                    }
                    function validateItems(_valid, block) {
                        gen.forRange("i", 0, len, function (i) {
                            cxt.subschema({
                                keyword: "contains",
                                dataProp: i,
                                dataPropType: util_1.Type.Num,
                                compositeRule: true
                            }, _valid);
                            block();
                        });
                    }
                    function checkLimits(count) {
                        gen.code((0, codegen_1._)(__makeTemplateObject(["", "++"], ["", "++"]), count));
                        if (max === undefined) {
                            gen["if"]((0, codegen_1._)(__makeTemplateObject(["", " >= ", ""], ["", " >= ", ""]), count, min), function () { return gen.assign(valid, true)["break"](); });
                        }
                        else {
                            gen["if"]((0, codegen_1._)(__makeTemplateObject(["", " > ", ""], ["", " > ", ""]), count, max), function () { return gen.assign(valid, false)["break"](); });
                            if (min === 1)
                                gen.assign(valid, true);
                            else
                                gen["if"]((0, codegen_1._)(__makeTemplateObject(["", " >= ", ""], ["", " >= ", ""]), count, min), function () { return gen.assign(valid, true); });
                        }
                    }
                }
            };
            exports["default"] = def;
            //# sourceMappingURL=contains.js.map
            /***/ 
        }),
        /***/ 4611: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
            var codegen_1 = __nccwpck_require__(9179);
            var util_1 = __nccwpck_require__(3439);
            var code_1 = __nccwpck_require__(4205);
            exports.error = {
                message: function (_1) {
                    var _2 = _1.params, property = _2.property, depsCount = _2.depsCount, deps = _2.deps;
                    var property_ies = depsCount === 1 ? "property" : "properties";
                    return (0, codegen_1.str)(__makeTemplateObject(["must have ", " ", " when property ", " is present"], ["must have ", " ", " when property ", " is present"]), property_ies, deps, property);
                },
                params: function (_1) {
                    var _2 = _1.params, property = _2.property, depsCount = _2.depsCount, deps = _2.deps, missingProperty = _2.missingProperty;
                    return (0, codegen_1._)(__makeTemplateObject(["{property: ", ",\n    missingProperty: ", ",\n    depsCount: ", ",\n    deps: ", "}"], ["{property: ", ",\n    missingProperty: ", ",\n    depsCount: ", ",\n    deps: ", "}"]), property, missingProperty, depsCount, deps);
                }
            };
            var def = {
                keyword: "dependencies",
                type: "object",
                schemaType: "object",
                error: exports.error,
                code: function (cxt) {
                    var _1 = splitDependencies(cxt), propDeps = _1[0], schDeps = _1[1];
                    validatePropertyDeps(cxt, propDeps);
                    validateSchemaDeps(cxt, schDeps);
                }
            };
            function splitDependencies(_1) {
                var schema = _1.schema;
                var propertyDeps = {};
                var schemaDeps = {};
                for (var key in schema) {
                    if (key === "__proto__")
                        continue;
                    var deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
                    deps[key] = schema[key];
                }
                return [propertyDeps, schemaDeps];
            }
            function validatePropertyDeps(cxt, propertyDeps) {
                if (propertyDeps === void 0) { propertyDeps = cxt.schema; }
                var gen = cxt.gen, data = cxt.data, it = cxt.it;
                if (Object.keys(propertyDeps).length === 0)
                    return;
                var missing = gen.let("missing");
                var _loop_6 = function (prop) {
                    var deps = propertyDeps[prop];
                    if (deps.length === 0)
                        return "continue";
                    var hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
                    cxt.setParams({
                        property: prop,
                        depsCount: deps.length,
                        deps: deps.join(", ")
                    });
                    if (it.allErrors) {
                        gen["if"](hasProperty, function () {
                            for (var _1 = 0, deps_1 = deps; _1 < deps_1.length; _1++) {
                                var depProp = deps_1[_1];
                                (0, code_1.checkReportMissingProp)(cxt, depProp);
                            }
                        });
                    }
                    else {
                        gen["if"]((0, codegen_1._)(__makeTemplateObject(["", " && (", ")"], ["", " && (", ")"]), hasProperty, (0, code_1.checkMissingProp)(cxt, deps, missing)));
                        (0, code_1.reportMissingProp)(cxt, missing);
                        gen["else"]();
                    }
                };
                for (var prop in propertyDeps) {
                    _loop_6(prop);
                }
            }
            exports.validatePropertyDeps = validatePropertyDeps;
            function validateSchemaDeps(cxt, schemaDeps) {
                if (schemaDeps === void 0) { schemaDeps = cxt.schema; }
                var gen = cxt.gen, data = cxt.data, keyword = cxt.keyword, it = cxt.it;
                var valid = gen.name("valid");
                var _loop_7 = function (prop) {
                    if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
                        return "continue";
                    gen["if"]((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), function () {
                        var schCxt = cxt.subschema({ keyword: keyword, schemaProp: prop }, valid);
                        cxt.mergeValidEvaluated(schCxt, valid);
                    }, function () { return gen["var"](valid, true); } // TODO var
                    );
                    cxt.ok(valid);
                };
                for (var prop in schemaDeps) {
                    _loop_7(prop);
                }
            }
            exports.validateSchemaDeps = validateSchemaDeps;
            exports["default"] = def;
            //# sourceMappingURL=dependencies.js.map
            /***/ 
        }),
        /***/ 7701: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var codegen_1 = __nccwpck_require__(9179);
            var util_1 = __nccwpck_require__(3439);
            var error = {
                message: function (_1) {
                    var params = _1.params;
                    return (0, codegen_1.str)(__makeTemplateObject(["must match \"", "\" schema"], ["must match \"", "\" schema"]), params.ifClause);
                },
                params: function (_1) {
                    var params = _1.params;
                    return (0, codegen_1._)(__makeTemplateObject(["{failingKeyword: ", "}"], ["{failingKeyword: ", "}"]), params.ifClause);
                }
            };
            var def = {
                keyword: "if",
                schemaType: ["object", "boolean"],
                trackErrors: true,
                error: error,
                code: function (cxt) {
                    var gen = cxt.gen, parentSchema = cxt.parentSchema, it = cxt.it;
                    if (parentSchema.then === undefined && parentSchema["else"] === undefined) {
                        (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
                    }
                    var hasThen = hasSchema(it, "then");
                    var hasElse = hasSchema(it, "else");
                    if (!hasThen && !hasElse)
                        return;
                    var valid = gen.let("valid", true);
                    var schValid = gen.name("_valid");
                    validateIf();
                    cxt.reset();
                    if (hasThen && hasElse) {
                        var ifClause = gen.let("ifClause");
                        cxt.setParams({ ifClause: ifClause });
                        gen["if"](schValid, validateClause("then", ifClause), validateClause("else", ifClause));
                    }
                    else if (hasThen) {
                        gen["if"](schValid, validateClause("then"));
                    }
                    else {
                        gen["if"]((0, codegen_1.not)(schValid), validateClause("else"));
                    }
                    cxt.pass(valid, function () { return cxt.error(true); });
                    function validateIf() {
                        var schCxt = cxt.subschema({
                            keyword: "if",
                            compositeRule: true,
                            createErrors: false,
                            allErrors: false
                        }, schValid);
                        cxt.mergeEvaluated(schCxt);
                    }
                    function validateClause(keyword, ifClause) {
                        return function () {
                            var schCxt = cxt.subschema({ keyword: keyword }, schValid);
                            gen.assign(valid, schValid);
                            cxt.mergeValidEvaluated(schCxt, valid);
                            if (ifClause)
                                gen.assign(ifClause, (0, codegen_1._)(__makeTemplateObject(["", ""], ["", ""]), keyword));
                            else
                                cxt.setParams({ ifClause: keyword });
                        };
                    }
                }
            };
            function hasSchema(it, keyword) {
                var schema = it.schema[keyword];
                return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);
            }
            exports["default"] = def;
            //# sourceMappingURL=if.js.map
            /***/ 
        }),
        /***/ 3048: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var additionalItems_1 = __nccwpck_require__(4720);
            var prefixItems_1 = __nccwpck_require__(9498);
            var items_1 = __nccwpck_require__(8008);
            var items2020_1 = __nccwpck_require__(9084);
            var contains_1 = __nccwpck_require__(9535);
            var dependencies_1 = __nccwpck_require__(4611);
            var propertyNames_1 = __nccwpck_require__(2554);
            var additionalProperties_1 = __nccwpck_require__(3481);
            var properties_1 = __nccwpck_require__(7666);
            var patternProperties_1 = __nccwpck_require__(5157);
            var not_1 = __nccwpck_require__(8720);
            var anyOf_1 = __nccwpck_require__(8168);
            var oneOf_1 = __nccwpck_require__(6434);
            var allOf_1 = __nccwpck_require__(8406);
            var if_1 = __nccwpck_require__(7701);
            var thenElse_1 = __nccwpck_require__(7680);
            function getApplicator(draft2020) {
                if (draft2020 === void 0) { draft2020 = false; }
                var applicator = [
                    // any
                    not_1["default"],
                    anyOf_1["default"],
                    oneOf_1["default"],
                    allOf_1["default"],
                    if_1["default"],
                    thenElse_1["default"],
                    // object
                    propertyNames_1["default"],
                    additionalProperties_1["default"],
                    dependencies_1["default"],
                    properties_1["default"],
                    patternProperties_1["default"],
                ];
                // array
                if (draft2020)
                    applicator.push(prefixItems_1["default"], items2020_1["default"]);
                else
                    applicator.push(additionalItems_1["default"], items_1["default"]);
                applicator.push(contains_1["default"]);
                return applicator;
            }
            exports["default"] = getApplicator;
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 8008: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.validateTuple = void 0;
            var codegen_1 = __nccwpck_require__(9179);
            var util_1 = __nccwpck_require__(3439);
            var code_1 = __nccwpck_require__(4205);
            var def = {
                keyword: "items",
                type: "array",
                schemaType: ["object", "array", "boolean"],
                before: "uniqueItems",
                code: function (cxt) {
                    var schema = cxt.schema, it = cxt.it;
                    if (Array.isArray(schema))
                        return validateTuple(cxt, "additionalItems", schema);
                    it.items = true;
                    if ((0, util_1.alwaysValidSchema)(it, schema))
                        return;
                    cxt.ok((0, code_1.validateArray)(cxt));
                }
            };
            function validateTuple(cxt, extraItems, schArr) {
                if (schArr === void 0) { schArr = cxt.schema; }
                var gen = cxt.gen, parentSchema = cxt.parentSchema, data = cxt.data, keyword = cxt.keyword, it = cxt.it;
                checkStrictTuple(parentSchema);
                if (it.opts.unevaluated && schArr.length && it.items !== true) {
                    it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
                }
                var valid = gen.name("valid");
                var len = gen["const"]("len", (0, codegen_1._)(__makeTemplateObject(["", ".length"], ["", ".length"]), data));
                schArr.forEach(function (sch, i) {
                    if ((0, util_1.alwaysValidSchema)(it, sch))
                        return;
                    gen["if"]((0, codegen_1._)(__makeTemplateObject(["", " > ", ""], ["", " > ", ""]), len, i), function () { return cxt.subschema({
                        keyword: keyword,
                        schemaProp: i,
                        dataProp: i
                    }, valid); });
                    cxt.ok(valid);
                });
                function checkStrictTuple(sch) {
                    var opts = it.opts, errSchemaPath = it.errSchemaPath;
                    var l = schArr.length;
                    var fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
                    if (opts.strictTuples && !fullTuple) {
                        var msg = "\"".concat(keyword, "\" is ").concat(l, "-tuple, but minItems or maxItems/").concat(extraItems, " are not specified or different at path \"").concat(errSchemaPath, "\"");
                        (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
                    }
                }
            }
            exports.validateTuple = validateTuple;
            exports["default"] = def;
            //# sourceMappingURL=items.js.map
            /***/ 
        }),
        /***/ 9084: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var codegen_1 = __nccwpck_require__(9179);
            var util_1 = __nccwpck_require__(3439);
            var code_1 = __nccwpck_require__(4205);
            var additionalItems_1 = __nccwpck_require__(4720);
            var error = {
                message: function (_1) {
                    var len = _1.params.len;
                    return (0, codegen_1.str)(__makeTemplateObject(["must NOT have more than ", " items"], ["must NOT have more than ", " items"]), len);
                },
                params: function (_1) {
                    var len = _1.params.len;
                    return (0, codegen_1._)(__makeTemplateObject(["{limit: ", "}"], ["{limit: ", "}"]), len);
                }
            };
            var def = {
                keyword: "items",
                type: "array",
                schemaType: ["object", "boolean"],
                before: "uniqueItems",
                error: error,
                code: function (cxt) {
                    var schema = cxt.schema, parentSchema = cxt.parentSchema, it = cxt.it;
                    var prefixItems = parentSchema.prefixItems;
                    it.items = true;
                    if ((0, util_1.alwaysValidSchema)(it, schema))
                        return;
                    if (prefixItems)
                        (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
                    else
                        cxt.ok((0, code_1.validateArray)(cxt));
                }
            };
            exports["default"] = def;
            //# sourceMappingURL=items2020.js.map
            /***/ 
        }),
        /***/ 8720: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var util_1 = __nccwpck_require__(3439);
            var def = {
                keyword: "not",
                schemaType: ["object", "boolean"],
                trackErrors: true,
                code: function (cxt) {
                    var gen = cxt.gen, schema = cxt.schema, it = cxt.it;
                    if ((0, util_1.alwaysValidSchema)(it, schema)) {
                        cxt.fail();
                        return;
                    }
                    var valid = gen.name("valid");
                    cxt.subschema({
                        keyword: "not",
                        compositeRule: true,
                        createErrors: false,
                        allErrors: false
                    }, valid);
                    cxt.failResult(valid, function () { return cxt.reset(); }, function () { return cxt.error(); });
                },
                error: { message: "must NOT be valid" }
            };
            exports["default"] = def;
            //# sourceMappingURL=not.js.map
            /***/ 
        }),
        /***/ 6434: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var codegen_1 = __nccwpck_require__(9179);
            var util_1 = __nccwpck_require__(3439);
            var error = {
                message: "must match exactly one schema in oneOf",
                params: function (_1) {
                    var params = _1.params;
                    return (0, codegen_1._)(__makeTemplateObject(["{passingSchemas: ", "}"], ["{passingSchemas: ", "}"]), params.passing);
                }
            };
            var def = {
                keyword: "oneOf",
                schemaType: "array",
                trackErrors: true,
                error: error,
                code: function (cxt) {
                    var gen = cxt.gen, schema = cxt.schema, parentSchema = cxt.parentSchema, it = cxt.it;
                    /* istanbul ignore if */
                    if (!Array.isArray(schema))
                        throw new Error("ajv implementation error");
                    if (it.opts.discriminator && parentSchema.discriminator)
                        return;
                    var schArr = schema;
                    var valid = gen.let("valid", false);
                    var passing = gen.let("passing", null);
                    var schValid = gen.name("_valid");
                    cxt.setParams({ passing: passing });
                    // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas
                    gen.block(validateOneOf);
                    cxt.result(valid, function () { return cxt.reset(); }, function () { return cxt.error(true); });
                    function validateOneOf() {
                        schArr.forEach(function (sch, i) {
                            var schCxt;
                            if ((0, util_1.alwaysValidSchema)(it, sch)) {
                                gen["var"](schValid, true);
                            }
                            else {
                                schCxt = cxt.subschema({
                                    keyword: "oneOf",
                                    schemaProp: i,
                                    compositeRule: true
                                }, schValid);
                            }
                            if (i > 0) {
                                gen["if"]((0, codegen_1._)(__makeTemplateObject(["", " && ", ""], ["", " && ", ""]), schValid, valid))
                                    .assign(valid, false)
                                    .assign(passing, (0, codegen_1._)(__makeTemplateObject(["[", ", ", "]"], ["[", ", ", "]"]), passing, i))["else"]();
                            }
                            gen["if"](schValid, function () {
                                gen.assign(valid, true);
                                gen.assign(passing, i);
                                if (schCxt)
                                    cxt.mergeEvaluated(schCxt, codegen_1.Name);
                            });
                        });
                    }
                }
            };
            exports["default"] = def;
            //# sourceMappingURL=oneOf.js.map
            /***/ 
        }),
        /***/ 5157: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var code_1 = __nccwpck_require__(4205);
            var codegen_1 = __nccwpck_require__(9179);
            var util_1 = __nccwpck_require__(3439);
            var util_2 = __nccwpck_require__(3439);
            var def = {
                keyword: "patternProperties",
                type: "object",
                schemaType: "object",
                code: function (cxt) {
                    var gen = cxt.gen, schema = cxt.schema, data = cxt.data, parentSchema = cxt.parentSchema, it = cxt.it;
                    var opts = it.opts;
                    var patterns = (0, code_1.allSchemaProperties)(schema);
                    var alwaysValidPatterns = patterns.filter(function (p) { return (0, util_1.alwaysValidSchema)(it, schema[p]); });
                    if (patterns.length === 0 ||
                        (alwaysValidPatterns.length === patterns.length &&
                            (!it.opts.unevaluated || it.props === true))) {
                        return;
                    }
                    var checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
                    var valid = gen.name("valid");
                    if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
                        it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
                    }
                    var props = it.props;
                    validatePatternProperties();
                    function validatePatternProperties() {
                        for (var _1 = 0, patterns_1 = patterns; _1 < patterns_1.length; _1++) {
                            var pat = patterns_1[_1];
                            if (checkProperties)
                                checkMatchingProperties(pat);
                            if (it.allErrors) {
                                validateProperties(pat);
                            }
                            else {
                                gen["var"](valid, true); // TODO var
                                validateProperties(pat);
                                gen["if"](valid);
                            }
                        }
                    }
                    function checkMatchingProperties(pat) {
                        for (var prop in checkProperties) {
                            if (new RegExp(pat).test(prop)) {
                                (0, util_1.checkStrictMode)(it, "property ".concat(prop, " matches pattern ").concat(pat, " (use allowMatchingProperties)"));
                            }
                        }
                    }
                    function validateProperties(pat) {
                        gen.forIn("key", data, function (key) {
                            gen["if"]((0, codegen_1._)(__makeTemplateObject(["", ".test(", ")"], ["", ".test(", ")"]), (0, code_1.usePattern)(cxt, pat), key), function () {
                                var alwaysValid = alwaysValidPatterns.includes(pat);
                                if (!alwaysValid) {
                                    cxt.subschema({
                                        keyword: "patternProperties",
                                        schemaProp: pat,
                                        dataProp: key,
                                        dataPropType: util_2.Type.Str
                                    }, valid);
                                }
                                if (it.opts.unevaluated && props !== true) {
                                    gen.assign((0, codegen_1._)(__makeTemplateObject(["", "[", "]"], ["", "[", "]"]), props, key), true);
                                }
                                else if (!alwaysValid && !it.allErrors) {
                                    // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)
                                    // or if all properties were evaluated (props === true)
                                    gen["if"]((0, codegen_1.not)(valid), function () { return gen["break"](); });
                                }
                            });
                        });
                    }
                }
            };
            exports["default"] = def;
            //# sourceMappingURL=patternProperties.js.map
            /***/ 
        }),
        /***/ 9498: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var items_1 = __nccwpck_require__(8008);
            var def = {
                keyword: "prefixItems",
                type: "array",
                schemaType: ["array"],
                before: "uniqueItems",
                code: function (cxt) { return (0, items_1.validateTuple)(cxt, "items"); }
            };
            exports["default"] = def;
            //# sourceMappingURL=prefixItems.js.map
            /***/ 
        }),
        /***/ 7666: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var validate_1 = __nccwpck_require__(8955);
            var code_1 = __nccwpck_require__(4205);
            var util_1 = __nccwpck_require__(3439);
            var additionalProperties_1 = __nccwpck_require__(3481);
            var def = {
                keyword: "properties",
                type: "object",
                schemaType: "object",
                code: function (cxt) {
                    var gen = cxt.gen, schema = cxt.schema, parentSchema = cxt.parentSchema, data = cxt.data, it = cxt.it;
                    if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === undefined) {
                        additionalProperties_1["default"].code(new validate_1.KeywordCxt(it, additionalProperties_1["default"], "additionalProperties"));
                    }
                    var allProps = (0, code_1.allSchemaProperties)(schema);
                    for (var _1 = 0, allProps_1 = allProps; _1 < allProps_1.length; _1++) {
                        var prop = allProps_1[_1];
                        it.definedProperties.add(prop);
                    }
                    if (it.opts.unevaluated && allProps.length && it.props !== true) {
                        it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
                    }
                    var properties = allProps.filter(function (p) { return !(0, util_1.alwaysValidSchema)(it, schema[p]); });
                    if (properties.length === 0)
                        return;
                    var valid = gen.name("valid");
                    for (var _2 = 0, properties_2 = properties; _2 < properties_2.length; _2++) {
                        var prop = properties_2[_2];
                        if (hasDefault(prop)) {
                            applyPropertySchema(prop);
                        }
                        else {
                            gen["if"]((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
                            applyPropertySchema(prop);
                            if (!it.allErrors)
                                gen["else"]()["var"](valid, true);
                            gen.endIf();
                        }
                        cxt.it.definedProperties.add(prop);
                        cxt.ok(valid);
                    }
                    function hasDefault(prop) {
                        return it.opts.useDefaults && !it.compositeRule && schema[prop]["default"] !== undefined;
                    }
                    function applyPropertySchema(prop) {
                        cxt.subschema({
                            keyword: "properties",
                            schemaProp: prop,
                            dataProp: prop
                        }, valid);
                    }
                }
            };
            exports["default"] = def;
            //# sourceMappingURL=properties.js.map
            /***/ 
        }),
        /***/ 2554: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var codegen_1 = __nccwpck_require__(9179);
            var util_1 = __nccwpck_require__(3439);
            var error = {
                message: "property name must be valid",
                params: function (_1) {
                    var params = _1.params;
                    return (0, codegen_1._)(__makeTemplateObject(["{propertyName: ", "}"], ["{propertyName: ", "}"]), params.propertyName);
                }
            };
            var def = {
                keyword: "propertyNames",
                type: "object",
                schemaType: ["object", "boolean"],
                error: error,
                code: function (cxt) {
                    var gen = cxt.gen, schema = cxt.schema, data = cxt.data, it = cxt.it;
                    if ((0, util_1.alwaysValidSchema)(it, schema))
                        return;
                    var valid = gen.name("valid");
                    gen.forIn("key", data, function (key) {
                        cxt.setParams({ propertyName: key });
                        cxt.subschema({
                            keyword: "propertyNames",
                            data: key,
                            dataTypes: ["string"],
                            propertyName: key,
                            compositeRule: true
                        }, valid);
                        gen["if"]((0, codegen_1.not)(valid), function () {
                            cxt.error(true);
                            if (!it.allErrors)
                                gen["break"]();
                        });
                    });
                    cxt.ok(valid);
                }
            };
            exports["default"] = def;
            //# sourceMappingURL=propertyNames.js.map
            /***/ 
        }),
        /***/ 7680: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var util_1 = __nccwpck_require__(3439);
            var def = {
                keyword: ["then", "else"],
                schemaType: ["object", "boolean"],
                code: function (_1) {
                    var keyword = _1.keyword, parentSchema = _1.parentSchema, it = _1.it;
                    if (parentSchema["if"] === undefined)
                        (0, util_1.checkStrictMode)(it, "\"".concat(keyword, "\" without \"if\" is ignored"));
                }
            };
            exports["default"] = def;
            //# sourceMappingURL=thenElse.js.map
            /***/ 
        }),
        /***/ 4205: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
            var codegen_1 = __nccwpck_require__(9179);
            var util_1 = __nccwpck_require__(3439);
            var names_1 = __nccwpck_require__(50);
            var util_2 = __nccwpck_require__(3439);
            function checkReportMissingProp(cxt, prop) {
                var gen = cxt.gen, data = cxt.data, it = cxt.it;
                gen["if"](noPropertyInData(gen, data, prop, it.opts.ownProperties), function () {
                    cxt.setParams({ missingProperty: (0, codegen_1._)(__makeTemplateObject(["", ""], ["", ""]), prop) }, true);
                    cxt.error();
                });
            }
            exports.checkReportMissingProp = checkReportMissingProp;
            function checkMissingProp(_1, properties, missing) {
                var gen = _1.gen, data = _1.data, opts = _1.it.opts;
                return (0, codegen_1.or).apply(void 0, properties.map(function (prop) { return (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)(__makeTemplateObject(["", " = ", ""], ["", " = ", ""]), missing, prop)); }));
            }
            exports.checkMissingProp = checkMissingProp;
            function reportMissingProp(cxt, missing) {
                cxt.setParams({ missingProperty: missing }, true);
                cxt.error();
            }
            exports.reportMissingProp = reportMissingProp;
            function hasPropFunc(gen) {
                return gen.scopeValue("func", {
                    // eslint-disable-next-line @typescript-eslint/unbound-method
                    ref: Object.prototype.hasOwnProperty,
                    code: (0, codegen_1._)(__makeTemplateObject(["Object.prototype.hasOwnProperty"], ["Object.prototype.hasOwnProperty"]))
                });
            }
            exports.hasPropFunc = hasPropFunc;
            function isOwnProperty(gen, data, property) {
                return (0, codegen_1._)(__makeTemplateObject(["", ".call(", ", ", ")"], ["", ".call(", ", ", ")"]), hasPropFunc(gen), data, property);
            }
            exports.isOwnProperty = isOwnProperty;
            function propertyInData(gen, data, property, ownProperties) {
                var cond = (0, codegen_1._)(__makeTemplateObject(["", "", " !== undefined"], ["", "", " !== undefined"]), data, (0, codegen_1.getProperty)(property));
                return ownProperties ? (0, codegen_1._)(__makeTemplateObject(["", " && ", ""], ["", " && ", ""]), cond, isOwnProperty(gen, data, property)) : cond;
            }
            exports.propertyInData = propertyInData;
            function noPropertyInData(gen, data, property, ownProperties) {
                var cond = (0, codegen_1._)(__makeTemplateObject(["", "", " === undefined"], ["", "", " === undefined"]), data, (0, codegen_1.getProperty)(property));
                return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
            }
            exports.noPropertyInData = noPropertyInData;
            function allSchemaProperties(schemaMap) {
                return schemaMap ? Object.keys(schemaMap).filter(function (p) { return p !== "__proto__"; }) : [];
            }
            exports.allSchemaProperties = allSchemaProperties;
            function schemaProperties(it, schemaMap) {
                return allSchemaProperties(schemaMap).filter(function (p) { return !(0, util_1.alwaysValidSchema)(it, schemaMap[p]); });
            }
            exports.schemaProperties = schemaProperties;
            function callValidateCode(_1, func, context, passSchema) {
                var schemaCode = _1.schemaCode, data = _1.data, _2 = _1.it, gen = _2.gen, topSchemaRef = _2.topSchemaRef, schemaPath = _2.schemaPath, errorPath = _2.errorPath, it = _1.it;
                var dataAndSchema = passSchema ? (0, codegen_1._)(__makeTemplateObject(["", ", ", ", ", "", ""], ["", ", ", ", ", "", ""]), schemaCode, data, topSchemaRef, schemaPath) : data;
                var valCxt = [
                    [names_1["default"].instancePath, (0, codegen_1.strConcat)(names_1["default"].instancePath, errorPath)],
                    [names_1["default"].parentData, it.parentData],
                    [names_1["default"].parentDataProperty, it.parentDataProperty],
                    [names_1["default"].rootData, names_1["default"].rootData],
                ];
                if (it.opts.dynamicRef)
                    valCxt.push([names_1["default"].dynamicAnchors, names_1["default"].dynamicAnchors]);
                var args = (0, codegen_1._)(__makeTemplateObject(["", ", ", ""], ["", ", ", ""]), dataAndSchema, gen.object.apply(gen, valCxt));
                return context !== codegen_1.nil ? (0, codegen_1._)(__makeTemplateObject(["", ".call(", ", ", ")"], ["", ".call(", ", ", ")"]), func, context, args) : (0, codegen_1._)(__makeTemplateObject(["", "(", ")"], ["", "(", ")"]), func, args);
            }
            exports.callValidateCode = callValidateCode;
            var newRegExp = (0, codegen_1._)(__makeTemplateObject(["new RegExp"], ["new RegExp"]));
            function usePattern(_1, pattern) {
                var gen = _1.gen, opts = _1.it.opts;
                var u = opts.unicodeRegExp ? "u" : "";
                var regExp = opts.code.regExp;
                var rx = regExp(pattern, u);
                return gen.scopeValue("pattern", {
                    key: rx.toString(),
                    ref: rx,
                    code: (0, codegen_1._)(__makeTemplateObject(["", "(", ", ", ")"], ["", "(", ", ", ")"]), regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp), pattern, u)
                });
            }
            exports.usePattern = usePattern;
            function validateArray(cxt) {
                var gen = cxt.gen, data = cxt.data, keyword = cxt.keyword, it = cxt.it;
                var valid = gen.name("valid");
                if (it.allErrors) {
                    var validArr_1 = gen.let("valid", true);
                    validateItems(function () { return gen.assign(validArr_1, false); });
                    return validArr_1;
                }
                gen["var"](valid, true);
                validateItems(function () { return gen["break"](); });
                return valid;
                function validateItems(notValid) {
                    var len = gen["const"]("len", (0, codegen_1._)(__makeTemplateObject(["", ".length"], ["", ".length"]), data));
                    gen.forRange("i", 0, len, function (i) {
                        cxt.subschema({
                            keyword: keyword,
                            dataProp: i,
                            dataPropType: util_1.Type.Num
                        }, valid);
                        gen["if"]((0, codegen_1.not)(valid), notValid);
                    });
                }
            }
            exports.validateArray = validateArray;
            function validateUnion(cxt) {
                var gen = cxt.gen, schema = cxt.schema, keyword = cxt.keyword, it = cxt.it;
                /* istanbul ignore if */
                if (!Array.isArray(schema))
                    throw new Error("ajv implementation error");
                var alwaysValid = schema.some(function (sch) { return (0, util_1.alwaysValidSchema)(it, sch); });
                if (alwaysValid && !it.opts.unevaluated)
                    return;
                var valid = gen.let("valid", false);
                var schValid = gen.name("_valid");
                gen.block(function () { return schema.forEach(function (_sch, i) {
                    var schCxt = cxt.subschema({
                        keyword: keyword,
                        schemaProp: i,
                        compositeRule: true
                    }, schValid);
                    gen.assign(valid, (0, codegen_1._)(__makeTemplateObject(["", " || ", ""], ["", " || ", ""]), valid, schValid));
                    var merged = cxt.mergeValidEvaluated(schCxt, schValid);
                    // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)
                    // or if all properties and items were evaluated (it.props === true && it.items === true)
                    if (!merged)
                        gen["if"]((0, codegen_1.not)(valid));
                }); });
                cxt.result(valid, function () { return cxt.reset(); }, function () { return cxt.error(true); });
            }
            exports.validateUnion = validateUnion;
            //# sourceMappingURL=code.js.map
            /***/ 
        }),
        /***/ 1674: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var def = {
                keyword: "id",
                code: function () {
                    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
                }
            };
            exports["default"] = def;
            //# sourceMappingURL=id.js.map
            /***/ 
        }),
        /***/ 3707: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var id_1 = __nccwpck_require__(1674);
            var ref_1 = __nccwpck_require__(6532);
            var core = [
                "$schema",
                "$id",
                "$defs",
                "$vocabulary",
                { keyword: "$comment" },
                "definitions",
                id_1["default"],
                ref_1["default"],
            ];
            exports["default"] = core;
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 6532: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.callRef = exports.getValidate = void 0;
            var ref_error_1 = __nccwpck_require__(8190);
            var code_1 = __nccwpck_require__(4205);
            var codegen_1 = __nccwpck_require__(9179);
            var names_1 = __nccwpck_require__(50);
            var compile_1 = __nccwpck_require__(813);
            var util_1 = __nccwpck_require__(3439);
            var def = {
                keyword: "$ref",
                schemaType: "string",
                code: function (cxt) {
                    var gen = cxt.gen, $ref = cxt.schema, it = cxt.it;
                    var baseId = it.baseId, env = it.schemaEnv, validateName = it.validateName, opts = it.opts, self = it.self;
                    var root = env.root;
                    if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
                        return callRootRef();
                    var schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
                    if (schOrEnv === undefined)
                        throw new ref_error_1["default"](it.opts.uriResolver, baseId, $ref);
                    if (schOrEnv instanceof compile_1.SchemaEnv)
                        return callValidate(schOrEnv);
                    return inlineRefSchema(schOrEnv);
                    function callRootRef() {
                        if (env === root)
                            return callRef(cxt, validateName, env, env.$async);
                        var rootName = gen.scopeValue("root", { ref: root });
                        return callRef(cxt, (0, codegen_1._)(__makeTemplateObject(["", ".validate"], ["", ".validate"]), rootName), root, root.$async);
                    }
                    function callValidate(sch) {
                        var v = getValidate(cxt, sch);
                        callRef(cxt, v, sch, sch.$async);
                    }
                    function inlineRefSchema(sch) {
                        var schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
                        var valid = gen.name("valid");
                        var schCxt = cxt.subschema({
                            schema: sch,
                            dataTypes: [],
                            schemaPath: codegen_1.nil,
                            topSchemaRef: schName,
                            errSchemaPath: $ref
                        }, valid);
                        cxt.mergeEvaluated(schCxt);
                        cxt.ok(valid);
                    }
                }
            };
            function getValidate(cxt, sch) {
                var gen = cxt.gen;
                return sch.validate
                    ? gen.scopeValue("validate", { ref: sch.validate })
                    : (0, codegen_1._)(__makeTemplateObject(["", ".validate"], ["", ".validate"]), gen.scopeValue("wrapper", { ref: sch }));
            }
            exports.getValidate = getValidate;
            function callRef(cxt, v, sch, $async) {
                var gen = cxt.gen, it = cxt.it;
                var allErrors = it.allErrors, env = it.schemaEnv, opts = it.opts;
                var passCxt = opts.passContext ? names_1["default"]["this"] : codegen_1.nil;
                if ($async)
                    callAsyncRef();
                else
                    callSyncRef();
                function callAsyncRef() {
                    if (!env.$async)
                        throw new Error("async schema referenced by sync schema");
                    var valid = gen.let("valid");
                    gen["try"](function () {
                        gen.code((0, codegen_1._)(__makeTemplateObject(["await ", ""], ["await ", ""]), (0, code_1.callValidateCode)(cxt, v, passCxt)));
                        addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result
                        if (!allErrors)
                            gen.assign(valid, true);
                    }, function (e) {
                        gen["if"]((0, codegen_1._)(__makeTemplateObject(["!(", " instanceof ", ")"], ["!(", " instanceof ", ")"]), e, it.ValidationError), function () { return gen["throw"](e); });
                        addErrorsFrom(e);
                        if (!allErrors)
                            gen.assign(valid, false);
                    });
                    cxt.ok(valid);
                }
                function callSyncRef() {
                    cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), function () { return addEvaluatedFrom(v); }, function () { return addErrorsFrom(v); });
                }
                function addErrorsFrom(source) {
                    var errs = (0, codegen_1._)(__makeTemplateObject(["", ".errors"], ["", ".errors"]), source);
                    gen.assign(names_1["default"].vErrors, (0, codegen_1._)(__makeTemplateObject(["", " === null ? ", " : ", ".concat(", ")"], ["", " === null ? ", " : ", ".concat(", ")"]), names_1["default"].vErrors, errs, names_1["default"].vErrors, errs)); // TODO tagged
                    gen.assign(names_1["default"].errors, (0, codegen_1._)(__makeTemplateObject(["", ".length"], ["", ".length"]), names_1["default"].vErrors));
                }
                function addEvaluatedFrom(source) {
                    var _a;
                    if (!it.opts.unevaluated)
                        return;
                    var schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
                    // TODO refactor
                    if (it.props !== true) {
                        if (schEvaluated && !schEvaluated.dynamicProps) {
                            if (schEvaluated.props !== undefined) {
                                it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
                            }
                        }
                        else {
                            var props = gen["var"]("props", (0, codegen_1._)(__makeTemplateObject(["", ".evaluated.props"], ["", ".evaluated.props"]), source));
                            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
                        }
                    }
                    if (it.items !== true) {
                        if (schEvaluated && !schEvaluated.dynamicItems) {
                            if (schEvaluated.items !== undefined) {
                                it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
                            }
                        }
                        else {
                            var items = gen["var"]("items", (0, codegen_1._)(__makeTemplateObject(["", ".evaluated.items"], ["", ".evaluated.items"]), source));
                            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
                        }
                    }
                }
            }
            exports.callRef = callRef;
            exports["default"] = def;
            //# sourceMappingURL=ref.js.map
            /***/ 
        }),
        /***/ 4025: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var codegen_1 = __nccwpck_require__(9179);
            var types_1 = __nccwpck_require__(8374);
            var compile_1 = __nccwpck_require__(813);
            var util_1 = __nccwpck_require__(3439);
            var error = {
                message: function (_1) {
                    var _2 = _1.params, discrError = _2.discrError, tagName = _2.tagName;
                    return discrError === types_1.DiscrError.Tag
                        ? "tag \"".concat(tagName, "\" must be string")
                        : "value of tag \"".concat(tagName, "\" must be in oneOf");
                },
                params: function (_1) {
                    var _2 = _1.params, discrError = _2.discrError, tag = _2.tag, tagName = _2.tagName;
                    return (0, codegen_1._)(__makeTemplateObject(["{error: ", ", tag: ", ", tagValue: ", "}"], ["{error: ", ", tag: ", ", tagValue: ", "}"]), discrError, tagName, tag);
                }
            };
            var def = {
                keyword: "discriminator",
                type: "object",
                schemaType: "object",
                error: error,
                code: function (cxt) {
                    var gen = cxt.gen, data = cxt.data, schema = cxt.schema, parentSchema = cxt.parentSchema, it = cxt.it;
                    var oneOf = parentSchema.oneOf;
                    if (!it.opts.discriminator) {
                        throw new Error("discriminator: requires discriminator option");
                    }
                    var tagName = schema.propertyName;
                    if (typeof tagName != "string")
                        throw new Error("discriminator: requires propertyName");
                    if (schema.mapping)
                        throw new Error("discriminator: mapping is not supported");
                    if (!oneOf)
                        throw new Error("discriminator: requires oneOf keyword");
                    var valid = gen.let("valid", false);
                    var tag = gen["const"]("tag", (0, codegen_1._)(__makeTemplateObject(["", "", ""], ["", "", ""]), data, (0, codegen_1.getProperty)(tagName)));
                    gen["if"]((0, codegen_1._)(__makeTemplateObject(["typeof ", " == \"string\""], ["typeof ", " == \"string\""]), tag), function () { return validateMapping(); }, function () { return cxt.error(false, { discrError: types_1.DiscrError.Tag, tag: tag, tagName: tagName }); });
                    cxt.ok(valid);
                    function validateMapping() {
                        var mapping = getMapping();
                        gen["if"](false);
                        for (var tagValue in mapping) {
                            gen.elseIf((0, codegen_1._)(__makeTemplateObject(["", " === ", ""], ["", " === ", ""]), tag, tagValue));
                            gen.assign(valid, applyTagSchema(mapping[tagValue]));
                        }
                        gen["else"]();
                        cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag: tag, tagName: tagName });
                        gen.endIf();
                    }
                    function applyTagSchema(schemaProp) {
                        var _valid = gen.name("valid");
                        var schCxt = cxt.subschema({ keyword: "oneOf", schemaProp: schemaProp }, _valid);
                        cxt.mergeEvaluated(schCxt, codegen_1.Name);
                        return _valid;
                    }
                    function getMapping() {
                        var _a;
                        var oneOfMapping = {};
                        var topRequired = hasRequired(parentSchema);
                        var tagRequired = true;
                        for (var i = 0; i < oneOf.length; i++) {
                            var sch = oneOf[i];
                            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
                                sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);
                                if (sch instanceof compile_1.SchemaEnv)
                                    sch = sch.schema;
                            }
                            var propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
                            if (typeof propSch != "object") {
                                throw new Error("discriminator: oneOf subschemas (or referenced schemas) must have \"properties/".concat(tagName, "\""));
                            }
                            tagRequired = tagRequired && (topRequired || hasRequired(sch));
                            addMappings(propSch, i);
                        }
                        if (!tagRequired)
                            throw new Error("discriminator: \"".concat(tagName, "\" must be required"));
                        return oneOfMapping;
                        function hasRequired(_1) {
                            var required = _1.required;
                            return Array.isArray(required) && required.includes(tagName);
                        }
                        function addMappings(sch, i) {
                            if (sch["const"]) {
                                addMapping(sch["const"], i);
                            }
                            else if (sch["enum"]) {
                                for (var _1 = 0, _2 = sch["enum"]; _1 < _2.length; _1++) {
                                    var tagValue = _2[_1];
                                    addMapping(tagValue, i);
                                }
                            }
                            else {
                                throw new Error("discriminator: \"properties/".concat(tagName, "\" must have \"const\" or \"enum\""));
                            }
                        }
                        function addMapping(tagValue, i) {
                            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
                                throw new Error("discriminator: \"".concat(tagName, "\" values must be unique strings"));
                            }
                            oneOfMapping[tagValue] = i;
                        }
                    }
                }
            };
            exports["default"] = def;
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 8374: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.DiscrError = void 0;
            var DiscrError;
            (function (DiscrError) {
                DiscrError["Tag"] = "tag";
                DiscrError["Mapping"] = "mapping";
            })(DiscrError = exports.DiscrError || (exports.DiscrError = {}));
            //# sourceMappingURL=types.js.map
            /***/ 
        }),
        /***/ 691: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var core_1 = __nccwpck_require__(3707);
            var validation_1 = __nccwpck_require__(9805);
            var applicator_1 = __nccwpck_require__(3048);
            var format_1 = __nccwpck_require__(9841);
            var metadata_1 = __nccwpck_require__(5799);
            var draft7Vocabularies = [
                core_1["default"],
                validation_1["default"],
                (0, applicator_1["default"])(),
                format_1["default"],
                metadata_1.metadataVocabulary,
                metadata_1.contentVocabulary,
            ];
            exports["default"] = draft7Vocabularies;
            //# sourceMappingURL=draft7.js.map
            /***/ 
        }),
        /***/ 3691: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var codegen_1 = __nccwpck_require__(9179);
            var error = {
                message: function (_1) {
                    var schemaCode = _1.schemaCode;
                    return (0, codegen_1.str)(__makeTemplateObject(["must match format \"", "\""], ["must match format \"", "\""]), schemaCode);
                },
                params: function (_1) {
                    var schemaCode = _1.schemaCode;
                    return (0, codegen_1._)(__makeTemplateObject(["{format: ", "}"], ["{format: ", "}"]), schemaCode);
                }
            };
            var def = {
                keyword: "format",
                type: ["number", "string"],
                schemaType: "string",
                $data: true,
                error: error,
                code: function (cxt, ruleType) {
                    var gen = cxt.gen, data = cxt.data, $data = cxt.$data, schema = cxt.schema, schemaCode = cxt.schemaCode, it = cxt.it;
                    var opts = it.opts, errSchemaPath = it.errSchemaPath, schemaEnv = it.schemaEnv, self = it.self;
                    if (!opts.validateFormats)
                        return;
                    if ($data)
                        validate$DataFormat();
                    else
                        validateFormat();
                    function validate$DataFormat() {
                        var fmts = gen.scopeValue("formats", {
                            ref: self.formats,
                            code: opts.code.formats
                        });
                        var fDef = gen["const"]("fDef", (0, codegen_1._)(__makeTemplateObject(["", "[", "]"], ["", "[", "]"]), fmts, schemaCode));
                        var fType = gen.let("fType");
                        var format = gen.let("format");
                        // TODO simplify
                        gen["if"]((0, codegen_1._)(__makeTemplateObject(["typeof ", " == \"object\" && !(", " instanceof RegExp)"], ["typeof ", " == \"object\" && !(", " instanceof RegExp)"]), fDef, fDef), function () { return gen.assign(fType, (0, codegen_1._)(__makeTemplateObject(["", ".type || \"string\""], ["", ".type || \"string\""]), fDef)).assign(format, (0, codegen_1._)(__makeTemplateObject(["", ".validate"], ["", ".validate"]), fDef)); }, function () { return gen.assign(fType, (0, codegen_1._)(__makeTemplateObject(["\"string\""], ["\"string\""]))).assign(format, fDef); });
                        cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
                        function unknownFmt() {
                            if (opts.strictSchema === false)
                                return codegen_1.nil;
                            return (0, codegen_1._)(__makeTemplateObject(["", " && !", ""], ["", " && !", ""]), schemaCode, format);
                        }
                        function invalidFmt() {
                            var callFormat = schemaEnv.$async
                                ? (0, codegen_1._)(__makeTemplateObject(["(", ".async ? await ", "(", ") : ", "(", "))"], ["(", ".async ? await ", "(", ") : ", "(", "))"]), fDef, format, data, format, data) : (0, codegen_1._)(__makeTemplateObject(["", "(", ")"], ["", "(", ")"]), format, data);
                            var validData = (0, codegen_1._)(__makeTemplateObject(["(typeof ", " == \"function\" ? ", " : ", ".test(", "))"], ["(typeof ", " == \"function\" ? ", " : ", ".test(", "))"]), format, callFormat, format, data);
                            return (0, codegen_1._)(__makeTemplateObject(["", " && ", " !== true && ", " === ", " && !", ""], ["", " && ", " !== true && ", " === ", " && !", ""]), format, format, fType, ruleType, validData);
                        }
                    }
                    function validateFormat() {
                        var formatDef = self.formats[schema];
                        if (!formatDef) {
                            unknownFormat();
                            return;
                        }
                        if (formatDef === true)
                            return;
                        var _1 = getFormat(formatDef), fmtType = _1[0], format = _1[1], fmtRef = _1[2];
                        if (fmtType === ruleType)
                            cxt.pass(validCondition());
                        function unknownFormat() {
                            if (opts.strictSchema === false) {
                                self.logger.warn(unknownMsg());
                                return;
                            }
                            throw new Error(unknownMsg());
                            function unknownMsg() {
                                return "unknown format \"".concat(schema, "\" ignored in schema at path \"").concat(errSchemaPath, "\"");
                            }
                        }
                        function getFormat(fmtDef) {
                            var code = fmtDef instanceof RegExp
                                ? (0, codegen_1.regexpCode)(fmtDef)
                                : opts.code.formats
                                    ? (0, codegen_1._)(__makeTemplateObject(["", "", ""], ["", "", ""]), opts.code.formats, (0, codegen_1.getProperty)(schema)) : undefined;
                            var fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code: code });
                            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
                                return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)(__makeTemplateObject(["", ".validate"], ["", ".validate"]), fmt)];
                            }
                            return ["string", fmtDef, fmt];
                        }
                        function validCondition() {
                            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
                                if (!schemaEnv.$async)
                                    throw new Error("async format in sync schema");
                                return (0, codegen_1._)(__makeTemplateObject(["await ", "(", ")"], ["await ", "(", ")"]), fmtRef, data);
                            }
                            return typeof format == "function" ? (0, codegen_1._)(__makeTemplateObject(["", "(", ")"], ["", "(", ")"]), fmtRef, data) : (0, codegen_1._)(__makeTemplateObject(["", ".test(", ")"], ["", ".test(", ")"]), fmtRef, data);
                        }
                    }
                }
            };
            exports["default"] = def;
            //# sourceMappingURL=format.js.map
            /***/ 
        }),
        /***/ 9841: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var format_1 = __nccwpck_require__(3691);
            var format = [format_1["default"]];
            exports["default"] = format;
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 5799: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.contentVocabulary = exports.metadataVocabulary = void 0;
            exports.metadataVocabulary = [
                "title",
                "description",
                "default",
                "deprecated",
                "readOnly",
                "writeOnly",
                "examples",
            ];
            exports.contentVocabulary = [
                "contentMediaType",
                "contentEncoding",
                "contentSchema",
            ];
            //# sourceMappingURL=metadata.js.map
            /***/ 
        }),
        /***/ 3694: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var codegen_1 = __nccwpck_require__(9179);
            var util_1 = __nccwpck_require__(3439);
            var equal_1 = __nccwpck_require__(3809);
            var error = {
                message: "must be equal to constant",
                params: function (_1) {
                    var schemaCode = _1.schemaCode;
                    return (0, codegen_1._)(__makeTemplateObject(["{allowedValue: ", "}"], ["{allowedValue: ", "}"]), schemaCode);
                }
            };
            var def = {
                keyword: "const",
                $data: true,
                error: error,
                code: function (cxt) {
                    var gen = cxt.gen, data = cxt.data, $data = cxt.$data, schemaCode = cxt.schemaCode, schema = cxt.schema;
                    if ($data || (schema && typeof schema == "object")) {
                        cxt.fail$data((0, codegen_1._)(__makeTemplateObject(["!", "(", ", ", ")"], ["!", "(", ", ", ")"]), (0, util_1.useFunc)(gen, equal_1["default"]), data, schemaCode));
                    }
                    else {
                        cxt.fail((0, codegen_1._)(__makeTemplateObject(["", " !== ", ""], ["", " !== ", ""]), schema, data));
                    }
                }
            };
            exports["default"] = def;
            //# sourceMappingURL=const.js.map
            /***/ 
        }),
        /***/ 5529: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var codegen_1 = __nccwpck_require__(9179);
            var util_1 = __nccwpck_require__(3439);
            var equal_1 = __nccwpck_require__(3809);
            var error = {
                message: "must be equal to one of the allowed values",
                params: function (_1) {
                    var schemaCode = _1.schemaCode;
                    return (0, codegen_1._)(__makeTemplateObject(["{allowedValues: ", "}"], ["{allowedValues: ", "}"]), schemaCode);
                }
            };
            var def = {
                keyword: "enum",
                schemaType: "array",
                $data: true,
                error: error,
                code: function (cxt) {
                    var gen = cxt.gen, data = cxt.data, $data = cxt.$data, schema = cxt.schema, schemaCode = cxt.schemaCode, it = cxt.it;
                    if (!$data && schema.length === 0)
                        throw new Error("enum must have non-empty array");
                    var useLoop = schema.length >= it.opts.loopEnum;
                    var eql;
                    var getEql = function () { return (eql !== null && eql !== void 0 ? eql : (eql = (0, util_1.useFunc)(gen, equal_1["default"]))); };
                    var valid;
                    if (useLoop || $data) {
                        valid = gen.let("valid");
                        cxt.block$data(valid, loopEnum);
                    }
                    else {
                        /* istanbul ignore if */
                        if (!Array.isArray(schema))
                            throw new Error("ajv implementation error");
                        var vSchema_1 = gen["const"]("vSchema", schemaCode);
                        valid = (0, codegen_1.or).apply(void 0, schema.map(function (_x, i) { return equalCode(vSchema_1, i); }));
                    }
                    cxt.pass(valid);
                    function loopEnum() {
                        gen.assign(valid, false);
                        gen.forOf("v", schemaCode, function (v) { return gen["if"]((0, codegen_1._)(__makeTemplateObject(["", "(", ", ", ")"], ["", "(", ", ", ")"]), getEql(), data, v), function () { return gen.assign(valid, true)["break"](); }); });
                    }
                    function equalCode(vSchema, i) {
                        var sch = schema[i];
                        return typeof sch === "object" && sch !== null
                            ? (0, codegen_1._)(__makeTemplateObject(["", "(", ", ", "[", "])"], ["", "(", ", ", "[", "])"]), getEql(), data, vSchema, i) : (0, codegen_1._)(__makeTemplateObject(["", " === ", ""], ["", " === ", ""]), data, sch);
                    }
                }
            };
            exports["default"] = def;
            //# sourceMappingURL=enum.js.map
            /***/ 
        }),
        /***/ 9805: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var limitNumber_1 = __nccwpck_require__(345);
            var multipleOf_1 = __nccwpck_require__(3201);
            var limitLength_1 = __nccwpck_require__(7598);
            var pattern_1 = __nccwpck_require__(4960);
            var limitProperties_1 = __nccwpck_require__(3470);
            var required_1 = __nccwpck_require__(3602);
            var limitItems_1 = __nccwpck_require__(3924);
            var uniqueItems_1 = __nccwpck_require__(9351);
            var const_1 = __nccwpck_require__(3694);
            var enum_1 = __nccwpck_require__(5529);
            var validation = [
                // number
                limitNumber_1["default"],
                multipleOf_1["default"],
                // string
                limitLength_1["default"],
                pattern_1["default"],
                // object
                limitProperties_1["default"],
                required_1["default"],
                // array
                limitItems_1["default"],
                uniqueItems_1["default"],
                // any
                { keyword: "type", schemaType: ["string", "array"] },
                { keyword: "nullable", schemaType: "boolean" },
                const_1["default"],
                enum_1["default"],
            ];
            exports["default"] = validation;
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 3924: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var codegen_1 = __nccwpck_require__(9179);
            var error = {
                message: function (_1) {
                    var keyword = _1.keyword, schemaCode = _1.schemaCode;
                    var comp = keyword === "maxItems" ? "more" : "fewer";
                    return (0, codegen_1.str)(__makeTemplateObject(["must NOT have ", " than ", " items"], ["must NOT have ", " than ", " items"]), comp, schemaCode);
                },
                params: function (_1) {
                    var schemaCode = _1.schemaCode;
                    return (0, codegen_1._)(__makeTemplateObject(["{limit: ", "}"], ["{limit: ", "}"]), schemaCode);
                }
            };
            var def = {
                keyword: ["maxItems", "minItems"],
                type: "array",
                schemaType: "number",
                $data: true,
                error: error,
                code: function (cxt) {
                    var keyword = cxt.keyword, data = cxt.data, schemaCode = cxt.schemaCode;
                    var op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
                    cxt.fail$data((0, codegen_1._)(__makeTemplateObject(["", ".length ", " ", ""], ["", ".length ", " ", ""]), data, op, schemaCode));
                }
            };
            exports["default"] = def;
            //# sourceMappingURL=limitItems.js.map
            /***/ 
        }),
        /***/ 7598: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var codegen_1 = __nccwpck_require__(9179);
            var util_1 = __nccwpck_require__(3439);
            var ucs2length_1 = __nccwpck_require__(2470);
            var error = {
                message: function (_1) {
                    var keyword = _1.keyword, schemaCode = _1.schemaCode;
                    var comp = keyword === "maxLength" ? "more" : "fewer";
                    return (0, codegen_1.str)(__makeTemplateObject(["must NOT have ", " than ", " characters"], ["must NOT have ", " than ", " characters"]), comp, schemaCode);
                },
                params: function (_1) {
                    var schemaCode = _1.schemaCode;
                    return (0, codegen_1._)(__makeTemplateObject(["{limit: ", "}"], ["{limit: ", "}"]), schemaCode);
                }
            };
            var def = {
                keyword: ["maxLength", "minLength"],
                type: "string",
                schemaType: "number",
                $data: true,
                error: error,
                code: function (cxt) {
                    var keyword = cxt.keyword, data = cxt.data, schemaCode = cxt.schemaCode, it = cxt.it;
                    var op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
                    var len = it.opts.unicode === false ? (0, codegen_1._)(__makeTemplateObject(["", ".length"], ["", ".length"]), data) : (0, codegen_1._)(__makeTemplateObject(["", "(", ")"], ["", "(", ")"]), (0, util_1.useFunc)(cxt.gen, ucs2length_1["default"]), data);
                    cxt.fail$data((0, codegen_1._)(__makeTemplateObject(["", " ", " ", ""], ["", " ", " ", ""]), len, op, schemaCode));
                }
            };
            exports["default"] = def;
            //# sourceMappingURL=limitLength.js.map
            /***/ 
        }),
        /***/ 345: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var codegen_1 = __nccwpck_require__(9179);
            var ops = codegen_1.operators;
            var KWDs = {
                maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
                minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
                exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
                exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
            };
            var error = {
                message: function (_1) {
                    var keyword = _1.keyword, schemaCode = _1.schemaCode;
                    return (0, codegen_1.str)(__makeTemplateObject(["must be ", " ", ""], ["must be ", " ", ""]), KWDs[keyword].okStr, schemaCode);
                },
                params: function (_1) {
                    var keyword = _1.keyword, schemaCode = _1.schemaCode;
                    return (0, codegen_1._)(__makeTemplateObject(["{comparison: ", ", limit: ", "}"], ["{comparison: ", ", limit: ", "}"]), KWDs[keyword].okStr, schemaCode);
                }
            };
            var def = {
                keyword: Object.keys(KWDs),
                type: "number",
                schemaType: "number",
                $data: true,
                error: error,
                code: function (cxt) {
                    var keyword = cxt.keyword, data = cxt.data, schemaCode = cxt.schemaCode;
                    cxt.fail$data((0, codegen_1._)(__makeTemplateObject(["", " ", " ", " || isNaN(", ")"], ["", " ", " ", " || isNaN(", ")"]), data, KWDs[keyword].fail, schemaCode, data));
                }
            };
            exports["default"] = def;
            //# sourceMappingURL=limitNumber.js.map
            /***/ 
        }),
        /***/ 3470: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var codegen_1 = __nccwpck_require__(9179);
            var error = {
                message: function (_1) {
                    var keyword = _1.keyword, schemaCode = _1.schemaCode;
                    var comp = keyword === "maxProperties" ? "more" : "fewer";
                    return (0, codegen_1.str)(__makeTemplateObject(["must NOT have ", " than ", " properties"], ["must NOT have ", " than ", " properties"]), comp, schemaCode);
                },
                params: function (_1) {
                    var schemaCode = _1.schemaCode;
                    return (0, codegen_1._)(__makeTemplateObject(["{limit: ", "}"], ["{limit: ", "}"]), schemaCode);
                }
            };
            var def = {
                keyword: ["maxProperties", "minProperties"],
                type: "object",
                schemaType: "number",
                $data: true,
                error: error,
                code: function (cxt) {
                    var keyword = cxt.keyword, data = cxt.data, schemaCode = cxt.schemaCode;
                    var op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
                    cxt.fail$data((0, codegen_1._)(__makeTemplateObject(["Object.keys(", ").length ", " ", ""], ["Object.keys(", ").length ", " ", ""]), data, op, schemaCode));
                }
            };
            exports["default"] = def;
            //# sourceMappingURL=limitProperties.js.map
            /***/ 
        }),
        /***/ 3201: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var codegen_1 = __nccwpck_require__(9179);
            var error = {
                message: function (_1) {
                    var schemaCode = _1.schemaCode;
                    return (0, codegen_1.str)(__makeTemplateObject(["must be multiple of ", ""], ["must be multiple of ", ""]), schemaCode);
                },
                params: function (_1) {
                    var schemaCode = _1.schemaCode;
                    return (0, codegen_1._)(__makeTemplateObject(["{multipleOf: ", "}"], ["{multipleOf: ", "}"]), schemaCode);
                }
            };
            var def = {
                keyword: "multipleOf",
                type: "number",
                schemaType: "number",
                $data: true,
                error: error,
                code: function (cxt) {
                    var gen = cxt.gen, data = cxt.data, schemaCode = cxt.schemaCode, it = cxt.it;
                    // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)
                    var prec = it.opts.multipleOfPrecision;
                    var res = gen.let("res");
                    var invalid = prec
                        ? (0, codegen_1._)(__makeTemplateObject(["Math.abs(Math.round(", ") - ", ") > 1e-", ""], ["Math.abs(Math.round(", ") - ", ") > 1e-", ""]), res, res, prec) : (0, codegen_1._)(__makeTemplateObject(["", " !== parseInt(", ")"], ["", " !== parseInt(", ")"]), res, res);
                    cxt.fail$data((0, codegen_1._)(__makeTemplateObject(["(", " === 0 || (", " = ", "/", ", ", "))"], ["(", " === 0 || (", " = ", "/", ", ", "))"]), schemaCode, res, data, schemaCode, invalid));
                }
            };
            exports["default"] = def;
            //# sourceMappingURL=multipleOf.js.map
            /***/ 
        }),
        /***/ 4960: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var code_1 = __nccwpck_require__(4205);
            var codegen_1 = __nccwpck_require__(9179);
            var error = {
                message: function (_1) {
                    var schemaCode = _1.schemaCode;
                    return (0, codegen_1.str)(__makeTemplateObject(["must match pattern \"", "\""], ["must match pattern \"", "\""]), schemaCode);
                },
                params: function (_1) {
                    var schemaCode = _1.schemaCode;
                    return (0, codegen_1._)(__makeTemplateObject(["{pattern: ", "}"], ["{pattern: ", "}"]), schemaCode);
                }
            };
            var def = {
                keyword: "pattern",
                type: "string",
                schemaType: "string",
                $data: true,
                error: error,
                code: function (cxt) {
                    var data = cxt.data, $data = cxt.$data, schema = cxt.schema, schemaCode = cxt.schemaCode, it = cxt.it;
                    // TODO regexp should be wrapped in try/catchs
                    var u = it.opts.unicodeRegExp ? "u" : "";
                    var regExp = $data ? (0, codegen_1._)(__makeTemplateObject(["(new RegExp(", ", ", "))"], ["(new RegExp(", ", ", "))"]), schemaCode, u) : (0, code_1.usePattern)(cxt, schema);
                    cxt.fail$data((0, codegen_1._)(__makeTemplateObject(["!", ".test(", ")"], ["!", ".test(", ")"]), regExp, data));
                }
            };
            exports["default"] = def;
            //# sourceMappingURL=pattern.js.map
            /***/ 
        }),
        /***/ 3602: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var code_1 = __nccwpck_require__(4205);
            var codegen_1 = __nccwpck_require__(9179);
            var util_1 = __nccwpck_require__(3439);
            var error = {
                message: function (_1) {
                    var missingProperty = _1.params.missingProperty;
                    return (0, codegen_1.str)(__makeTemplateObject(["must have required property '", "'"], ["must have required property '", "'"]), missingProperty);
                },
                params: function (_1) {
                    var missingProperty = _1.params.missingProperty;
                    return (0, codegen_1._)(__makeTemplateObject(["{missingProperty: ", "}"], ["{missingProperty: ", "}"]), missingProperty);
                }
            };
            var def = {
                keyword: "required",
                type: "object",
                schemaType: "array",
                $data: true,
                error: error,
                code: function (cxt) {
                    var gen = cxt.gen, schema = cxt.schema, schemaCode = cxt.schemaCode, data = cxt.data, $data = cxt.$data, it = cxt.it;
                    var opts = it.opts;
                    if (!$data && schema.length === 0)
                        return;
                    var useLoop = schema.length >= opts.loopRequired;
                    if (it.allErrors)
                        allErrorsMode();
                    else
                        exitOnErrorMode();
                    if (opts.strictRequired) {
                        var props = cxt.parentSchema.properties;
                        var definedProperties = cxt.it.definedProperties;
                        for (var _1 = 0, schema_2 = schema; _1 < schema_2.length; _1++) {
                            var requiredKey = schema_2[_1];
                            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {
                                var schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
                                var msg = "required property \"".concat(requiredKey, "\" is not defined at \"").concat(schemaPath, "\" (strictRequired)");
                                (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
                            }
                        }
                    }
                    function allErrorsMode() {
                        if (useLoop || $data) {
                            cxt.block$data(codegen_1.nil, loopAllRequired);
                        }
                        else {
                            for (var _1 = 0, schema_3 = schema; _1 < schema_3.length; _1++) {
                                var prop = schema_3[_1];
                                (0, code_1.checkReportMissingProp)(cxt, prop);
                            }
                        }
                    }
                    function exitOnErrorMode() {
                        var missing = gen.let("missing");
                        if (useLoop || $data) {
                            var valid_2 = gen.let("valid", true);
                            cxt.block$data(valid_2, function () { return loopUntilMissing(missing, valid_2); });
                            cxt.ok(valid_2);
                        }
                        else {
                            gen["if"]((0, code_1.checkMissingProp)(cxt, schema, missing));
                            (0, code_1.reportMissingProp)(cxt, missing);
                            gen["else"]();
                        }
                    }
                    function loopAllRequired() {
                        gen.forOf("prop", schemaCode, function (prop) {
                            cxt.setParams({ missingProperty: prop });
                            gen["if"]((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), function () { return cxt.error(); });
                        });
                    }
                    function loopUntilMissing(missing, valid) {
                        cxt.setParams({ missingProperty: missing });
                        gen.forOf(missing, schemaCode, function () {
                            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
                            gen["if"]((0, codegen_1.not)(valid), function () {
                                cxt.error();
                                gen["break"]();
                            });
                        }, codegen_1.nil);
                    }
                }
            };
            exports["default"] = def;
            //# sourceMappingURL=required.js.map
            /***/ 
        }),
        /***/ 9351: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var dataType_1 = __nccwpck_require__(7725);
            var codegen_1 = __nccwpck_require__(9179);
            var util_1 = __nccwpck_require__(3439);
            var equal_1 = __nccwpck_require__(3809);
            var error = {
                message: function (_1) {
                    var _2 = _1.params, i = _2.i, j = _2.j;
                    return (0, codegen_1.str)(__makeTemplateObject(["must NOT have duplicate items (items ## ", " and ", " are identical)"], ["must NOT have duplicate items (items ## ", " and ", " are identical)"]), j, i);
                },
                params: function (_1) {
                    var _2 = _1.params, i = _2.i, j = _2.j;
                    return (0, codegen_1._)(__makeTemplateObject(["{i: ", ", j: ", "}"], ["{i: ", ", j: ", "}"]), i, j);
                }
            };
            var def = {
                keyword: "uniqueItems",
                type: "array",
                schemaType: "boolean",
                $data: true,
                error: error,
                code: function (cxt) {
                    var gen = cxt.gen, data = cxt.data, $data = cxt.$data, schema = cxt.schema, parentSchema = cxt.parentSchema, schemaCode = cxt.schemaCode, it = cxt.it;
                    if (!$data && !schema)
                        return;
                    var valid = gen.let("valid");
                    var itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
                    cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)(__makeTemplateObject(["", " === false"], ["", " === false"]), schemaCode));
                    cxt.ok(valid);
                    function validateUniqueItems() {
                        var i = gen.let("i", (0, codegen_1._)(__makeTemplateObject(["", ".length"], ["", ".length"]), data));
                        var j = gen.let("j");
                        cxt.setParams({ i: i, j: j });
                        gen.assign(valid, true);
                        gen["if"]((0, codegen_1._)(__makeTemplateObject(["", " > 1"], ["", " > 1"]), i), function () { return (canOptimize() ? loopN : loopN2)(i, j); });
                    }
                    function canOptimize() {
                        return itemTypes.length > 0 && !itemTypes.some(function (t) { return t === "object" || t === "array"; });
                    }
                    function loopN(i, j) {
                        var item = gen.name("item");
                        var wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
                        var indices = gen["const"]("indices", (0, codegen_1._)(__makeTemplateObject(["{}"], ["{}"])));
                        gen["for"]((0, codegen_1._)(__makeTemplateObject([";", "--;"], [";", "--;"]), i), function () {
                            gen.let(item, (0, codegen_1._)(__makeTemplateObject(["", "[", "]"], ["", "[", "]"]), data, i));
                            gen["if"](wrongType, (0, codegen_1._)(__makeTemplateObject(["continue"], ["continue"])));
                            if (itemTypes.length > 1)
                                gen["if"]((0, codegen_1._)(__makeTemplateObject(["typeof ", " == \"string\""], ["typeof ", " == \"string\""]), item), (0, codegen_1._)(__makeTemplateObject(["", " += \"_\""], ["", " += \"_\""]), item));
                            gen["if"]((0, codegen_1._)(__makeTemplateObject(["typeof ", "[", "] == \"number\""], ["typeof ", "[", "] == \"number\""]), indices, item), function () {
                                gen.assign(j, (0, codegen_1._)(__makeTemplateObject(["", "[", "]"], ["", "[", "]"]), indices, item));
                                cxt.error();
                                gen.assign(valid, false)["break"]();
                            })
                                .code((0, codegen_1._)(__makeTemplateObject(["", "[", "] = ", ""], ["", "[", "] = ", ""]), indices, item, i));
                        });
                    }
                    function loopN2(i, j) {
                        var eql = (0, util_1.useFunc)(gen, equal_1["default"]);
                        var outer = gen.name("outer");
                        gen.label(outer)["for"]((0, codegen_1._)(__makeTemplateObject([";", "--;"], [";", "--;"]), i), function () { return gen["for"]((0, codegen_1._)(__makeTemplateObject(["", " = ", "; ", "--;"], ["", " = ", "; ", "--;"]), j, i, j), function () { return gen["if"]((0, codegen_1._)(__makeTemplateObject(["", "(", "[", "], ", "[", "])"], ["", "(", "[", "], ", "[", "])"]), eql, data, i, data, j), function () {
                            cxt.error();
                            gen.assign(valid, false)["break"](outer);
                        }); }); });
                    }
                }
            };
            exports["default"] = def;
            //# sourceMappingURL=uniqueItems.js.map
            /***/ 
        }),
        /***/ 2068: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            /* module decorator */ module = __nccwpck_require__.nmd(module);
            var wrapAnsi16 = function (fn, offset) { return function () {
                var args = [];
                for (var _1 = 0; _1 < arguments.length; _1++) {
                    args[_1] = arguments[_1];
                }
                var code = fn.apply(void 0, args);
                return "\u001B[".concat(code + offset, "m");
            }; };
            var wrapAnsi256 = function (fn, offset) { return function () {
                var args = [];
                for (var _1 = 0; _1 < arguments.length; _1++) {
                    args[_1] = arguments[_1];
                }
                var code = fn.apply(void 0, args);
                return "\u001B[".concat(38 + offset, ";5;").concat(code, "m");
            }; };
            var wrapAnsi16m = function (fn, offset) { return function () {
                var args = [];
                for (var _1 = 0; _1 < arguments.length; _1++) {
                    args[_1] = arguments[_1];
                }
                var rgb = fn.apply(void 0, args);
                return "\u001B[".concat(38 + offset, ";2;").concat(rgb[0], ";").concat(rgb[1], ";").concat(rgb[2], "m");
            }; };
            var ansi2ansi = function (n) { return n; };
            var rgb2rgb = function (r, g, b) { return [r, g, b]; };
            var setLazyProperty = function (object, property, get) {
                Object.defineProperty(object, property, {
                    get: function () {
                        var value = get();
                        Object.defineProperty(object, property, {
                            value: value,
                            enumerable: true,
                            configurable: true
                        });
                        return value;
                    },
                    enumerable: true,
                    configurable: true
                });
            };
            /** @type {typeof import('color-convert')} */
            var colorConvert;
            var makeDynamicStyles = function (wrap, targetSpace, identity, isBackground) {
                if (colorConvert === undefined) {
                    colorConvert = __nccwpck_require__(6931);
                }
                var offset = isBackground ? 10 : 0;
                var styles = {};
                for (var _1 = 0, _2 = Object.entries(colorConvert); _1 < _2.length; _1++) {
                    var _3 = _2[_1], sourceSpace = _3[0], suite = _3[1];
                    var name_4 = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;
                    if (sourceSpace === targetSpace) {
                        styles[name_4] = wrap(identity, offset);
                    }
                    else if (typeof suite === 'object') {
                        styles[name_4] = wrap(suite[targetSpace], offset);
                    }
                }
                return styles;
            };
            function assembleStyles() {
                var codes = new Map();
                var styles = {
                    modifier: {
                        reset: [0, 0],
                        // 21 isn't widely supported and 22 does the same thing
                        bold: [1, 22],
                        dim: [2, 22],
                        italic: [3, 23],
                        underline: [4, 24],
                        inverse: [7, 27],
                        hidden: [8, 28],
                        strikethrough: [9, 29]
                    },
                    color: {
                        black: [30, 39],
                        red: [31, 39],
                        green: [32, 39],
                        yellow: [33, 39],
                        blue: [34, 39],
                        magenta: [35, 39],
                        cyan: [36, 39],
                        white: [37, 39],
                        // Bright color
                        blackBright: [90, 39],
                        redBright: [91, 39],
                        greenBright: [92, 39],
                        yellowBright: [93, 39],
                        blueBright: [94, 39],
                        magentaBright: [95, 39],
                        cyanBright: [96, 39],
                        whiteBright: [97, 39]
                    },
                    bgColor: {
                        bgBlack: [40, 49],
                        bgRed: [41, 49],
                        bgGreen: [42, 49],
                        bgYellow: [43, 49],
                        bgBlue: [44, 49],
                        bgMagenta: [45, 49],
                        bgCyan: [46, 49],
                        bgWhite: [47, 49],
                        // Bright color
                        bgBlackBright: [100, 49],
                        bgRedBright: [101, 49],
                        bgGreenBright: [102, 49],
                        bgYellowBright: [103, 49],
                        bgBlueBright: [104, 49],
                        bgMagentaBright: [105, 49],
                        bgCyanBright: [106, 49],
                        bgWhiteBright: [107, 49]
                    }
                };
                // Alias bright black as gray (and grey)
                styles.color.gray = styles.color.blackBright;
                styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
                styles.color.grey = styles.color.blackBright;
                styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
                for (var _1 = 0, _2 = Object.entries(styles); _1 < _2.length; _1++) {
                    var _3 = _2[_1], groupName = _3[0], group = _3[1];
                    for (var _4 = 0, _5 = Object.entries(group); _4 < _5.length; _4++) {
                        var _6 = _5[_4], styleName = _6[0], style = _6[1];
                        styles[styleName] = {
                            open: "\u001B[".concat(style[0], "m"),
                            close: "\u001B[".concat(style[1], "m")
                        };
                        group[styleName] = styles[styleName];
                        codes.set(style[0], style[1]);
                    }
                    Object.defineProperty(styles, groupName, {
                        value: group,
                        enumerable: false
                    });
                }
                Object.defineProperty(styles, 'codes', {
                    value: codes,
                    enumerable: false
                });
                styles.color.close = '\u001B[39m';
                styles.bgColor.close = '\u001B[49m';
                setLazyProperty(styles.color, 'ansi', function () { return makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false); });
                setLazyProperty(styles.color, 'ansi256', function () { return makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false); });
                setLazyProperty(styles.color, 'ansi16m', function () { return makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false); });
                setLazyProperty(styles.bgColor, 'ansi', function () { return makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true); });
                setLazyProperty(styles.bgColor, 'ansi256', function () { return makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true); });
                setLazyProperty(styles.bgColor, 'ansi16m', function () { return makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true); });
                return styles;
            }
            // Make the export immutable
            Object.defineProperty(module, 'exports', {
                enumerable: true,
                get: assembleStyles
            });
            /***/ 
        }),
        /***/ 9417: 
        /***/ (function (module) {
            "use strict";
            module.exports = balanced;
            function balanced(a, b, str) {
                if (a instanceof RegExp)
                    a = maybeMatch(a, str);
                if (b instanceof RegExp)
                    b = maybeMatch(b, str);
                var r = range(a, b, str);
                return r && {
                    start: r[0],
                    end: r[1],
                    pre: str.slice(0, r[0]),
                    body: str.slice(r[0] + a.length, r[1]),
                    post: str.slice(r[1] + b.length)
                };
            }
            function maybeMatch(reg, str) {
                var m = str.match(reg);
                return m ? m[0] : null;
            }
            balanced.range = range;
            function range(a, b, str) {
                var begs, beg, left, right, result;
                var ai = str.indexOf(a);
                var bi = str.indexOf(b, ai + 1);
                var i = ai;
                if (ai >= 0 && bi > 0) {
                    if (a === b) {
                        return [ai, bi];
                    }
                    begs = [];
                    left = str.length;
                    while (i >= 0 && !result) {
                        if (i == ai) {
                            begs.push(i);
                            ai = str.indexOf(a, i + 1);
                        }
                        else if (begs.length == 1) {
                            result = [begs.pop(), bi];
                        }
                        else {
                            beg = begs.pop();
                            if (beg < left) {
                                left = beg;
                                right = bi;
                            }
                            bi = str.indexOf(b, i + 1);
                        }
                        i = ai < bi && ai >= 0 ? ai : bi;
                    }
                    if (begs.length) {
                        result = [left, right];
                    }
                }
                return result;
            }
            /***/ 
        }),
        /***/ 3682: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var register = __nccwpck_require__(4670);
            var addHook = __nccwpck_require__(5549);
            var removeHook = __nccwpck_require__(6819);
            // bind with array of arguments: https://stackoverflow.com/a/21792913
            var bind = Function.bind;
            var bindable = bind.bind(bind);
            function bindApi(hook, state, name) {
                var removeHookRef = bindable(removeHook, null).apply(null, name ? [state, name] : [state]);
                hook.api = { remove: removeHookRef };
                hook.remove = removeHookRef;
                ["before", "error", "after", "wrap"].forEach(function (kind) {
                    var args = name ? [state, kind, name] : [state, kind];
                    hook[kind] = hook.api[kind] = bindable(addHook, null).apply(null, args);
                });
            }
            function HookSingular() {
                var singularHookName = "h";
                var singularHookState = {
                    registry: {}
                };
                var singularHook = register.bind(null, singularHookState, singularHookName);
                bindApi(singularHook, singularHookState, singularHookName);
                return singularHook;
            }
            function HookCollection() {
                var state = {
                    registry: {}
                };
                var hook = register.bind(null, state);
                bindApi(hook, state);
                return hook;
            }
            var collectionHookDeprecationMessageDisplayed = false;
            function Hook() {
                if (!collectionHookDeprecationMessageDisplayed) {
                    console.warn('[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4');
                    collectionHookDeprecationMessageDisplayed = true;
                }
                return HookCollection();
            }
            Hook.Singular = HookSingular.bind();
            Hook.Collection = HookCollection.bind();
            module.exports = Hook;
            // expose constructors as a named property for TypeScript
            module.exports.Hook = Hook;
            module.exports.Singular = Hook.Singular;
            module.exports.Collection = Hook.Collection;
            /***/ 
        }),
        /***/ 5549: 
        /***/ (function (module) {
            module.exports = addHook;
            function addHook(state, kind, name, hook) {
                var orig = hook;
                if (!state.registry[name]) {
                    state.registry[name] = [];
                }
                if (kind === "before") {
                    hook = function (method, options) {
                        return Promise.resolve()
                            .then(orig.bind(null, options))
                            .then(method.bind(null, options));
                    };
                }
                if (kind === "after") {
                    hook = function (method, options) {
                        var result;
                        return Promise.resolve()
                            .then(method.bind(null, options))
                            .then(function (result_) {
                            result = result_;
                            return orig(result, options);
                        })
                            .then(function () {
                            return result;
                        });
                    };
                }
                if (kind === "error") {
                    hook = function (method, options) {
                        return Promise.resolve()
                            .then(method.bind(null, options))["catch"](function (error) {
                            return orig(error, options);
                        });
                    };
                }
                state.registry[name].push({
                    hook: hook,
                    orig: orig
                });
            }
            /***/ 
        }),
        /***/ 4670: 
        /***/ (function (module) {
            module.exports = register;
            function register(state, name, method, options) {
                if (typeof method !== "function") {
                    throw new Error("method for before hook must be a function");
                }
                if (!options) {
                    options = {};
                }
                if (Array.isArray(name)) {
                    return name.reverse().reduce(function (callback, name) {
                        return register.bind(null, state, name, callback, options);
                    }, method)();
                }
                return Promise.resolve().then(function () {
                    if (!state.registry[name]) {
                        return method(options);
                    }
                    return state.registry[name].reduce(function (method, registered) {
                        return registered.hook.bind(null, method, options);
                    }, method)();
                });
            }
            /***/ 
        }),
        /***/ 6819: 
        /***/ (function (module) {
            module.exports = removeHook;
            function removeHook(state, name, method) {
                if (!state.registry[name]) {
                    return;
                }
                var index = state.registry[name]
                    .map(function (registered) {
                    return registered.orig;
                })
                    .indexOf(method);
                if (index === -1) {
                    return;
                }
                state.registry[name].splice(index, 1);
            }
            /***/ 
        }),
        /***/ 3717: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var balanced = __nccwpck_require__(9417);
            module.exports = expandTop;
            var escSlash = '\0SLASH' + Math.random() + '\0';
            var escOpen = '\0OPEN' + Math.random() + '\0';
            var escClose = '\0CLOSE' + Math.random() + '\0';
            var escComma = '\0COMMA' + Math.random() + '\0';
            var escPeriod = '\0PERIOD' + Math.random() + '\0';
            function numeric(str) {
                return parseInt(str, 10) == str
                    ? parseInt(str, 10)
                    : str.charCodeAt(0);
            }
            function escapeBraces(str) {
                return str.split('\\\\').join(escSlash)
                    .split('\\{').join(escOpen)
                    .split('\\}').join(escClose)
                    .split('\\,').join(escComma)
                    .split('\\.').join(escPeriod);
            }
            function unescapeBraces(str) {
                return str.split(escSlash).join('\\')
                    .split(escOpen).join('{')
                    .split(escClose).join('}')
                    .split(escComma).join(',')
                    .split(escPeriod).join('.');
            }
            // Basically just str.split(","), but handling cases
            // where we have nested braced sections, which should be
            // treated as individual members, like {a,{b,c},d}
            function parseCommaParts(str) {
                if (!str)
                    return [''];
                var parts = [];
                var m = balanced('{', '}', str);
                if (!m)
                    return str.split(',');
                var pre = m.pre;
                var body = m.body;
                var post = m.post;
                var p = pre.split(',');
                p[p.length - 1] += '{' + body + '}';
                var postParts = parseCommaParts(post);
                if (post.length) {
                    p[p.length - 1] += postParts.shift();
                    p.push.apply(p, postParts);
                }
                parts.push.apply(parts, p);
                return parts;
            }
            function expandTop(str) {
                if (!str)
                    return [];
                // I don't know why Bash 4.3 does this, but it does.
                // Anything starting with {} will have the first two bytes preserved
                // but *only* at the top level, so {},a}b will not expand to anything,
                // but a{},b}c will be expanded to [a}c,abc].
                // One could argue that this is a bug in Bash, but since the goal of
                // this module is to match Bash's rules, we escape a leading {}
                if (str.substr(0, 2) === '{}') {
                    str = '\\{\\}' + str.substr(2);
                }
                return expand(escapeBraces(str), true).map(unescapeBraces);
            }
            function embrace(str) {
                return '{' + str + '}';
            }
            function isPadded(el) {
                return /^-?0\d/.test(el);
            }
            function lte(i, y) {
                return i <= y;
            }
            function gte(i, y) {
                return i >= y;
            }
            function expand(str, isTop) {
                var expansions = [];
                var m = balanced('{', '}', str);
                if (!m)
                    return [str];
                // no need to expand pre, since it is guaranteed to be free of brace-sets
                var pre = m.pre;
                var post = m.post.length
                    ? expand(m.post, false)
                    : [''];
                if (/\$$/.test(m.pre)) {
                    for (var k = 0; k < post.length; k++) {
                        var expansion = pre + '{' + m.body + '}' + post[k];
                        expansions.push(expansion);
                    }
                }
                else {
                    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
                    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
                    var isSequence = isNumericSequence || isAlphaSequence;
                    var isOptions = m.body.indexOf(',') >= 0;
                    if (!isSequence && !isOptions) {
                        // {a},b}
                        if (m.post.match(/,.*\}/)) {
                            str = m.pre + '{' + m.body + escClose + m.post;
                            return expand(str);
                        }
                        return [str];
                    }
                    var n;
                    if (isSequence) {
                        n = m.body.split(/\.\./);
                    }
                    else {
                        n = parseCommaParts(m.body);
                        if (n.length === 1) {
                            // x{{a,b}}y ==> x{a}y x{b}y
                            n = expand(n[0], false).map(embrace);
                            if (n.length === 1) {
                                return post.map(function (p) {
                                    return m.pre + n[0] + p;
                                });
                            }
                        }
                    }
                    // at this point, n is the parts, and we know it's not a comma set
                    // with a single entry.
                    var N;
                    if (isSequence) {
                        var x = numeric(n[0]);
                        var y = numeric(n[1]);
                        var width = Math.max(n[0].length, n[1].length);
                        var incr = n.length == 3
                            ? Math.abs(numeric(n[2]))
                            : 1;
                        var test = lte;
                        var reverse = y < x;
                        if (reverse) {
                            incr *= -1;
                            test = gte;
                        }
                        var pad = n.some(isPadded);
                        N = [];
                        for (var i = x; test(i, y); i += incr) {
                            var c;
                            if (isAlphaSequence) {
                                c = String.fromCharCode(i);
                                if (c === '\\')
                                    c = '';
                            }
                            else {
                                c = String(i);
                                if (pad) {
                                    var need = width - c.length;
                                    if (need > 0) {
                                        var z = new Array(need + 1).join('0');
                                        if (i < 0)
                                            c = '-' + z + c.slice(1);
                                        else
                                            c = z + c;
                                    }
                                }
                            }
                            N.push(c);
                        }
                    }
                    else {
                        N = [];
                        for (var j = 0; j < n.length; j++) {
                            N.push.apply(N, expand(n[j], false));
                        }
                    }
                    for (var j = 0; j < N.length; j++) {
                        for (var k = 0; k < post.length; k++) {
                            var expansion = pre + N[j] + post[k];
                            if (!isTop || isSequence || expansion)
                                expansions.push(expansion);
                        }
                    }
                }
                return expansions;
            }
            /***/ 
        }),
        /***/ 8707: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var escapeStringRegexp = __nccwpck_require__(8691);
            var ansiStyles = __nccwpck_require__(6734);
            var stdoutColor = (__nccwpck_require__(9318).stdout);
            var template = __nccwpck_require__(2138);
            var isSimpleWindowsTerm = process.platform === 'win32' && !(process.env.TERM || '').toLowerCase().startsWith('xterm');
            // `supportsColor.level`  `ansiStyles.color[name]` mapping
            var levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];
            // `color-convert` models to exclude from the Chalk API due to conflicts and such
            var skipModels = new Set(['gray']);
            var styles = Object.create(null);
            function applyOptions(obj, options) {
                options = options || {};
                // Detect level if not set manually
                var scLevel = stdoutColor ? stdoutColor.level : 0;
                obj.level = options.level === undefined ? scLevel : options.level;
                obj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;
            }
            function Chalk(options) {
                // We check for this.template here since calling `chalk.constructor()`
                // by itself will have a `this` of a previously constructed chalk object
                if (!this || !(this instanceof Chalk) || this.template) {
                    var chalk_1 = {};
                    applyOptions(chalk_1, options);
                    chalk_1.template = function () {
                        var args = [].slice.call(arguments);
                        return chalkTag.apply(null, [chalk_1.template].concat(args));
                    };
                    Object.setPrototypeOf(chalk_1, Chalk.prototype);
                    Object.setPrototypeOf(chalk_1.template, chalk_1);
                    chalk_1.template.constructor = Chalk;
                    return chalk_1.template;
                }
                applyOptions(this, options);
            }
            // Use bright blue on Windows as the normal blue color is illegible
            if (isSimpleWindowsTerm) {
                ansiStyles.blue.open = '\u001B[94m';
            }
            var _loop_8 = function (key) {
                ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
                styles[key] = {
                    get: function () {
                        var codes = ansiStyles[key];
                        return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
                    }
                };
            };
            for (var _1 = 0, _2 = Object.keys(ansiStyles); _1 < _2.length; _1++) {
                var key = _2[_1];
                _loop_8(key);
            }
            styles.visible = {
                get: function () {
                    return build.call(this, this._styles || [], true, 'visible');
                }
            };
            ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), 'g');
            var _loop_9 = function (model) {
                if (skipModels.has(model)) {
                    return "continue";
                }
                styles[model] = {
                    get: function () {
                        var level = this.level;
                        return function () {
                            var open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
                            var codes = {
                                open: open,
                                close: ansiStyles.color.close,
                                closeRe: ansiStyles.color.closeRe
                            };
                            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
                        };
                    }
                };
            };
            for (var _3 = 0, _4 = Object.keys(ansiStyles.color.ansi); _3 < _4.length; _3++) {
                var model = _4[_3];
                _loop_9(model);
            }
            ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), 'g');
            var _loop_10 = function (model) {
                if (skipModels.has(model)) {
                    return "continue";
                }
                var bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
                styles[bgModel] = {
                    get: function () {
                        var level = this.level;
                        return function () {
                            var open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
                            var codes = {
                                open: open,
                                close: ansiStyles.bgColor.close,
                                closeRe: ansiStyles.bgColor.closeRe
                            };
                            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
                        };
                    }
                };
            };
            for (var _5 = 0, _6 = Object.keys(ansiStyles.bgColor.ansi); _5 < _6.length; _5++) {
                var model = _6[_5];
                _loop_10(model);
            }
            var proto = Object.defineProperties(function () { }, styles);
            function build(_styles, _empty, key) {
                var builder = function () {
                    return applyStyle.apply(builder, arguments);
                };
                builder._styles = _styles;
                builder._empty = _empty;
                var self = this;
                Object.defineProperty(builder, 'level', {
                    enumerable: true,
                    get: function () {
                        return self.level;
                    },
                    set: function (level) {
                        self.level = level;
                    }
                });
                Object.defineProperty(builder, 'enabled', {
                    enumerable: true,
                    get: function () {
                        return self.enabled;
                    },
                    set: function (enabled) {
                        self.enabled = enabled;
                    }
                });
                // See below for fix regarding invisible grey/dim combination on Windows
                builder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey';
                // `__proto__` is used because we must return a function, but there is
                // no way to create a function with a different prototype
                builder.__proto__ = proto; // eslint-disable-line no-proto
                return builder;
            }
            function applyStyle() {
                // Support varags, but simply cast to string in case there's only one arg
                var args = arguments;
                var argsLen = args.length;
                var str = String(arguments[0]);
                if (argsLen === 0) {
                    return '';
                }
                if (argsLen > 1) {
                    // Don't slice `arguments`, it prevents V8 optimizations
                    for (var a = 1; a < argsLen; a++) {
                        str += ' ' + args[a];
                    }
                }
                if (!this.enabled || this.level <= 0 || !str) {
                    return this._empty ? '' : str;
                }
                // Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
                // see https://github.com/chalk/chalk/issues/58
                // If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
                var originalDim = ansiStyles.dim.open;
                if (isSimpleWindowsTerm && this.hasGrey) {
                    ansiStyles.dim.open = '';
                }
                for (var _1 = 0, _2 = this._styles.slice().reverse(); _1 < _2.length; _1++) {
                    var code = _2[_1];
                    // Replace any instances already present with a re-opening code
                    // otherwise only the part of the string until said closing code
                    // will be colored, and the rest will simply be 'plain'.
                    str = code.open + str.replace(code.closeRe, code.open) + code.close;
                    // Close the styling before a linebreak and reopen
                    // after next line to fix a bleed issue on macOS
                    // https://github.com/chalk/chalk/pull/92
                    str = str.replace(/\r?\n/g, "".concat(code.close, "$&").concat(code.open));
                }
                // Reset the original `dim` if we changed it to work around the Windows dimmed gray issue
                ansiStyles.dim.open = originalDim;
                return str;
            }
            function chalkTag(chalk, strings) {
                if (!Array.isArray(strings)) {
                    // If chalk() was called by itself or with a string,
                    // return the string itself as a string.
                    return [].slice.call(arguments, 1).join(' ');
                }
                var args = [].slice.call(arguments, 2);
                var parts = [strings.raw[0]];
                for (var i = 1; i < strings.length; i++) {
                    parts.push(String(args[i - 1]).replace(/[{}\\]/g, '\\$&'));
                    parts.push(String(strings.raw[i]));
                }
                return template(chalk, parts.join(''));
            }
            Object.defineProperties(Chalk.prototype, styles);
            module.exports = Chalk(); // eslint-disable-line new-cap
            module.exports.supportsColor = stdoutColor;
            module.exports["default"] = module.exports; // For TypeScript
            /***/ 
        }),
        /***/ 6734: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            /* module decorator */ module = __nccwpck_require__.nmd(module);
            var colorConvert = __nccwpck_require__(5121);
            var wrapAnsi16 = function (fn, offset) { return function () {
                var code = fn.apply(colorConvert, arguments);
                return "\u001B[".concat(code + offset, "m");
            }; };
            var wrapAnsi256 = function (fn, offset) { return function () {
                var code = fn.apply(colorConvert, arguments);
                return "\u001B[".concat(38 + offset, ";5;").concat(code, "m");
            }; };
            var wrapAnsi16m = function (fn, offset) { return function () {
                var rgb = fn.apply(colorConvert, arguments);
                return "\u001B[".concat(38 + offset, ";2;").concat(rgb[0], ";").concat(rgb[1], ";").concat(rgb[2], "m");
            }; };
            function assembleStyles() {
                var codes = new Map();
                var styles = {
                    modifier: {
                        reset: [0, 0],
                        // 21 isn't widely supported and 22 does the same thing
                        bold: [1, 22],
                        dim: [2, 22],
                        italic: [3, 23],
                        underline: [4, 24],
                        inverse: [7, 27],
                        hidden: [8, 28],
                        strikethrough: [9, 29]
                    },
                    color: {
                        black: [30, 39],
                        red: [31, 39],
                        green: [32, 39],
                        yellow: [33, 39],
                        blue: [34, 39],
                        magenta: [35, 39],
                        cyan: [36, 39],
                        white: [37, 39],
                        gray: [90, 39],
                        // Bright color
                        redBright: [91, 39],
                        greenBright: [92, 39],
                        yellowBright: [93, 39],
                        blueBright: [94, 39],
                        magentaBright: [95, 39],
                        cyanBright: [96, 39],
                        whiteBright: [97, 39]
                    },
                    bgColor: {
                        bgBlack: [40, 49],
                        bgRed: [41, 49],
                        bgGreen: [42, 49],
                        bgYellow: [43, 49],
                        bgBlue: [44, 49],
                        bgMagenta: [45, 49],
                        bgCyan: [46, 49],
                        bgWhite: [47, 49],
                        // Bright color
                        bgBlackBright: [100, 49],
                        bgRedBright: [101, 49],
                        bgGreenBright: [102, 49],
                        bgYellowBright: [103, 49],
                        bgBlueBright: [104, 49],
                        bgMagentaBright: [105, 49],
                        bgCyanBright: [106, 49],
                        bgWhiteBright: [107, 49]
                    }
                };
                // Fix humans
                styles.color.grey = styles.color.gray;
                for (var _1 = 0, _2 = Object.keys(styles); _1 < _2.length; _1++) {
                    var groupName = _2[_1];
                    var group = styles[groupName];
                    for (var _3 = 0, _4 = Object.keys(group); _3 < _4.length; _3++) {
                        var styleName = _4[_3];
                        var style = group[styleName];
                        styles[styleName] = {
                            open: "\u001B[".concat(style[0], "m"),
                            close: "\u001B[".concat(style[1], "m")
                        };
                        group[styleName] = styles[styleName];
                        codes.set(style[0], style[1]);
                    }
                    Object.defineProperty(styles, groupName, {
                        value: group,
                        enumerable: false
                    });
                    Object.defineProperty(styles, 'codes', {
                        value: codes,
                        enumerable: false
                    });
                }
                var ansi2ansi = function (n) { return n; };
                var rgb2rgb = function (r, g, b) { return [r, g, b]; };
                styles.color.close = '\u001B[39m';
                styles.bgColor.close = '\u001B[49m';
                styles.color.ansi = {
                    ansi: wrapAnsi16(ansi2ansi, 0)
                };
                styles.color.ansi256 = {
                    ansi256: wrapAnsi256(ansi2ansi, 0)
                };
                styles.color.ansi16m = {
                    rgb: wrapAnsi16m(rgb2rgb, 0)
                };
                styles.bgColor.ansi = {
                    ansi: wrapAnsi16(ansi2ansi, 10)
                };
                styles.bgColor.ansi256 = {
                    ansi256: wrapAnsi256(ansi2ansi, 10)
                };
                styles.bgColor.ansi16m = {
                    rgb: wrapAnsi16m(rgb2rgb, 10)
                };
                for (var _5 = 0, _6 = Object.keys(colorConvert); _5 < _6.length; _5++) {
                    var key = _6[_5];
                    if (typeof colorConvert[key] !== 'object') {
                        continue;
                    }
                    var suite = colorConvert[key];
                    if (key === 'ansi16') {
                        key = 'ansi';
                    }
                    if ('ansi16' in suite) {
                        styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
                        styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
                    }
                    if ('ansi256' in suite) {
                        styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
                        styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
                    }
                    if ('rgb' in suite) {
                        styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
                        styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
                    }
                }
                return styles;
            }
            // Make the export immutable
            Object.defineProperty(module, 'exports', {
                enumerable: true,
                get: assembleStyles
            });
            /***/ 
        }),
        /***/ 8159: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            /* MIT license */
            var cssKeywords = __nccwpck_require__(4057);
            // NOTE: conversions should only return primitive values (i.e. arrays, or
            //       values that give correct `typeof` results).
            //       do not use box values types (i.e. Number(), String(), etc.)
            var reverseKeywords = {};
            for (var key in cssKeywords) {
                if (cssKeywords.hasOwnProperty(key)) {
                    reverseKeywords[cssKeywords[key]] = key;
                }
            }
            var convert = module.exports = {
                rgb: { channels: 3, labels: 'rgb' },
                hsl: { channels: 3, labels: 'hsl' },
                hsv: { channels: 3, labels: 'hsv' },
                hwb: { channels: 3, labels: 'hwb' },
                cmyk: { channels: 4, labels: 'cmyk' },
                xyz: { channels: 3, labels: 'xyz' },
                lab: { channels: 3, labels: 'lab' },
                lch: { channels: 3, labels: 'lch' },
                hex: { channels: 1, labels: ['hex'] },
                keyword: { channels: 1, labels: ['keyword'] },
                ansi16: { channels: 1, labels: ['ansi16'] },
                ansi256: { channels: 1, labels: ['ansi256'] },
                hcg: { channels: 3, labels: ['h', 'c', 'g'] },
                apple: { channels: 3, labels: ['r16', 'g16', 'b16'] },
                gray: { channels: 1, labels: ['gray'] }
            };
            // hide .channels and .labels properties
            for (var model in convert) {
                if (convert.hasOwnProperty(model)) {
                    if (!('channels' in convert[model])) {
                        throw new Error('missing channels property: ' + model);
                    }
                    if (!('labels' in convert[model])) {
                        throw new Error('missing channel labels property: ' + model);
                    }
                    if (convert[model].labels.length !== convert[model].channels) {
                        throw new Error('channel and label counts mismatch: ' + model);
                    }
                    var channels = convert[model].channels;
                    var labels = convert[model].labels;
                    delete convert[model].channels;
                    delete convert[model].labels;
                    Object.defineProperty(convert[model], 'channels', { value: channels });
                    Object.defineProperty(convert[model], 'labels', { value: labels });
                }
            }
            convert.rgb.hsl = function (rgb) {
                var r = rgb[0] / 255;
                var g = rgb[1] / 255;
                var b = rgb[2] / 255;
                var min = Math.min(r, g, b);
                var max = Math.max(r, g, b);
                var delta = max - min;
                var h;
                var s;
                var l;
                if (max === min) {
                    h = 0;
                }
                else if (r === max) {
                    h = (g - b) / delta;
                }
                else if (g === max) {
                    h = 2 + (b - r) / delta;
                }
                else if (b === max) {
                    h = 4 + (r - g) / delta;
                }
                h = Math.min(h * 60, 360);
                if (h < 0) {
                    h += 360;
                }
                l = (min + max) / 2;
                if (max === min) {
                    s = 0;
                }
                else if (l <= 0.5) {
                    s = delta / (max + min);
                }
                else {
                    s = delta / (2 - max - min);
                }
                return [h, s * 100, l * 100];
            };
            convert.rgb.hsv = function (rgb) {
                var rdif;
                var gdif;
                var bdif;
                var h;
                var s;
                var r = rgb[0] / 255;
                var g = rgb[1] / 255;
                var b = rgb[2] / 255;
                var v = Math.max(r, g, b);
                var diff = v - Math.min(r, g, b);
                var diffc = function (c) {
                    return (v - c) / 6 / diff + 1 / 2;
                };
                if (diff === 0) {
                    h = s = 0;
                }
                else {
                    s = diff / v;
                    rdif = diffc(r);
                    gdif = diffc(g);
                    bdif = diffc(b);
                    if (r === v) {
                        h = bdif - gdif;
                    }
                    else if (g === v) {
                        h = (1 / 3) + rdif - bdif;
                    }
                    else if (b === v) {
                        h = (2 / 3) + gdif - rdif;
                    }
                    if (h < 0) {
                        h += 1;
                    }
                    else if (h > 1) {
                        h -= 1;
                    }
                }
                return [
                    h * 360,
                    s * 100,
                    v * 100
                ];
            };
            convert.rgb.hwb = function (rgb) {
                var r = rgb[0];
                var g = rgb[1];
                var b = rgb[2];
                var h = convert.rgb.hsl(rgb)[0];
                var w = 1 / 255 * Math.min(r, Math.min(g, b));
                b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
                return [h, w * 100, b * 100];
            };
            convert.rgb.cmyk = function (rgb) {
                var r = rgb[0] / 255;
                var g = rgb[1] / 255;
                var b = rgb[2] / 255;
                var c;
                var m;
                var y;
                var k;
                k = Math.min(1 - r, 1 - g, 1 - b);
                c = (1 - r - k) / (1 - k) || 0;
                m = (1 - g - k) / (1 - k) || 0;
                y = (1 - b - k) / (1 - k) || 0;
                return [c * 100, m * 100, y * 100, k * 100];
            };
            /**
             * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
             * */
            function comparativeDistance(x, y) {
                return (Math.pow(x[0] - y[0], 2) +
                    Math.pow(x[1] - y[1], 2) +
                    Math.pow(x[2] - y[2], 2));
            }
            convert.rgb.keyword = function (rgb) {
                var reversed = reverseKeywords[rgb];
                if (reversed) {
                    return reversed;
                }
                var currentClosestDistance = Infinity;
                var currentClosestKeyword;
                for (var keyword in cssKeywords) {
                    if (cssKeywords.hasOwnProperty(keyword)) {
                        var value = cssKeywords[keyword];
                        // Compute comparative distance
                        var distance = comparativeDistance(rgb, value);
                        // Check if its less, if so set as closest
                        if (distance < currentClosestDistance) {
                            currentClosestDistance = distance;
                            currentClosestKeyword = keyword;
                        }
                    }
                }
                return currentClosestKeyword;
            };
            convert.keyword.rgb = function (keyword) {
                return cssKeywords[keyword];
            };
            convert.rgb.xyz = function (rgb) {
                var r = rgb[0] / 255;
                var g = rgb[1] / 255;
                var b = rgb[2] / 255;
                // assume sRGB
                r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
                g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
                b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);
                var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
                var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
                var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);
                return [x * 100, y * 100, z * 100];
            };
            convert.rgb.lab = function (rgb) {
                var xyz = convert.rgb.xyz(rgb);
                var x = xyz[0];
                var y = xyz[1];
                var z = xyz[2];
                var l;
                var a;
                var b;
                x /= 95.047;
                y /= 100;
                z /= 108.883;
                x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
                y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
                z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);
                l = (116 * y) - 16;
                a = 500 * (x - y);
                b = 200 * (y - z);
                return [l, a, b];
            };
            convert.hsl.rgb = function (hsl) {
                var h = hsl[0] / 360;
                var s = hsl[1] / 100;
                var l = hsl[2] / 100;
                var t1;
                var t2;
                var t3;
                var rgb;
                var val;
                if (s === 0) {
                    val = l * 255;
                    return [val, val, val];
                }
                if (l < 0.5) {
                    t2 = l * (1 + s);
                }
                else {
                    t2 = l + s - l * s;
                }
                t1 = 2 * l - t2;
                rgb = [0, 0, 0];
                for (var i = 0; i < 3; i++) {
                    t3 = h + 1 / 3 * -(i - 1);
                    if (t3 < 0) {
                        t3++;
                    }
                    if (t3 > 1) {
                        t3--;
                    }
                    if (6 * t3 < 1) {
                        val = t1 + (t2 - t1) * 6 * t3;
                    }
                    else if (2 * t3 < 1) {
                        val = t2;
                    }
                    else if (3 * t3 < 2) {
                        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
                    }
                    else {
                        val = t1;
                    }
                    rgb[i] = val * 255;
                }
                return rgb;
            };
            convert.hsl.hsv = function (hsl) {
                var h = hsl[0];
                var s = hsl[1] / 100;
                var l = hsl[2] / 100;
                var smin = s;
                var lmin = Math.max(l, 0.01);
                var sv;
                var v;
                l *= 2;
                s *= (l <= 1) ? l : 2 - l;
                smin *= lmin <= 1 ? lmin : 2 - lmin;
                v = (l + s) / 2;
                sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);
                return [h, sv * 100, v * 100];
            };
            convert.hsv.rgb = function (hsv) {
                var h = hsv[0] / 60;
                var s = hsv[1] / 100;
                var v = hsv[2] / 100;
                var hi = Math.floor(h) % 6;
                var f = h - Math.floor(h);
                var p = 255 * v * (1 - s);
                var q = 255 * v * (1 - (s * f));
                var t = 255 * v * (1 - (s * (1 - f)));
                v *= 255;
                switch (hi) {
                    case 0:
                        return [v, t, p];
                    case 1:
                        return [q, v, p];
                    case 2:
                        return [p, v, t];
                    case 3:
                        return [p, q, v];
                    case 4:
                        return [t, p, v];
                    case 5:
                        return [v, p, q];
                }
            };
            convert.hsv.hsl = function (hsv) {
                var h = hsv[0];
                var s = hsv[1] / 100;
                var v = hsv[2] / 100;
                var vmin = Math.max(v, 0.01);
                var lmin;
                var sl;
                var l;
                l = (2 - s) * v;
                lmin = (2 - s) * vmin;
                sl = s * vmin;
                sl /= (lmin <= 1) ? lmin : 2 - lmin;
                sl = sl || 0;
                l /= 2;
                return [h, sl * 100, l * 100];
            };
            // http://dev.w3.org/csswg/css-color/#hwb-to-rgb
            convert.hwb.rgb = function (hwb) {
                var h = hwb[0] / 360;
                var wh = hwb[1] / 100;
                var bl = hwb[2] / 100;
                var ratio = wh + bl;
                var i;
                var v;
                var f;
                var n;
                // wh + bl cant be > 1
                if (ratio > 1) {
                    wh /= ratio;
                    bl /= ratio;
                }
                i = Math.floor(6 * h);
                v = 1 - bl;
                f = 6 * h - i;
                if ((i & 0x01) !== 0) {
                    f = 1 - f;
                }
                n = wh + f * (v - wh); // linear interpolation
                var r;
                var g;
                var b;
                switch (i) {
                    default:
                    case 6:
                    case 0:
                        r = v;
                        g = n;
                        b = wh;
                        break;
                    case 1:
                        r = n;
                        g = v;
                        b = wh;
                        break;
                    case 2:
                        r = wh;
                        g = v;
                        b = n;
                        break;
                    case 3:
                        r = wh;
                        g = n;
                        b = v;
                        break;
                    case 4:
                        r = n;
                        g = wh;
                        b = v;
                        break;
                    case 5:
                        r = v;
                        g = wh;
                        b = n;
                        break;
                }
                return [r * 255, g * 255, b * 255];
            };
            convert.cmyk.rgb = function (cmyk) {
                var c = cmyk[0] / 100;
                var m = cmyk[1] / 100;
                var y = cmyk[2] / 100;
                var k = cmyk[3] / 100;
                var r;
                var g;
                var b;
                r = 1 - Math.min(1, c * (1 - k) + k);
                g = 1 - Math.min(1, m * (1 - k) + k);
                b = 1 - Math.min(1, y * (1 - k) + k);
                return [r * 255, g * 255, b * 255];
            };
            convert.xyz.rgb = function (xyz) {
                var x = xyz[0] / 100;
                var y = xyz[1] / 100;
                var z = xyz[2] / 100;
                var r;
                var g;
                var b;
                r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
                g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
                b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);
                // assume sRGB
                r = r > 0.0031308
                    ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
                    : r * 12.92;
                g = g > 0.0031308
                    ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
                    : g * 12.92;
                b = b > 0.0031308
                    ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
                    : b * 12.92;
                r = Math.min(Math.max(0, r), 1);
                g = Math.min(Math.max(0, g), 1);
                b = Math.min(Math.max(0, b), 1);
                return [r * 255, g * 255, b * 255];
            };
            convert.xyz.lab = function (xyz) {
                var x = xyz[0];
                var y = xyz[1];
                var z = xyz[2];
                var l;
                var a;
                var b;
                x /= 95.047;
                y /= 100;
                z /= 108.883;
                x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
                y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
                z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);
                l = (116 * y) - 16;
                a = 500 * (x - y);
                b = 200 * (y - z);
                return [l, a, b];
            };
            convert.lab.xyz = function (lab) {
                var l = lab[0];
                var a = lab[1];
                var b = lab[2];
                var x;
                var y;
                var z;
                y = (l + 16) / 116;
                x = a / 500 + y;
                z = y - b / 200;
                var y2 = Math.pow(y, 3);
                var x2 = Math.pow(x, 3);
                var z2 = Math.pow(z, 3);
                y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
                x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
                z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
                x *= 95.047;
                y *= 100;
                z *= 108.883;
                return [x, y, z];
            };
            convert.lab.lch = function (lab) {
                var l = lab[0];
                var a = lab[1];
                var b = lab[2];
                var hr;
                var h;
                var c;
                hr = Math.atan2(b, a);
                h = hr * 360 / 2 / Math.PI;
                if (h < 0) {
                    h += 360;
                }
                c = Math.sqrt(a * a + b * b);
                return [l, c, h];
            };
            convert.lch.lab = function (lch) {
                var l = lch[0];
                var c = lch[1];
                var h = lch[2];
                var a;
                var b;
                var hr;
                hr = h / 360 * 2 * Math.PI;
                a = c * Math.cos(hr);
                b = c * Math.sin(hr);
                return [l, a, b];
            };
            convert.rgb.ansi16 = function (args) {
                var r = args[0];
                var g = args[1];
                var b = args[2];
                var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization
                value = Math.round(value / 50);
                if (value === 0) {
                    return 30;
                }
                var ansi = 30
                    + ((Math.round(b / 255) << 2)
                        | (Math.round(g / 255) << 1)
                        | Math.round(r / 255));
                if (value === 2) {
                    ansi += 60;
                }
                return ansi;
            };
            convert.hsv.ansi16 = function (args) {
                // optimization here; we already know the value and don't need to get
                // it converted for us.
                return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
            };
            convert.rgb.ansi256 = function (args) {
                var r = args[0];
                var g = args[1];
                var b = args[2];
                // we use the extended greyscale palette here, with the exception of
                // black and white. normal palette only has 4 greyscale shades.
                if (r === g && g === b) {
                    if (r < 8) {
                        return 16;
                    }
                    if (r > 248) {
                        return 231;
                    }
                    return Math.round(((r - 8) / 247) * 24) + 232;
                }
                var ansi = 16
                    + (36 * Math.round(r / 255 * 5))
                    + (6 * Math.round(g / 255 * 5))
                    + Math.round(b / 255 * 5);
                return ansi;
            };
            convert.ansi16.rgb = function (args) {
                var color = args % 10;
                // handle greyscale
                if (color === 0 || color === 7) {
                    if (args > 50) {
                        color += 3.5;
                    }
                    color = color / 10.5 * 255;
                    return [color, color, color];
                }
                var mult = (~~(args > 50) + 1) * 0.5;
                var r = ((color & 1) * mult) * 255;
                var g = (((color >> 1) & 1) * mult) * 255;
                var b = (((color >> 2) & 1) * mult) * 255;
                return [r, g, b];
            };
            convert.ansi256.rgb = function (args) {
                // handle greyscale
                if (args >= 232) {
                    var c = (args - 232) * 10 + 8;
                    return [c, c, c];
                }
                args -= 16;
                var rem;
                var r = Math.floor(args / 36) / 5 * 255;
                var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
                var b = (rem % 6) / 5 * 255;
                return [r, g, b];
            };
            convert.rgb.hex = function (args) {
                var integer = ((Math.round(args[0]) & 0xFF) << 16)
                    + ((Math.round(args[1]) & 0xFF) << 8)
                    + (Math.round(args[2]) & 0xFF);
                var string = integer.toString(16).toUpperCase();
                return '000000'.substring(string.length) + string;
            };
            convert.hex.rgb = function (args) {
                var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
                if (!match) {
                    return [0, 0, 0];
                }
                var colorString = match[0];
                if (match[0].length === 3) {
                    colorString = colorString.split('').map(function (char) {
                        return char + char;
                    }).join('');
                }
                var integer = parseInt(colorString, 16);
                var r = (integer >> 16) & 0xFF;
                var g = (integer >> 8) & 0xFF;
                var b = integer & 0xFF;
                return [r, g, b];
            };
            convert.rgb.hcg = function (rgb) {
                var r = rgb[0] / 255;
                var g = rgb[1] / 255;
                var b = rgb[2] / 255;
                var max = Math.max(Math.max(r, g), b);
                var min = Math.min(Math.min(r, g), b);
                var chroma = (max - min);
                var grayscale;
                var hue;
                if (chroma < 1) {
                    grayscale = min / (1 - chroma);
                }
                else {
                    grayscale = 0;
                }
                if (chroma <= 0) {
                    hue = 0;
                }
                else if (max === r) {
                    hue = ((g - b) / chroma) % 6;
                }
                else if (max === g) {
                    hue = 2 + (b - r) / chroma;
                }
                else {
                    hue = 4 + (r - g) / chroma + 4;
                }
                hue /= 6;
                hue %= 1;
                return [hue * 360, chroma * 100, grayscale * 100];
            };
            convert.hsl.hcg = function (hsl) {
                var s = hsl[1] / 100;
                var l = hsl[2] / 100;
                var c = 1;
                var f = 0;
                if (l < 0.5) {
                    c = 2.0 * s * l;
                }
                else {
                    c = 2.0 * s * (1.0 - l);
                }
                if (c < 1.0) {
                    f = (l - 0.5 * c) / (1.0 - c);
                }
                return [hsl[0], c * 100, f * 100];
            };
            convert.hsv.hcg = function (hsv) {
                var s = hsv[1] / 100;
                var v = hsv[2] / 100;
                var c = s * v;
                var f = 0;
                if (c < 1.0) {
                    f = (v - c) / (1 - c);
                }
                return [hsv[0], c * 100, f * 100];
            };
            convert.hcg.rgb = function (hcg) {
                var h = hcg[0] / 360;
                var c = hcg[1] / 100;
                var g = hcg[2] / 100;
                if (c === 0.0) {
                    return [g * 255, g * 255, g * 255];
                }
                var pure = [0, 0, 0];
                var hi = (h % 1) * 6;
                var v = hi % 1;
                var w = 1 - v;
                var mg = 0;
                switch (Math.floor(hi)) {
                    case 0:
                        pure[0] = 1;
                        pure[1] = v;
                        pure[2] = 0;
                        break;
                    case 1:
                        pure[0] = w;
                        pure[1] = 1;
                        pure[2] = 0;
                        break;
                    case 2:
                        pure[0] = 0;
                        pure[1] = 1;
                        pure[2] = v;
                        break;
                    case 3:
                        pure[0] = 0;
                        pure[1] = w;
                        pure[2] = 1;
                        break;
                    case 4:
                        pure[0] = v;
                        pure[1] = 0;
                        pure[2] = 1;
                        break;
                    default:
                        pure[0] = 1;
                        pure[1] = 0;
                        pure[2] = w;
                }
                mg = (1.0 - c) * g;
                return [
                    (c * pure[0] + mg) * 255,
                    (c * pure[1] + mg) * 255,
                    (c * pure[2] + mg) * 255
                ];
            };
            convert.hcg.hsv = function (hcg) {
                var c = hcg[1] / 100;
                var g = hcg[2] / 100;
                var v = c + g * (1.0 - c);
                var f = 0;
                if (v > 0.0) {
                    f = c / v;
                }
                return [hcg[0], f * 100, v * 100];
            };
            convert.hcg.hsl = function (hcg) {
                var c = hcg[1] / 100;
                var g = hcg[2] / 100;
                var l = g * (1.0 - c) + 0.5 * c;
                var s = 0;
                if (l > 0.0 && l < 0.5) {
                    s = c / (2 * l);
                }
                else if (l >= 0.5 && l < 1.0) {
                    s = c / (2 * (1 - l));
                }
                return [hcg[0], s * 100, l * 100];
            };
            convert.hcg.hwb = function (hcg) {
                var c = hcg[1] / 100;
                var g = hcg[2] / 100;
                var v = c + g * (1.0 - c);
                return [hcg[0], (v - c) * 100, (1 - v) * 100];
            };
            convert.hwb.hcg = function (hwb) {
                var w = hwb[1] / 100;
                var b = hwb[2] / 100;
                var v = 1 - b;
                var c = v - w;
                var g = 0;
                if (c < 1) {
                    g = (v - c) / (1 - c);
                }
                return [hwb[0], c * 100, g * 100];
            };
            convert.apple.rgb = function (apple) {
                return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
            };
            convert.rgb.apple = function (rgb) {
                return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
            };
            convert.gray.rgb = function (args) {
                return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
            };
            convert.gray.hsl = convert.gray.hsv = function (args) {
                return [0, 0, args[0]];
            };
            convert.gray.hwb = function (gray) {
                return [0, 100, gray[0]];
            };
            convert.gray.cmyk = function (gray) {
                return [0, 0, 0, gray[0]];
            };
            convert.gray.lab = function (gray) {
                return [gray[0], 0, 0];
            };
            convert.gray.hex = function (gray) {
                var val = Math.round(gray[0] / 100 * 255) & 0xFF;
                var integer = (val << 16) + (val << 8) + val;
                var string = integer.toString(16).toUpperCase();
                return '000000'.substring(string.length) + string;
            };
            convert.rgb.gray = function (rgb) {
                var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
                return [val / 255 * 100];
            };
            /***/ 
        }),
        /***/ 5121: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var conversions = __nccwpck_require__(8159);
            var route = __nccwpck_require__(4663);
            var convert = {};
            var models = Object.keys(conversions);
            function wrapRaw(fn) {
                var wrappedFn = function (args) {
                    if (args === undefined || args === null) {
                        return args;
                    }
                    if (arguments.length > 1) {
                        args = Array.prototype.slice.call(arguments);
                    }
                    return fn(args);
                };
                // preserve .conversion property if there is one
                if ('conversion' in fn) {
                    wrappedFn.conversion = fn.conversion;
                }
                return wrappedFn;
            }
            function wrapRounded(fn) {
                var wrappedFn = function (args) {
                    if (args === undefined || args === null) {
                        return args;
                    }
                    if (arguments.length > 1) {
                        args = Array.prototype.slice.call(arguments);
                    }
                    var result = fn(args);
                    // we're assuming the result is an array here.
                    // see notice in conversions.js; don't use box types
                    // in conversion functions.
                    if (typeof result === 'object') {
                        for (var len = result.length, i = 0; i < len; i++) {
                            result[i] = Math.round(result[i]);
                        }
                    }
                    return result;
                };
                // preserve .conversion property if there is one
                if ('conversion' in fn) {
                    wrappedFn.conversion = fn.conversion;
                }
                return wrappedFn;
            }
            models.forEach(function (fromModel) {
                convert[fromModel] = {};
                Object.defineProperty(convert[fromModel], 'channels', { value: conversions[fromModel].channels });
                Object.defineProperty(convert[fromModel], 'labels', { value: conversions[fromModel].labels });
                var routes = route(fromModel);
                var routeModels = Object.keys(routes);
                routeModels.forEach(function (toModel) {
                    var fn = routes[toModel];
                    convert[fromModel][toModel] = wrapRounded(fn);
                    convert[fromModel][toModel].raw = wrapRaw(fn);
                });
            });
            module.exports = convert;
            /***/ 
        }),
        /***/ 4663: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var conversions = __nccwpck_require__(8159);
            /*
                this function routes a model to all other models.
            
                all functions that are routed have a property `.conversion` attached
                to the returned synthetic function. This property is an array
                of strings, each with the steps in between the 'from' and 'to'
                color models (inclusive).
            
                conversions that are not possible simply are not included.
            */
            function buildGraph() {
                var graph = {};
                // https://jsperf.com/object-keys-vs-for-in-with-closure/3
                var models = Object.keys(conversions);
                for (var len = models.length, i = 0; i < len; i++) {
                    graph[models[i]] = {
                        // http://jsperf.com/1-vs-infinity
                        // micro-opt, but this is simple.
                        distance: -1,
                        parent: null
                    };
                }
                return graph;
            }
            // https://en.wikipedia.org/wiki/Breadth-first_search
            function deriveBFS(fromModel) {
                var graph = buildGraph();
                var queue = [fromModel]; // unshift -> queue -> pop
                graph[fromModel].distance = 0;
                while (queue.length) {
                    var current = queue.pop();
                    var adjacents = Object.keys(conversions[current]);
                    for (var len = adjacents.length, i = 0; i < len; i++) {
                        var adjacent = adjacents[i];
                        var node = graph[adjacent];
                        if (node.distance === -1) {
                            node.distance = graph[current].distance + 1;
                            node.parent = current;
                            queue.unshift(adjacent);
                        }
                    }
                }
                return graph;
            }
            function link(from, to) {
                return function (args) {
                    return to(from(args));
                };
            }
            function wrapConversion(toModel, graph) {
                var path = [graph[toModel].parent, toModel];
                var fn = conversions[graph[toModel].parent][toModel];
                var cur = graph[toModel].parent;
                while (graph[cur].parent) {
                    path.unshift(graph[cur].parent);
                    fn = link(conversions[graph[cur].parent][cur], fn);
                    cur = graph[cur].parent;
                }
                fn.conversion = path;
                return fn;
            }
            module.exports = function (fromModel) {
                var graph = deriveBFS(fromModel);
                var conversion = {};
                var models = Object.keys(graph);
                for (var len = models.length, i = 0; i < len; i++) {
                    var toModel = models[i];
                    var node = graph[toModel];
                    if (node.parent === null) {
                        // no possible conversion, or this node is the source model.
                        continue;
                    }
                    conversion[toModel] = wrapConversion(toModel, graph);
                }
                return conversion;
            };
            /***/ 
        }),
        /***/ 4057: 
        /***/ (function (module) {
            "use strict";
            module.exports = {
                "aliceblue": [240, 248, 255],
                "antiquewhite": [250, 235, 215],
                "aqua": [0, 255, 255],
                "aquamarine": [127, 255, 212],
                "azure": [240, 255, 255],
                "beige": [245, 245, 220],
                "bisque": [255, 228, 196],
                "black": [0, 0, 0],
                "blanchedalmond": [255, 235, 205],
                "blue": [0, 0, 255],
                "blueviolet": [138, 43, 226],
                "brown": [165, 42, 42],
                "burlywood": [222, 184, 135],
                "cadetblue": [95, 158, 160],
                "chartreuse": [127, 255, 0],
                "chocolate": [210, 105, 30],
                "coral": [255, 127, 80],
                "cornflowerblue": [100, 149, 237],
                "cornsilk": [255, 248, 220],
                "crimson": [220, 20, 60],
                "cyan": [0, 255, 255],
                "darkblue": [0, 0, 139],
                "darkcyan": [0, 139, 139],
                "darkgoldenrod": [184, 134, 11],
                "darkgray": [169, 169, 169],
                "darkgreen": [0, 100, 0],
                "darkgrey": [169, 169, 169],
                "darkkhaki": [189, 183, 107],
                "darkmagenta": [139, 0, 139],
                "darkolivegreen": [85, 107, 47],
                "darkorange": [255, 140, 0],
                "darkorchid": [153, 50, 204],
                "darkred": [139, 0, 0],
                "darksalmon": [233, 150, 122],
                "darkseagreen": [143, 188, 143],
                "darkslateblue": [72, 61, 139],
                "darkslategray": [47, 79, 79],
                "darkslategrey": [47, 79, 79],
                "darkturquoise": [0, 206, 209],
                "darkviolet": [148, 0, 211],
                "deeppink": [255, 20, 147],
                "deepskyblue": [0, 191, 255],
                "dimgray": [105, 105, 105],
                "dimgrey": [105, 105, 105],
                "dodgerblue": [30, 144, 255],
                "firebrick": [178, 34, 34],
                "floralwhite": [255, 250, 240],
                "forestgreen": [34, 139, 34],
                "fuchsia": [255, 0, 255],
                "gainsboro": [220, 220, 220],
                "ghostwhite": [248, 248, 255],
                "gold": [255, 215, 0],
                "goldenrod": [218, 165, 32],
                "gray": [128, 128, 128],
                "green": [0, 128, 0],
                "greenyellow": [173, 255, 47],
                "grey": [128, 128, 128],
                "honeydew": [240, 255, 240],
                "hotpink": [255, 105, 180],
                "indianred": [205, 92, 92],
                "indigo": [75, 0, 130],
                "ivory": [255, 255, 240],
                "khaki": [240, 230, 140],
                "lavender": [230, 230, 250],
                "lavenderblush": [255, 240, 245],
                "lawngreen": [124, 252, 0],
                "lemonchiffon": [255, 250, 205],
                "lightblue": [173, 216, 230],
                "lightcoral": [240, 128, 128],
                "lightcyan": [224, 255, 255],
                "lightgoldenrodyellow": [250, 250, 210],
                "lightgray": [211, 211, 211],
                "lightgreen": [144, 238, 144],
                "lightgrey": [211, 211, 211],
                "lightpink": [255, 182, 193],
                "lightsalmon": [255, 160, 122],
                "lightseagreen": [32, 178, 170],
                "lightskyblue": [135, 206, 250],
                "lightslategray": [119, 136, 153],
                "lightslategrey": [119, 136, 153],
                "lightsteelblue": [176, 196, 222],
                "lightyellow": [255, 255, 224],
                "lime": [0, 255, 0],
                "limegreen": [50, 205, 50],
                "linen": [250, 240, 230],
                "magenta": [255, 0, 255],
                "maroon": [128, 0, 0],
                "mediumaquamarine": [102, 205, 170],
                "mediumblue": [0, 0, 205],
                "mediumorchid": [186, 85, 211],
                "mediumpurple": [147, 112, 219],
                "mediumseagreen": [60, 179, 113],
                "mediumslateblue": [123, 104, 238],
                "mediumspringgreen": [0, 250, 154],
                "mediumturquoise": [72, 209, 204],
                "mediumvioletred": [199, 21, 133],
                "midnightblue": [25, 25, 112],
                "mintcream": [245, 255, 250],
                "mistyrose": [255, 228, 225],
                "moccasin": [255, 228, 181],
                "navajowhite": [255, 222, 173],
                "navy": [0, 0, 128],
                "oldlace": [253, 245, 230],
                "olive": [128, 128, 0],
                "olivedrab": [107, 142, 35],
                "orange": [255, 165, 0],
                "orangered": [255, 69, 0],
                "orchid": [218, 112, 214],
                "palegoldenrod": [238, 232, 170],
                "palegreen": [152, 251, 152],
                "paleturquoise": [175, 238, 238],
                "palevioletred": [219, 112, 147],
                "papayawhip": [255, 239, 213],
                "peachpuff": [255, 218, 185],
                "peru": [205, 133, 63],
                "pink": [255, 192, 203],
                "plum": [221, 160, 221],
                "powderblue": [176, 224, 230],
                "purple": [128, 0, 128],
                "rebeccapurple": [102, 51, 153],
                "red": [255, 0, 0],
                "rosybrown": [188, 143, 143],
                "royalblue": [65, 105, 225],
                "saddlebrown": [139, 69, 19],
                "salmon": [250, 128, 114],
                "sandybrown": [244, 164, 96],
                "seagreen": [46, 139, 87],
                "seashell": [255, 245, 238],
                "sienna": [160, 82, 45],
                "silver": [192, 192, 192],
                "skyblue": [135, 206, 235],
                "slateblue": [106, 90, 205],
                "slategray": [112, 128, 144],
                "slategrey": [112, 128, 144],
                "snow": [255, 250, 250],
                "springgreen": [0, 255, 127],
                "steelblue": [70, 130, 180],
                "tan": [210, 180, 140],
                "teal": [0, 128, 128],
                "thistle": [216, 191, 216],
                "tomato": [255, 99, 71],
                "turquoise": [64, 224, 208],
                "violet": [238, 130, 238],
                "wheat": [245, 222, 179],
                "white": [255, 255, 255],
                "whitesmoke": [245, 245, 245],
                "yellow": [255, 255, 0],
                "yellowgreen": [154, 205, 50]
            };
            /***/ 
        }),
        /***/ 2138: 
        /***/ (function (module) {
            "use strict";
            var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
            var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
            var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
            var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
            var ESCAPES = new Map([
                ['n', '\n'],
                ['r', '\r'],
                ['t', '\t'],
                ['b', '\b'],
                ['f', '\f'],
                ['v', '\v'],
                ['0', '\0'],
                ['\\', '\\'],
                ['e', '\u001B'],
                ['a', '\u0007']
            ]);
            function unescape(c) {
                if ((c[0] === 'u' && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
                    return String.fromCharCode(parseInt(c.slice(1), 16));
                }
                return ESCAPES.get(c) || c;
            }
            function parseArguments(name, args) {
                var results = [];
                var chunks = args.trim().split(/\s*,\s*/g);
                var matches;
                for (var _1 = 0, chunks_2 = chunks; _1 < chunks_2.length; _1++) {
                    var chunk = chunks_2[_1];
                    if (!isNaN(chunk)) {
                        results.push(Number(chunk));
                    }
                    else if ((matches = chunk.match(STRING_REGEX))) {
                        results.push(matches[2].replace(ESCAPE_REGEX, function (m, escape, chr) { return escape ? unescape(escape) : chr; }));
                    }
                    else {
                        throw new Error("Invalid Chalk template style argument: ".concat(chunk, " (in style '").concat(name, "')"));
                    }
                }
                return results;
            }
            function parseStyle(style) {
                STYLE_REGEX.lastIndex = 0;
                var results = [];
                var matches;
                while ((matches = STYLE_REGEX.exec(style)) !== null) {
                    var name_5 = matches[1];
                    if (matches[2]) {
                        var args = parseArguments(name_5, matches[2]);
                        results.push([name_5].concat(args));
                    }
                    else {
                        results.push([name_5]);
                    }
                }
                return results;
            }
            function buildStyle(chalk, styles) {
                var enabled = {};
                for (var _1 = 0, styles_3 = styles; _1 < styles_3.length; _1++) {
                    var layer = styles_3[_1];
                    for (var _2 = 0, _3 = layer.styles; _2 < _3.length; _2++) {
                        var style = _3[_2];
                        enabled[style[0]] = layer.inverse ? null : style.slice(1);
                    }
                }
                var current = chalk;
                for (var _4 = 0, _5 = Object.keys(enabled); _4 < _5.length; _4++) {
                    var styleName = _5[_4];
                    if (Array.isArray(enabled[styleName])) {
                        if (!(styleName in current)) {
                            throw new Error("Unknown Chalk style: ".concat(styleName));
                        }
                        if (enabled[styleName].length > 0) {
                            current = current[styleName].apply(current, enabled[styleName]);
                        }
                        else {
                            current = current[styleName];
                        }
                    }
                }
                return current;
            }
            module.exports = function (chalk, tmp) {
                var styles = [];
                var chunks = [];
                var chunk = [];
                // eslint-disable-next-line max-params
                tmp.replace(TEMPLATE_REGEX, function (m, escapeChar, inverse, style, close, chr) {
                    if (escapeChar) {
                        chunk.push(unescape(escapeChar));
                    }
                    else if (style) {
                        var str = chunk.join('');
                        chunk = [];
                        chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
                        styles.push({ inverse: inverse, styles: parseStyle(style) });
                    }
                    else if (close) {
                        if (styles.length === 0) {
                            throw new Error('Found extraneous } in Chalk template literal');
                        }
                        chunks.push(buildStyle(chalk, styles)(chunk.join('')));
                        chunk = [];
                        styles.pop();
                    }
                    else {
                        chunk.push(chr);
                    }
                });
                chunks.push(chunk.join(''));
                if (styles.length > 0) {
                    var errMsg = "Chalk template literal is missing ".concat(styles.length, " closing bracket").concat(styles.length === 1 ? '' : 's', " (`}`)");
                    throw new Error(errMsg);
                }
                return chunks.join('');
            };
            /***/ 
        }),
        /***/ 7391: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            /* MIT license */
            /* eslint-disable no-mixed-operators */
            var cssKeywords = __nccwpck_require__(8510);
            // NOTE: conversions should only return primitive values (i.e. arrays, or
            //       values that give correct `typeof` results).
            //       do not use box values types (i.e. Number(), String(), etc.)
            var reverseKeywords = {};
            for (var _1 = 0, _2 = Object.keys(cssKeywords); _1 < _2.length; _1++) {
                var key = _2[_1];
                reverseKeywords[cssKeywords[key]] = key;
            }
            var convert = {
                rgb: { channels: 3, labels: 'rgb' },
                hsl: { channels: 3, labels: 'hsl' },
                hsv: { channels: 3, labels: 'hsv' },
                hwb: { channels: 3, labels: 'hwb' },
                cmyk: { channels: 4, labels: 'cmyk' },
                xyz: { channels: 3, labels: 'xyz' },
                lab: { channels: 3, labels: 'lab' },
                lch: { channels: 3, labels: 'lch' },
                hex: { channels: 1, labels: ['hex'] },
                keyword: { channels: 1, labels: ['keyword'] },
                ansi16: { channels: 1, labels: ['ansi16'] },
                ansi256: { channels: 1, labels: ['ansi256'] },
                hcg: { channels: 3, labels: ['h', 'c', 'g'] },
                apple: { channels: 3, labels: ['r16', 'g16', 'b16'] },
                gray: { channels: 1, labels: ['gray'] }
            };
            module.exports = convert;
            // Hide .channels and .labels properties
            for (var _3 = 0, _4 = Object.keys(convert); _3 < _4.length; _3++) {
                var model = _4[_3];
                if (!('channels' in convert[model])) {
                    throw new Error('missing channels property: ' + model);
                }
                if (!('labels' in convert[model])) {
                    throw new Error('missing channel labels property: ' + model);
                }
                if (convert[model].labels.length !== convert[model].channels) {
                    throw new Error('channel and label counts mismatch: ' + model);
                }
                var _5 = convert[model], channels = _5.channels, labels = _5.labels;
                delete convert[model].channels;
                delete convert[model].labels;
                Object.defineProperty(convert[model], 'channels', { value: channels });
                Object.defineProperty(convert[model], 'labels', { value: labels });
            }
            convert.rgb.hsl = function (rgb) {
                var r = rgb[0] / 255;
                var g = rgb[1] / 255;
                var b = rgb[2] / 255;
                var min = Math.min(r, g, b);
                var max = Math.max(r, g, b);
                var delta = max - min;
                var h;
                var s;
                if (max === min) {
                    h = 0;
                }
                else if (r === max) {
                    h = (g - b) / delta;
                }
                else if (g === max) {
                    h = 2 + (b - r) / delta;
                }
                else if (b === max) {
                    h = 4 + (r - g) / delta;
                }
                h = Math.min(h * 60, 360);
                if (h < 0) {
                    h += 360;
                }
                var l = (min + max) / 2;
                if (max === min) {
                    s = 0;
                }
                else if (l <= 0.5) {
                    s = delta / (max + min);
                }
                else {
                    s = delta / (2 - max - min);
                }
                return [h, s * 100, l * 100];
            };
            convert.rgb.hsv = function (rgb) {
                var rdif;
                var gdif;
                var bdif;
                var h;
                var s;
                var r = rgb[0] / 255;
                var g = rgb[1] / 255;
                var b = rgb[2] / 255;
                var v = Math.max(r, g, b);
                var diff = v - Math.min(r, g, b);
                var diffc = function (c) {
                    return (v - c) / 6 / diff + 1 / 2;
                };
                if (diff === 0) {
                    h = 0;
                    s = 0;
                }
                else {
                    s = diff / v;
                    rdif = diffc(r);
                    gdif = diffc(g);
                    bdif = diffc(b);
                    if (r === v) {
                        h = bdif - gdif;
                    }
                    else if (g === v) {
                        h = (1 / 3) + rdif - bdif;
                    }
                    else if (b === v) {
                        h = (2 / 3) + gdif - rdif;
                    }
                    if (h < 0) {
                        h += 1;
                    }
                    else if (h > 1) {
                        h -= 1;
                    }
                }
                return [
                    h * 360,
                    s * 100,
                    v * 100
                ];
            };
            convert.rgb.hwb = function (rgb) {
                var r = rgb[0];
                var g = rgb[1];
                var b = rgb[2];
                var h = convert.rgb.hsl(rgb)[0];
                var w = 1 / 255 * Math.min(r, Math.min(g, b));
                b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
                return [h, w * 100, b * 100];
            };
            convert.rgb.cmyk = function (rgb) {
                var r = rgb[0] / 255;
                var g = rgb[1] / 255;
                var b = rgb[2] / 255;
                var k = Math.min(1 - r, 1 - g, 1 - b);
                var c = (1 - r - k) / (1 - k) || 0;
                var m = (1 - g - k) / (1 - k) || 0;
                var y = (1 - b - k) / (1 - k) || 0;
                return [c * 100, m * 100, y * 100, k * 100];
            };
            function comparativeDistance(x, y) {
                /*
                    See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
                */
                return ((Math.pow((x[0] - y[0]), 2)) +
                    (Math.pow((x[1] - y[1]), 2)) +
                    (Math.pow((x[2] - y[2]), 2)));
            }
            convert.rgb.keyword = function (rgb) {
                var reversed = reverseKeywords[rgb];
                if (reversed) {
                    return reversed;
                }
                var currentClosestDistance = Infinity;
                var currentClosestKeyword;
                for (var _1 = 0, _2 = Object.keys(cssKeywords); _1 < _2.length; _1++) {
                    var keyword = _2[_1];
                    var value = cssKeywords[keyword];
                    // Compute comparative distance
                    var distance = comparativeDistance(rgb, value);
                    // Check if its less, if so set as closest
                    if (distance < currentClosestDistance) {
                        currentClosestDistance = distance;
                        currentClosestKeyword = keyword;
                    }
                }
                return currentClosestKeyword;
            };
            convert.keyword.rgb = function (keyword) {
                return cssKeywords[keyword];
            };
            convert.rgb.xyz = function (rgb) {
                var r = rgb[0] / 255;
                var g = rgb[1] / 255;
                var b = rgb[2] / 255;
                // Assume sRGB
                r = r > 0.04045 ? (Math.pow(((r + 0.055) / 1.055), 2.4)) : (r / 12.92);
                g = g > 0.04045 ? (Math.pow(((g + 0.055) / 1.055), 2.4)) : (g / 12.92);
                b = b > 0.04045 ? (Math.pow(((b + 0.055) / 1.055), 2.4)) : (b / 12.92);
                var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
                var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
                var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);
                return [x * 100, y * 100, z * 100];
            };
            convert.rgb.lab = function (rgb) {
                var xyz = convert.rgb.xyz(rgb);
                var x = xyz[0];
                var y = xyz[1];
                var z = xyz[2];
                x /= 95.047;
                y /= 100;
                z /= 108.883;
                x = x > 0.008856 ? (Math.pow(x, (1 / 3))) : (7.787 * x) + (16 / 116);
                y = y > 0.008856 ? (Math.pow(y, (1 / 3))) : (7.787 * y) + (16 / 116);
                z = z > 0.008856 ? (Math.pow(z, (1 / 3))) : (7.787 * z) + (16 / 116);
                var l = (116 * y) - 16;
                var a = 500 * (x - y);
                var b = 200 * (y - z);
                return [l, a, b];
            };
            convert.hsl.rgb = function (hsl) {
                var h = hsl[0] / 360;
                var s = hsl[1] / 100;
                var l = hsl[2] / 100;
                var t2;
                var t3;
                var val;
                if (s === 0) {
                    val = l * 255;
                    return [val, val, val];
                }
                if (l < 0.5) {
                    t2 = l * (1 + s);
                }
                else {
                    t2 = l + s - l * s;
                }
                var t1 = 2 * l - t2;
                var rgb = [0, 0, 0];
                for (var i = 0; i < 3; i++) {
                    t3 = h + 1 / 3 * -(i - 1);
                    if (t3 < 0) {
                        t3++;
                    }
                    if (t3 > 1) {
                        t3--;
                    }
                    if (6 * t3 < 1) {
                        val = t1 + (t2 - t1) * 6 * t3;
                    }
                    else if (2 * t3 < 1) {
                        val = t2;
                    }
                    else if (3 * t3 < 2) {
                        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
                    }
                    else {
                        val = t1;
                    }
                    rgb[i] = val * 255;
                }
                return rgb;
            };
            convert.hsl.hsv = function (hsl) {
                var h = hsl[0];
                var s = hsl[1] / 100;
                var l = hsl[2] / 100;
                var smin = s;
                var lmin = Math.max(l, 0.01);
                l *= 2;
                s *= (l <= 1) ? l : 2 - l;
                smin *= lmin <= 1 ? lmin : 2 - lmin;
                var v = (l + s) / 2;
                var sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);
                return [h, sv * 100, v * 100];
            };
            convert.hsv.rgb = function (hsv) {
                var h = hsv[0] / 60;
                var s = hsv[1] / 100;
                var v = hsv[2] / 100;
                var hi = Math.floor(h) % 6;
                var f = h - Math.floor(h);
                var p = 255 * v * (1 - s);
                var q = 255 * v * (1 - (s * f));
                var t = 255 * v * (1 - (s * (1 - f)));
                v *= 255;
                switch (hi) {
                    case 0:
                        return [v, t, p];
                    case 1:
                        return [q, v, p];
                    case 2:
                        return [p, v, t];
                    case 3:
                        return [p, q, v];
                    case 4:
                        return [t, p, v];
                    case 5:
                        return [v, p, q];
                }
            };
            convert.hsv.hsl = function (hsv) {
                var h = hsv[0];
                var s = hsv[1] / 100;
                var v = hsv[2] / 100;
                var vmin = Math.max(v, 0.01);
                var sl;
                var l;
                l = (2 - s) * v;
                var lmin = (2 - s) * vmin;
                sl = s * vmin;
                sl /= (lmin <= 1) ? lmin : 2 - lmin;
                sl = sl || 0;
                l /= 2;
                return [h, sl * 100, l * 100];
            };
            // http://dev.w3.org/csswg/css-color/#hwb-to-rgb
            convert.hwb.rgb = function (hwb) {
                var h = hwb[0] / 360;
                var wh = hwb[1] / 100;
                var bl = hwb[2] / 100;
                var ratio = wh + bl;
                var f;
                // Wh + bl cant be > 1
                if (ratio > 1) {
                    wh /= ratio;
                    bl /= ratio;
                }
                var i = Math.floor(6 * h);
                var v = 1 - bl;
                f = 6 * h - i;
                if ((i & 0x01) !== 0) {
                    f = 1 - f;
                }
                var n = wh + f * (v - wh); // Linear interpolation
                var r;
                var g;
                var b;
                /* eslint-disable max-statements-per-line,no-multi-spaces */
                switch (i) {
                    default:
                    case 6:
                    case 0:
                        r = v;
                        g = n;
                        b = wh;
                        break;
                    case 1:
                        r = n;
                        g = v;
                        b = wh;
                        break;
                    case 2:
                        r = wh;
                        g = v;
                        b = n;
                        break;
                    case 3:
                        r = wh;
                        g = n;
                        b = v;
                        break;
                    case 4:
                        r = n;
                        g = wh;
                        b = v;
                        break;
                    case 5:
                        r = v;
                        g = wh;
                        b = n;
                        break;
                }
                /* eslint-enable max-statements-per-line,no-multi-spaces */
                return [r * 255, g * 255, b * 255];
            };
            convert.cmyk.rgb = function (cmyk) {
                var c = cmyk[0] / 100;
                var m = cmyk[1] / 100;
                var y = cmyk[2] / 100;
                var k = cmyk[3] / 100;
                var r = 1 - Math.min(1, c * (1 - k) + k);
                var g = 1 - Math.min(1, m * (1 - k) + k);
                var b = 1 - Math.min(1, y * (1 - k) + k);
                return [r * 255, g * 255, b * 255];
            };
            convert.xyz.rgb = function (xyz) {
                var x = xyz[0] / 100;
                var y = xyz[1] / 100;
                var z = xyz[2] / 100;
                var r;
                var g;
                var b;
                r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
                g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
                b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);
                // Assume sRGB
                r = r > 0.0031308
                    ? ((1.055 * (Math.pow(r, (1.0 / 2.4)))) - 0.055)
                    : r * 12.92;
                g = g > 0.0031308
                    ? ((1.055 * (Math.pow(g, (1.0 / 2.4)))) - 0.055)
                    : g * 12.92;
                b = b > 0.0031308
                    ? ((1.055 * (Math.pow(b, (1.0 / 2.4)))) - 0.055)
                    : b * 12.92;
                r = Math.min(Math.max(0, r), 1);
                g = Math.min(Math.max(0, g), 1);
                b = Math.min(Math.max(0, b), 1);
                return [r * 255, g * 255, b * 255];
            };
            convert.xyz.lab = function (xyz) {
                var x = xyz[0];
                var y = xyz[1];
                var z = xyz[2];
                x /= 95.047;
                y /= 100;
                z /= 108.883;
                x = x > 0.008856 ? (Math.pow(x, (1 / 3))) : (7.787 * x) + (16 / 116);
                y = y > 0.008856 ? (Math.pow(y, (1 / 3))) : (7.787 * y) + (16 / 116);
                z = z > 0.008856 ? (Math.pow(z, (1 / 3))) : (7.787 * z) + (16 / 116);
                var l = (116 * y) - 16;
                var a = 500 * (x - y);
                var b = 200 * (y - z);
                return [l, a, b];
            };
            convert.lab.xyz = function (lab) {
                var l = lab[0];
                var a = lab[1];
                var b = lab[2];
                var x;
                var y;
                var z;
                y = (l + 16) / 116;
                x = a / 500 + y;
                z = y - b / 200;
                var y2 = Math.pow(y, 3);
                var x2 = Math.pow(x, 3);
                var z2 = Math.pow(z, 3);
                y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
                x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
                z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
                x *= 95.047;
                y *= 100;
                z *= 108.883;
                return [x, y, z];
            };
            convert.lab.lch = function (lab) {
                var l = lab[0];
                var a = lab[1];
                var b = lab[2];
                var h;
                var hr = Math.atan2(b, a);
                h = hr * 360 / 2 / Math.PI;
                if (h < 0) {
                    h += 360;
                }
                var c = Math.sqrt(a * a + b * b);
                return [l, c, h];
            };
            convert.lch.lab = function (lch) {
                var l = lch[0];
                var c = lch[1];
                var h = lch[2];
                var hr = h / 360 * 2 * Math.PI;
                var a = c * Math.cos(hr);
                var b = c * Math.sin(hr);
                return [l, a, b];
            };
            convert.rgb.ansi16 = function (args, saturation) {
                if (saturation === void 0) { saturation = null; }
                var r = args[0], g = args[1], b = args[2];
                var value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization
                value = Math.round(value / 50);
                if (value === 0) {
                    return 30;
                }
                var ansi = 30
                    + ((Math.round(b / 255) << 2)
                        | (Math.round(g / 255) << 1)
                        | Math.round(r / 255));
                if (value === 2) {
                    ansi += 60;
                }
                return ansi;
            };
            convert.hsv.ansi16 = function (args) {
                // Optimization here; we already know the value and don't need to get
                // it converted for us.
                return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
            };
            convert.rgb.ansi256 = function (args) {
                var r = args[0];
                var g = args[1];
                var b = args[2];
                // We use the extended greyscale palette here, with the exception of
                // black and white. normal palette only has 4 greyscale shades.
                if (r === g && g === b) {
                    if (r < 8) {
                        return 16;
                    }
                    if (r > 248) {
                        return 231;
                    }
                    return Math.round(((r - 8) / 247) * 24) + 232;
                }
                var ansi = 16
                    + (36 * Math.round(r / 255 * 5))
                    + (6 * Math.round(g / 255 * 5))
                    + Math.round(b / 255 * 5);
                return ansi;
            };
            convert.ansi16.rgb = function (args) {
                var color = args % 10;
                // Handle greyscale
                if (color === 0 || color === 7) {
                    if (args > 50) {
                        color += 3.5;
                    }
                    color = color / 10.5 * 255;
                    return [color, color, color];
                }
                var mult = (~~(args > 50) + 1) * 0.5;
                var r = ((color & 1) * mult) * 255;
                var g = (((color >> 1) & 1) * mult) * 255;
                var b = (((color >> 2) & 1) * mult) * 255;
                return [r, g, b];
            };
            convert.ansi256.rgb = function (args) {
                // Handle greyscale
                if (args >= 232) {
                    var c = (args - 232) * 10 + 8;
                    return [c, c, c];
                }
                args -= 16;
                var rem;
                var r = Math.floor(args / 36) / 5 * 255;
                var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
                var b = (rem % 6) / 5 * 255;
                return [r, g, b];
            };
            convert.rgb.hex = function (args) {
                var integer = ((Math.round(args[0]) & 0xFF) << 16)
                    + ((Math.round(args[1]) & 0xFF) << 8)
                    + (Math.round(args[2]) & 0xFF);
                var string = integer.toString(16).toUpperCase();
                return '000000'.substring(string.length) + string;
            };
            convert.hex.rgb = function (args) {
                var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
                if (!match) {
                    return [0, 0, 0];
                }
                var colorString = match[0];
                if (match[0].length === 3) {
                    colorString = colorString.split('').map(function (char) {
                        return char + char;
                    }).join('');
                }
                var integer = parseInt(colorString, 16);
                var r = (integer >> 16) & 0xFF;
                var g = (integer >> 8) & 0xFF;
                var b = integer & 0xFF;
                return [r, g, b];
            };
            convert.rgb.hcg = function (rgb) {
                var r = rgb[0] / 255;
                var g = rgb[1] / 255;
                var b = rgb[2] / 255;
                var max = Math.max(Math.max(r, g), b);
                var min = Math.min(Math.min(r, g), b);
                var chroma = (max - min);
                var grayscale;
                var hue;
                if (chroma < 1) {
                    grayscale = min / (1 - chroma);
                }
                else {
                    grayscale = 0;
                }
                if (chroma <= 0) {
                    hue = 0;
                }
                else if (max === r) {
                    hue = ((g - b) / chroma) % 6;
                }
                else if (max === g) {
                    hue = 2 + (b - r) / chroma;
                }
                else {
                    hue = 4 + (r - g) / chroma;
                }
                hue /= 6;
                hue %= 1;
                return [hue * 360, chroma * 100, grayscale * 100];
            };
            convert.hsl.hcg = function (hsl) {
                var s = hsl[1] / 100;
                var l = hsl[2] / 100;
                var c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));
                var f = 0;
                if (c < 1.0) {
                    f = (l - 0.5 * c) / (1.0 - c);
                }
                return [hsl[0], c * 100, f * 100];
            };
            convert.hsv.hcg = function (hsv) {
                var s = hsv[1] / 100;
                var v = hsv[2] / 100;
                var c = s * v;
                var f = 0;
                if (c < 1.0) {
                    f = (v - c) / (1 - c);
                }
                return [hsv[0], c * 100, f * 100];
            };
            convert.hcg.rgb = function (hcg) {
                var h = hcg[0] / 360;
                var c = hcg[1] / 100;
                var g = hcg[2] / 100;
                if (c === 0.0) {
                    return [g * 255, g * 255, g * 255];
                }
                var pure = [0, 0, 0];
                var hi = (h % 1) * 6;
                var v = hi % 1;
                var w = 1 - v;
                var mg = 0;
                /* eslint-disable max-statements-per-line */
                switch (Math.floor(hi)) {
                    case 0:
                        pure[0] = 1;
                        pure[1] = v;
                        pure[2] = 0;
                        break;
                    case 1:
                        pure[0] = w;
                        pure[1] = 1;
                        pure[2] = 0;
                        break;
                    case 2:
                        pure[0] = 0;
                        pure[1] = 1;
                        pure[2] = v;
                        break;
                    case 3:
                        pure[0] = 0;
                        pure[1] = w;
                        pure[2] = 1;
                        break;
                    case 4:
                        pure[0] = v;
                        pure[1] = 0;
                        pure[2] = 1;
                        break;
                    default:
                        pure[0] = 1;
                        pure[1] = 0;
                        pure[2] = w;
                }
                /* eslint-enable max-statements-per-line */
                mg = (1.0 - c) * g;
                return [
                    (c * pure[0] + mg) * 255,
                    (c * pure[1] + mg) * 255,
                    (c * pure[2] + mg) * 255
                ];
            };
            convert.hcg.hsv = function (hcg) {
                var c = hcg[1] / 100;
                var g = hcg[2] / 100;
                var v = c + g * (1.0 - c);
                var f = 0;
                if (v > 0.0) {
                    f = c / v;
                }
                return [hcg[0], f * 100, v * 100];
            };
            convert.hcg.hsl = function (hcg) {
                var c = hcg[1] / 100;
                var g = hcg[2] / 100;
                var l = g * (1.0 - c) + 0.5 * c;
                var s = 0;
                if (l > 0.0 && l < 0.5) {
                    s = c / (2 * l);
                }
                else if (l >= 0.5 && l < 1.0) {
                    s = c / (2 * (1 - l));
                }
                return [hcg[0], s * 100, l * 100];
            };
            convert.hcg.hwb = function (hcg) {
                var c = hcg[1] / 100;
                var g = hcg[2] / 100;
                var v = c + g * (1.0 - c);
                return [hcg[0], (v - c) * 100, (1 - v) * 100];
            };
            convert.hwb.hcg = function (hwb) {
                var w = hwb[1] / 100;
                var b = hwb[2] / 100;
                var v = 1 - b;
                var c = v - w;
                var g = 0;
                if (c < 1) {
                    g = (v - c) / (1 - c);
                }
                return [hwb[0], c * 100, g * 100];
            };
            convert.apple.rgb = function (apple) {
                return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
            };
            convert.rgb.apple = function (rgb) {
                return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
            };
            convert.gray.rgb = function (args) {
                return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
            };
            convert.gray.hsl = function (args) {
                return [0, 0, args[0]];
            };
            convert.gray.hsv = convert.gray.hsl;
            convert.gray.hwb = function (gray) {
                return [0, 100, gray[0]];
            };
            convert.gray.cmyk = function (gray) {
                return [0, 0, 0, gray[0]];
            };
            convert.gray.lab = function (gray) {
                return [gray[0], 0, 0];
            };
            convert.gray.hex = function (gray) {
                var val = Math.round(gray[0] / 100 * 255) & 0xFF;
                var integer = (val << 16) + (val << 8) + val;
                var string = integer.toString(16).toUpperCase();
                return '000000'.substring(string.length) + string;
            };
            convert.rgb.gray = function (rgb) {
                var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
                return [val / 255 * 100];
            };
            /***/ 
        }),
        /***/ 6931: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var conversions = __nccwpck_require__(7391);
            var route = __nccwpck_require__(880);
            var convert = {};
            var models = Object.keys(conversions);
            function wrapRaw(fn) {
                var wrappedFn = function () {
                    var args = [];
                    for (var _1 = 0; _1 < arguments.length; _1++) {
                        args[_1] = arguments[_1];
                    }
                    var arg0 = args[0];
                    if (arg0 === undefined || arg0 === null) {
                        return arg0;
                    }
                    if (arg0.length > 1) {
                        args = arg0;
                    }
                    return fn(args);
                };
                // Preserve .conversion property if there is one
                if ('conversion' in fn) {
                    wrappedFn.conversion = fn.conversion;
                }
                return wrappedFn;
            }
            function wrapRounded(fn) {
                var wrappedFn = function () {
                    var args = [];
                    for (var _1 = 0; _1 < arguments.length; _1++) {
                        args[_1] = arguments[_1];
                    }
                    var arg0 = args[0];
                    if (arg0 === undefined || arg0 === null) {
                        return arg0;
                    }
                    if (arg0.length > 1) {
                        args = arg0;
                    }
                    var result = fn(args);
                    // We're assuming the result is an array here.
                    // see notice in conversions.js; don't use box types
                    // in conversion functions.
                    if (typeof result === 'object') {
                        for (var len = result.length, i = 0; i < len; i++) {
                            result[i] = Math.round(result[i]);
                        }
                    }
                    return result;
                };
                // Preserve .conversion property if there is one
                if ('conversion' in fn) {
                    wrappedFn.conversion = fn.conversion;
                }
                return wrappedFn;
            }
            models.forEach(function (fromModel) {
                convert[fromModel] = {};
                Object.defineProperty(convert[fromModel], 'channels', { value: conversions[fromModel].channels });
                Object.defineProperty(convert[fromModel], 'labels', { value: conversions[fromModel].labels });
                var routes = route(fromModel);
                var routeModels = Object.keys(routes);
                routeModels.forEach(function (toModel) {
                    var fn = routes[toModel];
                    convert[fromModel][toModel] = wrapRounded(fn);
                    convert[fromModel][toModel].raw = wrapRaw(fn);
                });
            });
            module.exports = convert;
            /***/ 
        }),
        /***/ 880: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var conversions = __nccwpck_require__(7391);
            /*
                This function routes a model to all other models.
            
                all functions that are routed have a property `.conversion` attached
                to the returned synthetic function. This property is an array
                of strings, each with the steps in between the 'from' and 'to'
                color models (inclusive).
            
                conversions that are not possible simply are not included.
            */
            function buildGraph() {
                var graph = {};
                // https://jsperf.com/object-keys-vs-for-in-with-closure/3
                var models = Object.keys(conversions);
                for (var len = models.length, i = 0; i < len; i++) {
                    graph[models[i]] = {
                        // http://jsperf.com/1-vs-infinity
                        // micro-opt, but this is simple.
                        distance: -1,
                        parent: null
                    };
                }
                return graph;
            }
            // https://en.wikipedia.org/wiki/Breadth-first_search
            function deriveBFS(fromModel) {
                var graph = buildGraph();
                var queue = [fromModel]; // Unshift -> queue -> pop
                graph[fromModel].distance = 0;
                while (queue.length) {
                    var current = queue.pop();
                    var adjacents = Object.keys(conversions[current]);
                    for (var len = adjacents.length, i = 0; i < len; i++) {
                        var adjacent = adjacents[i];
                        var node = graph[adjacent];
                        if (node.distance === -1) {
                            node.distance = graph[current].distance + 1;
                            node.parent = current;
                            queue.unshift(adjacent);
                        }
                    }
                }
                return graph;
            }
            function link(from, to) {
                return function (args) {
                    return to(from(args));
                };
            }
            function wrapConversion(toModel, graph) {
                var path = [graph[toModel].parent, toModel];
                var fn = conversions[graph[toModel].parent][toModel];
                var cur = graph[toModel].parent;
                while (graph[cur].parent) {
                    path.unshift(graph[cur].parent);
                    fn = link(conversions[graph[cur].parent][cur], fn);
                    cur = graph[cur].parent;
                }
                fn.conversion = path;
                return fn;
            }
            module.exports = function (fromModel) {
                var graph = deriveBFS(fromModel);
                var conversion = {};
                var models = Object.keys(graph);
                for (var len = models.length, i = 0; i < len; i++) {
                    var toModel = models[i];
                    var node = graph[toModel];
                    if (node.parent === null) {
                        // No possible conversion, or this node is the source model.
                        continue;
                    }
                    conversion[toModel] = wrapConversion(toModel, graph);
                }
                return conversion;
            };
            /***/ 
        }),
        /***/ 8510: 
        /***/ (function (module) {
            "use strict";
            module.exports = {
                "aliceblue": [240, 248, 255],
                "antiquewhite": [250, 235, 215],
                "aqua": [0, 255, 255],
                "aquamarine": [127, 255, 212],
                "azure": [240, 255, 255],
                "beige": [245, 245, 220],
                "bisque": [255, 228, 196],
                "black": [0, 0, 0],
                "blanchedalmond": [255, 235, 205],
                "blue": [0, 0, 255],
                "blueviolet": [138, 43, 226],
                "brown": [165, 42, 42],
                "burlywood": [222, 184, 135],
                "cadetblue": [95, 158, 160],
                "chartreuse": [127, 255, 0],
                "chocolate": [210, 105, 30],
                "coral": [255, 127, 80],
                "cornflowerblue": [100, 149, 237],
                "cornsilk": [255, 248, 220],
                "crimson": [220, 20, 60],
                "cyan": [0, 255, 255],
                "darkblue": [0, 0, 139],
                "darkcyan": [0, 139, 139],
                "darkgoldenrod": [184, 134, 11],
                "darkgray": [169, 169, 169],
                "darkgreen": [0, 100, 0],
                "darkgrey": [169, 169, 169],
                "darkkhaki": [189, 183, 107],
                "darkmagenta": [139, 0, 139],
                "darkolivegreen": [85, 107, 47],
                "darkorange": [255, 140, 0],
                "darkorchid": [153, 50, 204],
                "darkred": [139, 0, 0],
                "darksalmon": [233, 150, 122],
                "darkseagreen": [143, 188, 143],
                "darkslateblue": [72, 61, 139],
                "darkslategray": [47, 79, 79],
                "darkslategrey": [47, 79, 79],
                "darkturquoise": [0, 206, 209],
                "darkviolet": [148, 0, 211],
                "deeppink": [255, 20, 147],
                "deepskyblue": [0, 191, 255],
                "dimgray": [105, 105, 105],
                "dimgrey": [105, 105, 105],
                "dodgerblue": [30, 144, 255],
                "firebrick": [178, 34, 34],
                "floralwhite": [255, 250, 240],
                "forestgreen": [34, 139, 34],
                "fuchsia": [255, 0, 255],
                "gainsboro": [220, 220, 220],
                "ghostwhite": [248, 248, 255],
                "gold": [255, 215, 0],
                "goldenrod": [218, 165, 32],
                "gray": [128, 128, 128],
                "green": [0, 128, 0],
                "greenyellow": [173, 255, 47],
                "grey": [128, 128, 128],
                "honeydew": [240, 255, 240],
                "hotpink": [255, 105, 180],
                "indianred": [205, 92, 92],
                "indigo": [75, 0, 130],
                "ivory": [255, 255, 240],
                "khaki": [240, 230, 140],
                "lavender": [230, 230, 250],
                "lavenderblush": [255, 240, 245],
                "lawngreen": [124, 252, 0],
                "lemonchiffon": [255, 250, 205],
                "lightblue": [173, 216, 230],
                "lightcoral": [240, 128, 128],
                "lightcyan": [224, 255, 255],
                "lightgoldenrodyellow": [250, 250, 210],
                "lightgray": [211, 211, 211],
                "lightgreen": [144, 238, 144],
                "lightgrey": [211, 211, 211],
                "lightpink": [255, 182, 193],
                "lightsalmon": [255, 160, 122],
                "lightseagreen": [32, 178, 170],
                "lightskyblue": [135, 206, 250],
                "lightslategray": [119, 136, 153],
                "lightslategrey": [119, 136, 153],
                "lightsteelblue": [176, 196, 222],
                "lightyellow": [255, 255, 224],
                "lime": [0, 255, 0],
                "limegreen": [50, 205, 50],
                "linen": [250, 240, 230],
                "magenta": [255, 0, 255],
                "maroon": [128, 0, 0],
                "mediumaquamarine": [102, 205, 170],
                "mediumblue": [0, 0, 205],
                "mediumorchid": [186, 85, 211],
                "mediumpurple": [147, 112, 219],
                "mediumseagreen": [60, 179, 113],
                "mediumslateblue": [123, 104, 238],
                "mediumspringgreen": [0, 250, 154],
                "mediumturquoise": [72, 209, 204],
                "mediumvioletred": [199, 21, 133],
                "midnightblue": [25, 25, 112],
                "mintcream": [245, 255, 250],
                "mistyrose": [255, 228, 225],
                "moccasin": [255, 228, 181],
                "navajowhite": [255, 222, 173],
                "navy": [0, 0, 128],
                "oldlace": [253, 245, 230],
                "olive": [128, 128, 0],
                "olivedrab": [107, 142, 35],
                "orange": [255, 165, 0],
                "orangered": [255, 69, 0],
                "orchid": [218, 112, 214],
                "palegoldenrod": [238, 232, 170],
                "palegreen": [152, 251, 152],
                "paleturquoise": [175, 238, 238],
                "palevioletred": [219, 112, 147],
                "papayawhip": [255, 239, 213],
                "peachpuff": [255, 218, 185],
                "peru": [205, 133, 63],
                "pink": [255, 192, 203],
                "plum": [221, 160, 221],
                "powderblue": [176, 224, 230],
                "purple": [128, 0, 128],
                "rebeccapurple": [102, 51, 153],
                "red": [255, 0, 0],
                "rosybrown": [188, 143, 143],
                "royalblue": [65, 105, 225],
                "saddlebrown": [139, 69, 19],
                "salmon": [250, 128, 114],
                "sandybrown": [244, 164, 96],
                "seagreen": [46, 139, 87],
                "seashell": [255, 245, 238],
                "sienna": [160, 82, 45],
                "silver": [192, 192, 192],
                "skyblue": [135, 206, 235],
                "slateblue": [106, 90, 205],
                "slategray": [112, 128, 144],
                "slategrey": [112, 128, 144],
                "snow": [255, 250, 250],
                "springgreen": [0, 255, 127],
                "steelblue": [70, 130, 180],
                "tan": [210, 180, 140],
                "teal": [0, 128, 128],
                "thistle": [216, 191, 216],
                "tomato": [255, 99, 71],
                "turquoise": [64, 224, 208],
                "violet": [238, 130, 238],
                "wheat": [245, 222, 179],
                "white": [255, 255, 255],
                "whitesmoke": [245, 245, 245],
                "yellow": [255, 255, 0],
                "yellowgreen": [154, 205, 50]
            };
            /***/ 
        }),
        /***/ 6323: 
        /***/ (function (module) {
            "use strict";
            var isMergeableObject = function isMergeableObject(value) {
                return isNonNullObject(value)
                    && !isSpecial(value);
            };
            function isNonNullObject(value) {
                return !!value && typeof value === 'object';
            }
            function isSpecial(value) {
                var stringValue = Object.prototype.toString.call(value);
                return stringValue === '[object RegExp]'
                    || stringValue === '[object Date]'
                    || isReactElement(value);
            }
            // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
            var canUseSymbol = typeof Symbol === 'function' && Symbol["for"];
            var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol["for"]('react.element') : 0xeac7;
            function isReactElement(value) {
                return value.$$typeof === REACT_ELEMENT_TYPE;
            }
            function emptyTarget(val) {
                return Array.isArray(val) ? [] : {};
            }
            function cloneUnlessOtherwiseSpecified(value, options) {
                return (options.clone !== false && options.isMergeableObject(value))
                    ? deepmerge(emptyTarget(value), value, options)
                    : value;
            }
            function defaultArrayMerge(target, source, options) {
                return target.concat(source).map(function (element) {
                    return cloneUnlessOtherwiseSpecified(element, options);
                });
            }
            function getMergeFunction(key, options) {
                if (!options.customMerge) {
                    return deepmerge;
                }
                var customMerge = options.customMerge(key);
                return typeof customMerge === 'function' ? customMerge : deepmerge;
            }
            function getEnumerableOwnPropertySymbols(target) {
                return Object.getOwnPropertySymbols
                    ? Object.getOwnPropertySymbols(target).filter(function (symbol) {
                        return Object.propertyIsEnumerable.call(target, symbol);
                    })
                    : [];
            }
            function getKeys(target) {
                return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
            }
            function propertyIsOnObject(object, property) {
                try {
                    return property in object;
                }
                catch (_) {
                    return false;
                }
            }
            // Protects from prototype poisoning and unexpected merging up the prototype chain.
            function propertyIsUnsafe(target, key) {
                return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
                    && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
                        && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.
            }
            function mergeObject(target, source, options) {
                var destination = {};
                if (options.isMergeableObject(target)) {
                    getKeys(target).forEach(function (key) {
                        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
                    });
                }
                getKeys(source).forEach(function (key) {
                    if (propertyIsUnsafe(target, key)) {
                        return;
                    }
                    if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
                        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
                    }
                    else {
                        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
                    }
                });
                return destination;
            }
            function deepmerge(target, source, options) {
                options = options || {};
                options.arrayMerge = options.arrayMerge || defaultArrayMerge;
                options.isMergeableObject = options.isMergeableObject || isMergeableObject;
                // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
                // implementations can use it. The caller may not replace it.
                options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
                var sourceIsArray = Array.isArray(source);
                var targetIsArray = Array.isArray(target);
                var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
                if (!sourceAndTargetTypesMatch) {
                    return cloneUnlessOtherwiseSpecified(source, options);
                }
                else if (sourceIsArray) {
                    return options.arrayMerge(target, source, options);
                }
                else {
                    return mergeObject(target, source, options);
                }
            }
            deepmerge.all = function deepmergeAll(array, options) {
                if (!Array.isArray(array)) {
                    throw new Error('first argument should be an array');
                }
                return array.reduce(function (prev, next) {
                    return deepmerge(prev, next, options);
                }, {});
            };
            var deepmerge_1 = deepmerge;
            module.exports = deepmerge_1;
            /***/ 
        }),
        /***/ 8932: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var Deprecation = /** @class */ (function (_super) {
                __extends(Deprecation, _super);
                function Deprecation(message) {
                    var _this_1 = _super.call(this, message) || this;
                    /* istanbul ignore next */
                    if (Error.captureStackTrace) {
                        Error.captureStackTrace(_this_1, _this_1.constructor);
                    }
                    _this_1.name = 'Deprecation';
                    return _this_1;
                }
                return Deprecation;
            }(Error));
            exports.Deprecation = Deprecation;
            /***/ 
        }),
        /***/ 8691: 
        /***/ (function (module) {
            "use strict";
            var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
            module.exports = function (str) {
                if (typeof str !== 'string') {
                    throw new TypeError('Expected a string');
                }
                return str.replace(matchOperatorsRe, '\\$&');
            };
            /***/ 
        }),
        /***/ 8206: 
        /***/ (function (module) {
            "use strict";
            // do not edit .js files directly - edit src/index.jst
            module.exports = function equal(a, b) {
                if (a === b)
                    return true;
                if (a && b && typeof a == 'object' && typeof b == 'object') {
                    if (a.constructor !== b.constructor)
                        return false;
                    var length, i, keys;
                    if (Array.isArray(a)) {
                        length = a.length;
                        if (length != b.length)
                            return false;
                        for (i = length; i-- !== 0;)
                            if (!equal(a[i], b[i]))
                                return false;
                        return true;
                    }
                    if (a.constructor === RegExp)
                        return a.source === b.source && a.flags === b.flags;
                    if (a.valueOf !== Object.prototype.valueOf)
                        return a.valueOf() === b.valueOf();
                    if (a.toString !== Object.prototype.toString)
                        return a.toString() === b.toString();
                    keys = Object.keys(a);
                    length = keys.length;
                    if (length !== Object.keys(b).length)
                        return false;
                    for (i = length; i-- !== 0;)
                        if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
                            return false;
                    for (i = length; i-- !== 0;) {
                        var key = keys[i];
                        if (!equal(a[key], b[key]))
                            return false;
                    }
                    return true;
                }
                // true if both NaN, false otherwise
                return a !== a && b !== b;
            };
            /***/ 
        }),
        /***/ 1621: 
        /***/ (function (module) {
            "use strict";
            module.exports = function (flag, argv) {
                argv = argv || process.argv;
                var prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
                var pos = argv.indexOf(prefix + flag);
                var terminatorPos = argv.indexOf('--');
                return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
            };
            /***/ 
        }),
        /***/ 1230: 
        /***/ (function (module) {
            // A simple implementation of make-array
            function makeArray(subject) {
                return Array.isArray(subject)
                    ? subject
                    : [subject];
            }
            var EMPTY = '';
            var SPACE = ' ';
            var ESCAPE = '\\';
            var REGEX_TEST_BLANK_LINE = /^\s+$/;
            var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
            var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
            var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
            var REGEX_SPLITALL_CRLF = /\r?\n/g;
            // /foo,
            // ./foo,
            // ../foo,
            // .
            // ..
            var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
            var SLASH = '/';
            // Do not use ternary expression here, since "istanbul ignore next" is buggy
            var TMP_KEY_IGNORE = 'node-ignore';
            /* istanbul ignore else */
            if (typeof Symbol !== 'undefined') {
                TMP_KEY_IGNORE = Symbol["for"]('node-ignore');
            }
            var KEY_IGNORE = TMP_KEY_IGNORE;
            var define = function (object, key, value) {
                return Object.defineProperty(object, key, { value: value });
            };
            var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
            var RETURN_FALSE = function () { return false; };
            // Sanitize the range of a regular expression
            // The cases are complicated, see test cases for details
            var sanitizeRange = function (range) { return range.replace(REGEX_REGEXP_RANGE, function (match, from, to) { return from.charCodeAt(0) <= to.charCodeAt(0)
                ? match
                // Invalid range (out of order) which is ok for gitignore rules but
                //   fatal for JavaScript regular expression, so eliminate it.
                : EMPTY; }); };
            // See fixtures #59
            var cleanRangeBackSlash = function (slashes) {
                var length = slashes.length;
                return slashes.slice(0, length - length % 2);
            };
            // > If the pattern ends with a slash,
            // > it is removed for the purpose of the following description,
            // > but it would only find a match with a directory.
            // > In other words, foo/ will match a directory foo and paths underneath it,
            // > but will not match a regular file or a symbolic link foo
            // >  (this is consistent with the way how pathspec works in general in Git).
            // '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'
            // -> ignore-rules will not deal with it, because it costs extra `fs.stat` call
            //      you could use option `mark: true` with `glob`
            // '`foo/`' should not continue with the '`..`'
            var REPLACERS = [
                // > Trailing spaces are ignored unless they are quoted with backslash ("\")
                [
                    // (a\ ) -> (a )
                    // (a  ) -> (a)
                    // (a \ ) -> (a  )
                    /\\?\s+$/,
                    function (match) { return match.indexOf('\\') === 0
                        ? SPACE
                        : EMPTY; }
                ],
                // replace (\ ) with ' '
                [
                    /\\\s/g,
                    function () { return SPACE; }
                ],
                // Escape metacharacters
                // which is written down by users but means special for regular expressions.
                // > There are 12 characters with special meanings:
                // > - the backslash \,
                // > - the caret ^,
                // > - the dollar sign $,
                // > - the period or dot .,
                // > - the vertical bar or pipe symbol |,
                // > - the question mark ?,
                // > - the asterisk or star *,
                // > - the plus sign +,
                // > - the opening parenthesis (,
                // > - the closing parenthesis ),
                // > - and the opening square bracket [,
                // > - the opening curly brace {,
                // > These special characters are often called "metacharacters".
                [
                    /[\\$.|*+(){^]/g,
                    function (match) { return "\\".concat(match); }
                ],
                [
                    // > a question mark (?) matches a single character
                    /(?!\\)\?/g,
                    function () { return '[^/]'; }
                ],
                // leading slash
                [
                    // > A leading slash matches the beginning of the pathname.
                    // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
                    // A leading slash matches the beginning of the pathname
                    /^\//,
                    function () { return '^'; }
                ],
                // replace special metacharacter slash after the leading slash
                [
                    /\//g,
                    function () { return '\\/'; }
                ],
                [
                    // > A leading "**" followed by a slash means match in all directories.
                    // > For example, "**/foo" matches file or directory "foo" anywhere,
                    // > the same as pattern "foo".
                    // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
                    // >   under directory "foo".
                    // Notice that the '*'s have been replaced as '\\*'
                    /^\^*\\\*\\\*\\\//,
                    // '**/foo' <-> 'foo'
                    function () { return '^(?:.*\\/)?'; }
                ],
                // starting
                [
                    // there will be no leading '/'
                    //   (which has been replaced by section "leading slash")
                    // If starts with '**', adding a '^' to the regular expression also works
                    /^(?=[^^])/,
                    function startingReplacer() {
                        // If has a slash `/` at the beginning or middle
                        return !/\/(?!$)/.test(this)
                            // > Prior to 2.22.1
                            // > If the pattern does not contain a slash /,
                            // >   Git treats it as a shell glob pattern
                            // Actually, if there is only a trailing slash,
                            //   git also treats it as a shell glob pattern
                            // After 2.22.1 (compatible but clearer)
                            // > If there is a separator at the beginning or middle (or both)
                            // > of the pattern, then the pattern is relative to the directory
                            // > level of the particular .gitignore file itself.
                            // > Otherwise the pattern may also match at any level below
                            // > the .gitignore level.
                            ? '(?:^|\\/)'
                            // > Otherwise, Git treats the pattern as a shell glob suitable for
                            // >   consumption by fnmatch(3)
                            : '^';
                    }
                ],
                // two globstars
                [
                    // Use lookahead assertions so that we could match more than one `'/**'`
                    /\\\/\\\*\\\*(?=\\\/|$)/g,
                    // Zero, one or several directories
                    // should not use '*', or it will be replaced by the next replacer
                    // Check if it is not the last `'/**'`
                    function (_, index, str) { return index + 6 < str.length
                        // case: /**/
                        // > A slash followed by two consecutive asterisks then a slash matches
                        // >   zero or more directories.
                        // > For example, "a/**/b" matches "a/b", "a/x/b", "a/x/y/b" and so on.
                        // '/**/'
                        ? '(?:\\/[^\\/]+)*'
                        // case: /**
                        // > A trailing `"/**"` matches everything inside.
                        // #21: everything inside but it should not include the current folder
                        : '\\/.+'; }
                ],
                // normal intermediate wildcards
                [
                    // Never replace escaped '*'
                    // ignore rule '\*' will match the path '*'
                    // 'abc.*/' -> go
                    // 'abc.*'  -> skip this rule,
                    //    coz trailing single wildcard will be handed by [trailing wildcard]
                    /(^|[^\\]+)(\\\*)+(?=.+)/g,
                    // '*.js' matches '.js'
                    // '*.js' doesn't match 'abc'
                    function (_, p1, p2) {
                        // 1.
                        // > An asterisk "*" matches anything except a slash.
                        // 2.
                        // > Other consecutive asterisks are considered regular asterisks
                        // > and will match according to the previous rules.
                        var unescaped = p2.replace(/\\\*/g, '[^\\/]*');
                        return p1 + unescaped;
                    }
                ],
                [
                    // unescape, revert step 3 except for back slash
                    // For example, if a user escape a '\\*',
                    // after step 3, the result will be '\\\\\\*'
                    /\\\\\\(?=[$.|*+(){^])/g,
                    function () { return ESCAPE; }
                ],
                [
                    // '\\\\' -> '\\'
                    /\\\\/g,
                    function () { return ESCAPE; }
                ],
                [
                    // > The range notation, e.g. [a-zA-Z],
                    // > can be used to match one of the characters in a range.
                    // `\` is escaped by step 3
                    /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
                    function (match, leadEscape, range, endEscape, close) { return leadEscape === ESCAPE
                        // '\\[bar]' -> '\\\\[bar\\]'
                        ? "\\[".concat(range).concat(cleanRangeBackSlash(endEscape)).concat(close)
                        : close === ']'
                            ? endEscape.length % 2 === 0
                                // A normal case, and it is a range notation
                                // '[bar]'
                                // '[bar\\\\]'
                                ? "[".concat(sanitizeRange(range)).concat(endEscape, "]")
                                // Invalid range notaton
                                // '[bar\\]' -> '[bar\\\\]'
                                : '[]'
                            : '[]'; }
                ],
                // ending
                [
                    // 'js' will not match 'js.'
                    // 'ab' will not match 'abc'
                    /(?:[^*])$/,
                    // WTF!
                    // https://git-scm.com/docs/gitignore
                    // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
                    // which re-fixes #24, #38
                    // > If there is a separator at the end of the pattern then the pattern
                    // > will only match directories, otherwise the pattern can match both
                    // > files and directories.
                    // 'js*' will not match 'a.js'
                    // 'js/' will not match 'a.js'
                    // 'js' will match 'a.js' and 'a.js/'
                    function (match) { return /\/$/.test(match)
                        // foo/ will not match 'foo'
                        ? "".concat(match, "$")
                        // foo matches 'foo' and 'foo/'
                        : "".concat(match, "(?=$|\\/$)"); }
                ],
                // trailing wildcard
                [
                    /(\^|\\\/)?\\\*$/,
                    function (_, p1) {
                        var prefix = p1
                            // '\^':
                            // '/*' does not match EMPTY
                            // '/*' does not match everything
                            // '\\\/':
                            // 'abc/*' does not match 'abc/'
                            ? "".concat(p1, "[^/]+")
                            // 'a*' matches 'a'
                            // 'a*' matches 'aa'
                            : '[^/]*';
                        return "".concat(prefix, "(?=$|\\/$)");
                    }
                ],
            ];
            // A simple cache, because an ignore rule only has only one certain meaning
            var regexCache = Object.create(null);
            // @param {pattern}
            var makeRegex = function (pattern, ignoreCase) {
                var source = regexCache[pattern];
                if (!source) {
                    source = REPLACERS.reduce(function (prev, current) { return prev.replace(current[0], current[1].bind(pattern)); }, pattern);
                    regexCache[pattern] = source;
                }
                return ignoreCase
                    ? new RegExp(source, 'i')
                    : new RegExp(source);
            };
            var isString = function (subject) { return typeof subject === 'string'; };
            // > A blank line matches no files, so it can serve as a separator for readability.
            var checkPattern = function (pattern) { return pattern
                && isString(pattern)
                && !REGEX_TEST_BLANK_LINE.test(pattern)
                && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern)
                // > A line starting with # serves as a comment.
                && pattern.indexOf('#') !== 0; };
            var splitPattern = function (pattern) { return pattern.split(REGEX_SPLITALL_CRLF); };
            var IgnoreRule = /** @class */ (function () {
                function IgnoreRule(origin, pattern, negative, regex) {
                    this.origin = origin;
                    this.pattern = pattern;
                    this.negative = negative;
                    this.regex = regex;
                }
                return IgnoreRule;
            }());
            var createRule = function (pattern, ignoreCase) {
                var origin = pattern;
                var negative = false;
                // > An optional prefix "!" which negates the pattern;
                if (pattern.indexOf('!') === 0) {
                    negative = true;
                    pattern = pattern.substr(1);
                }
                pattern = pattern
                    // > Put a backslash ("\") in front of the first "!" for patterns that
                    // >   begin with a literal "!", for example, `"\!important!.txt"`.
                    .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')
                    // > Put a backslash ("\") in front of the first hash for patterns that
                    // >   begin with a hash.
                    .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#');
                var regex = makeRegex(pattern, ignoreCase);
                return new IgnoreRule(origin, pattern, negative, regex);
            };
            var throwError = function (message, Ctor) {
                throw new Ctor(message);
            };
            var checkPath = function (path, originalPath, doThrow) {
                if (!isString(path)) {
                    return doThrow("path must be a string, but got `".concat(originalPath, "`"), TypeError);
                }
                // We don't know if we should ignore EMPTY, so throw
                if (!path) {
                    return doThrow("path must not be empty", TypeError);
                }
                // Check if it is a relative path
                if (checkPath.isNotRelative(path)) {
                    var r = '`path.relative()`d';
                    return doThrow("path should be a ".concat(r, " string, but got \"").concat(originalPath, "\""), RangeError);
                }
                return true;
            };
            var isNotRelative = function (path) { return REGEX_TEST_INVALID_PATH.test(path); };
            checkPath.isNotRelative = isNotRelative;
            checkPath.convert = function (p) { return p; };
            var Ignore = /** @class */ (function () {
                function Ignore(_1) {
                    var _2 = _1 === void 0 ? {} : _1, _3 = _2.ignorecase, ignorecase = _3 === void 0 ? true : _3, _4 = _2.ignoreCase, ignoreCase = _4 === void 0 ? ignorecase : _4, _5 = _2.allowRelativePaths, allowRelativePaths = _5 === void 0 ? false : _5;
                    define(this, KEY_IGNORE, true);
                    this._rules = [];
                    this._ignoreCase = ignoreCase;
                    this._allowRelativePaths = allowRelativePaths;
                    this._initCache();
                }
                Ignore.prototype._initCache = function () {
                    this._ignoreCache = Object.create(null);
                    this._testCache = Object.create(null);
                };
                Ignore.prototype._addPattern = function (pattern) {
                    // #32
                    if (pattern && pattern[KEY_IGNORE]) {
                        this._rules = this._rules.concat(pattern._rules);
                        this._added = true;
                        return;
                    }
                    if (checkPattern(pattern)) {
                        var rule = createRule(pattern, this._ignoreCase);
                        this._added = true;
                        this._rules.push(rule);
                    }
                };
                // @param {Array<string> | string | Ignore} pattern
                Ignore.prototype.add = function (pattern) {
                    this._added = false;
                    makeArray(isString(pattern)
                        ? splitPattern(pattern)
                        : pattern).forEach(this._addPattern, this);
                    // Some rules have just added to the ignore,
                    // making the behavior changed.
                    if (this._added) {
                        this._initCache();
                    }
                    return this;
                };
                // legacy
                Ignore.prototype.addPattern = function (pattern) {
                    return this.add(pattern);
                };
                //          |           ignored : unignored
                // negative |   0:0   |   0:1   |   1:0   |   1:1
                // -------- | ------- | ------- | ------- | --------
                //     0    |  TEST   |  TEST   |  SKIP   |    X
                //     1    |  TESTIF |  SKIP   |  TEST   |    X
                // - SKIP: always skip
                // - TEST: always test
                // - TESTIF: only test if checkUnignored
                // - X: that never happen
                // @param {boolean} whether should check if the path is unignored,
                //   setting `checkUnignored` to `false` could reduce additional
                //   path matching.
                // @returns {TestResult} true if a file is ignored
                Ignore.prototype._testOne = function (path, checkUnignored) {
                    var ignored = false;
                    var unignored = false;
                    this._rules.forEach(function (rule) {
                        var negative = rule.negative;
                        if (unignored === negative && ignored !== unignored
                            || negative && !ignored && !unignored && !checkUnignored) {
                            return;
                        }
                        var matched = rule.regex.test(path);
                        if (matched) {
                            ignored = !negative;
                            unignored = negative;
                        }
                    });
                    return {
                        ignored: ignored,
                        unignored: unignored
                    };
                };
                // @returns {TestResult}
                Ignore.prototype._test = function (originalPath, cache, checkUnignored, slices) {
                    var path = originalPath
                        // Supports nullable path
                        && checkPath.convert(originalPath);
                    checkPath(path, originalPath, this._allowRelativePaths
                        ? RETURN_FALSE
                        : throwError);
                    return this._t(path, cache, checkUnignored, slices);
                };
                Ignore.prototype._t = function (path, cache, checkUnignored, slices) {
                    if (path in cache) {
                        return cache[path];
                    }
                    if (!slices) {
                        // path/to/a.js
                        // ['path', 'to', 'a.js']
                        slices = path.split(SLASH);
                    }
                    slices.pop();
                    // If the path has no parent directory, just test it
                    if (!slices.length) {
                        return cache[path] = this._testOne(path, checkUnignored);
                    }
                    var parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices);
                    // If the path contains a parent directory, check the parent first
                    return cache[path] = parent.ignored
                        // > It is not possible to re-include a file if a parent directory of
                        // >   that file is excluded.
                        ? parent
                        : this._testOne(path, checkUnignored);
                };
                Ignore.prototype.ignores = function (path) {
                    return this._test(path, this._ignoreCache, false).ignored;
                };
                Ignore.prototype.createFilter = function () {
                    var _this_1 = this;
                    return function (path) { return !_this_1.ignores(path); };
                };
                Ignore.prototype.filter = function (paths) {
                    return makeArray(paths).filter(this.createFilter());
                };
                // @returns {TestResult}
                Ignore.prototype.test = function (path) {
                    return this._test(path, this._testCache, true);
                };
                return Ignore;
            }());
            var factory = function (options) { return new Ignore(options); };
            var isPathValid = function (path) {
                return checkPath(path && checkPath.convert(path), path, RETURN_FALSE);
            };
            factory.isPathValid = isPathValid;
            // Fixes typescript
            factory["default"] = factory;
            module.exports = factory;
            // Windows
            // --------------------------------------------------------------
            /* istanbul ignore if */
            if (
            // Detect `process` so that it can run in browsers.
            typeof process !== 'undefined'
                && (process.env && process.env.IGNORE_TEST_WIN32
                    || process.platform === 'win32')) {
                /* eslint no-control-regex: "off" */
                var makePosix = function (str) { return /^\\\\\?\\/.test(str)
                    || /["<>|\u0000-\u001F]+/u.test(str)
                    ? str
                    : str.replace(/\\/g, '/'); };
                checkPath.convert = makePosix;
                // 'C:\\foo'     <- 'C:\\foo' has been converted to 'C:/'
                // 'd:\\foo'
                var REGIX_IS_WINDOWS_PATH_ABSOLUTE_1 = /^[a-z]:\//i;
                checkPath.isNotRelative = function (path) {
                    return REGIX_IS_WINDOWS_PATH_ABSOLUTE_1.test(path)
                        || isNotRelative(path);
                };
            }
            /***/ 
        }),
        /***/ 3287: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            /*!
             * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
             *
             * Copyright (c) 2014-2017, Jon Schlinkert.
             * Released under the MIT License.
             */
            function isObject(o) {
                return Object.prototype.toString.call(o) === '[object Object]';
            }
            function isPlainObject(o) {
                var ctor, prot;
                if (isObject(o) === false)
                    return false;
                // If has modified constructor
                ctor = o.constructor;
                if (ctor === undefined)
                    return true;
                // If has modified prototype
                prot = ctor.prototype;
                if (isObject(prot) === false)
                    return false;
                // If constructor does not have an Object-specific method
                if (prot.hasOwnProperty('isPrototypeOf') === false) {
                    return false;
                }
                // Most likely a plain Object
                return true;
            }
            exports.isPlainObject = isPlainObject;
            /***/ 
        }),
        /***/ 1531: 
        /***/ (function (__unused_webpack_module, exports) {
            // Copyright 2014, 2015, 2016, 2017, 2018 Simon Lydell
            // License: MIT. (See LICENSE.)
            Object.defineProperty(exports, "__esModule", ({
                value: true
            }));
            // This regex comes from regex.coffee, and is inserted here by generate-index.js
            // (run `npm run build`).
            exports["default"] = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
            exports.matchToToken = function (match) {
                var token = { type: "invalid", value: match[0], closed: undefined };
                if (match[1])
                    token.type = "string", token.closed = !!(match[3] || match[4]);
                else if (match[5])
                    token.type = "comment";
                else if (match[6])
                    token.type = "comment", token.closed = !!match[7];
                else if (match[8])
                    token.type = "regex";
                else if (match[9])
                    token.type = "number";
                else if (match[10])
                    token.type = "name";
                else if (match[11])
                    token.type = "punctuator";
                else if (match[12])
                    token.type = "whitespace";
                return token;
            };
            /***/ 
        }),
        /***/ 2533: 
        /***/ (function (module) {
            "use strict";
            var traverse = module.exports = function (schema, opts, cb) {
                // Legacy support for v0.3.1 and earlier.
                if (typeof opts == 'function') {
                    cb = opts;
                    opts = {};
                }
                cb = opts.cb || cb;
                var pre = (typeof cb == 'function') ? cb : cb.pre || function () { };
                var post = cb.post || function () { };
                _traverse(opts, pre, post, schema, '', schema);
            };
            traverse.keywords = {
                additionalItems: true,
                items: true,
                contains: true,
                additionalProperties: true,
                propertyNames: true,
                not: true,
                "if": true,
                then: true,
                "else": true
            };
            traverse.arrayKeywords = {
                items: true,
                allOf: true,
                anyOf: true,
                oneOf: true
            };
            traverse.propsKeywords = {
                $defs: true,
                definitions: true,
                properties: true,
                patternProperties: true,
                dependencies: true
            };
            traverse.skipKeywords = {
                "default": true,
                "enum": true,
                "const": true,
                required: true,
                maximum: true,
                minimum: true,
                exclusiveMaximum: true,
                exclusiveMinimum: true,
                multipleOf: true,
                maxLength: true,
                minLength: true,
                pattern: true,
                format: true,
                maxItems: true,
                minItems: true,
                uniqueItems: true,
                maxProperties: true,
                minProperties: true
            };
            function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
                if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
                    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
                    for (var key in schema) {
                        var sch = schema[key];
                        if (Array.isArray(sch)) {
                            if (key in traverse.arrayKeywords) {
                                for (var i = 0; i < sch.length; i++)
                                    _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
                            }
                        }
                        else if (key in traverse.propsKeywords) {
                            if (sch && typeof sch == 'object') {
                                for (var prop in sch)
                                    _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
                            }
                        }
                        else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
                            _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
                        }
                    }
                    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
                }
            }
            function escapeJsonPtr(str) {
                return str.replace(/~/g, '~0').replace(/\//g, '~1');
            }
            /***/ 
        }),
        /***/ 68: 
        /***/ (function (__unused_webpack_module, exports) {
            var _1;
            var FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM, isTTY = true;
            if (typeof process !== 'undefined') {
                (_1 = process.env || {}, FORCE_COLOR = _1.FORCE_COLOR, NODE_DISABLE_COLORS = _1.NODE_DISABLE_COLORS, NO_COLOR = _1.NO_COLOR, TERM = _1.TERM);
                isTTY = process.stdout && process.stdout.isTTY;
            }
            var $ = exports.$ = {
                enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== 'dumb' && (FORCE_COLOR != null && FORCE_COLOR !== '0' || isTTY)
            };
            function init(x, y) {
                var rgx = new RegExp("\\x1b\\[".concat(y, "m"), 'g');
                var open = "\u001B[".concat(x, "m"), close = "\u001B[".concat(y, "m");
                return function (txt) {
                    if (!$.enabled || txt == null)
                        return txt;
                    return open + (!!~('' + txt).indexOf(close) ? txt.replace(rgx, close + open) : txt) + close;
                };
            }
            // modifiers
            exports.reset = init(0, 0);
            exports.bold = init(1, 22);
            exports.dim = init(2, 22);
            exports.italic = init(3, 23);
            exports.underline = init(4, 24);
            exports.inverse = init(7, 27);
            exports.hidden = init(8, 28);
            exports.strikethrough = init(9, 29);
            // colors
            exports.black = init(30, 39);
            exports.red = init(31, 39);
            exports.green = init(32, 39);
            exports.yellow = init(33, 39);
            exports.blue = init(34, 39);
            exports.magenta = init(35, 39);
            exports.cyan = init(36, 39);
            exports.white = init(37, 39);
            exports.gray = init(90, 39);
            exports.grey = init(90, 39);
            // background colors
            exports.bgBlack = init(40, 49);
            exports.bgRed = init(41, 49);
            exports.bgGreen = init(42, 49);
            exports.bgYellow = init(43, 49);
            exports.bgBlue = init(44, 49);
            exports.bgMagenta = init(45, 49);
            exports.bgCyan = init(46, 49);
            exports.bgWhite = init(47, 49);
            /***/ 
        }),
        /***/ 5215: 
        /***/ (function (module) {
            "use strict";
            var _1;
            var FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM, isTTY = true;
            if (typeof process !== 'undefined') {
                (_1 = process.env || {}, FORCE_COLOR = _1.FORCE_COLOR, NODE_DISABLE_COLORS = _1.NODE_DISABLE_COLORS, NO_COLOR = _1.NO_COLOR, TERM = _1.TERM);
                isTTY = process.stdout && process.stdout.isTTY;
            }
            var $ = {
                enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== 'dumb' && (FORCE_COLOR != null && FORCE_COLOR !== '0' || isTTY),
                // modifiers
                reset: init(0, 0),
                bold: init(1, 22),
                dim: init(2, 22),
                italic: init(3, 23),
                underline: init(4, 24),
                inverse: init(7, 27),
                hidden: init(8, 28),
                strikethrough: init(9, 29),
                // colors
                black: init(30, 39),
                red: init(31, 39),
                green: init(32, 39),
                yellow: init(33, 39),
                blue: init(34, 39),
                magenta: init(35, 39),
                cyan: init(36, 39),
                white: init(37, 39),
                gray: init(90, 39),
                grey: init(90, 39),
                // background colors
                bgBlack: init(40, 49),
                bgRed: init(41, 49),
                bgGreen: init(42, 49),
                bgYellow: init(43, 49),
                bgBlue: init(44, 49),
                bgMagenta: init(45, 49),
                bgCyan: init(46, 49),
                bgWhite: init(47, 49)
            };
            function run(arr, str) {
                var i = 0, tmp, beg = '', end = '';
                for (; i < arr.length; i++) {
                    tmp = arr[i];
                    beg += tmp.open;
                    end += tmp.close;
                    if (!!~str.indexOf(tmp.close)) {
                        str = str.replace(tmp.rgx, tmp.close + tmp.open);
                    }
                }
                return beg + str + end;
            }
            function chain(has, keys) {
                var ctx = { has: has, keys: keys };
                ctx.reset = $.reset.bind(ctx);
                ctx.bold = $.bold.bind(ctx);
                ctx.dim = $.dim.bind(ctx);
                ctx.italic = $.italic.bind(ctx);
                ctx.underline = $.underline.bind(ctx);
                ctx.inverse = $.inverse.bind(ctx);
                ctx.hidden = $.hidden.bind(ctx);
                ctx.strikethrough = $.strikethrough.bind(ctx);
                ctx.black = $.black.bind(ctx);
                ctx.red = $.red.bind(ctx);
                ctx.green = $.green.bind(ctx);
                ctx.yellow = $.yellow.bind(ctx);
                ctx.blue = $.blue.bind(ctx);
                ctx.magenta = $.magenta.bind(ctx);
                ctx.cyan = $.cyan.bind(ctx);
                ctx.white = $.white.bind(ctx);
                ctx.gray = $.gray.bind(ctx);
                ctx.grey = $.grey.bind(ctx);
                ctx.bgBlack = $.bgBlack.bind(ctx);
                ctx.bgRed = $.bgRed.bind(ctx);
                ctx.bgGreen = $.bgGreen.bind(ctx);
                ctx.bgYellow = $.bgYellow.bind(ctx);
                ctx.bgBlue = $.bgBlue.bind(ctx);
                ctx.bgMagenta = $.bgMagenta.bind(ctx);
                ctx.bgCyan = $.bgCyan.bind(ctx);
                ctx.bgWhite = $.bgWhite.bind(ctx);
                return ctx;
            }
            function init(open, close) {
                var blk = {
                    open: "\u001B[".concat(open, "m"),
                    close: "\u001B[".concat(close, "m"),
                    rgx: new RegExp("\\x1b\\[".concat(close, "m"), 'g')
                };
                return function (txt) {
                    if (this !== void 0 && this.has !== void 0) {
                        !!~this.has.indexOf(open) || (this.has.push(open), this.keys.push(blk));
                        return txt === void 0 ? this : $.enabled ? run(this.keys, txt + '') : txt + '';
                    }
                    return txt === void 0 ? chain([open], [blk]) : $.enabled ? run([blk], txt + '') : txt + '';
                };
            }
            module.exports = $;
            /***/ 
        }),
        /***/ 7129: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            // A linked list to keep track of recently-used-ness
            var Yallist = __nccwpck_require__(665);
            var MAX = Symbol('max');
            var LENGTH = Symbol('length');
            var LENGTH_CALCULATOR = Symbol('lengthCalculator');
            var ALLOW_STALE = Symbol('allowStale');
            var MAX_AGE = Symbol('maxAge');
            var DISPOSE = Symbol('dispose');
            var NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');
            var LRU_LIST = Symbol('lruList');
            var CACHE = Symbol('cache');
            var UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');
            var naiveLength = function () { return 1; };
            // lruList is a yallist where the head is the youngest
            // item, and the tail is the oldest.  the list contains the Hit
            // objects as the entries.
            // Each Hit object has a reference to its Yallist.Node.  This
            // never changes.
            //
            // cache is a Map (or PseudoMap) that matches the keys to
            // the Yallist.Node object.
            var LRUCache = /** @class */ (function () {
                function LRUCache(options) {
                    if (typeof options === 'number')
                        options = { max: options };
                    if (!options)
                        options = {};
                    if (options.max && (typeof options.max !== 'number' || options.max < 0))
                        throw new TypeError('max must be a non-negative number');
                    // Kind of weird to have a default max of Infinity, but oh well.
                    var max = this[MAX] = options.max || Infinity;
                    var lc = options.length || naiveLength;
                    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc;
                    this[ALLOW_STALE] = options.stale || false;
                    if (options.maxAge && typeof options.maxAge !== 'number')
                        throw new TypeError('maxAge must be a number');
                    this[MAX_AGE] = options.maxAge || 0;
                    this[DISPOSE] = options.dispose;
                    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
                    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
                    this.reset();
                }
                Object.defineProperty(LRUCache.prototype, "max", {
                    get: function () {
                        return this[MAX];
                    },
                    // resize the cache when the max changes.
                    set: function (mL) {
                        if (typeof mL !== 'number' || mL < 0)
                            throw new TypeError('max must be a non-negative number');
                        this[MAX] = mL || Infinity;
                        trim(this);
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(LRUCache.prototype, "allowStale", {
                    get: function () {
                        return this[ALLOW_STALE];
                    },
                    set: function (allowStale) {
                        this[ALLOW_STALE] = !!allowStale;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(LRUCache.prototype, "maxAge", {
                    get: function () {
                        return this[MAX_AGE];
                    },
                    set: function (mA) {
                        if (typeof mA !== 'number')
                            throw new TypeError('maxAge must be a non-negative number');
                        this[MAX_AGE] = mA;
                        trim(this);
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(LRUCache.prototype, "lengthCalculator", {
                    get: function () { return this[LENGTH_CALCULATOR]; },
                    // resize the cache when the lengthCalculator changes.
                    set: function (lC) {
                        var _this_1 = this;
                        if (typeof lC !== 'function')
                            lC = naiveLength;
                        if (lC !== this[LENGTH_CALCULATOR]) {
                            this[LENGTH_CALCULATOR] = lC;
                            this[LENGTH] = 0;
                            this[LRU_LIST].forEach(function (hit) {
                                hit.length = _this_1[LENGTH_CALCULATOR](hit.value, hit.key);
                                _this_1[LENGTH] += hit.length;
                            });
                        }
                        trim(this);
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(LRUCache.prototype, "length", {
                    get: function () { return this[LENGTH]; },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(LRUCache.prototype, "itemCount", {
                    get: function () { return this[LRU_LIST].length; },
                    enumerable: false,
                    configurable: true
                });
                LRUCache.prototype.rforEach = function (fn, thisp) {
                    thisp = thisp || this;
                    for (var walker = this[LRU_LIST].tail; walker !== null;) {
                        var prev = walker.prev;
                        forEachStep(this, fn, walker, thisp);
                        walker = prev;
                    }
                };
                LRUCache.prototype.forEach = function (fn, thisp) {
                    thisp = thisp || this;
                    for (var walker = this[LRU_LIST].head; walker !== null;) {
                        var next = walker.next;
                        forEachStep(this, fn, walker, thisp);
                        walker = next;
                    }
                };
                LRUCache.prototype.keys = function () {
                    return this[LRU_LIST].toArray().map(function (k) { return k.key; });
                };
                LRUCache.prototype.values = function () {
                    return this[LRU_LIST].toArray().map(function (k) { return k.value; });
                };
                LRUCache.prototype.reset = function () {
                    var _this_1 = this;
                    if (this[DISPOSE] &&
                        this[LRU_LIST] &&
                        this[LRU_LIST].length) {
                        this[LRU_LIST].forEach(function (hit) { return _this_1[DISPOSE](hit.key, hit.value); });
                    }
                    this[CACHE] = new Map(); // hash of items by key
                    this[LRU_LIST] = new Yallist(); // list of items in order of use recency
                    this[LENGTH] = 0; // length of items in the list
                };
                LRUCache.prototype.dump = function () {
                    var _this_1 = this;
                    return this[LRU_LIST].map(function (hit) {
                        return isStale(_this_1, hit) ? false : {
                            k: hit.key,
                            v: hit.value,
                            e: hit.now + (hit.maxAge || 0)
                        };
                    }).toArray().filter(function (h) { return h; });
                };
                LRUCache.prototype.dumpLru = function () {
                    return this[LRU_LIST];
                };
                LRUCache.prototype.set = function (key, value, maxAge) {
                    maxAge = maxAge || this[MAX_AGE];
                    if (maxAge && typeof maxAge !== 'number')
                        throw new TypeError('maxAge must be a number');
                    var now = maxAge ? Date.now() : 0;
                    var len = this[LENGTH_CALCULATOR](value, key);
                    if (this[CACHE].has(key)) {
                        if (len > this[MAX]) {
                            del(this, this[CACHE].get(key));
                            return false;
                        }
                        var node = this[CACHE].get(key);
                        var item = node.value;
                        // dispose of the old one before overwriting
                        // split out into 2 ifs for better coverage tracking
                        if (this[DISPOSE]) {
                            if (!this[NO_DISPOSE_ON_SET])
                                this[DISPOSE](key, item.value);
                        }
                        item.now = now;
                        item.maxAge = maxAge;
                        item.value = value;
                        this[LENGTH] += len - item.length;
                        item.length = len;
                        this.get(key);
                        trim(this);
                        return true;
                    }
                    var hit = new Entry(key, value, len, now, maxAge);
                    // oversized objects fall out of cache automatically.
                    if (hit.length > this[MAX]) {
                        if (this[DISPOSE])
                            this[DISPOSE](key, value);
                        return false;
                    }
                    this[LENGTH] += hit.length;
                    this[LRU_LIST].unshift(hit);
                    this[CACHE].set(key, this[LRU_LIST].head);
                    trim(this);
                    return true;
                };
                LRUCache.prototype.has = function (key) {
                    if (!this[CACHE].has(key))
                        return false;
                    var hit = this[CACHE].get(key).value;
                    return !isStale(this, hit);
                };
                LRUCache.prototype.get = function (key) {
                    return get(this, key, true);
                };
                LRUCache.prototype.peek = function (key) {
                    return get(this, key, false);
                };
                LRUCache.prototype.pop = function () {
                    var node = this[LRU_LIST].tail;
                    if (!node)
                        return null;
                    del(this, node);
                    return node.value;
                };
                LRUCache.prototype.del = function (key) {
                    del(this, this[CACHE].get(key));
                };
                LRUCache.prototype.load = function (arr) {
                    // reset the cache
                    this.reset();
                    var now = Date.now();
                    // A previous serialized cache has the most recent items first
                    for (var l = arr.length - 1; l >= 0; l--) {
                        var hit = arr[l];
                        var expiresAt = hit.e || 0;
                        if (expiresAt === 0)
                            // the item was created without expiration in a non aged cache
                            this.set(hit.k, hit.v);
                        else {
                            var maxAge = expiresAt - now;
                            // dont add already expired items
                            if (maxAge > 0) {
                                this.set(hit.k, hit.v, maxAge);
                            }
                        }
                    }
                };
                LRUCache.prototype.prune = function () {
                    var _this_1 = this;
                    this[CACHE].forEach(function (value, key) { return get(_this_1, key, false); });
                };
                return LRUCache;
            }());
            var get = function (self, key, doUse) {
                var node = self[CACHE].get(key);
                if (node) {
                    var hit = node.value;
                    if (isStale(self, hit)) {
                        del(self, node);
                        if (!self[ALLOW_STALE])
                            return undefined;
                    }
                    else {
                        if (doUse) {
                            if (self[UPDATE_AGE_ON_GET])
                                node.value.now = Date.now();
                            self[LRU_LIST].unshiftNode(node);
                        }
                    }
                    return hit.value;
                }
            };
            var isStale = function (self, hit) {
                if (!hit || (!hit.maxAge && !self[MAX_AGE]))
                    return false;
                var diff = Date.now() - hit.now;
                return hit.maxAge ? diff > hit.maxAge
                    : self[MAX_AGE] && (diff > self[MAX_AGE]);
            };
            var trim = function (self) {
                if (self[LENGTH] > self[MAX]) {
                    for (var walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;) {
                        // We know that we're about to delete this one, and also
                        // what the next least recently used key will be, so just
                        // go ahead and set it now.
                        var prev = walker.prev;
                        del(self, walker);
                        walker = prev;
                    }
                }
            };
            var del = function (self, node) {
                if (node) {
                    var hit = node.value;
                    if (self[DISPOSE])
                        self[DISPOSE](hit.key, hit.value);
                    self[LENGTH] -= hit.length;
                    self[CACHE]["delete"](hit.key);
                    self[LRU_LIST].removeNode(node);
                }
            };
            var Entry = /** @class */ (function () {
                function Entry(key, value, length, now, maxAge) {
                    this.key = key;
                    this.value = value;
                    this.length = length;
                    this.now = now;
                    this.maxAge = maxAge || 0;
                }
                return Entry;
            }());
            var forEachStep = function (self, fn, node, thisp) {
                var hit = node.value;
                if (isStale(self, hit)) {
                    del(self, node);
                    if (!self[ALLOW_STALE])
                        hit = undefined;
                }
                if (hit)
                    fn.call(thisp, hit.value, hit.key, self);
            };
            module.exports = LRUCache;
            /***/ 
        }),
        /***/ 467: 
        /***/ (function (module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            function _interopDefault(ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }
            var Stream = _interopDefault(__nccwpck_require__(2781));
            var http = _interopDefault(__nccwpck_require__(3685));
            var Url = _interopDefault(__nccwpck_require__(7310));
            var whatwgUrl = _interopDefault(__nccwpck_require__(8665));
            var https = _interopDefault(__nccwpck_require__(5687));
            var zlib = _interopDefault(__nccwpck_require__(9796));
            // Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js
            // fix for "Readable" isn't a named export issue
            var Readable = Stream.Readable;
            var BUFFER = Symbol('buffer');
            var TYPE = Symbol('type');
            var Blob = /** @class */ (function () {
                function Blob() {
                    this[TYPE] = '';
                    var blobParts = arguments[0];
                    var options = arguments[1];
                    var buffers = [];
                    var size = 0;
                    if (blobParts) {
                        var a = blobParts;
                        var length_1 = Number(a.length);
                        for (var i = 0; i < length_1; i++) {
                            var element = a[i];
                            var buffer = void 0;
                            if (element instanceof Buffer) {
                                buffer = element;
                            }
                            else if (ArrayBuffer.isView(element)) {
                                buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
                            }
                            else if (element instanceof ArrayBuffer) {
                                buffer = Buffer.from(element);
                            }
                            else if (element instanceof Blob) {
                                buffer = element[BUFFER];
                            }
                            else {
                                buffer = Buffer.from(typeof element === 'string' ? element : String(element));
                            }
                            size += buffer.length;
                            buffers.push(buffer);
                        }
                    }
                    this[BUFFER] = Buffer.concat(buffers);
                    var type = options && options.type !== undefined && String(options.type).toLowerCase();
                    if (type && !/[^\u0020-\u007E]/.test(type)) {
                        this[TYPE] = type;
                    }
                }
                Object.defineProperty(Blob.prototype, "size", {
                    get: function () {
                        return this[BUFFER].length;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(Blob.prototype, "type", {
                    get: function () {
                        return this[TYPE];
                    },
                    enumerable: false,
                    configurable: true
                });
                Blob.prototype.text = function () {
                    return Promise.resolve(this[BUFFER].toString());
                };
                Blob.prototype.arrayBuffer = function () {
                    var buf = this[BUFFER];
                    var ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
                    return Promise.resolve(ab);
                };
                Blob.prototype.stream = function () {
                    var readable = new Readable();
                    readable._read = function () { };
                    readable.push(this[BUFFER]);
                    readable.push(null);
                    return readable;
                };
                Blob.prototype.toString = function () {
                    return '[object Blob]';
                };
                Blob.prototype.slice = function () {
                    var size = this.size;
                    var start = arguments[0];
                    var end = arguments[1];
                    var relativeStart, relativeEnd;
                    if (start === undefined) {
                        relativeStart = 0;
                    }
                    else if (start < 0) {
                        relativeStart = Math.max(size + start, 0);
                    }
                    else {
                        relativeStart = Math.min(start, size);
                    }
                    if (end === undefined) {
                        relativeEnd = size;
                    }
                    else if (end < 0) {
                        relativeEnd = Math.max(size + end, 0);
                    }
                    else {
                        relativeEnd = Math.min(end, size);
                    }
                    var span = Math.max(relativeEnd - relativeStart, 0);
                    var buffer = this[BUFFER];
                    var slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
                    var blob = new Blob([], { type: arguments[2] });
                    blob[BUFFER] = slicedBuffer;
                    return blob;
                };
                return Blob;
            }());
            Object.defineProperties(Blob.prototype, {
                size: { enumerable: true },
                type: { enumerable: true },
                slice: { enumerable: true }
            });
            Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
                value: 'Blob',
                writable: false,
                enumerable: false,
                configurable: true
            });
            /**
             * fetch-error.js
             *
             * FetchError interface for operational errors
             */
            /**
             * Create FetchError instance
             *
             * @param   String      message      Error message for human
             * @param   String      type         Error type for machine
             * @param   String      systemError  For Node.js system error
             * @return  FetchError
             */
            function FetchError(message, type, systemError) {
                Error.call(this, message);
                this.message = message;
                this.type = type;
                // when err.type is `system`, err.code contains system error code
                if (systemError) {
                    this.code = this.errno = systemError.code;
                }
                // hide custom error implementation details from end-users
                Error.captureStackTrace(this, this.constructor);
            }
            FetchError.prototype = Object.create(Error.prototype);
            FetchError.prototype.constructor = FetchError;
            FetchError.prototype.name = 'FetchError';
            var convert;
            try {
                convert = (__nccwpck_require__(2877).convert);
            }
            catch (e) { }
            var INTERNALS = Symbol('Body internals');
            // fix an issue where "PassThrough" isn't a named export for node <10
            var PassThrough = Stream.PassThrough;
            /**
             * Body mixin
             *
             * Ref: https://fetch.spec.whatwg.org/#body
             *
             * @param   Stream  body  Readable stream
             * @param   Object  opts  Response options
             * @return  Void
             */
            function Body(body) {
                var _this = this;
                var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$size = _ref.size;
                var size = _ref$size === undefined ? 0 : _ref$size;
                var _ref$timeout = _ref.timeout;
                var timeout = _ref$timeout === undefined ? 0 : _ref$timeout;
                if (body == null) {
                    // body is undefined or null
                    body = null;
                }
                else if (isURLSearchParams(body)) {
                    // body is a URLSearchParams
                    body = Buffer.from(body.toString());
                }
                else if (isBlob(body))
                    ;
                else if (Buffer.isBuffer(body))
                    ;
                else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
                    // body is ArrayBuffer
                    body = Buffer.from(body);
                }
                else if (ArrayBuffer.isView(body)) {
                    // body is ArrayBufferView
                    body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
                }
                else if (body instanceof Stream)
                    ;
                else {
                    // none of the above
                    // coerce to string then buffer
                    body = Buffer.from(String(body));
                }
                this[INTERNALS] = {
                    body: body,
                    disturbed: false,
                    error: null
                };
                this.size = size;
                this.timeout = timeout;
                if (body instanceof Stream) {
                    body.on('error', function (err) {
                        var error = err.name === 'AbortError' ? err : new FetchError("Invalid response body while trying to fetch ".concat(_this.url, ": ").concat(err.message), 'system', err);
                        _this[INTERNALS].error = error;
                    });
                }
            }
            Body.prototype = {
                get body() {
                    return this[INTERNALS].body;
                },
                get bodyUsed() {
                    return this[INTERNALS].disturbed;
                },
                /**
              * Decode response as ArrayBuffer
              *
              * @return  Promise
              */
                arrayBuffer: function () {
                    return consumeBody.call(this).then(function (buf) {
                        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
                    });
                },
                /**
              * Return raw response as Blob
              *
              * @return Promise
              */
                blob: function () {
                    var ct = this.headers && this.headers.get('content-type') || '';
                    return consumeBody.call(this).then(function (buf) {
                        var _1;
                        return Object.assign(
                        // Prevent copying
                        new Blob([], {
                            type: ct.toLowerCase()
                        }), (_1 = {},
                            _1[BUFFER] = buf,
                            _1));
                    });
                },
                /**
              * Decode response as json
              *
              * @return  Promise
              */
                json: function () {
                    var _this2 = this;
                    return consumeBody.call(this).then(function (buffer) {
                        try {
                            return JSON.parse(buffer.toString());
                        }
                        catch (err) {
                            return Body.Promise.reject(new FetchError("invalid json response body at ".concat(_this2.url, " reason: ").concat(err.message), 'invalid-json'));
                        }
                    });
                },
                /**
              * Decode response as text
              *
              * @return  Promise
              */
                text: function () {
                    return consumeBody.call(this).then(function (buffer) {
                        return buffer.toString();
                    });
                },
                /**
              * Decode response as buffer (non-spec api)
              *
              * @return  Promise
              */
                buffer: function () {
                    return consumeBody.call(this);
                },
                /**
              * Decode response as text, while automatically detecting the encoding and
              * trying to decode to UTF-8 (non-spec api)
              *
              * @return  Promise
              */
                textConverted: function () {
                    var _this3 = this;
                    return consumeBody.call(this).then(function (buffer) {
                        return convertBody(buffer, _this3.headers);
                    });
                }
            };
            // In browsers, all properties are enumerable.
            Object.defineProperties(Body.prototype, {
                body: { enumerable: true },
                bodyUsed: { enumerable: true },
                arrayBuffer: { enumerable: true },
                blob: { enumerable: true },
                json: { enumerable: true },
                text: { enumerable: true }
            });
            Body.mixIn = function (proto) {
                for (var _1 = 0, _2 = Object.getOwnPropertyNames(Body.prototype); _1 < _2.length; _1++) {
                    var name_6 = _2[_1];
                    // istanbul ignore else: future proof
                    if (!(name_6 in proto)) {
                        var desc = Object.getOwnPropertyDescriptor(Body.prototype, name_6);
                        Object.defineProperty(proto, name_6, desc);
                    }
                }
            };
            /**
             * Consume and convert an entire Body to a Buffer.
             *
             * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
             *
             * @return  Promise
             */
            function consumeBody() {
                var _this4 = this;
                if (this[INTERNALS].disturbed) {
                    return Body.Promise.reject(new TypeError("body used already for: ".concat(this.url)));
                }
                this[INTERNALS].disturbed = true;
                if (this[INTERNALS].error) {
                    return Body.Promise.reject(this[INTERNALS].error);
                }
                var body = this.body;
                // body is null
                if (body === null) {
                    return Body.Promise.resolve(Buffer.alloc(0));
                }
                // body is blob
                if (isBlob(body)) {
                    body = body.stream();
                }
                // body is buffer
                if (Buffer.isBuffer(body)) {
                    return Body.Promise.resolve(body);
                }
                // istanbul ignore if: should never happen
                if (!(body instanceof Stream)) {
                    return Body.Promise.resolve(Buffer.alloc(0));
                }
                // body is stream
                // get ready to actually consume the body
                var accum = [];
                var accumBytes = 0;
                var abort = false;
                return new Body.Promise(function (resolve, reject) {
                    var resTimeout;
                    // allow timeout on slow response body
                    if (_this4.timeout) {
                        resTimeout = setTimeout(function () {
                            abort = true;
                            reject(new FetchError("Response timeout while trying to fetch ".concat(_this4.url, " (over ").concat(_this4.timeout, "ms)"), 'body-timeout'));
                        }, _this4.timeout);
                    }
                    // handle stream errors
                    body.on('error', function (err) {
                        if (err.name === 'AbortError') {
                            // if the request was aborted, reject with this Error
                            abort = true;
                            reject(err);
                        }
                        else {
                            // other errors, such as incorrect content-encoding
                            reject(new FetchError("Invalid response body while trying to fetch ".concat(_this4.url, ": ").concat(err.message), 'system', err));
                        }
                    });
                    body.on('data', function (chunk) {
                        if (abort || chunk === null) {
                            return;
                        }
                        if (_this4.size && accumBytes + chunk.length > _this4.size) {
                            abort = true;
                            reject(new FetchError("content size at ".concat(_this4.url, " over limit: ").concat(_this4.size), 'max-size'));
                            return;
                        }
                        accumBytes += chunk.length;
                        accum.push(chunk);
                    });
                    body.on('end', function () {
                        if (abort) {
                            return;
                        }
                        clearTimeout(resTimeout);
                        try {
                            resolve(Buffer.concat(accum, accumBytes));
                        }
                        catch (err) {
                            // handle streams that have accumulated too much data (issue #414)
                            reject(new FetchError("Could not create Buffer from response body for ".concat(_this4.url, ": ").concat(err.message), 'system', err));
                        }
                    });
                });
            }
            /**
             * Detect buffer encoding and convert to target encoding
             * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
             *
             * @param   Buffer  buffer    Incoming buffer
             * @param   String  encoding  Target encoding
             * @return  String
             */
            function convertBody(buffer, headers) {
                if (typeof convert !== 'function') {
                    throw new Error('The package `encoding` must be installed to use the textConverted() function');
                }
                var ct = headers.get('content-type');
                var charset = 'utf-8';
                var res, str;
                // header
                if (ct) {
                    res = /charset=([^;]*)/i.exec(ct);
                }
                // no charset in content type, peek at response body for at most 1024 bytes
                str = buffer.slice(0, 1024).toString();
                // html5
                if (!res && str) {
                    res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
                }
                // html4
                if (!res && str) {
                    res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
                    if (!res) {
                        res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
                        if (res) {
                            res.pop(); // drop last quote
                        }
                    }
                    if (res) {
                        res = /charset=(.*)/i.exec(res.pop());
                    }
                }
                // xml
                if (!res && str) {
                    res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
                }
                // found charset
                if (res) {
                    charset = res.pop();
                    // prevent decode issues when sites use incorrect encoding
                    // ref: https://hsivonen.fi/encoding-menu/
                    if (charset === 'gb2312' || charset === 'gbk') {
                        charset = 'gb18030';
                    }
                }
                // turn raw buffers into a single utf-8 buffer
                return convert(buffer, 'UTF-8', charset).toString();
            }
            /**
             * Detect a URLSearchParams object
             * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143
             *
             * @param   Object  obj     Object to detect by type or brand
             * @return  String
             */
            function isURLSearchParams(obj) {
                // Duck-typing as a necessary condition.
                if (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj["delete"] !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {
                    return false;
                }
                // Brand-checking and more duck-typing as optional condition.
                return obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';
            }
            /**
             * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
             * @param  {*} obj
             * @return {boolean}
             */
            function isBlob(obj) {
                return typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
            }
            /**
             * Clone body given Res/Req instance
             *
             * @param   Mixed  instance  Response or Request instance
             * @return  Mixed
             */
            function clone(instance) {
                var p1, p2;
                var body = instance.body;
                // don't allow cloning a used body
                if (instance.bodyUsed) {
                    throw new Error('cannot clone body after it is used');
                }
                // check that body is a stream and not form-data object
                // note: we can't clone the form-data object without having it as a dependency
                if (body instanceof Stream && typeof body.getBoundary !== 'function') {
                    // tee instance body
                    p1 = new PassThrough();
                    p2 = new PassThrough();
                    body.pipe(p1);
                    body.pipe(p2);
                    // set instance body to teed body and return the other teed body
                    instance[INTERNALS].body = p1;
                    body = p2;
                }
                return body;
            }
            /**
             * Performs the operation "extract a `Content-Type` value from |object|" as
             * specified in the specification:
             * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
             *
             * This function assumes that instance.body is present.
             *
             * @param   Mixed  instance  Any options.body input
             */
            function extractContentType(body) {
                if (body === null) {
                    // body is null
                    return null;
                }
                else if (typeof body === 'string') {
                    // body is string
                    return 'text/plain;charset=UTF-8';
                }
                else if (isURLSearchParams(body)) {
                    // body is a URLSearchParams
                    return 'application/x-www-form-urlencoded;charset=UTF-8';
                }
                else if (isBlob(body)) {
                    // body is blob
                    return body.type || null;
                }
                else if (Buffer.isBuffer(body)) {
                    // body is buffer
                    return null;
                }
                else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
                    // body is ArrayBuffer
                    return null;
                }
                else if (ArrayBuffer.isView(body)) {
                    // body is ArrayBufferView
                    return null;
                }
                else if (typeof body.getBoundary === 'function') {
                    // detect form data input from form-data module
                    return "multipart/form-data;boundary=".concat(body.getBoundary());
                }
                else if (body instanceof Stream) {
                    // body is stream
                    // can't really do much about this
                    return null;
                }
                else {
                    // Body constructor defaults other things to string
                    return 'text/plain;charset=UTF-8';
                }
            }
            /**
             * The Fetch Standard treats this as if "total bytes" is a property on the body.
             * For us, we have to explicitly get it with a function.
             *
             * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
             *
             * @param   Body    instance   Instance of Body
             * @return  Number?            Number of bytes, or null if not possible
             */
            function getTotalBytes(instance) {
                var body = instance.body;
                if (body === null) {
                    // body is null
                    return 0;
                }
                else if (isBlob(body)) {
                    return body.size;
                }
                else if (Buffer.isBuffer(body)) {
                    // body is buffer
                    return body.length;
                }
                else if (body && typeof body.getLengthSync === 'function') {
                    // detect form data input from form-data module
                    if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
                        body.hasKnownLength && body.hasKnownLength()) {
                        // 2.x
                        return body.getLengthSync();
                    }
                    return null;
                }
                else {
                    // body is stream
                    return null;
                }
            }
            /**
             * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
             *
             * @param   Body    instance   Instance of Body
             * @return  Void
             */
            function writeToStream(dest, instance) {
                var body = instance.body;
                if (body === null) {
                    // body is null
                    dest.end();
                }
                else if (isBlob(body)) {
                    body.stream().pipe(dest);
                }
                else if (Buffer.isBuffer(body)) {
                    // body is buffer
                    dest.write(body);
                    dest.end();
                }
                else {
                    // body is stream
                    body.pipe(dest);
                }
            }
            // expose Promise
            Body.Promise = global.Promise;
            /**
             * headers.js
             *
             * Headers class offers convenient helpers
             */
            var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
            var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
            function validateName(name) {
                name = "".concat(name);
                if (invalidTokenRegex.test(name) || name === '') {
                    throw new TypeError("".concat(name, " is not a legal HTTP header name"));
                }
            }
            function validateValue(value) {
                value = "".concat(value);
                if (invalidHeaderCharRegex.test(value)) {
                    throw new TypeError("".concat(value, " is not a legal HTTP header value"));
                }
            }
            /**
             * Find the key in the map object given a header name.
             *
             * Returns undefined if not found.
             *
             * @param   String  name  Header name
             * @return  String|Undefined
             */
            function find(map, name) {
                name = name.toLowerCase();
                for (var key in map) {
                    if (key.toLowerCase() === name) {
                        return key;
                    }
                }
                return undefined;
            }
            var MAP = Symbol('map');
            var Headers = /** @class */ (function () {
                /**
              * Headers class
              *
              * @param   Object  headers  Response headers
              * @return  Void
              */
                function Headers() {
                    var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
                    this[MAP] = Object.create(null);
                    if (init instanceof Headers) {
                        var rawHeaders = init.raw();
                        var headerNames = Object.keys(rawHeaders);
                        for (var _1 = 0, headerNames_1 = headerNames; _1 < headerNames_1.length; _1++) {
                            var headerName = headerNames_1[_1];
                            for (var _2 = 0, _3 = rawHeaders[headerName]; _2 < _3.length; _2++) {
                                var value = _3[_2];
                                this.append(headerName, value);
                            }
                        }
                        return;
                    }
                    // We don't worry about converting prop to ByteString here as append()
                    // will handle it.
                    if (init == null)
                        ;
                    else if (typeof init === 'object') {
                        var method = init[Symbol.iterator];
                        if (method != null) {
                            if (typeof method !== 'function') {
                                throw new TypeError('Header pairs must be iterable');
                            }
                            // sequence<sequence<ByteString>>
                            // Note: per spec we have to first exhaust the lists then process them
                            var pairs = [];
                            for (var _4 = 0, init_1 = init; _4 < init_1.length; _4++) {
                                var pair = init_1[_4];
                                if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {
                                    throw new TypeError('Each header pair must be iterable');
                                }
                                pairs.push(Array.from(pair));
                            }
                            for (var _5 = 0, pairs_1 = pairs; _5 < pairs_1.length; _5++) {
                                var pair = pairs_1[_5];
                                if (pair.length !== 2) {
                                    throw new TypeError('Each header pair must be a name/value tuple');
                                }
                                this.append(pair[0], pair[1]);
                            }
                        }
                        else {
                            // record<ByteString, ByteString>
                            for (var _6 = 0, _7 = Object.keys(init); _6 < _7.length; _6++) {
                                var key = _7[_6];
                                var value = init[key];
                                this.append(key, value);
                            }
                        }
                    }
                    else {
                        throw new TypeError('Provided initializer must be an object');
                    }
                }
                /**
              * Return combined header value given name
              *
              * @param   String  name  Header name
              * @return  Mixed
              */
                Headers.prototype.get = function (name) {
                    name = "".concat(name);
                    validateName(name);
                    var key = find(this[MAP], name);
                    if (key === undefined) {
                        return null;
                    }
                    return this[MAP][key].join(', ');
                };
                /**
              * Iterate over all headers
              *
              * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
              * @param   Boolean   thisArg   `this` context for callback function
              * @return  Void
              */
                Headers.prototype.forEach = function (callback) {
                    var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
                    var pairs = getHeaders(this);
                    var i = 0;
                    while (i < pairs.length) {
                        var _pairs$i = pairs[i];
                        var name_7 = _pairs$i[0], value = _pairs$i[1];
                        callback.call(thisArg, value, name_7, this);
                        pairs = getHeaders(this);
                        i++;
                    }
                };
                /**
              * Overwrite header values given name
              *
              * @param   String  name   Header name
              * @param   String  value  Header value
              * @return  Void
              */
                Headers.prototype.set = function (name, value) {
                    name = "".concat(name);
                    value = "".concat(value);
                    validateName(name);
                    validateValue(value);
                    var key = find(this[MAP], name);
                    this[MAP][key !== undefined ? key : name] = [value];
                };
                /**
              * Append a value onto existing header
              *
              * @param   String  name   Header name
              * @param   String  value  Header value
              * @return  Void
              */
                Headers.prototype.append = function (name, value) {
                    name = "".concat(name);
                    value = "".concat(value);
                    validateName(name);
                    validateValue(value);
                    var key = find(this[MAP], name);
                    if (key !== undefined) {
                        this[MAP][key].push(value);
                    }
                    else {
                        this[MAP][name] = [value];
                    }
                };
                /**
              * Check for header name existence
              *
              * @param   String   name  Header name
              * @return  Boolean
              */
                Headers.prototype.has = function (name) {
                    name = "".concat(name);
                    validateName(name);
                    return find(this[MAP], name) !== undefined;
                };
                /**
              * Delete all header values given name
              *
              * @param   String  name  Header name
              * @return  Void
              */
                Headers.prototype["delete"] = function (name) {
                    name = "".concat(name);
                    validateName(name);
                    var key = find(this[MAP], name);
                    if (key !== undefined) {
                        delete this[MAP][key];
                    }
                };
                /**
              * Return raw headers (non-spec api)
              *
              * @return  Object
              */
                Headers.prototype.raw = function () {
                    return this[MAP];
                };
                /**
              * Get an iterator on keys.
              *
              * @return  Iterator
              */
                Headers.prototype.keys = function () {
                    return createHeadersIterator(this, 'key');
                };
                /**
              * Get an iterator on values.
              *
              * @return  Iterator
              */
                Headers.prototype.values = function () {
                    return createHeadersIterator(this, 'value');
                };
                /**
              * Get an iterator on entries.
              *
              * This is the default iterator of the Headers object.
              *
              * @return  Iterator
              */
                Headers.prototype[Symbol.iterator] = function () {
                    return createHeadersIterator(this, 'key+value');
                };
                return Headers;
            }());
            Headers.prototype.entries = Headers.prototype[Symbol.iterator];
            Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
                value: 'Headers',
                writable: false,
                enumerable: false,
                configurable: true
            });
            Object.defineProperties(Headers.prototype, {
                get: { enumerable: true },
                forEach: { enumerable: true },
                set: { enumerable: true },
                append: { enumerable: true },
                has: { enumerable: true },
                "delete": { enumerable: true },
                keys: { enumerable: true },
                values: { enumerable: true },
                entries: { enumerable: true }
            });
            function getHeaders(headers) {
                var kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';
                var keys = Object.keys(headers[MAP]).sort();
                return keys.map(kind === 'key' ? function (k) {
                    return k.toLowerCase();
                } : kind === 'value' ? function (k) {
                    return headers[MAP][k].join(', ');
                } : function (k) {
                    return [k.toLowerCase(), headers[MAP][k].join(', ')];
                });
            }
            var INTERNAL = Symbol('internal');
            function createHeadersIterator(target, kind) {
                var iterator = Object.create(HeadersIteratorPrototype);
                iterator[INTERNAL] = {
                    target: target,
                    kind: kind,
                    index: 0
                };
                return iterator;
            }
            var HeadersIteratorPrototype = Object.setPrototypeOf({
                next: function () {
                    // istanbul ignore if
                    if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
                        throw new TypeError('Value of `this` is not a HeadersIterator');
                    }
                    var _INTERNAL = this[INTERNAL];
                    var target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
                    var values = getHeaders(target, kind);
                    var len = values.length;
                    if (index >= len) {
                        return {
                            value: undefined,
                            done: true
                        };
                    }
                    this[INTERNAL].index = index + 1;
                    return {
                        value: values[index],
                        done: false
                    };
                }
            }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
            Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
                value: 'HeadersIterator',
                writable: false,
                enumerable: false,
                configurable: true
            });
            /**
             * Export the Headers object in a form that Node.js can consume.
             *
             * @param   Headers  headers
             * @return  Object
             */
            function exportNodeCompatibleHeaders(headers) {
                var obj = Object.assign({ __proto__: null }, headers[MAP]);
                // http.request() only supports string as Host header. This hack makes
                // specifying custom Host header possible.
                var hostHeaderKey = find(headers[MAP], 'Host');
                if (hostHeaderKey !== undefined) {
                    obj[hostHeaderKey] = obj[hostHeaderKey][0];
                }
                return obj;
            }
            /**
             * Create a Headers object from an object of headers, ignoring those that do
             * not conform to HTTP grammar productions.
             *
             * @param   Object  obj  Object of headers
             * @return  Headers
             */
            function createHeadersLenient(obj) {
                var headers = new Headers();
                for (var _1 = 0, _2 = Object.keys(obj); _1 < _2.length; _1++) {
                    var name_8 = _2[_1];
                    if (invalidTokenRegex.test(name_8)) {
                        continue;
                    }
                    if (Array.isArray(obj[name_8])) {
                        for (var _3 = 0, _4 = obj[name_8]; _3 < _4.length; _3++) {
                            var val = _4[_3];
                            if (invalidHeaderCharRegex.test(val)) {
                                continue;
                            }
                            if (headers[MAP][name_8] === undefined) {
                                headers[MAP][name_8] = [val];
                            }
                            else {
                                headers[MAP][name_8].push(val);
                            }
                        }
                    }
                    else if (!invalidHeaderCharRegex.test(obj[name_8])) {
                        headers[MAP][name_8] = [obj[name_8]];
                    }
                }
                return headers;
            }
            var INTERNALS$1 = Symbol('Response internals');
            // fix an issue where "STATUS_CODES" aren't a named export for node <10
            var STATUS_CODES = http.STATUS_CODES;
            /**
             * Response class
             *
             * @param   Stream  body  Readable stream
             * @param   Object  opts  Response options
             * @return  Void
             */
            var Response = /** @class */ (function () {
                function Response() {
                    var body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
                    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                    Body.call(this, body, opts);
                    var status = opts.status || 200;
                    var headers = new Headers(opts.headers);
                    if (body != null && !headers.has('Content-Type')) {
                        var contentType = extractContentType(body);
                        if (contentType) {
                            headers.append('Content-Type', contentType);
                        }
                    }
                    this[INTERNALS$1] = {
                        url: opts.url,
                        status: status,
                        statusText: opts.statusText || STATUS_CODES[status],
                        headers: headers,
                        counter: opts.counter
                    };
                }
                Object.defineProperty(Response.prototype, "url", {
                    get: function () {
                        return this[INTERNALS$1].url || '';
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(Response.prototype, "status", {
                    get: function () {
                        return this[INTERNALS$1].status;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(Response.prototype, "ok", {
                    /**
                  * Convenience property representing if the request ended normally
                  */
                    get: function () {
                        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(Response.prototype, "redirected", {
                    get: function () {
                        return this[INTERNALS$1].counter > 0;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(Response.prototype, "statusText", {
                    get: function () {
                        return this[INTERNALS$1].statusText;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(Response.prototype, "headers", {
                    get: function () {
                        return this[INTERNALS$1].headers;
                    },
                    enumerable: false,
                    configurable: true
                });
                /**
              * Clone this response
              *
              * @return  Response
              */
                Response.prototype.clone = function () {
                    return new Response(clone(this), {
                        url: this.url,
                        status: this.status,
                        statusText: this.statusText,
                        headers: this.headers,
                        ok: this.ok,
                        redirected: this.redirected
                    });
                };
                return Response;
            }());
            Body.mixIn(Response.prototype);
            Object.defineProperties(Response.prototype, {
                url: { enumerable: true },
                status: { enumerable: true },
                ok: { enumerable: true },
                redirected: { enumerable: true },
                statusText: { enumerable: true },
                headers: { enumerable: true },
                clone: { enumerable: true }
            });
            Object.defineProperty(Response.prototype, Symbol.toStringTag, {
                value: 'Response',
                writable: false,
                enumerable: false,
                configurable: true
            });
            var INTERNALS$2 = Symbol('Request internals');
            var URL = Url.URL || whatwgUrl.URL;
            // fix an issue where "format", "parse" aren't a named export for node <10
            var parse_url = Url.parse;
            var format_url = Url.format;
            /**
             * Wrapper around `new URL` to handle arbitrary URLs
             *
             * @param  {string} urlStr
             * @return {void}
             */
            function parseURL(urlStr) {
                /*
                Check whether the URL is absolute or not
                    Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
                Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
             */
                if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
                    urlStr = new URL(urlStr).toString();
                }
                // Fallback to old implementation for arbitrary URLs
                return parse_url(urlStr);
            }
            var streamDestructionSupported = 'destroy' in Stream.Readable.prototype;
            /**
             * Check if a value is an instance of Request.
             *
             * @param   Mixed   input
             * @return  Boolean
             */
            function isRequest(input) {
                return typeof input === 'object' && typeof input[INTERNALS$2] === 'object';
            }
            function isAbortSignal(signal) {
                var proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);
                return !!(proto && proto.constructor.name === 'AbortSignal');
            }
            /**
             * Request class
             *
             * @param   Mixed   input  Url or Request instance
             * @param   Object  init   Custom options
             * @return  Void
             */
            var Request = /** @class */ (function () {
                function Request(input) {
                    var init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                    var parsedURL;
                    // normalize input
                    if (!isRequest(input)) {
                        if (input && input.href) {
                            // in order to support Node.js' Url objects; though WHATWG's URL objects
                            // will fall into this branch also (since their `toString()` will return
                            // `href` property anyway)
                            parsedURL = parseURL(input.href);
                        }
                        else {
                            // coerce input to a string before attempting to parse
                            parsedURL = parseURL("".concat(input));
                        }
                        input = {};
                    }
                    else {
                        parsedURL = parseURL(input.url);
                    }
                    var method = init.method || input.method || 'GET';
                    method = method.toUpperCase();
                    if ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {
                        throw new TypeError('Request with GET/HEAD method cannot have body');
                    }
                    var inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
                    Body.call(this, inputBody, {
                        timeout: init.timeout || input.timeout || 0,
                        size: init.size || input.size || 0
                    });
                    var headers = new Headers(init.headers || input.headers || {});
                    if (inputBody != null && !headers.has('Content-Type')) {
                        var contentType = extractContentType(inputBody);
                        if (contentType) {
                            headers.append('Content-Type', contentType);
                        }
                    }
                    var signal = isRequest(input) ? input.signal : null;
                    if ('signal' in init)
                        signal = init.signal;
                    if (signal != null && !isAbortSignal(signal)) {
                        throw new TypeError('Expected signal to be an instanceof AbortSignal');
                    }
                    this[INTERNALS$2] = {
                        method: method,
                        redirect: init.redirect || input.redirect || 'follow',
                        headers: headers,
                        parsedURL: parsedURL,
                        signal: signal
                    };
                    // node-fetch-only options
                    this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
                    this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
                    this.counter = init.counter || input.counter || 0;
                    this.agent = init.agent || input.agent;
                }
                Object.defineProperty(Request.prototype, "method", {
                    get: function () {
                        return this[INTERNALS$2].method;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(Request.prototype, "url", {
                    get: function () {
                        return format_url(this[INTERNALS$2].parsedURL);
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(Request.prototype, "headers", {
                    get: function () {
                        return this[INTERNALS$2].headers;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(Request.prototype, "redirect", {
                    get: function () {
                        return this[INTERNALS$2].redirect;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(Request.prototype, "signal", {
                    get: function () {
                        return this[INTERNALS$2].signal;
                    },
                    enumerable: false,
                    configurable: true
                });
                /**
              * Clone this request
              *
              * @return  Request
              */
                Request.prototype.clone = function () {
                    return new Request(this);
                };
                return Request;
            }());
            Body.mixIn(Request.prototype);
            Object.defineProperty(Request.prototype, Symbol.toStringTag, {
                value: 'Request',
                writable: false,
                enumerable: false,
                configurable: true
            });
            Object.defineProperties(Request.prototype, {
                method: { enumerable: true },
                url: { enumerable: true },
                headers: { enumerable: true },
                redirect: { enumerable: true },
                clone: { enumerable: true },
                signal: { enumerable: true }
            });
            /**
             * Convert a Request to Node.js http request options.
             *
             * @param   Request  A Request instance
             * @return  Object   The options object to be passed to http.request
             */
            function getNodeRequestOptions(request) {
                var parsedURL = request[INTERNALS$2].parsedURL;
                var headers = new Headers(request[INTERNALS$2].headers);
                // fetch step 1.3
                if (!headers.has('Accept')) {
                    headers.set('Accept', '*/*');
                }
                // Basic fetch
                if (!parsedURL.protocol || !parsedURL.hostname) {
                    throw new TypeError('Only absolute URLs are supported');
                }
                if (!/^https?:$/.test(parsedURL.protocol)) {
                    throw new TypeError('Only HTTP(S) protocols are supported');
                }
                if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
                    throw new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');
                }
                // HTTP-network-or-cache fetch steps 2.4-2.7
                var contentLengthValue = null;
                if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
                    contentLengthValue = '0';
                }
                if (request.body != null) {
                    var totalBytes = getTotalBytes(request);
                    if (typeof totalBytes === 'number') {
                        contentLengthValue = String(totalBytes);
                    }
                }
                if (contentLengthValue) {
                    headers.set('Content-Length', contentLengthValue);
                }
                // HTTP-network-or-cache fetch step 2.11
                if (!headers.has('User-Agent')) {
                    headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
                }
                // HTTP-network-or-cache fetch step 2.15
                if (request.compress && !headers.has('Accept-Encoding')) {
                    headers.set('Accept-Encoding', 'gzip,deflate');
                }
                var agent = request.agent;
                if (typeof agent === 'function') {
                    agent = agent(parsedURL);
                }
                // HTTP-network fetch step 4.2
                // chunked encoding is handled by Node.js
                return Object.assign({}, parsedURL, {
                    method: request.method,
                    headers: exportNodeCompatibleHeaders(headers),
                    agent: agent
                });
            }
            /**
             * abort-error.js
             *
             * AbortError interface for cancelled requests
             */
            /**
             * Create AbortError instance
             *
             * @param   String      message      Error message for human
             * @return  AbortError
             */
            function AbortError(message) {
                Error.call(this, message);
                this.type = 'aborted';
                this.message = message;
                // hide custom error implementation details from end-users
                Error.captureStackTrace(this, this.constructor);
            }
            AbortError.prototype = Object.create(Error.prototype);
            AbortError.prototype.constructor = AbortError;
            AbortError.prototype.name = 'AbortError';
            var URL$1 = Url.URL || whatwgUrl.URL;
            // fix an issue where "PassThrough", "resolve" aren't a named export for node <10
            var PassThrough$1 = Stream.PassThrough;
            var isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {
                var orig = new URL$1(original).hostname;
                var dest = new URL$1(destination).hostname;
                return orig === dest || orig[orig.length - dest.length - 1] === '.' && orig.endsWith(dest);
            };
            /**
             * isSameProtocol reports whether the two provided URLs use the same protocol.
             *
             * Both domains must already be in canonical form.
             * @param {string|URL} original
             * @param {string|URL} destination
             */
            var isSameProtocol = function isSameProtocol(destination, original) {
                var orig = new URL$1(original).protocol;
                var dest = new URL$1(destination).protocol;
                return orig === dest;
            };
            /**
             * Fetch function
             *
             * @param   Mixed    url   Absolute url or Request instance
             * @param   Object   opts  Fetch options
             * @return  Promise
             */
            function fetch(url, opts) {
                // allow custom promise
                if (!fetch.Promise) {
                    throw new Error('native promise missing, set fetch.Promise to your favorite alternative');
                }
                Body.Promise = fetch.Promise;
                // wrap http.request into fetch
                return new fetch.Promise(function (resolve, reject) {
                    // build request object
                    var request = new Request(url, opts);
                    var options = getNodeRequestOptions(request);
                    var send = (options.protocol === 'https:' ? https : http).request;
                    var signal = request.signal;
                    var response = null;
                    var abort = function abort() {
                        var error = new AbortError('The user aborted a request.');
                        reject(error);
                        if (request.body && request.body instanceof Stream.Readable) {
                            destroyStream(request.body, error);
                        }
                        if (!response || !response.body)
                            return;
                        response.body.emit('error', error);
                    };
                    if (signal && signal.aborted) {
                        abort();
                        return;
                    }
                    var abortAndFinalize = function abortAndFinalize() {
                        abort();
                        finalize();
                    };
                    // send request
                    var req = send(options);
                    var reqTimeout;
                    if (signal) {
                        signal.addEventListener('abort', abortAndFinalize);
                    }
                    function finalize() {
                        req.abort();
                        if (signal)
                            signal.removeEventListener('abort', abortAndFinalize);
                        clearTimeout(reqTimeout);
                    }
                    if (request.timeout) {
                        req.once('socket', function (socket) {
                            reqTimeout = setTimeout(function () {
                                reject(new FetchError("network timeout at: ".concat(request.url), 'request-timeout'));
                                finalize();
                            }, request.timeout);
                        });
                    }
                    req.on('error', function (err) {
                        reject(new FetchError("request to ".concat(request.url, " failed, reason: ").concat(err.message), 'system', err));
                        if (response && response.body) {
                            destroyStream(response.body, err);
                        }
                        finalize();
                    });
                    fixResponseChunkedTransferBadEnding(req, function (err) {
                        if (signal && signal.aborted) {
                            return;
                        }
                        if (response && response.body) {
                            destroyStream(response.body, err);
                        }
                    });
                    /* c8 ignore next 18 */
                    if (parseInt(process.version.substring(1)) < 14) {
                        // Before Node.js 14, pipeline() does not fully support async iterators and does not always
                        // properly handle when the socket close/end events are out of order.
                        req.on('socket', function (s) {
                            s.addListener('close', function (hadError) {
                                // if a data listener is still present we didn't end cleanly
                                var hasDataListener = s.listenerCount('data') > 0;
                                // if end happened before close but the socket didn't emit an error, do it now
                                if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
                                    var err = new Error('Premature close');
                                    err.code = 'ERR_STREAM_PREMATURE_CLOSE';
                                    response.body.emit('error', err);
                                }
                            });
                        });
                    }
                    req.on('response', function (res) {
                        clearTimeout(reqTimeout);
                        var headers = createHeadersLenient(res.headers);
                        // HTTP fetch step 5
                        if (fetch.isRedirect(res.statusCode)) {
                            // HTTP fetch step 5.2
                            var location_1 = headers.get('Location');
                            // HTTP fetch step 5.3
                            var locationURL = null;
                            try {
                                locationURL = location_1 === null ? null : new URL$1(location_1, request.url).toString();
                            }
                            catch (err) {
                                // error here can only be invalid URL in Location: header
                                // do not throw when options.redirect == manual
                                // let the user extract the errorneous redirect URL
                                if (request.redirect !== 'manual') {
                                    reject(new FetchError("uri requested responds with an invalid redirect URL: ".concat(location_1), 'invalid-redirect'));
                                    finalize();
                                    return;
                                }
                            }
                            // HTTP fetch step 5.5
                            switch (request.redirect) {
                                case 'error':
                                    reject(new FetchError("uri requested responds with a redirect, redirect mode is set to error: ".concat(request.url), 'no-redirect'));
                                    finalize();
                                    return;
                                case 'manual':
                                    // node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.
                                    if (locationURL !== null) {
                                        // handle corrupted header
                                        try {
                                            headers.set('Location', locationURL);
                                        }
                                        catch (err) {
                                            // istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request
                                            reject(err);
                                        }
                                    }
                                    break;
                                case 'follow':
                                    // HTTP-redirect fetch step 2
                                    if (locationURL === null) {
                                        break;
                                    }
                                    // HTTP-redirect fetch step 5
                                    if (request.counter >= request.follow) {
                                        reject(new FetchError("maximum redirect reached at: ".concat(request.url), 'max-redirect'));
                                        finalize();
                                        return;
                                    }
                                    // HTTP-redirect fetch step 6 (counter increment)
                                    // Create a new Request object.
                                    var requestOpts = {
                                        headers: new Headers(request.headers),
                                        follow: request.follow,
                                        counter: request.counter + 1,
                                        agent: request.agent,
                                        compress: request.compress,
                                        method: request.method,
                                        body: request.body,
                                        signal: request.signal,
                                        timeout: request.timeout,
                                        size: request.size
                                    };
                                    if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
                                        for (var _1 = 0, _2 = ['authorization', 'www-authenticate', 'cookie', 'cookie2']; _1 < _2.length; _1++) {
                                            var name_9 = _2[_1];
                                            requestOpts.headers["delete"](name_9);
                                        }
                                    }
                                    // HTTP-redirect fetch step 9
                                    if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                                        reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
                                        finalize();
                                        return;
                                    }
                                    // HTTP-redirect fetch step 11
                                    if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {
                                        requestOpts.method = 'GET';
                                        requestOpts.body = undefined;
                                        requestOpts.headers["delete"]('content-length');
                                    }
                                    // HTTP-redirect fetch step 15
                                    resolve(fetch(new Request(locationURL, requestOpts)));
                                    finalize();
                                    return;
                            }
                        }
                        // prepare response
                        res.once('end', function () {
                            if (signal)
                                signal.removeEventListener('abort', abortAndFinalize);
                        });
                        var body = res.pipe(new PassThrough$1());
                        var response_options = {
                            url: request.url,
                            status: res.statusCode,
                            statusText: res.statusMessage,
                            headers: headers,
                            size: request.size,
                            timeout: request.timeout,
                            counter: request.counter
                        };
                        // HTTP-network fetch step 12.1.1.3
                        var codings = headers.get('Content-Encoding');
                        // HTTP-network fetch step 12.1.1.4: handle content codings
                        // in following scenarios we ignore compression support
                        // 1. compression support is disabled
                        // 2. HEAD request
                        // 3. no Content-Encoding header
                        // 4. no content response (204)
                        // 5. content not modified response (304)
                        if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {
                            response = new Response(body, response_options);
                            resolve(response);
                            return;
                        }
                        // For Node v6+
                        // Be less strict when decoding compressed responses, since sometimes
                        // servers send slightly invalid responses that are still accepted
                        // by common browsers.
                        // Always using Z_SYNC_FLUSH is what cURL does.
                        var zlibOptions = {
                            flush: zlib.Z_SYNC_FLUSH,
                            finishFlush: zlib.Z_SYNC_FLUSH
                        };
                        // for gzip
                        if (codings == 'gzip' || codings == 'x-gzip') {
                            body = body.pipe(zlib.createGunzip(zlibOptions));
                            response = new Response(body, response_options);
                            resolve(response);
                            return;
                        }
                        // for deflate
                        if (codings == 'deflate' || codings == 'x-deflate') {
                            // handle the infamous raw deflate response from old servers
                            // a hack for old IIS and Apache servers
                            var raw = res.pipe(new PassThrough$1());
                            raw.once('data', function (chunk) {
                                // see http://stackoverflow.com/questions/37519828
                                if ((chunk[0] & 0x0F) === 0x08) {
                                    body = body.pipe(zlib.createInflate());
                                }
                                else {
                                    body = body.pipe(zlib.createInflateRaw());
                                }
                                response = new Response(body, response_options);
                                resolve(response);
                            });
                            raw.on('end', function () {
                                // some old IIS servers return zero-length OK deflate responses, so 'data' is never emitted.
                                if (!response) {
                                    response = new Response(body, response_options);
                                    resolve(response);
                                }
                            });
                            return;
                        }
                        // for br
                        if (codings == 'br' && typeof zlib.createBrotliDecompress === 'function') {
                            body = body.pipe(zlib.createBrotliDecompress());
                            response = new Response(body, response_options);
                            resolve(response);
                            return;
                        }
                        // otherwise, use response as-is
                        response = new Response(body, response_options);
                        resolve(response);
                    });
                    writeToStream(req, request);
                });
            }
            function fixResponseChunkedTransferBadEnding(request, errorCallback) {
                var socket;
                request.on('socket', function (s) {
                    socket = s;
                });
                request.on('response', function (response) {
                    var headers = response.headers;
                    if (headers['transfer-encoding'] === 'chunked' && !headers['content-length']) {
                        response.once('close', function (hadError) {
                            // tests for socket presence, as in some situations the
                            // the 'socket' event is not triggered for the request
                            // (happens in deno), avoids `TypeError`
                            // if a data listener is still present we didn't end cleanly
                            var hasDataListener = socket && socket.listenerCount('data') > 0;
                            if (hasDataListener && !hadError) {
                                var err = new Error('Premature close');
                                err.code = 'ERR_STREAM_PREMATURE_CLOSE';
                                errorCallback(err);
                            }
                        });
                    }
                });
            }
            function destroyStream(stream, err) {
                if (stream.destroy) {
                    stream.destroy(err);
                }
                else {
                    // node < 8
                    stream.emit('error', err);
                    stream.end();
                }
            }
            /**
             * Redirect code matching
             *
             * @param   Number   code  Status code
             * @return  Boolean
             */
            fetch.isRedirect = function (code) {
                return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
            };
            // expose Promise
            fetch.Promise = global.Promise;
            module.exports = exports = fetch;
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports["default"] = exports;
            exports.Headers = Headers;
            exports.Request = Request;
            exports.Response = Response;
            exports.FetchError = FetchError;
            exports.AbortError = AbortError;
            /***/ 
        }),
        /***/ 1223: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var wrappy = __nccwpck_require__(2940);
            module.exports = wrappy(once);
            module.exports.strict = wrappy(onceStrict);
            once.proto = once(function () {
                Object.defineProperty(Function.prototype, 'once', {
                    value: function () {
                        return once(this);
                    },
                    configurable: true
                });
                Object.defineProperty(Function.prototype, 'onceStrict', {
                    value: function () {
                        return onceStrict(this);
                    },
                    configurable: true
                });
            });
            function once(fn) {
                var f = function () {
                    if (f.called)
                        return f.value;
                    f.called = true;
                    return f.value = fn.apply(this, arguments);
                };
                f.called = false;
                return f;
            }
            function onceStrict(fn) {
                var f = function () {
                    if (f.called)
                        throw new Error(f.onceError);
                    f.called = true;
                    return f.value = fn.apply(this, arguments);
                };
                var name = fn.name || 'Function wrapped with `once`';
                f.onceError = name + " shouldn't be called more than once";
                f.called = false;
                return f;
            }
            /***/ 
        }),
        /***/ 7280: 
        /***/ (function (module) {
            "use strict";
            var DatePart = /** @class */ (function () {
                function DatePart(_1) {
                    var token = _1.token, date = _1.date, parts = _1.parts, locales = _1.locales;
                    this.token = token;
                    this.date = date || new Date();
                    this.parts = parts || [this];
                    this.locales = locales || {};
                }
                DatePart.prototype.up = function () { };
                DatePart.prototype.down = function () { };
                DatePart.prototype.next = function () {
                    var currentIdx = this.parts.indexOf(this);
                    return this.parts.find(function (part, idx) { return idx > currentIdx && part instanceof DatePart; });
                };
                DatePart.prototype.setTo = function (val) { };
                DatePart.prototype.prev = function () {
                    var parts = [].concat(this.parts).reverse();
                    var currentIdx = parts.indexOf(this);
                    return parts.find(function (part, idx) { return idx > currentIdx && part instanceof DatePart; });
                };
                DatePart.prototype.toString = function () {
                    return String(this.date);
                };
                return DatePart;
            }());
            module.exports = DatePart;
            /***/ 
        }),
        /***/ 4203: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var DatePart = __nccwpck_require__(7280);
            var pos = function (n) {
                n = n % 10;
                return n === 1 ? 'st' : n === 2 ? 'nd' : n === 3 ? 'rd' : 'th';
            };
            var Day = /** @class */ (function (_super) {
                __extends(Day, _super);
                function Day(opts) {
                    if (opts === void 0) { opts = {}; }
                    return _super.call(this, opts) || this;
                }
                Day.prototype.up = function () {
                    this.date.setDate(this.date.getDate() + 1);
                };
                Day.prototype.down = function () {
                    this.date.setDate(this.date.getDate() - 1);
                };
                Day.prototype.setTo = function (val) {
                    this.date.setDate(parseInt(val.substr(-2)));
                };
                Day.prototype.toString = function () {
                    var date = this.date.getDate();
                    var day = this.date.getDay();
                    return this.token === 'DD' ? String(date).padStart(2, '0') : this.token === 'Do' ? date + pos(date) : this.token === 'd' ? day + 1 : this.token === 'ddd' ? this.locales.weekdaysShort[day] : this.token === 'dddd' ? this.locales.weekdays[day] : date;
                };
                return Day;
            }(DatePart));
            module.exports = Day;
            /***/ 
        }),
        /***/ 2574: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var DatePart = __nccwpck_require__(7280);
            var Hours = /** @class */ (function (_super) {
                __extends(Hours, _super);
                function Hours(opts) {
                    if (opts === void 0) { opts = {}; }
                    return _super.call(this, opts) || this;
                }
                Hours.prototype.up = function () {
                    this.date.setHours(this.date.getHours() + 1);
                };
                Hours.prototype.down = function () {
                    this.date.setHours(this.date.getHours() - 1);
                };
                Hours.prototype.setTo = function (val) {
                    this.date.setHours(parseInt(val.substr(-2)));
                };
                Hours.prototype.toString = function () {
                    var hours = this.date.getHours();
                    if (/h/.test(this.token))
                        hours = hours % 12 || 12;
                    return this.token.length > 1 ? String(hours).padStart(2, '0') : hours;
                };
                return Hours;
            }(DatePart));
            module.exports = Hours;
            /***/ 
        }),
        /***/ 2408: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            module.exports = {
                DatePart: __nccwpck_require__(7280),
                Meridiem: __nccwpck_require__(4853),
                Day: __nccwpck_require__(4203),
                Hours: __nccwpck_require__(2574),
                Milliseconds: __nccwpck_require__(4909),
                Minutes: __nccwpck_require__(5876),
                Month: __nccwpck_require__(9461),
                Seconds: __nccwpck_require__(5884),
                Year: __nccwpck_require__(359)
            };
            /***/ 
        }),
        /***/ 4853: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var DatePart = __nccwpck_require__(7280);
            var Meridiem = /** @class */ (function (_super) {
                __extends(Meridiem, _super);
                function Meridiem(opts) {
                    if (opts === void 0) { opts = {}; }
                    return _super.call(this, opts) || this;
                }
                Meridiem.prototype.up = function () {
                    this.date.setHours((this.date.getHours() + 12) % 24);
                };
                Meridiem.prototype.down = function () {
                    this.up();
                };
                Meridiem.prototype.toString = function () {
                    var meridiem = this.date.getHours() > 12 ? 'pm' : 'am';
                    return /\A/.test(this.token) ? meridiem.toUpperCase() : meridiem;
                };
                return Meridiem;
            }(DatePart));
            module.exports = Meridiem;
            /***/ 
        }),
        /***/ 4909: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var DatePart = __nccwpck_require__(7280);
            var Milliseconds = /** @class */ (function (_super) {
                __extends(Milliseconds, _super);
                function Milliseconds(opts) {
                    if (opts === void 0) { opts = {}; }
                    return _super.call(this, opts) || this;
                }
                Milliseconds.prototype.up = function () {
                    this.date.setMilliseconds(this.date.getMilliseconds() + 1);
                };
                Milliseconds.prototype.down = function () {
                    this.date.setMilliseconds(this.date.getMilliseconds() - 1);
                };
                Milliseconds.prototype.setTo = function (val) {
                    this.date.setMilliseconds(parseInt(val.substr(-this.token.length)));
                };
                Milliseconds.prototype.toString = function () {
                    return String(this.date.getMilliseconds()).padStart(4, '0').substr(0, this.token.length);
                };
                return Milliseconds;
            }(DatePart));
            module.exports = Milliseconds;
            /***/ 
        }),
        /***/ 5876: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var DatePart = __nccwpck_require__(7280);
            var Minutes = /** @class */ (function (_super) {
                __extends(Minutes, _super);
                function Minutes(opts) {
                    if (opts === void 0) { opts = {}; }
                    return _super.call(this, opts) || this;
                }
                Minutes.prototype.up = function () {
                    this.date.setMinutes(this.date.getMinutes() + 1);
                };
                Minutes.prototype.down = function () {
                    this.date.setMinutes(this.date.getMinutes() - 1);
                };
                Minutes.prototype.setTo = function (val) {
                    this.date.setMinutes(parseInt(val.substr(-2)));
                };
                Minutes.prototype.toString = function () {
                    var m = this.date.getMinutes();
                    return this.token.length > 1 ? String(m).padStart(2, '0') : m;
                };
                return Minutes;
            }(DatePart));
            module.exports = Minutes;
            /***/ 
        }),
        /***/ 9461: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var DatePart = __nccwpck_require__(7280);
            var Month = /** @class */ (function (_super) {
                __extends(Month, _super);
                function Month(opts) {
                    if (opts === void 0) { opts = {}; }
                    return _super.call(this, opts) || this;
                }
                Month.prototype.up = function () {
                    this.date.setMonth(this.date.getMonth() + 1);
                };
                Month.prototype.down = function () {
                    this.date.setMonth(this.date.getMonth() - 1);
                };
                Month.prototype.setTo = function (val) {
                    val = parseInt(val.substr(-2)) - 1;
                    this.date.setMonth(val < 0 ? 0 : val);
                };
                Month.prototype.toString = function () {
                    var month = this.date.getMonth();
                    var tl = this.token.length;
                    return tl === 2 ? String(month + 1).padStart(2, '0') : tl === 3 ? this.locales.monthsShort[month] : tl === 4 ? this.locales.months[month] : String(month + 1);
                };
                return Month;
            }(DatePart));
            module.exports = Month;
            /***/ 
        }),
        /***/ 5884: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var DatePart = __nccwpck_require__(7280);
            var Seconds = /** @class */ (function (_super) {
                __extends(Seconds, _super);
                function Seconds(opts) {
                    if (opts === void 0) { opts = {}; }
                    return _super.call(this, opts) || this;
                }
                Seconds.prototype.up = function () {
                    this.date.setSeconds(this.date.getSeconds() + 1);
                };
                Seconds.prototype.down = function () {
                    this.date.setSeconds(this.date.getSeconds() - 1);
                };
                Seconds.prototype.setTo = function (val) {
                    this.date.setSeconds(parseInt(val.substr(-2)));
                };
                Seconds.prototype.toString = function () {
                    var s = this.date.getSeconds();
                    return this.token.length > 1 ? String(s).padStart(2, '0') : s;
                };
                return Seconds;
            }(DatePart));
            module.exports = Seconds;
            /***/ 
        }),
        /***/ 359: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var DatePart = __nccwpck_require__(7280);
            var Year = /** @class */ (function (_super) {
                __extends(Year, _super);
                function Year(opts) {
                    if (opts === void 0) { opts = {}; }
                    return _super.call(this, opts) || this;
                }
                Year.prototype.up = function () {
                    this.date.setFullYear(this.date.getFullYear() + 1);
                };
                Year.prototype.down = function () {
                    this.date.setFullYear(this.date.getFullYear() - 1);
                };
                Year.prototype.setTo = function (val) {
                    this.date.setFullYear(val.substr(-4));
                };
                Year.prototype.toString = function () {
                    var year = String(this.date.getFullYear()).padStart(4, '0');
                    return this.token.length === 2 ? year.substr(-2) : year;
                };
                return Year;
            }(DatePart));
            module.exports = Year;
            /***/ 
        }),
        /***/ 2257: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try {
                var info = gen[key](arg);
                var value = info.value;
            }
            catch (error) {
                reject(error);
                return;
            } if (info.done) {
                resolve(value);
            }
            else {
                Promise.resolve(value).then(_next, _throw);
            } }
            function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
            var color = __nccwpck_require__(9407);
            var Prompt = __nccwpck_require__(461);
            var _require = __nccwpck_require__(9571), erase = _require.erase, cursor = _require.cursor;
            var _require2 = __nccwpck_require__(8091), style = _require2.style, clear = _require2.clear, figures = _require2.figures, wrap = _require2.wrap, entriesToDisplay = _require2.entriesToDisplay;
            var getVal = function (arr, i) { return arr[i] && (arr[i].value || arr[i].title || arr[i]); };
            var getTitle = function (arr, i) { return arr[i] && (arr[i].title || arr[i].value || arr[i]); };
            var getIndex = function (arr, valOrTitle) {
                var index = arr.findIndex(function (el) { return el.value === valOrTitle || el.title === valOrTitle; });
                return index > -1 ? index : undefined;
            };
            /**
             * TextPrompt Base Element
             * @param {Object} opts Options
             * @param {String} opts.message Message
             * @param {Array} opts.choices Array of auto-complete choices objects
             * @param {Function} [opts.suggest] Filter function. Defaults to sort by title
             * @param {Number} [opts.limit=10] Max number of results to show
             * @param {Number} [opts.cursor=0] Cursor start position
             * @param {String} [opts.style='default'] Render style
             * @param {String} [opts.fallback] Fallback message - initial to default value
             * @param {String} [opts.initial] Index of the default value
             * @param {Boolean} [opts.clearFirst] The first ESCAPE keypress will clear the input
             * @param {Stream} [opts.stdin] The Readable stream to listen to
             * @param {Stream} [opts.stdout] The Writable stream to write readline data to
             * @param {String} [opts.noMatches] The no matches found label
             */
            var AutocompletePrompt = /** @class */ (function (_super) {
                __extends(AutocompletePrompt, _super);
                function AutocompletePrompt(opts) {
                    if (opts === void 0) { opts = {}; }
                    var _this_1 = _super.call(this, opts) || this;
                    _this_1.msg = opts.message;
                    _this_1.suggest = opts.suggest;
                    _this_1.choices = opts.choices;
                    _this_1.initial = typeof opts.initial === 'number' ? opts.initial : getIndex(opts.choices, opts.initial);
                    _this_1.select = _this_1.initial || opts.cursor || 0;
                    _this_1.i18n = {
                        noMatches: opts.noMatches || 'no matches found'
                    };
                    _this_1.fallback = opts.fallback || _this_1.initial;
                    _this_1.clearFirst = opts.clearFirst || false;
                    _this_1.suggestions = [];
                    _this_1.input = '';
                    _this_1.limit = opts.limit || 10;
                    _this_1.cursor = 0;
                    _this_1.transform = style.render(opts.style);
                    _this_1.scale = _this_1.transform.scale;
                    _this_1.render = _this_1.render.bind(_this_1);
                    _this_1.complete = _this_1.complete.bind(_this_1);
                    _this_1.clear = clear('', _this_1.out.columns);
                    _this_1.complete(_this_1.render);
                    _this_1.render();
                    return _this_1;
                }
                Object.defineProperty(AutocompletePrompt.prototype, "fallback", {
                    get: function () {
                        var choice;
                        if (typeof this._fb === 'number')
                            choice = this.choices[this._fb];
                        else if (typeof this._fb === 'string')
                            choice = {
                                title: this._fb
                            };
                        return choice || this._fb || {
                            title: this.i18n.noMatches
                        };
                    },
                    set: function (fb) {
                        this._fb = Number.isSafeInteger(parseInt(fb)) ? parseInt(fb) : fb;
                    },
                    enumerable: false,
                    configurable: true
                });
                AutocompletePrompt.prototype.moveSelect = function (i) {
                    this.select = i;
                    if (this.suggestions.length > 0)
                        this.value = getVal(this.suggestions, i);
                    else
                        this.value = this.fallback.value;
                    this.fire();
                };
                AutocompletePrompt.prototype.complete = function (cb) {
                    var _this = this;
                    return _asyncToGenerator(function () {
                        var p, suggestions, l;
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0:
                                    p = _this.completing = _this.suggest(_this.input, _this.choices);
                                    return [4 /*yield*/, p];
                                case 1:
                                    suggestions = _1.sent();
                                    if (_this.completing !== p)
                                        return [2 /*return*/];
                                    _this.suggestions = suggestions.map(function (s, i, arr) { return ({
                                        title: getTitle(arr, i),
                                        value: getVal(arr, i),
                                        description: s.description
                                    }); });
                                    _this.completing = false;
                                    l = Math.max(suggestions.length - 1, 0);
                                    _this.moveSelect(Math.min(l, _this.select));
                                    cb && cb();
                                    return [2 /*return*/];
                            }
                        });
                    })();
                };
                AutocompletePrompt.prototype.reset = function () {
                    var _this_1 = this;
                    this.input = '';
                    this.complete(function () {
                        _this_1.moveSelect(_this_1.initial !== void 0 ? _this_1.initial : 0);
                        _this_1.render();
                    });
                    this.render();
                };
                AutocompletePrompt.prototype.exit = function () {
                    if (this.clearFirst && this.input.length > 0) {
                        this.reset();
                    }
                    else {
                        this.done = this.exited = true;
                        this.aborted = false;
                        this.fire();
                        this.render();
                        this.out.write('\n');
                        this.close();
                    }
                };
                AutocompletePrompt.prototype.abort = function () {
                    this.done = this.aborted = true;
                    this.exited = false;
                    this.fire();
                    this.render();
                    this.out.write('\n');
                    this.close();
                };
                AutocompletePrompt.prototype.submit = function () {
                    this.done = true;
                    this.aborted = this.exited = false;
                    this.fire();
                    this.render();
                    this.out.write('\n');
                    this.close();
                };
                AutocompletePrompt.prototype._ = function (c, key) {
                    var s1 = this.input.slice(0, this.cursor);
                    var s2 = this.input.slice(this.cursor);
                    this.input = "".concat(s1).concat(c).concat(s2);
                    this.cursor = s1.length + 1;
                    this.complete(this.render);
                    this.render();
                };
                AutocompletePrompt.prototype["delete"] = function () {
                    if (this.cursor === 0)
                        return this.bell();
                    var s1 = this.input.slice(0, this.cursor - 1);
                    var s2 = this.input.slice(this.cursor);
                    this.input = "".concat(s1).concat(s2);
                    this.complete(this.render);
                    this.cursor = this.cursor - 1;
                    this.render();
                };
                AutocompletePrompt.prototype.deleteForward = function () {
                    if (this.cursor * this.scale >= this.rendered.length)
                        return this.bell();
                    var s1 = this.input.slice(0, this.cursor);
                    var s2 = this.input.slice(this.cursor + 1);
                    this.input = "".concat(s1).concat(s2);
                    this.complete(this.render);
                    this.render();
                };
                AutocompletePrompt.prototype.first = function () {
                    this.moveSelect(0);
                    this.render();
                };
                AutocompletePrompt.prototype.last = function () {
                    this.moveSelect(this.suggestions.length - 1);
                    this.render();
                };
                AutocompletePrompt.prototype.up = function () {
                    if (this.select === 0) {
                        this.moveSelect(this.suggestions.length - 1);
                    }
                    else {
                        this.moveSelect(this.select - 1);
                    }
                    this.render();
                };
                AutocompletePrompt.prototype.down = function () {
                    if (this.select === this.suggestions.length - 1) {
                        this.moveSelect(0);
                    }
                    else {
                        this.moveSelect(this.select + 1);
                    }
                    this.render();
                };
                AutocompletePrompt.prototype.next = function () {
                    if (this.select === this.suggestions.length - 1) {
                        this.moveSelect(0);
                    }
                    else
                        this.moveSelect(this.select + 1);
                    this.render();
                };
                AutocompletePrompt.prototype.nextPage = function () {
                    this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1));
                    this.render();
                };
                AutocompletePrompt.prototype.prevPage = function () {
                    this.moveSelect(Math.max(this.select - this.limit, 0));
                    this.render();
                };
                AutocompletePrompt.prototype.left = function () {
                    if (this.cursor <= 0)
                        return this.bell();
                    this.cursor = this.cursor - 1;
                    this.render();
                };
                AutocompletePrompt.prototype.right = function () {
                    if (this.cursor * this.scale >= this.rendered.length)
                        return this.bell();
                    this.cursor = this.cursor + 1;
                    this.render();
                };
                AutocompletePrompt.prototype.renderOption = function (v, hovered, isStart, isEnd) {
                    var desc;
                    var prefix = isStart ? figures.arrowUp : isEnd ? figures.arrowDown : ' ';
                    var title = hovered ? color.cyan().underline(v.title) : v.title;
                    prefix = (hovered ? color.cyan(figures.pointer) + ' ' : '  ') + prefix;
                    if (v.description) {
                        desc = " - ".concat(v.description);
                        if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
                            desc = '\n' + wrap(v.description, {
                                margin: 3,
                                width: this.out.columns
                            });
                        }
                    }
                    return prefix + ' ' + title + color.gray(desc || '');
                };
                AutocompletePrompt.prototype.render = function () {
                    var _this_1 = this;
                    if (this.closed)
                        return;
                    if (this.firstRender)
                        this.out.write(cursor.hide);
                    else
                        this.out.write(clear(this.outputText, this.out.columns));
                    _super.prototype.render.call(this);
                    var _entriesToDisplay = entriesToDisplay(this.select, this.choices.length, this.limit), startIndex = _entriesToDisplay.startIndex, endIndex = _entriesToDisplay.endIndex;
                    this.outputText = [style.symbol(this.done, this.aborted, this.exited), color.bold(this.msg), style.delimiter(this.completing), this.done && this.suggestions[this.select] ? this.suggestions[this.select].title : this.rendered = this.transform.render(this.input)].join(' ');
                    if (!this.done) {
                        var suggestions = this.suggestions.slice(startIndex, endIndex).map(function (item, i) { return _this_1.renderOption(item, _this_1.select === i + startIndex, i === 0 && startIndex > 0, i + startIndex === endIndex - 1 && endIndex < _this_1.choices.length); }).join('\n');
                        this.outputText += "\n" + (suggestions || color.gray(this.fallback.title));
                    }
                    this.out.write(erase.line + cursor.to(0) + this.outputText);
                };
                return AutocompletePrompt;
            }(Prompt));
            module.exports = AutocompletePrompt;
            /***/ 
        }),
        /***/ 5441: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var color = __nccwpck_require__(9407);
            var _require = __nccwpck_require__(9571), cursor = _require.cursor;
            var MultiselectPrompt = __nccwpck_require__(4140);
            var _require2 = __nccwpck_require__(8091), clear = _require2.clear, style = _require2.style, figures = _require2.figures;
            /**
             * MultiselectPrompt Base Element
             * @param {Object} opts Options
             * @param {String} opts.message Message
             * @param {Array} opts.choices Array of choice objects
             * @param {String} [opts.hint] Hint to display
             * @param {String} [opts.warn] Hint shown for disabled choices
             * @param {Number} [opts.max] Max choices
             * @param {Number} [opts.cursor=0] Cursor start position
             * @param {Stream} [opts.stdin] The Readable stream to listen to
             * @param {Stream} [opts.stdout] The Writable stream to write readline data to
             */
            var AutocompleteMultiselectPrompt = /** @class */ (function (_super) {
                __extends(AutocompleteMultiselectPrompt, _super);
                function AutocompleteMultiselectPrompt(opts) {
                    if (opts === void 0) { opts = {}; }
                    var _this_1 = this;
                    opts.overrideRender = true;
                    _this_1 = _super.call(this, opts) || this;
                    _this_1.inputValue = '';
                    _this_1.clear = clear('', _this_1.out.columns);
                    _this_1.filteredOptions = _this_1.value;
                    _this_1.render();
                    return _this_1;
                }
                AutocompleteMultiselectPrompt.prototype.last = function () {
                    this.cursor = this.filteredOptions.length - 1;
                    this.render();
                };
                AutocompleteMultiselectPrompt.prototype.next = function () {
                    this.cursor = (this.cursor + 1) % this.filteredOptions.length;
                    this.render();
                };
                AutocompleteMultiselectPrompt.prototype.up = function () {
                    if (this.cursor === 0) {
                        this.cursor = this.filteredOptions.length - 1;
                    }
                    else {
                        this.cursor--;
                    }
                    this.render();
                };
                AutocompleteMultiselectPrompt.prototype.down = function () {
                    if (this.cursor === this.filteredOptions.length - 1) {
                        this.cursor = 0;
                    }
                    else {
                        this.cursor++;
                    }
                    this.render();
                };
                AutocompleteMultiselectPrompt.prototype.left = function () {
                    this.filteredOptions[this.cursor].selected = false;
                    this.render();
                };
                AutocompleteMultiselectPrompt.prototype.right = function () {
                    if (this.value.filter(function (e) { return e.selected; }).length >= this.maxChoices)
                        return this.bell();
                    this.filteredOptions[this.cursor].selected = true;
                    this.render();
                };
                AutocompleteMultiselectPrompt.prototype["delete"] = function () {
                    if (this.inputValue.length) {
                        this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1);
                        this.updateFilteredOptions();
                    }
                };
                AutocompleteMultiselectPrompt.prototype.updateFilteredOptions = function () {
                    var _this_1 = this;
                    var currentHighlight = this.filteredOptions[this.cursor];
                    this.filteredOptions = this.value.filter(function (v) {
                        if (_this_1.inputValue) {
                            if (typeof v.title === 'string') {
                                if (v.title.toLowerCase().includes(_this_1.inputValue.toLowerCase())) {
                                    return true;
                                }
                            }
                            if (typeof v.value === 'string') {
                                if (v.value.toLowerCase().includes(_this_1.inputValue.toLowerCase())) {
                                    return true;
                                }
                            }
                            return false;
                        }
                        return true;
                    });
                    var newHighlightIndex = this.filteredOptions.findIndex(function (v) { return v === currentHighlight; });
                    this.cursor = newHighlightIndex < 0 ? 0 : newHighlightIndex;
                    this.render();
                };
                AutocompleteMultiselectPrompt.prototype.handleSpaceToggle = function () {
                    var v = this.filteredOptions[this.cursor];
                    if (v.selected) {
                        v.selected = false;
                        this.render();
                    }
                    else if (v.disabled || this.value.filter(function (e) { return e.selected; }).length >= this.maxChoices) {
                        return this.bell();
                    }
                    else {
                        v.selected = true;
                        this.render();
                    }
                };
                AutocompleteMultiselectPrompt.prototype.handleInputChange = function (c) {
                    this.inputValue = this.inputValue + c;
                    this.updateFilteredOptions();
                };
                AutocompleteMultiselectPrompt.prototype._ = function (c, key) {
                    if (c === ' ') {
                        this.handleSpaceToggle();
                    }
                    else {
                        this.handleInputChange(c);
                    }
                };
                AutocompleteMultiselectPrompt.prototype.renderInstructions = function () {
                    if (this.instructions === undefined || this.instructions) {
                        if (typeof this.instructions === 'string') {
                            return this.instructions;
                        }
                        return "\nInstructions:\n    ".concat(figures.arrowUp, "/").concat(figures.arrowDown, ": Highlight option\n    ").concat(figures.arrowLeft, "/").concat(figures.arrowRight, "/[space]: Toggle selection\n    [a,b,c]/delete: Filter choices\n    enter/return: Complete answer\n");
                    }
                    return '';
                };
                AutocompleteMultiselectPrompt.prototype.renderCurrentInput = function () {
                    return "\nFiltered results for: ".concat(this.inputValue ? this.inputValue : color.gray('Enter something to filter'), "\n");
                };
                AutocompleteMultiselectPrompt.prototype.renderOption = function (cursor, v, i) {
                    var title;
                    if (v.disabled)
                        title = cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
                    else
                        title = cursor === i ? color.cyan().underline(v.title) : v.title;
                    return (v.selected ? color.green(figures.radioOn) : figures.radioOff) + '  ' + title;
                };
                AutocompleteMultiselectPrompt.prototype.renderDoneOrInstructions = function () {
                    if (this.done) {
                        return this.value.filter(function (e) { return e.selected; }).map(function (v) { return v.title; }).join(', ');
                    }
                    var output = [color.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
                    if (this.filteredOptions.length && this.filteredOptions[this.cursor].disabled) {
                        output.push(color.yellow(this.warn));
                    }
                    return output.join(' ');
                };
                AutocompleteMultiselectPrompt.prototype.render = function () {
                    if (this.closed)
                        return;
                    if (this.firstRender)
                        this.out.write(cursor.hide);
                    _super.prototype.render.call(this); // print prompt
                    var prompt = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.renderDoneOrInstructions()].join(' ');
                    if (this.showMinError) {
                        prompt += color.red("You must select a minimum of ".concat(this.minSelected, " choices."));
                        this.showMinError = false;
                    }
                    prompt += this.renderOptions(this.filteredOptions);
                    this.out.write(this.clear + prompt);
                    this.clear = clear(prompt, this.out.columns);
                };
                return AutocompleteMultiselectPrompt;
            }(MultiselectPrompt));
            module.exports = AutocompleteMultiselectPrompt;
            /***/ 
        }),
        /***/ 9486: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var color = __nccwpck_require__(9407);
            var Prompt = __nccwpck_require__(461);
            var _require = __nccwpck_require__(8091), style = _require.style, clear = _require.clear;
            var _require2 = __nccwpck_require__(9571), erase = _require2.erase, cursor = _require2.cursor;
            /**
             * ConfirmPrompt Base Element
             * @param {Object} opts Options
             * @param {String} opts.message Message
             * @param {Boolean} [opts.initial] Default value (true/false)
             * @param {Stream} [opts.stdin] The Readable stream to listen to
             * @param {Stream} [opts.stdout] The Writable stream to write readline data to
             * @param {String} [opts.yes] The "Yes" label
             * @param {String} [opts.yesOption] The "Yes" option when choosing between yes/no
             * @param {String} [opts.no] The "No" label
             * @param {String} [opts.noOption] The "No" option when choosing between yes/no
             */
            var ConfirmPrompt = /** @class */ (function (_super) {
                __extends(ConfirmPrompt, _super);
                function ConfirmPrompt(opts) {
                    if (opts === void 0) { opts = {}; }
                    var _this_1 = _super.call(this, opts) || this;
                    _this_1.msg = opts.message;
                    _this_1.value = opts.initial;
                    _this_1.initialValue = !!opts.initial;
                    _this_1.yesMsg = opts.yes || 'yes';
                    _this_1.yesOption = opts.yesOption || '(Y/n)';
                    _this_1.noMsg = opts.no || 'no';
                    _this_1.noOption = opts.noOption || '(y/N)';
                    _this_1.render();
                    return _this_1;
                }
                ConfirmPrompt.prototype.reset = function () {
                    this.value = this.initialValue;
                    this.fire();
                    this.render();
                };
                ConfirmPrompt.prototype.exit = function () {
                    this.abort();
                };
                ConfirmPrompt.prototype.abort = function () {
                    this.done = this.aborted = true;
                    this.fire();
                    this.render();
                    this.out.write('\n');
                    this.close();
                };
                ConfirmPrompt.prototype.submit = function () {
                    this.value = this.value || false;
                    this.done = true;
                    this.aborted = false;
                    this.fire();
                    this.render();
                    this.out.write('\n');
                    this.close();
                };
                ConfirmPrompt.prototype._ = function (c, key) {
                    if (c.toLowerCase() === 'y') {
                        this.value = true;
                        return this.submit();
                    }
                    if (c.toLowerCase() === 'n') {
                        this.value = false;
                        return this.submit();
                    }
                    return this.bell();
                };
                ConfirmPrompt.prototype.render = function () {
                    if (this.closed)
                        return;
                    if (this.firstRender)
                        this.out.write(cursor.hide);
                    else
                        this.out.write(clear(this.outputText, this.out.columns));
                    _super.prototype.render.call(this);
                    this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.done ? this.value ? this.yesMsg : this.noMsg : color.gray(this.initialValue ? this.yesOption : this.noOption)].join(' ');
                    this.out.write(erase.line + cursor.to(0) + this.outputText);
                };
                return ConfirmPrompt;
            }(Prompt));
            module.exports = ConfirmPrompt;
            /***/ 
        }),
        /***/ 4177: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try {
                var info = gen[key](arg);
                var value = info.value;
            }
            catch (error) {
                reject(error);
                return;
            } if (info.done) {
                resolve(value);
            }
            else {
                Promise.resolve(value).then(_next, _throw);
            } }
            function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
            var color = __nccwpck_require__(9407);
            var Prompt = __nccwpck_require__(461);
            var _require = __nccwpck_require__(8091), style = _require.style, clear = _require.clear, figures = _require.figures;
            var _require2 = __nccwpck_require__(9571), erase = _require2.erase, cursor = _require2.cursor;
            var _require3 = __nccwpck_require__(2408), DatePart = _require3.DatePart, Meridiem = _require3.Meridiem, Day = _require3.Day, Hours = _require3.Hours, Milliseconds = _require3.Milliseconds, Minutes = _require3.Minutes, Month = _require3.Month, Seconds = _require3.Seconds, Year = _require3.Year;
            var regex = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g;
            var regexGroups = {
                1: function (_1) {
                    var token = _1.token;
                    return token.replace(/\\(.)/g, '$1');
                },
                2: function (opts) { return new Day(opts); },
                // Day // TODO
                3: function (opts) { return new Month(opts); },
                // Month
                4: function (opts) { return new Year(opts); },
                // Year
                5: function (opts) { return new Meridiem(opts); },
                // AM/PM // TODO (special)
                6: function (opts) { return new Hours(opts); },
                // Hours
                7: function (opts) { return new Minutes(opts); },
                // Minutes
                8: function (opts) { return new Seconds(opts); },
                // Seconds
                9: function (opts) { return new Milliseconds(opts); } // Fractional seconds
            };
            var dfltLocales = {
                months: 'January,February,March,April,May,June,July,August,September,October,November,December'.split(','),
                monthsShort: 'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),
                weekdays: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),
                weekdaysShort: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(',')
            };
            /**
             * DatePrompt Base Element
             * @param {Object} opts Options
             * @param {String} opts.message Message
             * @param {Number} [opts.initial] Index of default value
             * @param {String} [opts.mask] The format mask
             * @param {object} [opts.locales] The date locales
             * @param {String} [opts.error] The error message shown on invalid value
             * @param {Function} [opts.validate] Function to validate the submitted value
             * @param {Stream} [opts.stdin] The Readable stream to listen to
             * @param {Stream} [opts.stdout] The Writable stream to write readline data to
             */
            var DatePrompt = /** @class */ (function (_super) {
                __extends(DatePrompt, _super);
                function DatePrompt(opts) {
                    if (opts === void 0) { opts = {}; }
                    var _this_1 = _super.call(this, opts) || this;
                    _this_1.msg = opts.message;
                    _this_1.cursor = 0;
                    _this_1.typed = '';
                    _this_1.locales = Object.assign(dfltLocales, opts.locales);
                    _this_1._date = opts.initial || new Date();
                    _this_1.errorMsg = opts.error || 'Please Enter A Valid Value';
                    _this_1.validator = opts.validate || (function () { return true; });
                    _this_1.mask = opts.mask || 'YYYY-MM-DD HH:mm:ss';
                    _this_1.clear = clear('', _this_1.out.columns);
                    _this_1.render();
                    return _this_1;
                }
                Object.defineProperty(DatePrompt.prototype, "value", {
                    get: function () {
                        return this.date;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(DatePrompt.prototype, "date", {
                    get: function () {
                        return this._date;
                    },
                    set: function (date) {
                        if (date)
                            this._date.setTime(date.getTime());
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(DatePrompt.prototype, "mask", {
                    set: function (mask) {
                        var _1;
                        var result;
                        this.parts = [];
                        while (result = regex.exec(mask)) {
                            var match = result.shift();
                            var idx = result.findIndex(function (gr) { return gr != null; });
                            this.parts.push(idx in regexGroups ? regexGroups[idx]({
                                token: result[idx] || match,
                                date: this.date,
                                parts: this.parts,
                                locales: this.locales
                            }) : result[idx] || match);
                        }
                        var parts = this.parts.reduce(function (arr, i) {
                            if (typeof i === 'string' && typeof arr[arr.length - 1] === 'string')
                                arr[arr.length - 1] += i;
                            else
                                arr.push(i);
                            return arr;
                        }, []);
                        this.parts.splice(0);
                        (_1 = this.parts).push.apply(_1, parts);
                        this.reset();
                    },
                    enumerable: false,
                    configurable: true
                });
                DatePrompt.prototype.moveCursor = function (n) {
                    this.typed = '';
                    this.cursor = n;
                    this.fire();
                };
                DatePrompt.prototype.reset = function () {
                    this.moveCursor(this.parts.findIndex(function (p) { return p instanceof DatePart; }));
                    this.fire();
                    this.render();
                };
                DatePrompt.prototype.exit = function () {
                    this.abort();
                };
                DatePrompt.prototype.abort = function () {
                    this.done = this.aborted = true;
                    this.error = false;
                    this.fire();
                    this.render();
                    this.out.write('\n');
                    this.close();
                };
                DatePrompt.prototype.validate = function () {
                    var _this = this;
                    return _asyncToGenerator(function () {
                        var valid;
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0: return [4 /*yield*/, _this.validator(_this.value)];
                                case 1:
                                    valid = _1.sent();
                                    if (typeof valid === 'string') {
                                        _this.errorMsg = valid;
                                        valid = false;
                                    }
                                    _this.error = !valid;
                                    return [2 /*return*/];
                            }
                        });
                    })();
                };
                DatePrompt.prototype.submit = function () {
                    var _this2 = this;
                    return _asyncToGenerator(function () {
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0: return [4 /*yield*/, _this2.validate()];
                                case 1:
                                    _1.sent();
                                    if (_this2.error) {
                                        _this2.color = 'red';
                                        _this2.fire();
                                        _this2.render();
                                        return [2 /*return*/];
                                    }
                                    _this2.done = true;
                                    _this2.aborted = false;
                                    _this2.fire();
                                    _this2.render();
                                    _this2.out.write('\n');
                                    _this2.close();
                                    return [2 /*return*/];
                            }
                        });
                    })();
                };
                DatePrompt.prototype.up = function () {
                    this.typed = '';
                    this.parts[this.cursor].up();
                    this.render();
                };
                DatePrompt.prototype.down = function () {
                    this.typed = '';
                    this.parts[this.cursor].down();
                    this.render();
                };
                DatePrompt.prototype.left = function () {
                    var prev = this.parts[this.cursor].prev();
                    if (prev == null)
                        return this.bell();
                    this.moveCursor(this.parts.indexOf(prev));
                    this.render();
                };
                DatePrompt.prototype.right = function () {
                    var next = this.parts[this.cursor].next();
                    if (next == null)
                        return this.bell();
                    this.moveCursor(this.parts.indexOf(next));
                    this.render();
                };
                DatePrompt.prototype.next = function () {
                    var next = this.parts[this.cursor].next();
                    this.moveCursor(next ? this.parts.indexOf(next) : this.parts.findIndex(function (part) { return part instanceof DatePart; }));
                    this.render();
                };
                DatePrompt.prototype._ = function (c) {
                    if (/\d/.test(c)) {
                        this.typed += c;
                        this.parts[this.cursor].setTo(this.typed);
                        this.render();
                    }
                };
                DatePrompt.prototype.render = function () {
                    var _this_1 = this;
                    if (this.closed)
                        return;
                    if (this.firstRender)
                        this.out.write(cursor.hide);
                    else
                        this.out.write(clear(this.outputText, this.out.columns));
                    _super.prototype.render.call(this); // Print prompt
                    this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.parts.reduce(function (arr, p, idx) { return arr.concat(idx === _this_1.cursor && !_this_1.done ? color.cyan().underline(p.toString()) : p); }, []).join('')].join(' '); // Print error
                    if (this.error) {
                        this.outputText += this.errorMsg.split('\n').reduce(function (a, l, i) { return a + "\n".concat(i ? " " : figures.pointerSmall, " ").concat(color.red().italic(l)); }, "");
                    }
                    this.out.write(erase.line + cursor.to(0) + this.outputText);
                };
                return DatePrompt;
            }(Prompt));
            module.exports = DatePrompt;
            /***/ 
        }),
        /***/ 2838: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            module.exports = {
                TextPrompt: __nccwpck_require__(16),
                SelectPrompt: __nccwpck_require__(8614),
                TogglePrompt: __nccwpck_require__(8001),
                DatePrompt: __nccwpck_require__(4177),
                NumberPrompt: __nccwpck_require__(7072),
                MultiselectPrompt: __nccwpck_require__(4140),
                AutocompletePrompt: __nccwpck_require__(2257),
                AutocompleteMultiselectPrompt: __nccwpck_require__(5441),
                ConfirmPrompt: __nccwpck_require__(9486)
            };
            /***/ 
        }),
        /***/ 4140: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var color = __nccwpck_require__(9407);
            var _require = __nccwpck_require__(9571), cursor = _require.cursor;
            var Prompt = __nccwpck_require__(461);
            var _require2 = __nccwpck_require__(8091), clear = _require2.clear, figures = _require2.figures, style = _require2.style, wrap = _require2.wrap, entriesToDisplay = _require2.entriesToDisplay;
            /**
             * MultiselectPrompt Base Element
             * @param {Object} opts Options
             * @param {String} opts.message Message
             * @param {Array} opts.choices Array of choice objects
             * @param {String} [opts.hint] Hint to display
             * @param {String} [opts.warn] Hint shown for disabled choices
             * @param {Number} [opts.max] Max choices
             * @param {Number} [opts.cursor=0] Cursor start position
             * @param {Number} [opts.optionsPerPage=10] Max options to display at once
             * @param {Stream} [opts.stdin] The Readable stream to listen to
             * @param {Stream} [opts.stdout] The Writable stream to write readline data to
             */
            var MultiselectPrompt = /** @class */ (function (_super) {
                __extends(MultiselectPrompt, _super);
                function MultiselectPrompt(opts) {
                    if (opts === void 0) { opts = {}; }
                    var _this_1 = _super.call(this, opts) || this;
                    _this_1.msg = opts.message;
                    _this_1.cursor = opts.cursor || 0;
                    _this_1.scrollIndex = opts.cursor || 0;
                    _this_1.hint = opts.hint || '';
                    _this_1.warn = opts.warn || '- This option is disabled -';
                    _this_1.minSelected = opts.min;
                    _this_1.showMinError = false;
                    _this_1.maxChoices = opts.max;
                    _this_1.instructions = opts.instructions;
                    _this_1.optionsPerPage = opts.optionsPerPage || 10;
                    _this_1.value = opts.choices.map(function (ch, idx) {
                        if (typeof ch === 'string')
                            ch = {
                                title: ch,
                                value: idx
                            };
                        return {
                            title: ch && (ch.title || ch.value || ch),
                            description: ch && ch.description,
                            value: ch && (ch.value === undefined ? idx : ch.value),
                            selected: ch && ch.selected,
                            disabled: ch && ch.disabled
                        };
                    });
                    _this_1.clear = clear('', _this_1.out.columns);
                    if (!opts.overrideRender) {
                        _this_1.render();
                    }
                    return _this_1;
                }
                MultiselectPrompt.prototype.reset = function () {
                    this.value.map(function (v) { return !v.selected; });
                    this.cursor = 0;
                    this.fire();
                    this.render();
                };
                MultiselectPrompt.prototype.selected = function () {
                    return this.value.filter(function (v) { return v.selected; });
                };
                MultiselectPrompt.prototype.exit = function () {
                    this.abort();
                };
                MultiselectPrompt.prototype.abort = function () {
                    this.done = this.aborted = true;
                    this.fire();
                    this.render();
                    this.out.write('\n');
                    this.close();
                };
                MultiselectPrompt.prototype.submit = function () {
                    var selected = this.value.filter(function (e) { return e.selected; });
                    if (this.minSelected && selected.length < this.minSelected) {
                        this.showMinError = true;
                        this.render();
                    }
                    else {
                        this.done = true;
                        this.aborted = false;
                        this.fire();
                        this.render();
                        this.out.write('\n');
                        this.close();
                    }
                };
                MultiselectPrompt.prototype.first = function () {
                    this.cursor = 0;
                    this.render();
                };
                MultiselectPrompt.prototype.last = function () {
                    this.cursor = this.value.length - 1;
                    this.render();
                };
                MultiselectPrompt.prototype.next = function () {
                    this.cursor = (this.cursor + 1) % this.value.length;
                    this.render();
                };
                MultiselectPrompt.prototype.up = function () {
                    if (this.cursor === 0) {
                        this.cursor = this.value.length - 1;
                    }
                    else {
                        this.cursor--;
                    }
                    this.render();
                };
                MultiselectPrompt.prototype.down = function () {
                    if (this.cursor === this.value.length - 1) {
                        this.cursor = 0;
                    }
                    else {
                        this.cursor++;
                    }
                    this.render();
                };
                MultiselectPrompt.prototype.left = function () {
                    this.value[this.cursor].selected = false;
                    this.render();
                };
                MultiselectPrompt.prototype.right = function () {
                    if (this.value.filter(function (e) { return e.selected; }).length >= this.maxChoices)
                        return this.bell();
                    this.value[this.cursor].selected = true;
                    this.render();
                };
                MultiselectPrompt.prototype.handleSpaceToggle = function () {
                    var v = this.value[this.cursor];
                    if (v.selected) {
                        v.selected = false;
                        this.render();
                    }
                    else if (v.disabled || this.value.filter(function (e) { return e.selected; }).length >= this.maxChoices) {
                        return this.bell();
                    }
                    else {
                        v.selected = true;
                        this.render();
                    }
                };
                MultiselectPrompt.prototype.toggleAll = function () {
                    if (this.maxChoices !== undefined || this.value[this.cursor].disabled) {
                        return this.bell();
                    }
                    var newSelected = !this.value[this.cursor].selected;
                    this.value.filter(function (v) { return !v.disabled; }).forEach(function (v) { return v.selected = newSelected; });
                    this.render();
                };
                MultiselectPrompt.prototype._ = function (c, key) {
                    if (c === ' ') {
                        this.handleSpaceToggle();
                    }
                    else if (c === 'a') {
                        this.toggleAll();
                    }
                    else {
                        return this.bell();
                    }
                };
                MultiselectPrompt.prototype.renderInstructions = function () {
                    if (this.instructions === undefined || this.instructions) {
                        if (typeof this.instructions === 'string') {
                            return this.instructions;
                        }
                        return '\nInstructions:\n' + "    ".concat(figures.arrowUp, "/").concat(figures.arrowDown, ": Highlight option\n") + "    ".concat(figures.arrowLeft, "/").concat(figures.arrowRight, "/[space]: Toggle selection\n") + (this.maxChoices === undefined ? "    a: Toggle all\n" : '') + "    enter/return: Complete answer";
                    }
                    return '';
                };
                MultiselectPrompt.prototype.renderOption = function (cursor, v, i, arrowIndicator) {
                    var prefix = (v.selected ? color.green(figures.radioOn) : figures.radioOff) + ' ' + arrowIndicator + ' ';
                    var title, desc;
                    if (v.disabled) {
                        title = cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
                    }
                    else {
                        title = cursor === i ? color.cyan().underline(v.title) : v.title;
                        if (cursor === i && v.description) {
                            desc = " - ".concat(v.description);
                            if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
                                desc = '\n' + wrap(v.description, {
                                    margin: prefix.length,
                                    width: this.out.columns
                                });
                            }
                        }
                    }
                    return prefix + title + color.gray(desc || '');
                }; // shared with autocompleteMultiselect
                MultiselectPrompt.prototype.paginateOptions = function (options) {
                    if (options.length === 0) {
                        return color.red('No matches for this query.');
                    }
                    var _entriesToDisplay = entriesToDisplay(this.cursor, options.length, this.optionsPerPage), startIndex = _entriesToDisplay.startIndex, endIndex = _entriesToDisplay.endIndex;
                    var prefix, styledOptions = [];
                    for (var i = startIndex; i < endIndex; i++) {
                        if (i === startIndex && startIndex > 0) {
                            prefix = figures.arrowUp;
                        }
                        else if (i === endIndex - 1 && endIndex < options.length) {
                            prefix = figures.arrowDown;
                        }
                        else {
                            prefix = ' ';
                        }
                        styledOptions.push(this.renderOption(this.cursor, options[i], i, prefix));
                    }
                    return '\n' + styledOptions.join('\n');
                }; // shared with autocomleteMultiselect
                MultiselectPrompt.prototype.renderOptions = function (options) {
                    if (!this.done) {
                        return this.paginateOptions(options);
                    }
                    return '';
                };
                MultiselectPrompt.prototype.renderDoneOrInstructions = function () {
                    if (this.done) {
                        return this.value.filter(function (e) { return e.selected; }).map(function (v) { return v.title; }).join(', ');
                    }
                    var output = [color.gray(this.hint), this.renderInstructions()];
                    if (this.value[this.cursor].disabled) {
                        output.push(color.yellow(this.warn));
                    }
                    return output.join(' ');
                };
                MultiselectPrompt.prototype.render = function () {
                    if (this.closed)
                        return;
                    if (this.firstRender)
                        this.out.write(cursor.hide);
                    _super.prototype.render.call(this); // print prompt
                    var prompt = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.renderDoneOrInstructions()].join(' ');
                    if (this.showMinError) {
                        prompt += color.red("You must select a minimum of ".concat(this.minSelected, " choices."));
                        this.showMinError = false;
                    }
                    prompt += this.renderOptions(this.value);
                    this.out.write(this.clear + prompt);
                    this.clear = clear(prompt, this.out.columns);
                };
                return MultiselectPrompt;
            }(Prompt));
            module.exports = MultiselectPrompt;
            /***/ 
        }),
        /***/ 7072: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try {
                var info = gen[key](arg);
                var value = info.value;
            }
            catch (error) {
                reject(error);
                return;
            } if (info.done) {
                resolve(value);
            }
            else {
                Promise.resolve(value).then(_next, _throw);
            } }
            function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
            var color = __nccwpck_require__(9407);
            var Prompt = __nccwpck_require__(461);
            var _require = __nccwpck_require__(9571), cursor = _require.cursor, erase = _require.erase;
            var _require2 = __nccwpck_require__(8091), style = _require2.style, figures = _require2.figures, clear = _require2.clear, lines = _require2.lines;
            var isNumber = /[0-9]/;
            var isDef = function (any) { return any !== undefined; };
            var round = function (number, precision) {
                var factor = Math.pow(10, precision);
                return Math.round(number * factor) / factor;
            };
            /**
             * NumberPrompt Base Element
             * @param {Object} opts Options
             * @param {String} opts.message Message
             * @param {String} [opts.style='default'] Render style
             * @param {Number} [opts.initial] Default value
             * @param {Number} [opts.max=+Infinity] Max value
             * @param {Number} [opts.min=-Infinity] Min value
             * @param {Boolean} [opts.float=false] Parse input as floats
             * @param {Number} [opts.round=2] Round floats to x decimals
             * @param {Number} [opts.increment=1] Number to increment by when using arrow-keys
             * @param {Function} [opts.validate] Validate function
             * @param {Stream} [opts.stdin] The Readable stream to listen to
             * @param {Stream} [opts.stdout] The Writable stream to write readline data to
             * @param {String} [opts.error] The invalid error label
             */
            var NumberPrompt = /** @class */ (function (_super) {
                __extends(NumberPrompt, _super);
                function NumberPrompt(opts) {
                    if (opts === void 0) { opts = {}; }
                    var _this_1 = _super.call(this, opts) || this;
                    _this_1.transform = style.render(opts.style);
                    _this_1.msg = opts.message;
                    _this_1.initial = isDef(opts.initial) ? opts.initial : '';
                    _this_1.float = !!opts.float;
                    _this_1.round = opts.round || 2;
                    _this_1.inc = opts.increment || 1;
                    _this_1.min = isDef(opts.min) ? opts.min : -Infinity;
                    _this_1.max = isDef(opts.max) ? opts.max : Infinity;
                    _this_1.errorMsg = opts.error || "Please Enter A Valid Value";
                    _this_1.validator = opts.validate || (function () { return true; });
                    _this_1.color = "cyan";
                    _this_1.value = "";
                    _this_1.typed = "";
                    _this_1.lastHit = 0;
                    _this_1.render();
                    return _this_1;
                }
                Object.defineProperty(NumberPrompt.prototype, "value", {
                    get: function () {
                        return this._value;
                    },
                    set: function (v) {
                        if (!v && v !== 0) {
                            this.placeholder = true;
                            this.rendered = color.gray(this.transform.render("".concat(this.initial)));
                            this._value = "";
                        }
                        else {
                            this.placeholder = false;
                            this.rendered = this.transform.render("".concat(round(v, this.round)));
                            this._value = round(v, this.round);
                        }
                        this.fire();
                    },
                    enumerable: false,
                    configurable: true
                });
                NumberPrompt.prototype.parse = function (x) {
                    return this.float ? parseFloat(x) : parseInt(x);
                };
                NumberPrompt.prototype.valid = function (c) {
                    return c === "-" || c === "." && this.float || isNumber.test(c);
                };
                NumberPrompt.prototype.reset = function () {
                    this.typed = "";
                    this.value = "";
                    this.fire();
                    this.render();
                };
                NumberPrompt.prototype.exit = function () {
                    this.abort();
                };
                NumberPrompt.prototype.abort = function () {
                    var x = this.value;
                    this.value = x !== "" ? x : this.initial;
                    this.done = this.aborted = true;
                    this.error = false;
                    this.fire();
                    this.render();
                    this.out.write("\n");
                    this.close();
                };
                NumberPrompt.prototype.validate = function () {
                    var _this = this;
                    return _asyncToGenerator(function () {
                        var valid;
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0: return [4 /*yield*/, _this.validator(_this.value)];
                                case 1:
                                    valid = _1.sent();
                                    if (typeof valid === "string") {
                                        _this.errorMsg = valid;
                                        valid = false;
                                    }
                                    _this.error = !valid;
                                    return [2 /*return*/];
                            }
                        });
                    })();
                };
                NumberPrompt.prototype.submit = function () {
                    var _this2 = this;
                    return _asyncToGenerator(function () {
                        var x;
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0: return [4 /*yield*/, _this2.validate()];
                                case 1:
                                    _1.sent();
                                    if (_this2.error) {
                                        _this2.color = "red";
                                        _this2.fire();
                                        _this2.render();
                                        return [2 /*return*/];
                                    }
                                    x = _this2.value;
                                    _this2.value = x !== "" ? x : _this2.initial;
                                    _this2.done = true;
                                    _this2.aborted = false;
                                    _this2.error = false;
                                    _this2.fire();
                                    _this2.render();
                                    _this2.out.write("\n");
                                    _this2.close();
                                    return [2 /*return*/];
                            }
                        });
                    })();
                };
                NumberPrompt.prototype.up = function () {
                    this.typed = "";
                    if (this.value === '') {
                        this.value = this.min - this.inc;
                    }
                    if (this.value >= this.max)
                        return this.bell();
                    this.value += this.inc;
                    this.color = "cyan";
                    this.fire();
                    this.render();
                };
                NumberPrompt.prototype.down = function () {
                    this.typed = "";
                    if (this.value === '') {
                        this.value = this.min + this.inc;
                    }
                    if (this.value <= this.min)
                        return this.bell();
                    this.value -= this.inc;
                    this.color = "cyan";
                    this.fire();
                    this.render();
                };
                NumberPrompt.prototype["delete"] = function () {
                    var val = this.value.toString();
                    if (val.length === 0)
                        return this.bell();
                    this.value = this.parse(val = val.slice(0, -1)) || "";
                    if (this.value !== '' && this.value < this.min) {
                        this.value = this.min;
                    }
                    this.color = "cyan";
                    this.fire();
                    this.render();
                };
                NumberPrompt.prototype.next = function () {
                    this.value = this.initial;
                    this.fire();
                    this.render();
                };
                NumberPrompt.prototype._ = function (c, key) {
                    if (!this.valid(c))
                        return this.bell();
                    var now = Date.now();
                    if (now - this.lastHit > 1000)
                        this.typed = ""; // 1s elapsed
                    this.typed += c;
                    this.lastHit = now;
                    this.color = "cyan";
                    if (c === ".")
                        return this.fire();
                    this.value = Math.min(this.parse(this.typed), this.max);
                    if (this.value > this.max)
                        this.value = this.max;
                    if (this.value < this.min)
                        this.value = this.min;
                    this.fire();
                    this.render();
                };
                NumberPrompt.prototype.render = function () {
                    if (this.closed)
                        return;
                    if (!this.firstRender) {
                        if (this.outputError)
                            this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
                        this.out.write(clear(this.outputText, this.out.columns));
                    }
                    _super.prototype.render.call(this);
                    this.outputError = ''; // Print prompt
                    this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), !this.done || !this.done && !this.placeholder ? color[this.color]().underline(this.rendered) : this.rendered].join(" "); // Print error
                    if (this.error) {
                        this.outputError += this.errorMsg.split("\n").reduce(function (a, l, i) { return a + "\n".concat(i ? " " : figures.pointerSmall, " ").concat(color.red().italic(l)); }, "");
                    }
                    this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore);
                };
                return NumberPrompt;
            }(Prompt));
            module.exports = NumberPrompt;
            /***/ 
        }),
        /***/ 461: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var readline = __nccwpck_require__(4521);
            var _require = __nccwpck_require__(8091), action = _require.action;
            var EventEmitter = __nccwpck_require__(2361);
            var _require2 = __nccwpck_require__(9571), beep = _require2.beep, cursor = _require2.cursor;
            var color = __nccwpck_require__(9407);
            /**
             * Base prompt skeleton
             * @param {Stream} [opts.stdin] The Readable stream to listen to
             * @param {Stream} [opts.stdout] The Writable stream to write readline data to
             */
            var Prompt = /** @class */ (function (_super) {
                __extends(Prompt, _super);
                function Prompt(opts) {
                    if (opts === void 0) { opts = {}; }
                    var _this_1 = _super.call(this) || this;
                    _this_1.firstRender = true;
                    _this_1["in"] = opts.stdin || process.stdin;
                    _this_1.out = opts.stdout || process.stdout;
                    _this_1.onRender = (opts.onRender || (function () { return void 0; })).bind(_this_1);
                    var rl = readline.createInterface({
                        input: _this_1["in"],
                        escapeCodeTimeout: 50
                    });
                    readline.emitKeypressEvents(_this_1["in"], rl);
                    if (_this_1["in"].isTTY)
                        _this_1["in"].setRawMode(true);
                    var isSelect = ['SelectPrompt', 'MultiselectPrompt'].indexOf(_this_1.constructor.name) > -1;
                    var keypress = function (str, key) {
                        var a = action(key, isSelect);
                        if (a === false) {
                            _this_1._ && _this_1._(str, key);
                        }
                        else if (typeof _this_1[a] === 'function') {
                            _this_1[a](key);
                        }
                        else {
                            _this_1.bell();
                        }
                    };
                    _this_1.close = function () {
                        _this_1.out.write(cursor.show);
                        _this_1["in"].removeListener('keypress', keypress);
                        if (_this_1["in"].isTTY)
                            _this_1["in"].setRawMode(false);
                        rl.close();
                        _this_1.emit(_this_1.aborted ? 'abort' : _this_1.exited ? 'exit' : 'submit', _this_1.value);
                        _this_1.closed = true;
                    };
                    _this_1["in"].on('keypress', keypress);
                    return _this_1;
                }
                Prompt.prototype.fire = function () {
                    this.emit('state', {
                        value: this.value,
                        aborted: !!this.aborted,
                        exited: !!this.exited
                    });
                };
                Prompt.prototype.bell = function () {
                    this.out.write(beep);
                };
                Prompt.prototype.render = function () {
                    this.onRender(color);
                    if (this.firstRender)
                        this.firstRender = false;
                };
                return Prompt;
            }(EventEmitter));
            module.exports = Prompt;
            /***/ 
        }),
        /***/ 8614: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var color = __nccwpck_require__(9407);
            var Prompt = __nccwpck_require__(461);
            var _require = __nccwpck_require__(8091), style = _require.style, clear = _require.clear, figures = _require.figures, wrap = _require.wrap, entriesToDisplay = _require.entriesToDisplay;
            var _require2 = __nccwpck_require__(9571), cursor = _require2.cursor;
            /**
             * SelectPrompt Base Element
             * @param {Object} opts Options
             * @param {String} opts.message Message
             * @param {Array} opts.choices Array of choice objects
             * @param {String} [opts.hint] Hint to display
             * @param {Number} [opts.initial] Index of default value
             * @param {Stream} [opts.stdin] The Readable stream to listen to
             * @param {Stream} [opts.stdout] The Writable stream to write readline data to
             * @param {Number} [opts.optionsPerPage=10] Max options to display at once
             */
            var SelectPrompt = /** @class */ (function (_super) {
                __extends(SelectPrompt, _super);
                function SelectPrompt(opts) {
                    if (opts === void 0) { opts = {}; }
                    var _this_1 = _super.call(this, opts) || this;
                    _this_1.msg = opts.message;
                    _this_1.hint = opts.hint || '- Use arrow-keys. Return to submit.';
                    _this_1.warn = opts.warn || '- This option is disabled';
                    _this_1.cursor = opts.initial || 0;
                    _this_1.choices = opts.choices.map(function (ch, idx) {
                        if (typeof ch === 'string')
                            ch = {
                                title: ch,
                                value: idx
                            };
                        return {
                            title: ch && (ch.title || ch.value || ch),
                            value: ch && (ch.value === undefined ? idx : ch.value),
                            description: ch && ch.description,
                            selected: ch && ch.selected,
                            disabled: ch && ch.disabled
                        };
                    });
                    _this_1.optionsPerPage = opts.optionsPerPage || 10;
                    _this_1.value = (_this_1.choices[_this_1.cursor] || {}).value;
                    _this_1.clear = clear('', _this_1.out.columns);
                    _this_1.render();
                    return _this_1;
                }
                SelectPrompt.prototype.moveCursor = function (n) {
                    this.cursor = n;
                    this.value = this.choices[n].value;
                    this.fire();
                };
                SelectPrompt.prototype.reset = function () {
                    this.moveCursor(0);
                    this.fire();
                    this.render();
                };
                SelectPrompt.prototype.exit = function () {
                    this.abort();
                };
                SelectPrompt.prototype.abort = function () {
                    this.done = this.aborted = true;
                    this.fire();
                    this.render();
                    this.out.write('\n');
                    this.close();
                };
                SelectPrompt.prototype.submit = function () {
                    if (!this.selection.disabled) {
                        this.done = true;
                        this.aborted = false;
                        this.fire();
                        this.render();
                        this.out.write('\n');
                        this.close();
                    }
                    else
                        this.bell();
                };
                SelectPrompt.prototype.first = function () {
                    this.moveCursor(0);
                    this.render();
                };
                SelectPrompt.prototype.last = function () {
                    this.moveCursor(this.choices.length - 1);
                    this.render();
                };
                SelectPrompt.prototype.up = function () {
                    if (this.cursor === 0) {
                        this.moveCursor(this.choices.length - 1);
                    }
                    else {
                        this.moveCursor(this.cursor - 1);
                    }
                    this.render();
                };
                SelectPrompt.prototype.down = function () {
                    if (this.cursor === this.choices.length - 1) {
                        this.moveCursor(0);
                    }
                    else {
                        this.moveCursor(this.cursor + 1);
                    }
                    this.render();
                };
                SelectPrompt.prototype.next = function () {
                    this.moveCursor((this.cursor + 1) % this.choices.length);
                    this.render();
                };
                SelectPrompt.prototype._ = function (c, key) {
                    if (c === ' ')
                        return this.submit();
                };
                Object.defineProperty(SelectPrompt.prototype, "selection", {
                    get: function () {
                        return this.choices[this.cursor];
                    },
                    enumerable: false,
                    configurable: true
                });
                SelectPrompt.prototype.render = function () {
                    if (this.closed)
                        return;
                    if (this.firstRender)
                        this.out.write(cursor.hide);
                    else
                        this.out.write(clear(this.outputText, this.out.columns));
                    _super.prototype.render.call(this);
                    var _entriesToDisplay = entriesToDisplay(this.cursor, this.choices.length, this.optionsPerPage), startIndex = _entriesToDisplay.startIndex, endIndex = _entriesToDisplay.endIndex; // Print prompt
                    this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.done ? this.selection.title : this.selection.disabled ? color.yellow(this.warn) : color.gray(this.hint)].join(' '); // Print choices
                    if (!this.done) {
                        this.outputText += '\n';
                        for (var i = startIndex; i < endIndex; i++) {
                            var title = void 0, prefix = void 0, desc = '', v = this.choices[i]; // Determine whether to display "more choices" indicators
                            if (i === startIndex && startIndex > 0) {
                                prefix = figures.arrowUp;
                            }
                            else if (i === endIndex - 1 && endIndex < this.choices.length) {
                                prefix = figures.arrowDown;
                            }
                            else {
                                prefix = ' ';
                            }
                            if (v.disabled) {
                                title = this.cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
                                prefix = (this.cursor === i ? color.bold().gray(figures.pointer) + ' ' : '  ') + prefix;
                            }
                            else {
                                title = this.cursor === i ? color.cyan().underline(v.title) : v.title;
                                prefix = (this.cursor === i ? color.cyan(figures.pointer) + ' ' : '  ') + prefix;
                                if (v.description && this.cursor === i) {
                                    desc = " - ".concat(v.description);
                                    if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
                                        desc = '\n' + wrap(v.description, {
                                            margin: 3,
                                            width: this.out.columns
                                        });
                                    }
                                }
                            }
                            this.outputText += "".concat(prefix, " ").concat(title).concat(color.gray(desc), "\n");
                        }
                    }
                    this.out.write(this.outputText);
                };
                return SelectPrompt;
            }(Prompt));
            module.exports = SelectPrompt;
            /***/ 
        }),
        /***/ 16: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try {
                var info = gen[key](arg);
                var value = info.value;
            }
            catch (error) {
                reject(error);
                return;
            } if (info.done) {
                resolve(value);
            }
            else {
                Promise.resolve(value).then(_next, _throw);
            } }
            function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
            var color = __nccwpck_require__(9407);
            var Prompt = __nccwpck_require__(461);
            var _require = __nccwpck_require__(9571), erase = _require.erase, cursor = _require.cursor;
            var _require2 = __nccwpck_require__(8091), style = _require2.style, clear = _require2.clear, lines = _require2.lines, figures = _require2.figures;
            /**
             * TextPrompt Base Element
             * @param {Object} opts Options
             * @param {String} opts.message Message
             * @param {String} [opts.style='default'] Render style
             * @param {String} [opts.initial] Default value
             * @param {Function} [opts.validate] Validate function
             * @param {Stream} [opts.stdin] The Readable stream to listen to
             * @param {Stream} [opts.stdout] The Writable stream to write readline data to
             * @param {String} [opts.error] The invalid error label
             */
            var TextPrompt = /** @class */ (function (_super) {
                __extends(TextPrompt, _super);
                function TextPrompt(opts) {
                    if (opts === void 0) { opts = {}; }
                    var _this_1 = _super.call(this, opts) || this;
                    _this_1.transform = style.render(opts.style);
                    _this_1.scale = _this_1.transform.scale;
                    _this_1.msg = opts.message;
                    _this_1.initial = opts.initial || "";
                    _this_1.validator = opts.validate || (function () { return true; });
                    _this_1.value = "";
                    _this_1.errorMsg = opts.error || "Please Enter A Valid Value";
                    _this_1.cursor = Number(!!_this_1.initial);
                    _this_1.cursorOffset = 0;
                    _this_1.clear = clear("", _this_1.out.columns);
                    _this_1.render();
                    return _this_1;
                }
                Object.defineProperty(TextPrompt.prototype, "value", {
                    get: function () {
                        return this._value;
                    },
                    set: function (v) {
                        if (!v && this.initial) {
                            this.placeholder = true;
                            this.rendered = color.gray(this.transform.render(this.initial));
                        }
                        else {
                            this.placeholder = false;
                            this.rendered = this.transform.render(v);
                        }
                        this._value = v;
                        this.fire();
                    },
                    enumerable: false,
                    configurable: true
                });
                TextPrompt.prototype.reset = function () {
                    this.value = "";
                    this.cursor = Number(!!this.initial);
                    this.cursorOffset = 0;
                    this.fire();
                    this.render();
                };
                TextPrompt.prototype.exit = function () {
                    this.abort();
                };
                TextPrompt.prototype.abort = function () {
                    this.value = this.value || this.initial;
                    this.done = this.aborted = true;
                    this.error = false;
                    this.red = false;
                    this.fire();
                    this.render();
                    this.out.write('\n');
                    this.close();
                };
                TextPrompt.prototype.validate = function () {
                    var _this = this;
                    return _asyncToGenerator(function () {
                        var valid;
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0: return [4 /*yield*/, _this.validator(_this.value)];
                                case 1:
                                    valid = _1.sent();
                                    if (typeof valid === "string") {
                                        _this.errorMsg = valid;
                                        valid = false;
                                    }
                                    _this.error = !valid;
                                    return [2 /*return*/];
                            }
                        });
                    })();
                };
                TextPrompt.prototype.submit = function () {
                    var _this2 = this;
                    return _asyncToGenerator(function () {
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0:
                                    _this2.value = _this2.value || _this2.initial;
                                    _this2.cursorOffset = 0;
                                    _this2.cursor = _this2.rendered.length;
                                    return [4 /*yield*/, _this2.validate()];
                                case 1:
                                    _1.sent();
                                    if (_this2.error) {
                                        _this2.red = true;
                                        _this2.fire();
                                        _this2.render();
                                        return [2 /*return*/];
                                    }
                                    _this2.done = true;
                                    _this2.aborted = false;
                                    _this2.fire();
                                    _this2.render();
                                    _this2.out.write('\n');
                                    _this2.close();
                                    return [2 /*return*/];
                            }
                        });
                    })();
                };
                TextPrompt.prototype.next = function () {
                    if (!this.placeholder)
                        return this.bell();
                    this.value = this.initial;
                    this.cursor = this.rendered.length;
                    this.fire();
                    this.render();
                };
                TextPrompt.prototype.moveCursor = function (n) {
                    if (this.placeholder)
                        return;
                    this.cursor = this.cursor + n;
                    this.cursorOffset += n;
                };
                TextPrompt.prototype._ = function (c, key) {
                    var s1 = this.value.slice(0, this.cursor);
                    var s2 = this.value.slice(this.cursor);
                    this.value = "".concat(s1).concat(c).concat(s2);
                    this.red = false;
                    this.cursor = this.placeholder ? 0 : s1.length + 1;
                    this.render();
                };
                TextPrompt.prototype["delete"] = function () {
                    if (this.isCursorAtStart())
                        return this.bell();
                    var s1 = this.value.slice(0, this.cursor - 1);
                    var s2 = this.value.slice(this.cursor);
                    this.value = "".concat(s1).concat(s2);
                    this.red = false;
                    if (this.isCursorAtStart()) {
                        this.cursorOffset = 0;
                    }
                    else {
                        this.cursorOffset++;
                        this.moveCursor(-1);
                    }
                    this.render();
                };
                TextPrompt.prototype.deleteForward = function () {
                    if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
                        return this.bell();
                    var s1 = this.value.slice(0, this.cursor);
                    var s2 = this.value.slice(this.cursor + 1);
                    this.value = "".concat(s1).concat(s2);
                    this.red = false;
                    if (this.isCursorAtEnd()) {
                        this.cursorOffset = 0;
                    }
                    else {
                        this.cursorOffset++;
                    }
                    this.render();
                };
                TextPrompt.prototype.first = function () {
                    this.cursor = 0;
                    this.render();
                };
                TextPrompt.prototype.last = function () {
                    this.cursor = this.value.length;
                    this.render();
                };
                TextPrompt.prototype.left = function () {
                    if (this.cursor <= 0 || this.placeholder)
                        return this.bell();
                    this.moveCursor(-1);
                    this.render();
                };
                TextPrompt.prototype.right = function () {
                    if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
                        return this.bell();
                    this.moveCursor(1);
                    this.render();
                };
                TextPrompt.prototype.isCursorAtStart = function () {
                    return this.cursor === 0 || this.placeholder && this.cursor === 1;
                };
                TextPrompt.prototype.isCursorAtEnd = function () {
                    return this.cursor === this.rendered.length || this.placeholder && this.cursor === this.rendered.length + 1;
                };
                TextPrompt.prototype.render = function () {
                    if (this.closed)
                        return;
                    if (!this.firstRender) {
                        if (this.outputError)
                            this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
                        this.out.write(clear(this.outputText, this.out.columns));
                    }
                    _super.prototype.render.call(this);
                    this.outputError = '';
                    this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.red ? color.red(this.rendered) : this.rendered].join(" ");
                    if (this.error) {
                        this.outputError += this.errorMsg.split("\n").reduce(function (a, l, i) { return a + "\n".concat(i ? ' ' : figures.pointerSmall, " ").concat(color.red().italic(l)); }, "");
                    }
                    this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore + cursor.move(this.cursorOffset, 0));
                };
                return TextPrompt;
            }(Prompt));
            module.exports = TextPrompt;
            /***/ 
        }),
        /***/ 8001: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var color = __nccwpck_require__(9407);
            var Prompt = __nccwpck_require__(461);
            var _require = __nccwpck_require__(8091), style = _require.style, clear = _require.clear;
            var _require2 = __nccwpck_require__(9571), cursor = _require2.cursor, erase = _require2.erase;
            /**
             * TogglePrompt Base Element
             * @param {Object} opts Options
             * @param {String} opts.message Message
             * @param {Boolean} [opts.initial=false] Default value
             * @param {String} [opts.active='no'] Active label
             * @param {String} [opts.inactive='off'] Inactive label
             * @param {Stream} [opts.stdin] The Readable stream to listen to
             * @param {Stream} [opts.stdout] The Writable stream to write readline data to
             */
            var TogglePrompt = /** @class */ (function (_super) {
                __extends(TogglePrompt, _super);
                function TogglePrompt(opts) {
                    if (opts === void 0) { opts = {}; }
                    var _this_1 = _super.call(this, opts) || this;
                    _this_1.msg = opts.message;
                    _this_1.value = !!opts.initial;
                    _this_1.active = opts.active || 'on';
                    _this_1.inactive = opts.inactive || 'off';
                    _this_1.initialValue = _this_1.value;
                    _this_1.render();
                    return _this_1;
                }
                TogglePrompt.prototype.reset = function () {
                    this.value = this.initialValue;
                    this.fire();
                    this.render();
                };
                TogglePrompt.prototype.exit = function () {
                    this.abort();
                };
                TogglePrompt.prototype.abort = function () {
                    this.done = this.aborted = true;
                    this.fire();
                    this.render();
                    this.out.write('\n');
                    this.close();
                };
                TogglePrompt.prototype.submit = function () {
                    this.done = true;
                    this.aborted = false;
                    this.fire();
                    this.render();
                    this.out.write('\n');
                    this.close();
                };
                TogglePrompt.prototype.deactivate = function () {
                    if (this.value === false)
                        return this.bell();
                    this.value = false;
                    this.render();
                };
                TogglePrompt.prototype.activate = function () {
                    if (this.value === true)
                        return this.bell();
                    this.value = true;
                    this.render();
                };
                TogglePrompt.prototype["delete"] = function () {
                    this.deactivate();
                };
                TogglePrompt.prototype.left = function () {
                    this.deactivate();
                };
                TogglePrompt.prototype.right = function () {
                    this.activate();
                };
                TogglePrompt.prototype.down = function () {
                    this.deactivate();
                };
                TogglePrompt.prototype.up = function () {
                    this.activate();
                };
                TogglePrompt.prototype.next = function () {
                    this.value = !this.value;
                    this.fire();
                    this.render();
                };
                TogglePrompt.prototype._ = function (c, key) {
                    if (c === ' ') {
                        this.value = !this.value;
                    }
                    else if (c === '1') {
                        this.value = true;
                    }
                    else if (c === '0') {
                        this.value = false;
                    }
                    else
                        return this.bell();
                    this.render();
                };
                TogglePrompt.prototype.render = function () {
                    if (this.closed)
                        return;
                    if (this.firstRender)
                        this.out.write(cursor.hide);
                    else
                        this.out.write(clear(this.outputText, this.out.columns));
                    _super.prototype.render.call(this);
                    this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.value ? this.inactive : color.cyan().underline(this.inactive), color.gray('/'), this.value ? color.cyan().underline(this.active) : this.active].join(' ');
                    this.out.write(erase.line + cursor.to(0) + this.outputText);
                };
                return TogglePrompt;
            }(Prompt));
            module.exports = TogglePrompt;
            /***/ 
        }),
        /***/ 5357: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                    symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; });
                }
                keys.push.apply(keys, symbols);
            } return keys; }
            function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                    ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); });
                }
                else if (Object.getOwnPropertyDescriptors) {
                    Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                }
                else {
                    ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); });
                }
            } return target; }
            function _defineProperty(obj, key, value) { if (key in obj) {
                Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
            }
            else {
                obj[key] = value;
            } return obj; }
            function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                        o = it;
                    var i = 0;
                    var F = function F() { };
                    return { s: F, n: function n() { if (i >= o.length)
                            return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                    if (!normalCompletion && it["return"] != null)
                        it["return"]();
                }
                finally {
                    if (didErr)
                        throw err;
                } } }; }
            function _unsupportedIterableToArray(o, minLen) { if (!o)
                return; if (typeof o === "string")
                return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                n = o.constructor.name; if (n === "Map" || n === "Set")
                return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray(o, minLen); }
            function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++)
                arr2[i] = arr[i]; return arr2; }
            function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try {
                var info = gen[key](arg);
                var value = info.value;
            }
            catch (error) {
                reject(error);
                return;
            } if (info.done) {
                resolve(value);
            }
            else {
                Promise.resolve(value).then(_next, _throw);
            } }
            function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
            var prompts = __nccwpck_require__(7627);
            var passOn = ['suggest', 'format', 'onState', 'validate', 'onRender', 'type'];
            var noop = function () { };
            /**
             * Prompt for a series of questions
             * @param {Array|Object} questions Single question object or Array of question objects
             * @param {Function} [onSubmit] Callback function called on prompt submit
             * @param {Function} [onCancel] Callback function called on cancel/abort
             * @returns {Object} Object with values from user input
             */
            function prompt() {
                return _prompt.apply(this, arguments);
            }
            function _prompt() {
                _prompt = _asyncToGenerator(function (questions, _1) {
                    var answers, override, answer, question, quit, name, type, lastPrompt, getFormattedAnswer, _iterator, _step, _question, _2, _3, _4, _5, key, value, _6, _7, _8, _question2, _9, _10, _11, err_2, err_3;
                    if (questions === void 0) { questions = []; }
                    var _12 = _1 === void 0 ? {} : _1, _13 = _12.onSubmit, onSubmit = _13 === void 0 ? noop : _13, _14 = _12.onCancel, onCancel = _14 === void 0 ? noop : _14;
                    return __generator(this, function (_15) {
                        switch (_15.label) {
                            case 0:
                                answers = {};
                                override = prompt._override || {};
                                questions = [].concat(questions);
                                getFormattedAnswer = function () {
                                    var _ref = _asyncToGenerator(function (question, answer, skipValidation) {
                                        var _1;
                                        if (skipValidation === void 0) { skipValidation = false; }
                                        return __generator(this, function (_2) {
                                            switch (_2.label) {
                                                case 0:
                                                    if (!skipValidation && question.validate && question.validate(answer) !== true) {
                                                        return [2 /*return*/];
                                                    }
                                                    if (!question.format) return [3 /*break*/, 2];
                                                    return [4 /*yield*/, question.format(answer, answers)];
                                                case 1:
                                                    _1 = _2.sent();
                                                    return [3 /*break*/, 3];
                                                case 2:
                                                    _1 = answer;
                                                    _2.label = 3;
                                                case 3: return [2 /*return*/, _1];
                                            }
                                        });
                                    });
                                    return function getFormattedAnswer(_x, _x2) {
                                        return _ref.apply(this, arguments);
                                    };
                                }();
                                _iterator = _createForOfIteratorHelper(questions);
                                _15.label = 1;
                            case 1:
                                _15.trys.push([1, 23, 24, 25]);
                                _iterator.s();
                                _15.label = 2;
                            case 2:
                                if (!!(_step = _iterator.n()).done) return [3 /*break*/, 22];
                                question = _step.value;
                                _question = question;
                                name = _question.name;
                                type = _question.type;
                                if (!(typeof type === 'function')) return [3 /*break*/, 4];
                                return [4 /*yield*/, type(answer, _objectSpread({}, answers), question)];
                            case 3:
                                type = _15.sent();
                                question['type'] = type;
                                _15.label = 4;
                            case 4:
                                if (!type)
                                    return [3 /*break*/, 21]; // if property is a function, invoke it unless it's a special function
                                _2 = question;
                                _3 = [];
                                for (_4 in _2)
                                    _3.push(_4);
                                _5 = 0;
                                _15.label = 5;
                            case 5:
                                if (!(_5 < _3.length)) return [3 /*break*/, 10];
                                _4 = _3[_5];
                                if (!(_4 in _2)) return [3 /*break*/, 9];
                                key = _4;
                                if (passOn.includes(key))
                                    return [3 /*break*/, 9];
                                value = question[key];
                                _6 = question;
                                _7 = key;
                                if (!(typeof value === 'function')) return [3 /*break*/, 7];
                                return [4 /*yield*/, value(answer, _objectSpread({}, answers), lastPrompt)];
                            case 6:
                                _8 = _15.sent();
                                return [3 /*break*/, 8];
                            case 7:
                                _8 = value;
                                _15.label = 8;
                            case 8:
                                _6[_7] = _8;
                                _15.label = 9;
                            case 9:
                                _5++;
                                return [3 /*break*/, 5];
                            case 10:
                                lastPrompt = question;
                                if (typeof question.message !== 'string') {
                                    throw new Error('prompt message is required');
                                } // update vars in case they changed
                                _question2 = question;
                                name = _question2.name;
                                type = _question2.type;
                                if (prompts[type] === void 0) {
                                    throw new Error("prompt type (".concat(type, ") is not defined"));
                                }
                                if (!(override[question.name] !== undefined)) return [3 /*break*/, 12];
                                return [4 /*yield*/, getFormattedAnswer(question, override[question.name])];
                            case 11:
                                answer = _15.sent();
                                if (answer !== undefined) {
                                    answers[name] = answer;
                                    return [3 /*break*/, 21];
                                }
                                _15.label = 12;
                            case 12:
                                _15.trys.push([12, 18, , 20]);
                                if (!prompt._injected) return [3 /*break*/, 13];
                                _9 = getInjectedAnswer(prompt._injected, question.initial);
                                return [3 /*break*/, 15];
                            case 13: return [4 /*yield*/, prompts[type](question)];
                            case 14:
                                _9 = _15.sent();
                                _15.label = 15;
                            case 15:
                                // Get the injected answer if there is one or prompt the user
                                answer = _9;
                                _10 = answers;
                                _11 = name;
                                return [4 /*yield*/, getFormattedAnswer(question, answer, true)];
                            case 16:
                                _10[_11] = answer = _15.sent();
                                return [4 /*yield*/, onSubmit(question, answer, answers)];
                            case 17:
                                quit = _15.sent();
                                return [3 /*break*/, 20];
                            case 18:
                                err_2 = _15.sent();
                                return [4 /*yield*/, onCancel(question, answers)];
                            case 19:
                                quit = !(_15.sent());
                                return [3 /*break*/, 20];
                            case 20:
                                if (quit)
                                    return [2 /*return*/, answers];
                                _15.label = 21;
                            case 21: return [3 /*break*/, 2];
                            case 22: return [3 /*break*/, 25];
                            case 23:
                                err_3 = _15.sent();
                                _iterator.e(err_3);
                                return [3 /*break*/, 25];
                            case 24:
                                _iterator.f();
                                return [7 /*endfinally*/];
                            case 25: return [2 /*return*/, answers];
                        }
                    });
                });
                return _prompt.apply(this, arguments);
            }
            function getInjectedAnswer(injected, deafultValue) {
                var answer = injected.shift();
                if (answer instanceof Error) {
                    throw answer;
                }
                return answer === undefined ? deafultValue : answer;
            }
            function inject(answers) {
                prompt._injected = (prompt._injected || []).concat(answers);
            }
            function override(answers) {
                prompt._override = Object.assign({}, answers);
            }
            module.exports = Object.assign(prompt, {
                prompt: prompt,
                prompts: prompts,
                inject: inject,
                override: override
            });
            /***/ 
        }),
        /***/ 7627: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var $ = exports;
            var el = __nccwpck_require__(2838);
            var noop = function (v) { return v; };
            function toPrompt(type, args, opts) {
                if (opts === void 0) { opts = {}; }
                return new Promise(function (res, rej) {
                    var p = new el[type](args);
                    var onAbort = opts.onAbort || noop;
                    var onSubmit = opts.onSubmit || noop;
                    var onExit = opts.onExit || noop;
                    p.on('state', args.onState || noop);
                    p.on('submit', function (x) { return res(onSubmit(x)); });
                    p.on('exit', function (x) { return res(onExit(x)); });
                    p.on('abort', function (x) { return rej(onAbort(x)); });
                });
            }
            /**
             * Text prompt
             * @param {string} args.message Prompt message to display
             * @param {string} [args.initial] Default string value
             * @param {string} [args.style="default"] Render style ('default', 'password', 'invisible')
             * @param {function} [args.onState] On state change callback
             * @param {function} [args.validate] Function to validate user input
             * @param {Stream} [args.stdin] The Readable stream to listen to
             * @param {Stream} [args.stdout] The Writable stream to write readline data to
             * @returns {Promise} Promise with user input
             */
            $.text = function (args) { return toPrompt('TextPrompt', args); };
            /**
             * Password prompt with masked input
             * @param {string} args.message Prompt message to display
             * @param {string} [args.initial] Default string value
             * @param {function} [args.onState] On state change callback
             * @param {function} [args.validate] Function to validate user input
             * @param {Stream} [args.stdin] The Readable stream to listen to
             * @param {Stream} [args.stdout] The Writable stream to write readline data to
             * @returns {Promise} Promise with user input
             */
            $.password = function (args) {
                args.style = 'password';
                return $.text(args);
            };
            /**
             * Prompt where input is invisible, like sudo
             * @param {string} args.message Prompt message to display
             * @param {string} [args.initial] Default string value
             * @param {function} [args.onState] On state change callback
             * @param {function} [args.validate] Function to validate user input
             * @param {Stream} [args.stdin] The Readable stream to listen to
             * @param {Stream} [args.stdout] The Writable stream to write readline data to
             * @returns {Promise} Promise with user input
             */
            $.invisible = function (args) {
                args.style = 'invisible';
                return $.text(args);
            };
            /**
             * Number prompt
             * @param {string} args.message Prompt message to display
             * @param {number} args.initial Default number value
             * @param {function} [args.onState] On state change callback
             * @param {number} [args.max] Max value
             * @param {number} [args.min] Min value
             * @param {string} [args.style="default"] Render style ('default', 'password', 'invisible')
             * @param {Boolean} [opts.float=false] Parse input as floats
             * @param {Number} [opts.round=2] Round floats to x decimals
             * @param {Number} [opts.increment=1] Number to increment by when using arrow-keys
             * @param {function} [args.validate] Function to validate user input
             * @param {Stream} [args.stdin] The Readable stream to listen to
             * @param {Stream} [args.stdout] The Writable stream to write readline data to
             * @returns {Promise} Promise with user input
             */
            $.number = function (args) { return toPrompt('NumberPrompt', args); };
            /**
             * Date prompt
             * @param {string} args.message Prompt message to display
             * @param {number} args.initial Default number value
             * @param {function} [args.onState] On state change callback
             * @param {number} [args.max] Max value
             * @param {number} [args.min] Min value
             * @param {string} [args.style="default"] Render style ('default', 'password', 'invisible')
             * @param {Boolean} [opts.float=false] Parse input as floats
             * @param {Number} [opts.round=2] Round floats to x decimals
             * @param {Number} [opts.increment=1] Number to increment by when using arrow-keys
             * @param {function} [args.validate] Function to validate user input
             * @param {Stream} [args.stdin] The Readable stream to listen to
             * @param {Stream} [args.stdout] The Writable stream to write readline data to
             * @returns {Promise} Promise with user input
             */
            $.date = function (args) { return toPrompt('DatePrompt', args); };
            /**
             * Classic yes/no prompt
             * @param {string} args.message Prompt message to display
             * @param {boolean} [args.initial=false] Default value
             * @param {function} [args.onState] On state change callback
             * @param {Stream} [args.stdin] The Readable stream to listen to
             * @param {Stream} [args.stdout] The Writable stream to write readline data to
             * @returns {Promise} Promise with user input
             */
            $.confirm = function (args) { return toPrompt('ConfirmPrompt', args); };
            /**
             * List prompt, split intput string by `seperator`
             * @param {string} args.message Prompt message to display
             * @param {string} [args.initial] Default string value
             * @param {string} [args.style="default"] Render style ('default', 'password', 'invisible')
             * @param {string} [args.separator] String separator
             * @param {function} [args.onState] On state change callback
             * @param {Stream} [args.stdin] The Readable stream to listen to
             * @param {Stream} [args.stdout] The Writable stream to write readline data to
             * @returns {Promise} Promise with user input, in form of an `Array`
             */
            $.list = function (args) {
                var sep = args.separator || ',';
                return toPrompt('TextPrompt', args, {
                    onSubmit: function (str) { return str.split(sep).map(function (s) { return s.trim(); }); }
                });
            };
            /**
             * Toggle/switch prompt
             * @param {string} args.message Prompt message to display
             * @param {boolean} [args.initial=false] Default value
             * @param {string} [args.active="on"] Text for `active` state
             * @param {string} [args.inactive="off"] Text for `inactive` state
             * @param {function} [args.onState] On state change callback
             * @param {Stream} [args.stdin] The Readable stream to listen to
             * @param {Stream} [args.stdout] The Writable stream to write readline data to
             * @returns {Promise} Promise with user input
             */
            $.toggle = function (args) { return toPrompt('TogglePrompt', args); };
            /**
             * Interactive select prompt
             * @param {string} args.message Prompt message to display
             * @param {Array} args.choices Array of choices objects `[{ title, value }, ...]`
             * @param {number} [args.initial] Index of default value
             * @param {String} [args.hint] Hint to display
             * @param {function} [args.onState] On state change callback
             * @param {Stream} [args.stdin] The Readable stream to listen to
             * @param {Stream} [args.stdout] The Writable stream to write readline data to
             * @returns {Promise} Promise with user input
             */
            $.select = function (args) { return toPrompt('SelectPrompt', args); };
            /**
             * Interactive multi-select / autocompleteMultiselect prompt
             * @param {string} args.message Prompt message to display
             * @param {Array} args.choices Array of choices objects `[{ title, value, [selected] }, ...]`
             * @param {number} [args.max] Max select
             * @param {string} [args.hint] Hint to display user
             * @param {Number} [args.cursor=0] Cursor start position
             * @param {function} [args.onState] On state change callback
             * @param {Stream} [args.stdin] The Readable stream to listen to
             * @param {Stream} [args.stdout] The Writable stream to write readline data to
             * @returns {Promise} Promise with user input
             */
            $.multiselect = function (args) {
                args.choices = [].concat(args.choices || []);
                var toSelected = function (items) { return items.filter(function (item) { return item.selected; }).map(function (item) { return item.value; }); };
                return toPrompt('MultiselectPrompt', args, {
                    onAbort: toSelected,
                    onSubmit: toSelected
                });
            };
            $.autocompleteMultiselect = function (args) {
                args.choices = [].concat(args.choices || []);
                var toSelected = function (items) { return items.filter(function (item) { return item.selected; }).map(function (item) { return item.value; }); };
                return toPrompt('AutocompleteMultiselectPrompt', args, {
                    onAbort: toSelected,
                    onSubmit: toSelected
                });
            };
            var byTitle = function (input, choices) { return Promise.resolve(choices.filter(function (item) { return item.title.slice(0, input.length).toLowerCase() === input.toLowerCase(); })); };
            /**
             * Interactive auto-complete prompt
             * @param {string} args.message Prompt message to display
             * @param {Array} args.choices Array of auto-complete choices objects `[{ title, value }, ...]`
             * @param {Function} [args.suggest] Function to filter results based on user input. Defaults to sort by `title`
             * @param {number} [args.limit=10] Max number of results to show
             * @param {string} [args.style="default"] Render style ('default', 'password', 'invisible')
             * @param {String} [args.initial] Index of the default value
             * @param {boolean} [opts.clearFirst] The first ESCAPE keypress will clear the input
             * @param {String} [args.fallback] Fallback message - defaults to initial value
             * @param {function} [args.onState] On state change callback
             * @param {Stream} [args.stdin] The Readable stream to listen to
             * @param {Stream} [args.stdout] The Writable stream to write readline data to
             * @returns {Promise} Promise with user input
             */
            $.autocomplete = function (args) {
                args.suggest = args.suggest || byTitle;
                args.choices = [].concat(args.choices || []);
                return toPrompt('AutocompletePrompt', args);
            };
            /***/ 
        }),
        /***/ 9001: 
        /***/ (function (module) {
            "use strict";
            module.exports = function (key, isSelect) {
                if (key.meta && key.name !== 'escape')
                    return;
                if (key.ctrl) {
                    if (key.name === 'a')
                        return 'first';
                    if (key.name === 'c')
                        return 'abort';
                    if (key.name === 'd')
                        return 'abort';
                    if (key.name === 'e')
                        return 'last';
                    if (key.name === 'g')
                        return 'reset';
                }
                if (isSelect) {
                    if (key.name === 'j')
                        return 'down';
                    if (key.name === 'k')
                        return 'up';
                }
                if (key.name === 'return')
                    return 'submit';
                if (key.name === 'enter')
                    return 'submit'; // ctrl + J
                if (key.name === 'backspace')
                    return 'delete';
                if (key.name === 'delete')
                    return 'deleteForward';
                if (key.name === 'abort')
                    return 'abort';
                if (key.name === 'escape')
                    return 'exit';
                if (key.name === 'tab')
                    return 'next';
                if (key.name === 'pagedown')
                    return 'nextPage';
                if (key.name === 'pageup')
                    return 'prevPage'; // TODO create home() in prompt types (e.g. TextPrompt)
                if (key.name === 'home')
                    return 'home'; // TODO create end() in prompt types (e.g. TextPrompt)
                if (key.name === 'end')
                    return 'end';
                if (key.name === 'up')
                    return 'up';
                if (key.name === 'down')
                    return 'down';
                if (key.name === 'right')
                    return 'right';
                if (key.name === 'left')
                    return 'left';
                return false;
            };
            /***/ 
        }),
        /***/ 3952: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                        o = it;
                    var i = 0;
                    var F = function F() { };
                    return { s: F, n: function n() { if (i >= o.length)
                            return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                    if (!normalCompletion && it["return"] != null)
                        it["return"]();
                }
                finally {
                    if (didErr)
                        throw err;
                } } }; }
            function _unsupportedIterableToArray(o, minLen) { if (!o)
                return; if (typeof o === "string")
                return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                n = o.constructor.name; if (n === "Map" || n === "Set")
                return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray(o, minLen); }
            function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++)
                arr2[i] = arr[i]; return arr2; }
            var strip = __nccwpck_require__(8007);
            var _require = __nccwpck_require__(9571), erase = _require.erase, cursor = _require.cursor;
            var width = function (str) { return __spreadArray([], strip(str), true).length; };
            /**
             * @param {string} prompt
             * @param {number} perLine
             */
            module.exports = function (prompt, perLine) {
                if (!perLine)
                    return erase.line + cursor.to(0);
                var rows = 0;
                var lines = prompt.split(/\r?\n/);
                var _iterator = _createForOfIteratorHelper(lines), _step;
                try {
                    for (_iterator.s(); !(_step = _iterator.n()).done;) {
                        var line = _step.value;
                        rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / perLine);
                    }
                }
                catch (err) {
                    _iterator.e(err);
                }
                finally {
                    _iterator.f();
                }
                return erase.lines(rows);
            };
            /***/ 
        }),
        /***/ 4464: 
        /***/ (function (module) {
            "use strict";
            /**
             * Determine what entries should be displayed on the screen, based on the
             * currently selected index and the maximum visible. Used in list-based
             * prompts like `select` and `multiselect`.
             *
             * @param {number} cursor the currently selected entry
             * @param {number} total the total entries available to display
             * @param {number} [maxVisible] the number of entries that can be displayed
             */
            module.exports = function (cursor, total, maxVisible) {
                maxVisible = maxVisible || total;
                var startIndex = Math.min(total - maxVisible, cursor - Math.floor(maxVisible / 2));
                if (startIndex < 0)
                    startIndex = 0;
                var endIndex = Math.min(startIndex + maxVisible, total);
                return {
                    startIndex: startIndex,
                    endIndex: endIndex
                };
            };
            /***/ 
        }),
        /***/ 8845: 
        /***/ (function (module) {
            "use strict";
            var main = {
                arrowUp: '',
                arrowDown: '',
                arrowLeft: '',
                arrowRight: '',
                radioOn: '',
                radioOff: '',
                tick: '',
                cross: '',
                ellipsis: '',
                pointerSmall: '',
                line: '',
                pointer: ''
            };
            var win = {
                arrowUp: main.arrowUp,
                arrowDown: main.arrowDown,
                arrowLeft: main.arrowLeft,
                arrowRight: main.arrowRight,
                radioOn: '(*)',
                radioOff: '( )',
                tick: '',
                cross: '',
                ellipsis: '...',
                pointerSmall: '',
                line: '',
                pointer: '>'
            };
            var figures = process.platform === 'win32' ? win : main;
            module.exports = figures;
            /***/ 
        }),
        /***/ 8091: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            module.exports = {
                action: __nccwpck_require__(9001),
                clear: __nccwpck_require__(3952),
                style: __nccwpck_require__(8295),
                strip: __nccwpck_require__(8007),
                figures: __nccwpck_require__(8845),
                lines: __nccwpck_require__(3802),
                wrap: __nccwpck_require__(1288),
                entriesToDisplay: __nccwpck_require__(4464)
            };
            /***/ 
        }),
        /***/ 3802: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var strip = __nccwpck_require__(8007);
            /**
             * @param {string} msg
             * @param {number} perLine
             */
            module.exports = function (msg, perLine) {
                var lines = String(strip(msg) || '').split(/\r?\n/);
                if (!perLine)
                    return lines.length;
                return lines.map(function (l) { return Math.ceil(l.length / perLine); }).reduce(function (a, b) { return a + b; });
            };
            /***/ 
        }),
        /***/ 8007: 
        /***/ (function (module) {
            "use strict";
            module.exports = function (str) {
                var pattern = ['[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)', '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))'].join('|');
                var RGX = new RegExp(pattern, 'g');
                return typeof str === 'string' ? str.replace(RGX, '') : str;
            };
            /***/ 
        }),
        /***/ 8295: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var c = __nccwpck_require__(9407);
            var figures = __nccwpck_require__(8845); // rendering user input.
            var styles = Object.freeze({
                password: {
                    scale: 1,
                    render: function (input) { return '*'.repeat(input.length); }
                },
                emoji: {
                    scale: 2,
                    render: function (input) { return ''.repeat(input.length); }
                },
                invisible: {
                    scale: 0,
                    render: function (input) { return ''; }
                },
                "default": {
                    scale: 1,
                    render: function (input) { return "".concat(input); }
                }
            });
            var render = function (type) { return styles[type] || styles["default"]; }; // icon to signalize a prompt.
            var symbols = Object.freeze({
                aborted: c.red(figures.cross),
                done: c.green(figures.tick),
                exited: c.yellow(figures.cross),
                "default": c.cyan('?')
            });
            var symbol = function (done, aborted, exited) { return aborted ? symbols.aborted : exited ? symbols.exited : done ? symbols.done : symbols["default"]; }; // between the question and the user's input.
            var delimiter = function (completing) { return c.gray(completing ? figures.ellipsis : figures.pointerSmall); };
            var item = function (expandable, expanded) { return c.gray(expandable ? expanded ? figures.pointerSmall : '+' : figures.line); };
            module.exports = {
                styles: styles,
                render: render,
                symbols: symbols,
                symbol: symbol,
                delimiter: delimiter,
                item: item
            };
            /***/ 
        }),
        /***/ 1288: 
        /***/ (function (module) {
            "use strict";
            /**
             * @param {string} msg The message to wrap
             * @param {object} opts
             * @param {number|string} [opts.margin] Left margin
             * @param {number} opts.width Maximum characters per line including the margin
             */
            module.exports = function (msg, opts) {
                if (opts === void 0) { opts = {}; }
                var tab = Number.isSafeInteger(parseInt(opts.margin)) ? new Array(parseInt(opts.margin)).fill(' ').join('') : opts.margin || '';
                var width = opts.width;
                return (msg || '').split(/\r?\n/g).map(function (line) { return line.split(/\s+/g).reduce(function (arr, w) {
                    if (w.length + tab.length >= width || arr[arr.length - 1].length + w.length + 1 < width)
                        arr[arr.length - 1] += " ".concat(w);
                    else
                        arr.push("".concat(tab).concat(w));
                    return arr;
                }, [tab]).join('\n'); }).join('\n');
            };
            /***/ 
        }),
        /***/ 9646: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            function isNodeLT(tar) {
                tar = (Array.isArray(tar) ? tar : tar.split('.')).map(Number);
                var i = 0, src = process.versions.node.split('.').map(Number);
                for (; i < tar.length; i++) {
                    if (src[i] > tar[i])
                        return false;
                    if (tar[i] > src[i])
                        return true;
                }
                return false;
            }
            module.exports =
                isNodeLT('8.6.0')
                    ? __nccwpck_require__(5357)
                    : __nccwpck_require__(5379);
            /***/ 
        }),
        /***/ 8377: 
        /***/ (function (module) {
            "use strict";
            var DatePart = /** @class */ (function () {
                function DatePart(_1) {
                    var token = _1.token, date = _1.date, parts = _1.parts, locales = _1.locales;
                    this.token = token;
                    this.date = date || new Date();
                    this.parts = parts || [this];
                    this.locales = locales || {};
                }
                DatePart.prototype.up = function () { };
                DatePart.prototype.down = function () { };
                DatePart.prototype.next = function () {
                    var currentIdx = this.parts.indexOf(this);
                    return this.parts.find(function (part, idx) { return idx > currentIdx && part instanceof DatePart; });
                };
                DatePart.prototype.setTo = function (val) { };
                DatePart.prototype.prev = function () {
                    var parts = [].concat(this.parts).reverse();
                    var currentIdx = parts.indexOf(this);
                    return parts.find(function (part, idx) { return idx > currentIdx && part instanceof DatePart; });
                };
                DatePart.prototype.toString = function () {
                    return String(this.date);
                };
                return DatePart;
            }());
            module.exports = DatePart;
            /***/ 
        }),
        /***/ 6784: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var DatePart = __nccwpck_require__(8377);
            var pos = function (n) {
                n = n % 10;
                return n === 1 ? 'st'
                    : n === 2 ? 'nd'
                        : n === 3 ? 'rd'
                            : 'th';
            };
            var Day = /** @class */ (function (_super) {
                __extends(Day, _super);
                function Day(opts) {
                    if (opts === void 0) { opts = {}; }
                    return _super.call(this, opts) || this;
                }
                Day.prototype.up = function () {
                    this.date.setDate(this.date.getDate() + 1);
                };
                Day.prototype.down = function () {
                    this.date.setDate(this.date.getDate() - 1);
                };
                Day.prototype.setTo = function (val) {
                    this.date.setDate(parseInt(val.substr(-2)));
                };
                Day.prototype.toString = function () {
                    var date = this.date.getDate();
                    var day = this.date.getDay();
                    return this.token === 'DD' ? String(date).padStart(2, '0')
                        : this.token === 'Do' ? date + pos(date)
                            : this.token === 'd' ? day + 1
                                : this.token === 'ddd' ? this.locales.weekdaysShort[day]
                                    : this.token === 'dddd' ? this.locales.weekdays[day]
                                        : date;
                };
                return Day;
            }(DatePart));
            module.exports = Day;
            /***/ 
        }),
        /***/ 754: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var DatePart = __nccwpck_require__(8377);
            var Hours = /** @class */ (function (_super) {
                __extends(Hours, _super);
                function Hours(opts) {
                    if (opts === void 0) { opts = {}; }
                    return _super.call(this, opts) || this;
                }
                Hours.prototype.up = function () {
                    this.date.setHours(this.date.getHours() + 1);
                };
                Hours.prototype.down = function () {
                    this.date.setHours(this.date.getHours() - 1);
                };
                Hours.prototype.setTo = function (val) {
                    this.date.setHours(parseInt(val.substr(-2)));
                };
                Hours.prototype.toString = function () {
                    var hours = this.date.getHours();
                    if (/h/.test(this.token))
                        hours = (hours % 12) || 12;
                    return this.token.length > 1 ? String(hours).padStart(2, '0') : hours;
                };
                return Hours;
            }(DatePart));
            module.exports = Hours;
            /***/ 
        }),
        /***/ 8108: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            module.exports = {
                DatePart: __nccwpck_require__(8377),
                Meridiem: __nccwpck_require__(2616),
                Day: __nccwpck_require__(6784),
                Hours: __nccwpck_require__(754),
                Milliseconds: __nccwpck_require__(4316),
                Minutes: __nccwpck_require__(1770),
                Month: __nccwpck_require__(8086),
                Seconds: __nccwpck_require__(1823),
                Year: __nccwpck_require__(9208)
            };
            /***/ 
        }),
        /***/ 2616: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var DatePart = __nccwpck_require__(8377);
            var Meridiem = /** @class */ (function (_super) {
                __extends(Meridiem, _super);
                function Meridiem(opts) {
                    if (opts === void 0) { opts = {}; }
                    return _super.call(this, opts) || this;
                }
                Meridiem.prototype.up = function () {
                    this.date.setHours((this.date.getHours() + 12) % 24);
                };
                Meridiem.prototype.down = function () {
                    this.up();
                };
                Meridiem.prototype.toString = function () {
                    var meridiem = this.date.getHours() > 12 ? 'pm' : 'am';
                    return /\A/.test(this.token) ? meridiem.toUpperCase() : meridiem;
                };
                return Meridiem;
            }(DatePart));
            module.exports = Meridiem;
            /***/ 
        }),
        /***/ 4316: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var DatePart = __nccwpck_require__(8377);
            var Milliseconds = /** @class */ (function (_super) {
                __extends(Milliseconds, _super);
                function Milliseconds(opts) {
                    if (opts === void 0) { opts = {}; }
                    return _super.call(this, opts) || this;
                }
                Milliseconds.prototype.up = function () {
                    this.date.setMilliseconds(this.date.getMilliseconds() + 1);
                };
                Milliseconds.prototype.down = function () {
                    this.date.setMilliseconds(this.date.getMilliseconds() - 1);
                };
                Milliseconds.prototype.setTo = function (val) {
                    this.date.setMilliseconds(parseInt(val.substr(-(this.token.length))));
                };
                Milliseconds.prototype.toString = function () {
                    return String(this.date.getMilliseconds()).padStart(4, '0')
                        .substr(0, this.token.length);
                };
                return Milliseconds;
            }(DatePart));
            module.exports = Milliseconds;
            /***/ 
        }),
        /***/ 1770: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var DatePart = __nccwpck_require__(8377);
            var Minutes = /** @class */ (function (_super) {
                __extends(Minutes, _super);
                function Minutes(opts) {
                    if (opts === void 0) { opts = {}; }
                    return _super.call(this, opts) || this;
                }
                Minutes.prototype.up = function () {
                    this.date.setMinutes(this.date.getMinutes() + 1);
                };
                Minutes.prototype.down = function () {
                    this.date.setMinutes(this.date.getMinutes() - 1);
                };
                Minutes.prototype.setTo = function (val) {
                    this.date.setMinutes(parseInt(val.substr(-2)));
                };
                Minutes.prototype.toString = function () {
                    var m = this.date.getMinutes();
                    return this.token.length > 1 ? String(m).padStart(2, '0') : m;
                };
                return Minutes;
            }(DatePart));
            module.exports = Minutes;
            /***/ 
        }),
        /***/ 8086: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var DatePart = __nccwpck_require__(8377);
            var Month = /** @class */ (function (_super) {
                __extends(Month, _super);
                function Month(opts) {
                    if (opts === void 0) { opts = {}; }
                    return _super.call(this, opts) || this;
                }
                Month.prototype.up = function () {
                    this.date.setMonth(this.date.getMonth() + 1);
                };
                Month.prototype.down = function () {
                    this.date.setMonth(this.date.getMonth() - 1);
                };
                Month.prototype.setTo = function (val) {
                    val = parseInt(val.substr(-2)) - 1;
                    this.date.setMonth(val < 0 ? 0 : val);
                };
                Month.prototype.toString = function () {
                    var month = this.date.getMonth();
                    var tl = this.token.length;
                    return tl === 2 ? String(month + 1).padStart(2, '0')
                        : tl === 3 ? this.locales.monthsShort[month]
                            : tl === 4 ? this.locales.months[month]
                                : String(month + 1);
                };
                return Month;
            }(DatePart));
            module.exports = Month;
            /***/ 
        }),
        /***/ 1823: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var DatePart = __nccwpck_require__(8377);
            var Seconds = /** @class */ (function (_super) {
                __extends(Seconds, _super);
                function Seconds(opts) {
                    if (opts === void 0) { opts = {}; }
                    return _super.call(this, opts) || this;
                }
                Seconds.prototype.up = function () {
                    this.date.setSeconds(this.date.getSeconds() + 1);
                };
                Seconds.prototype.down = function () {
                    this.date.setSeconds(this.date.getSeconds() - 1);
                };
                Seconds.prototype.setTo = function (val) {
                    this.date.setSeconds(parseInt(val.substr(-2)));
                };
                Seconds.prototype.toString = function () {
                    var s = this.date.getSeconds();
                    return this.token.length > 1 ? String(s).padStart(2, '0') : s;
                };
                return Seconds;
            }(DatePart));
            module.exports = Seconds;
            /***/ 
        }),
        /***/ 9208: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var DatePart = __nccwpck_require__(8377);
            var Year = /** @class */ (function (_super) {
                __extends(Year, _super);
                function Year(opts) {
                    if (opts === void 0) { opts = {}; }
                    return _super.call(this, opts) || this;
                }
                Year.prototype.up = function () {
                    this.date.setFullYear(this.date.getFullYear() + 1);
                };
                Year.prototype.down = function () {
                    this.date.setFullYear(this.date.getFullYear() - 1);
                };
                Year.prototype.setTo = function (val) {
                    this.date.setFullYear(val.substr(-4));
                };
                Year.prototype.toString = function () {
                    var year = String(this.date.getFullYear()).padStart(4, '0');
                    return this.token.length === 2 ? year.substr(-2) : year;
                };
                return Year;
            }(DatePart));
            module.exports = Year;
            /***/ 
        }),
        /***/ 1098: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var color = __nccwpck_require__(9407);
            var Prompt = __nccwpck_require__(4185);
            var _1 = __nccwpck_require__(9571), erase = _1.erase, cursor = _1.cursor;
            var _2 = __nccwpck_require__(9501), style = _2.style, clear = _2.clear, figures = _2.figures, wrap = _2.wrap, entriesToDisplay = _2.entriesToDisplay;
            var getVal = function (arr, i) { return arr[i] && (arr[i].value || arr[i].title || arr[i]); };
            var getTitle = function (arr, i) { return arr[i] && (arr[i].title || arr[i].value || arr[i]); };
            var getIndex = function (arr, valOrTitle) {
                var index = arr.findIndex(function (el) { return el.value === valOrTitle || el.title === valOrTitle; });
                return index > -1 ? index : undefined;
            };
            /**
             * TextPrompt Base Element
             * @param {Object} opts Options
             * @param {String} opts.message Message
             * @param {Array} opts.choices Array of auto-complete choices objects
             * @param {Function} [opts.suggest] Filter function. Defaults to sort by title
             * @param {Number} [opts.limit=10] Max number of results to show
             * @param {Number} [opts.cursor=0] Cursor start position
             * @param {String} [opts.style='default'] Render style
             * @param {String} [opts.fallback] Fallback message - initial to default value
             * @param {String} [opts.initial] Index of the default value
             * @param {Boolean} [opts.clearFirst] The first ESCAPE keypress will clear the input
             * @param {Stream} [opts.stdin] The Readable stream to listen to
             * @param {Stream} [opts.stdout] The Writable stream to write readline data to
             * @param {String} [opts.noMatches] The no matches found label
             */
            var AutocompletePrompt = /** @class */ (function (_super) {
                __extends(AutocompletePrompt, _super);
                function AutocompletePrompt(opts) {
                    if (opts === void 0) { opts = {}; }
                    var _this_1 = _super.call(this, opts) || this;
                    _this_1.msg = opts.message;
                    _this_1.suggest = opts.suggest;
                    _this_1.choices = opts.choices;
                    _this_1.initial = typeof opts.initial === 'number'
                        ? opts.initial
                        : getIndex(opts.choices, opts.initial);
                    _this_1.select = _this_1.initial || opts.cursor || 0;
                    _this_1.i18n = { noMatches: opts.noMatches || 'no matches found' };
                    _this_1.fallback = opts.fallback || _this_1.initial;
                    _this_1.clearFirst = opts.clearFirst || false;
                    _this_1.suggestions = [];
                    _this_1.input = '';
                    _this_1.limit = opts.limit || 10;
                    _this_1.cursor = 0;
                    _this_1.transform = style.render(opts.style);
                    _this_1.scale = _this_1.transform.scale;
                    _this_1.render = _this_1.render.bind(_this_1);
                    _this_1.complete = _this_1.complete.bind(_this_1);
                    _this_1.clear = clear('', _this_1.out.columns);
                    _this_1.complete(_this_1.render);
                    _this_1.render();
                    return _this_1;
                }
                Object.defineProperty(AutocompletePrompt.prototype, "fallback", {
                    get: function () {
                        var choice;
                        if (typeof this._fb === 'number')
                            choice = this.choices[this._fb];
                        else if (typeof this._fb === 'string')
                            choice = { title: this._fb };
                        return choice || this._fb || { title: this.i18n.noMatches };
                    },
                    set: function (fb) {
                        this._fb = Number.isSafeInteger(parseInt(fb)) ? parseInt(fb) : fb;
                    },
                    enumerable: false,
                    configurable: true
                });
                AutocompletePrompt.prototype.moveSelect = function (i) {
                    this.select = i;
                    if (this.suggestions.length > 0)
                        this.value = getVal(this.suggestions, i);
                    else
                        this.value = this.fallback.value;
                    this.fire();
                };
                AutocompletePrompt.prototype.complete = function (cb) {
                    return __awaiter(this, void 0, void 0, function () {
                        var p, suggestions, l;
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0:
                                    p = (this.completing = this.suggest(this.input, this.choices));
                                    return [4 /*yield*/, p];
                                case 1:
                                    suggestions = _1.sent();
                                    if (this.completing !== p)
                                        return [2 /*return*/];
                                    this.suggestions = suggestions
                                        .map(function (s, i, arr) { return ({ title: getTitle(arr, i), value: getVal(arr, i), description: s.description }); });
                                    this.completing = false;
                                    l = Math.max(suggestions.length - 1, 0);
                                    this.moveSelect(Math.min(l, this.select));
                                    cb && cb();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                AutocompletePrompt.prototype.reset = function () {
                    var _this_1 = this;
                    this.input = '';
                    this.complete(function () {
                        _this_1.moveSelect(_this_1.initial !== void 0 ? _this_1.initial : 0);
                        _this_1.render();
                    });
                    this.render();
                };
                AutocompletePrompt.prototype.exit = function () {
                    if (this.clearFirst && this.input.length > 0) {
                        this.reset();
                    }
                    else {
                        this.done = this.exited = true;
                        this.aborted = false;
                        this.fire();
                        this.render();
                        this.out.write('\n');
                        this.close();
                    }
                };
                AutocompletePrompt.prototype.abort = function () {
                    this.done = this.aborted = true;
                    this.exited = false;
                    this.fire();
                    this.render();
                    this.out.write('\n');
                    this.close();
                };
                AutocompletePrompt.prototype.submit = function () {
                    this.done = true;
                    this.aborted = this.exited = false;
                    this.fire();
                    this.render();
                    this.out.write('\n');
                    this.close();
                };
                AutocompletePrompt.prototype._ = function (c, key) {
                    var s1 = this.input.slice(0, this.cursor);
                    var s2 = this.input.slice(this.cursor);
                    this.input = "".concat(s1).concat(c).concat(s2);
                    this.cursor = s1.length + 1;
                    this.complete(this.render);
                    this.render();
                };
                AutocompletePrompt.prototype["delete"] = function () {
                    if (this.cursor === 0)
                        return this.bell();
                    var s1 = this.input.slice(0, this.cursor - 1);
                    var s2 = this.input.slice(this.cursor);
                    this.input = "".concat(s1).concat(s2);
                    this.complete(this.render);
                    this.cursor = this.cursor - 1;
                    this.render();
                };
                AutocompletePrompt.prototype.deleteForward = function () {
                    if (this.cursor * this.scale >= this.rendered.length)
                        return this.bell();
                    var s1 = this.input.slice(0, this.cursor);
                    var s2 = this.input.slice(this.cursor + 1);
                    this.input = "".concat(s1).concat(s2);
                    this.complete(this.render);
                    this.render();
                };
                AutocompletePrompt.prototype.first = function () {
                    this.moveSelect(0);
                    this.render();
                };
                AutocompletePrompt.prototype.last = function () {
                    this.moveSelect(this.suggestions.length - 1);
                    this.render();
                };
                AutocompletePrompt.prototype.up = function () {
                    if (this.select === 0) {
                        this.moveSelect(this.suggestions.length - 1);
                    }
                    else {
                        this.moveSelect(this.select - 1);
                    }
                    this.render();
                };
                AutocompletePrompt.prototype.down = function () {
                    if (this.select === this.suggestions.length - 1) {
                        this.moveSelect(0);
                    }
                    else {
                        this.moveSelect(this.select + 1);
                    }
                    this.render();
                };
                AutocompletePrompt.prototype.next = function () {
                    if (this.select === this.suggestions.length - 1) {
                        this.moveSelect(0);
                    }
                    else
                        this.moveSelect(this.select + 1);
                    this.render();
                };
                AutocompletePrompt.prototype.nextPage = function () {
                    this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1));
                    this.render();
                };
                AutocompletePrompt.prototype.prevPage = function () {
                    this.moveSelect(Math.max(this.select - this.limit, 0));
                    this.render();
                };
                AutocompletePrompt.prototype.left = function () {
                    if (this.cursor <= 0)
                        return this.bell();
                    this.cursor = this.cursor - 1;
                    this.render();
                };
                AutocompletePrompt.prototype.right = function () {
                    if (this.cursor * this.scale >= this.rendered.length)
                        return this.bell();
                    this.cursor = this.cursor + 1;
                    this.render();
                };
                AutocompletePrompt.prototype.renderOption = function (v, hovered, isStart, isEnd) {
                    var desc;
                    var prefix = isStart ? figures.arrowUp : isEnd ? figures.arrowDown : ' ';
                    var title = hovered ? color.cyan().underline(v.title) : v.title;
                    prefix = (hovered ? color.cyan(figures.pointer) + ' ' : '  ') + prefix;
                    if (v.description) {
                        desc = " - ".concat(v.description);
                        if (prefix.length + title.length + desc.length >= this.out.columns
                            || v.description.split(/\r?\n/).length > 1) {
                            desc = '\n' + wrap(v.description, { margin: 3, width: this.out.columns });
                        }
                    }
                    return prefix + ' ' + title + color.gray(desc || '');
                };
                AutocompletePrompt.prototype.render = function () {
                    var _this_1 = this;
                    if (this.closed)
                        return;
                    if (this.firstRender)
                        this.out.write(cursor.hide);
                    else
                        this.out.write(clear(this.outputText, this.out.columns));
                    _super.prototype.render.call(this);
                    var _1 = entriesToDisplay(this.select, this.choices.length, this.limit), startIndex = _1.startIndex, endIndex = _1.endIndex;
                    this.outputText = [
                        style.symbol(this.done, this.aborted, this.exited),
                        color.bold(this.msg),
                        style.delimiter(this.completing),
                        this.done && this.suggestions[this.select]
                            ? this.suggestions[this.select].title
                            : this.rendered = this.transform.render(this.input)
                    ].join(' ');
                    if (!this.done) {
                        var suggestions = this.suggestions
                            .slice(startIndex, endIndex)
                            .map(function (item, i) { return _this_1.renderOption(item, _this_1.select === i + startIndex, i === 0 && startIndex > 0, i + startIndex === endIndex - 1 && endIndex < _this_1.choices.length); })
                            .join('\n');
                        this.outputText += "\n" + (suggestions || color.gray(this.fallback.title));
                    }
                    this.out.write(erase.line + cursor.to(0) + this.outputText);
                };
                return AutocompletePrompt;
            }(Prompt));
            module.exports = AutocompletePrompt;
            /***/ 
        }),
        /***/ 8178: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var color = __nccwpck_require__(9407);
            var cursor = __nccwpck_require__(9571).cursor;
            var MultiselectPrompt = __nccwpck_require__(1944);
            var _1 = __nccwpck_require__(9501), clear = _1.clear, style = _1.style, figures = _1.figures;
            /**
             * MultiselectPrompt Base Element
             * @param {Object} opts Options
             * @param {String} opts.message Message
             * @param {Array} opts.choices Array of choice objects
             * @param {String} [opts.hint] Hint to display
             * @param {String} [opts.warn] Hint shown for disabled choices
             * @param {Number} [opts.max] Max choices
             * @param {Number} [opts.cursor=0] Cursor start position
             * @param {Stream} [opts.stdin] The Readable stream to listen to
             * @param {Stream} [opts.stdout] The Writable stream to write readline data to
             */
            var AutocompleteMultiselectPrompt = /** @class */ (function (_super) {
                __extends(AutocompleteMultiselectPrompt, _super);
                function AutocompleteMultiselectPrompt(opts) {
                    if (opts === void 0) { opts = {}; }
                    var _this_1 = this;
                    opts.overrideRender = true;
                    _this_1 = _super.call(this, opts) || this;
                    _this_1.inputValue = '';
                    _this_1.clear = clear('', _this_1.out.columns);
                    _this_1.filteredOptions = _this_1.value;
                    _this_1.render();
                    return _this_1;
                }
                AutocompleteMultiselectPrompt.prototype.last = function () {
                    this.cursor = this.filteredOptions.length - 1;
                    this.render();
                };
                AutocompleteMultiselectPrompt.prototype.next = function () {
                    this.cursor = (this.cursor + 1) % this.filteredOptions.length;
                    this.render();
                };
                AutocompleteMultiselectPrompt.prototype.up = function () {
                    if (this.cursor === 0) {
                        this.cursor = this.filteredOptions.length - 1;
                    }
                    else {
                        this.cursor--;
                    }
                    this.render();
                };
                AutocompleteMultiselectPrompt.prototype.down = function () {
                    if (this.cursor === this.filteredOptions.length - 1) {
                        this.cursor = 0;
                    }
                    else {
                        this.cursor++;
                    }
                    this.render();
                };
                AutocompleteMultiselectPrompt.prototype.left = function () {
                    this.filteredOptions[this.cursor].selected = false;
                    this.render();
                };
                AutocompleteMultiselectPrompt.prototype.right = function () {
                    if (this.value.filter(function (e) { return e.selected; }).length >= this.maxChoices)
                        return this.bell();
                    this.filteredOptions[this.cursor].selected = true;
                    this.render();
                };
                AutocompleteMultiselectPrompt.prototype["delete"] = function () {
                    if (this.inputValue.length) {
                        this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1);
                        this.updateFilteredOptions();
                    }
                };
                AutocompleteMultiselectPrompt.prototype.updateFilteredOptions = function () {
                    var _this_1 = this;
                    var currentHighlight = this.filteredOptions[this.cursor];
                    this.filteredOptions = this.value
                        .filter(function (v) {
                        if (_this_1.inputValue) {
                            if (typeof v.title === 'string') {
                                if (v.title.toLowerCase().includes(_this_1.inputValue.toLowerCase())) {
                                    return true;
                                }
                            }
                            if (typeof v.value === 'string') {
                                if (v.value.toLowerCase().includes(_this_1.inputValue.toLowerCase())) {
                                    return true;
                                }
                            }
                            return false;
                        }
                        return true;
                    });
                    var newHighlightIndex = this.filteredOptions.findIndex(function (v) { return v === currentHighlight; });
                    this.cursor = newHighlightIndex < 0 ? 0 : newHighlightIndex;
                    this.render();
                };
                AutocompleteMultiselectPrompt.prototype.handleSpaceToggle = function () {
                    var v = this.filteredOptions[this.cursor];
                    if (v.selected) {
                        v.selected = false;
                        this.render();
                    }
                    else if (v.disabled || this.value.filter(function (e) { return e.selected; }).length >= this.maxChoices) {
                        return this.bell();
                    }
                    else {
                        v.selected = true;
                        this.render();
                    }
                };
                AutocompleteMultiselectPrompt.prototype.handleInputChange = function (c) {
                    this.inputValue = this.inputValue + c;
                    this.updateFilteredOptions();
                };
                AutocompleteMultiselectPrompt.prototype._ = function (c, key) {
                    if (c === ' ') {
                        this.handleSpaceToggle();
                    }
                    else {
                        this.handleInputChange(c);
                    }
                };
                AutocompleteMultiselectPrompt.prototype.renderInstructions = function () {
                    if (this.instructions === undefined || this.instructions) {
                        if (typeof this.instructions === 'string') {
                            return this.instructions;
                        }
                        return "\nInstructions:\n    ".concat(figures.arrowUp, "/").concat(figures.arrowDown, ": Highlight option\n    ").concat(figures.arrowLeft, "/").concat(figures.arrowRight, "/[space]: Toggle selection\n    [a,b,c]/delete: Filter choices\n    enter/return: Complete answer\n");
                    }
                    return '';
                };
                AutocompleteMultiselectPrompt.prototype.renderCurrentInput = function () {
                    return "\nFiltered results for: ".concat(this.inputValue ? this.inputValue : color.gray('Enter something to filter'), "\n");
                };
                AutocompleteMultiselectPrompt.prototype.renderOption = function (cursor, v, i) {
                    var title;
                    if (v.disabled)
                        title = cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
                    else
                        title = cursor === i ? color.cyan().underline(v.title) : v.title;
                    return (v.selected ? color.green(figures.radioOn) : figures.radioOff) + '  ' + title;
                };
                AutocompleteMultiselectPrompt.prototype.renderDoneOrInstructions = function () {
                    if (this.done) {
                        return this.value
                            .filter(function (e) { return e.selected; })
                            .map(function (v) { return v.title; })
                            .join(', ');
                    }
                    var output = [color.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
                    if (this.filteredOptions.length && this.filteredOptions[this.cursor].disabled) {
                        output.push(color.yellow(this.warn));
                    }
                    return output.join(' ');
                };
                AutocompleteMultiselectPrompt.prototype.render = function () {
                    if (this.closed)
                        return;
                    if (this.firstRender)
                        this.out.write(cursor.hide);
                    _super.prototype.render.call(this);
                    // print prompt
                    var prompt = [
                        style.symbol(this.done, this.aborted),
                        color.bold(this.msg),
                        style.delimiter(false),
                        this.renderDoneOrInstructions()
                    ].join(' ');
                    if (this.showMinError) {
                        prompt += color.red("You must select a minimum of ".concat(this.minSelected, " choices."));
                        this.showMinError = false;
                    }
                    prompt += this.renderOptions(this.filteredOptions);
                    this.out.write(this.clear + prompt);
                    this.clear = clear(prompt, this.out.columns);
                };
                return AutocompleteMultiselectPrompt;
            }(MultiselectPrompt));
            module.exports = AutocompleteMultiselectPrompt;
            /***/ 
        }),
        /***/ 1491: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var color = __nccwpck_require__(9407);
            var Prompt = __nccwpck_require__(4185);
            var _1 = __nccwpck_require__(9501), style = _1.style, clear = _1.clear;
            var _2 = __nccwpck_require__(9571), erase = _2.erase, cursor = _2.cursor;
            /**
             * ConfirmPrompt Base Element
             * @param {Object} opts Options
             * @param {String} opts.message Message
             * @param {Boolean} [opts.initial] Default value (true/false)
             * @param {Stream} [opts.stdin] The Readable stream to listen to
             * @param {Stream} [opts.stdout] The Writable stream to write readline data to
             * @param {String} [opts.yes] The "Yes" label
             * @param {String} [opts.yesOption] The "Yes" option when choosing between yes/no
             * @param {String} [opts.no] The "No" label
             * @param {String} [opts.noOption] The "No" option when choosing between yes/no
             */
            var ConfirmPrompt = /** @class */ (function (_super) {
                __extends(ConfirmPrompt, _super);
                function ConfirmPrompt(opts) {
                    if (opts === void 0) { opts = {}; }
                    var _this_1 = _super.call(this, opts) || this;
                    _this_1.msg = opts.message;
                    _this_1.value = opts.initial;
                    _this_1.initialValue = !!opts.initial;
                    _this_1.yesMsg = opts.yes || 'yes';
                    _this_1.yesOption = opts.yesOption || '(Y/n)';
                    _this_1.noMsg = opts.no || 'no';
                    _this_1.noOption = opts.noOption || '(y/N)';
                    _this_1.render();
                    return _this_1;
                }
                ConfirmPrompt.prototype.reset = function () {
                    this.value = this.initialValue;
                    this.fire();
                    this.render();
                };
                ConfirmPrompt.prototype.exit = function () {
                    this.abort();
                };
                ConfirmPrompt.prototype.abort = function () {
                    this.done = this.aborted = true;
                    this.fire();
                    this.render();
                    this.out.write('\n');
                    this.close();
                };
                ConfirmPrompt.prototype.submit = function () {
                    this.value = this.value || false;
                    this.done = true;
                    this.aborted = false;
                    this.fire();
                    this.render();
                    this.out.write('\n');
                    this.close();
                };
                ConfirmPrompt.prototype._ = function (c, key) {
                    if (c.toLowerCase() === 'y') {
                        this.value = true;
                        return this.submit();
                    }
                    if (c.toLowerCase() === 'n') {
                        this.value = false;
                        return this.submit();
                    }
                    return this.bell();
                };
                ConfirmPrompt.prototype.render = function () {
                    if (this.closed)
                        return;
                    if (this.firstRender)
                        this.out.write(cursor.hide);
                    else
                        this.out.write(clear(this.outputText, this.out.columns));
                    _super.prototype.render.call(this);
                    this.outputText = [
                        style.symbol(this.done, this.aborted),
                        color.bold(this.msg),
                        style.delimiter(this.done),
                        this.done ? (this.value ? this.yesMsg : this.noMsg)
                            : color.gray(this.initialValue ? this.yesOption : this.noOption)
                    ].join(' ');
                    this.out.write(erase.line + cursor.to(0) + this.outputText);
                };
                return ConfirmPrompt;
            }(Prompt));
            module.exports = ConfirmPrompt;
            /***/ 
        }),
        /***/ 5667: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var color = __nccwpck_require__(9407);
            var Prompt = __nccwpck_require__(4185);
            var _1 = __nccwpck_require__(9501), style = _1.style, clear = _1.clear, figures = _1.figures;
            var _2 = __nccwpck_require__(9571), erase = _2.erase, cursor = _2.cursor;
            var _3 = __nccwpck_require__(8108), DatePart = _3.DatePart, Meridiem = _3.Meridiem, Day = _3.Day, Hours = _3.Hours, Milliseconds = _3.Milliseconds, Minutes = _3.Minutes, Month = _3.Month, Seconds = _3.Seconds, Year = _3.Year;
            var regex = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g;
            var regexGroups = {
                1: function (_1) {
                    var token = _1.token;
                    return token.replace(/\\(.)/g, '$1');
                },
                2: function (opts) { return new Day(opts); },
                3: function (opts) { return new Month(opts); },
                4: function (opts) { return new Year(opts); },
                5: function (opts) { return new Meridiem(opts); },
                6: function (opts) { return new Hours(opts); },
                7: function (opts) { return new Minutes(opts); },
                8: function (opts) { return new Seconds(opts); },
                9: function (opts) { return new Milliseconds(opts); }
            };
            var dfltLocales = {
                months: 'January,February,March,April,May,June,July,August,September,October,November,December'.split(','),
                monthsShort: 'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),
                weekdays: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),
                weekdaysShort: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(',')
            };
            /**
             * DatePrompt Base Element
             * @param {Object} opts Options
             * @param {String} opts.message Message
             * @param {Number} [opts.initial] Index of default value
             * @param {String} [opts.mask] The format mask
             * @param {object} [opts.locales] The date locales
             * @param {String} [opts.error] The error message shown on invalid value
             * @param {Function} [opts.validate] Function to validate the submitted value
             * @param {Stream} [opts.stdin] The Readable stream to listen to
             * @param {Stream} [opts.stdout] The Writable stream to write readline data to
             */
            var DatePrompt = /** @class */ (function (_super) {
                __extends(DatePrompt, _super);
                function DatePrompt(opts) {
                    if (opts === void 0) { opts = {}; }
                    var _this_1 = _super.call(this, opts) || this;
                    _this_1.msg = opts.message;
                    _this_1.cursor = 0;
                    _this_1.typed = '';
                    _this_1.locales = Object.assign(dfltLocales, opts.locales);
                    _this_1._date = opts.initial || new Date();
                    _this_1.errorMsg = opts.error || 'Please Enter A Valid Value';
                    _this_1.validator = opts.validate || (function () { return true; });
                    _this_1.mask = opts.mask || 'YYYY-MM-DD HH:mm:ss';
                    _this_1.clear = clear('', _this_1.out.columns);
                    _this_1.render();
                    return _this_1;
                }
                Object.defineProperty(DatePrompt.prototype, "value", {
                    get: function () {
                        return this.date;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(DatePrompt.prototype, "date", {
                    get: function () {
                        return this._date;
                    },
                    set: function (date) {
                        if (date)
                            this._date.setTime(date.getTime());
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(DatePrompt.prototype, "mask", {
                    set: function (mask) {
                        var _1;
                        var result;
                        this.parts = [];
                        while (result = regex.exec(mask)) {
                            var match = result.shift();
                            var idx = result.findIndex(function (gr) { return gr != null; });
                            this.parts.push(idx in regexGroups
                                ? regexGroups[idx]({ token: result[idx] || match, date: this.date, parts: this.parts, locales: this.locales })
                                : result[idx] || match);
                        }
                        var parts = this.parts.reduce(function (arr, i) {
                            if (typeof i === 'string' && typeof arr[arr.length - 1] === 'string')
                                arr[arr.length - 1] += i;
                            else
                                arr.push(i);
                            return arr;
                        }, []);
                        this.parts.splice(0);
                        (_1 = this.parts).push.apply(_1, parts);
                        this.reset();
                    },
                    enumerable: false,
                    configurable: true
                });
                DatePrompt.prototype.moveCursor = function (n) {
                    this.typed = '';
                    this.cursor = n;
                    this.fire();
                };
                DatePrompt.prototype.reset = function () {
                    this.moveCursor(this.parts.findIndex(function (p) { return p instanceof DatePart; }));
                    this.fire();
                    this.render();
                };
                DatePrompt.prototype.exit = function () {
                    this.abort();
                };
                DatePrompt.prototype.abort = function () {
                    this.done = this.aborted = true;
                    this.error = false;
                    this.fire();
                    this.render();
                    this.out.write('\n');
                    this.close();
                };
                DatePrompt.prototype.validate = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var valid;
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0: return [4 /*yield*/, this.validator(this.value)];
                                case 1:
                                    valid = _1.sent();
                                    if (typeof valid === 'string') {
                                        this.errorMsg = valid;
                                        valid = false;
                                    }
                                    this.error = !valid;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                DatePrompt.prototype.submit = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0: return [4 /*yield*/, this.validate()];
                                case 1:
                                    _1.sent();
                                    if (this.error) {
                                        this.color = 'red';
                                        this.fire();
                                        this.render();
                                        return [2 /*return*/];
                                    }
                                    this.done = true;
                                    this.aborted = false;
                                    this.fire();
                                    this.render();
                                    this.out.write('\n');
                                    this.close();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                DatePrompt.prototype.up = function () {
                    this.typed = '';
                    this.parts[this.cursor].up();
                    this.render();
                };
                DatePrompt.prototype.down = function () {
                    this.typed = '';
                    this.parts[this.cursor].down();
                    this.render();
                };
                DatePrompt.prototype.left = function () {
                    var prev = this.parts[this.cursor].prev();
                    if (prev == null)
                        return this.bell();
                    this.moveCursor(this.parts.indexOf(prev));
                    this.render();
                };
                DatePrompt.prototype.right = function () {
                    var next = this.parts[this.cursor].next();
                    if (next == null)
                        return this.bell();
                    this.moveCursor(this.parts.indexOf(next));
                    this.render();
                };
                DatePrompt.prototype.next = function () {
                    var next = this.parts[this.cursor].next();
                    this.moveCursor(next
                        ? this.parts.indexOf(next)
                        : this.parts.findIndex(function (part) { return part instanceof DatePart; }));
                    this.render();
                };
                DatePrompt.prototype._ = function (c) {
                    if (/\d/.test(c)) {
                        this.typed += c;
                        this.parts[this.cursor].setTo(this.typed);
                        this.render();
                    }
                };
                DatePrompt.prototype.render = function () {
                    var _this_1 = this;
                    if (this.closed)
                        return;
                    if (this.firstRender)
                        this.out.write(cursor.hide);
                    else
                        this.out.write(clear(this.outputText, this.out.columns));
                    _super.prototype.render.call(this);
                    // Print prompt
                    this.outputText = [
                        style.symbol(this.done, this.aborted),
                        color.bold(this.msg),
                        style.delimiter(false),
                        this.parts.reduce(function (arr, p, idx) { return arr.concat(idx === _this_1.cursor && !_this_1.done ? color.cyan().underline(p.toString()) : p); }, [])
                            .join('')
                    ].join(' ');
                    // Print error
                    if (this.error) {
                        this.outputText += this.errorMsg.split('\n').reduce(function (a, l, i) { return a + "\n".concat(i ? " " : figures.pointerSmall, " ").concat(color.red().italic(l)); }, "");
                    }
                    this.out.write(erase.line + cursor.to(0) + this.outputText);
                };
                return DatePrompt;
            }(Prompt));
            module.exports = DatePrompt;
            /***/ 
        }),
        /***/ 9098: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            module.exports = {
                TextPrompt: __nccwpck_require__(5387),
                SelectPrompt: __nccwpck_require__(6514),
                TogglePrompt: __nccwpck_require__(2093),
                DatePrompt: __nccwpck_require__(5667),
                NumberPrompt: __nccwpck_require__(2952),
                MultiselectPrompt: __nccwpck_require__(1944),
                AutocompletePrompt: __nccwpck_require__(1098),
                AutocompleteMultiselectPrompt: __nccwpck_require__(8178),
                ConfirmPrompt: __nccwpck_require__(1491)
            };
            /***/ 
        }),
        /***/ 1944: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var color = __nccwpck_require__(9407);
            var cursor = __nccwpck_require__(9571).cursor;
            var Prompt = __nccwpck_require__(4185);
            var _1 = __nccwpck_require__(9501), clear = _1.clear, figures = _1.figures, style = _1.style, wrap = _1.wrap, entriesToDisplay = _1.entriesToDisplay;
            /**
             * MultiselectPrompt Base Element
             * @param {Object} opts Options
             * @param {String} opts.message Message
             * @param {Array} opts.choices Array of choice objects
             * @param {String} [opts.hint] Hint to display
             * @param {String} [opts.warn] Hint shown for disabled choices
             * @param {Number} [opts.max] Max choices
             * @param {Number} [opts.cursor=0] Cursor start position
             * @param {Number} [opts.optionsPerPage=10] Max options to display at once
             * @param {Stream} [opts.stdin] The Readable stream to listen to
             * @param {Stream} [opts.stdout] The Writable stream to write readline data to
             */
            var MultiselectPrompt = /** @class */ (function (_super) {
                __extends(MultiselectPrompt, _super);
                function MultiselectPrompt(opts) {
                    if (opts === void 0) { opts = {}; }
                    var _this_1 = _super.call(this, opts) || this;
                    _this_1.msg = opts.message;
                    _this_1.cursor = opts.cursor || 0;
                    _this_1.scrollIndex = opts.cursor || 0;
                    _this_1.hint = opts.hint || '';
                    _this_1.warn = opts.warn || '- This option is disabled -';
                    _this_1.minSelected = opts.min;
                    _this_1.showMinError = false;
                    _this_1.maxChoices = opts.max;
                    _this_1.instructions = opts.instructions;
                    _this_1.optionsPerPage = opts.optionsPerPage || 10;
                    _this_1.value = opts.choices.map(function (ch, idx) {
                        if (typeof ch === 'string')
                            ch = { title: ch, value: idx };
                        return {
                            title: ch && (ch.title || ch.value || ch),
                            description: ch && ch.description,
                            value: ch && (ch.value === undefined ? idx : ch.value),
                            selected: ch && ch.selected,
                            disabled: ch && ch.disabled
                        };
                    });
                    _this_1.clear = clear('', _this_1.out.columns);
                    if (!opts.overrideRender) {
                        _this_1.render();
                    }
                    return _this_1;
                }
                MultiselectPrompt.prototype.reset = function () {
                    this.value.map(function (v) { return !v.selected; });
                    this.cursor = 0;
                    this.fire();
                    this.render();
                };
                MultiselectPrompt.prototype.selected = function () {
                    return this.value.filter(function (v) { return v.selected; });
                };
                MultiselectPrompt.prototype.exit = function () {
                    this.abort();
                };
                MultiselectPrompt.prototype.abort = function () {
                    this.done = this.aborted = true;
                    this.fire();
                    this.render();
                    this.out.write('\n');
                    this.close();
                };
                MultiselectPrompt.prototype.submit = function () {
                    var selected = this.value
                        .filter(function (e) { return e.selected; });
                    if (this.minSelected && selected.length < this.minSelected) {
                        this.showMinError = true;
                        this.render();
                    }
                    else {
                        this.done = true;
                        this.aborted = false;
                        this.fire();
                        this.render();
                        this.out.write('\n');
                        this.close();
                    }
                };
                MultiselectPrompt.prototype.first = function () {
                    this.cursor = 0;
                    this.render();
                };
                MultiselectPrompt.prototype.last = function () {
                    this.cursor = this.value.length - 1;
                    this.render();
                };
                MultiselectPrompt.prototype.next = function () {
                    this.cursor = (this.cursor + 1) % this.value.length;
                    this.render();
                };
                MultiselectPrompt.prototype.up = function () {
                    if (this.cursor === 0) {
                        this.cursor = this.value.length - 1;
                    }
                    else {
                        this.cursor--;
                    }
                    this.render();
                };
                MultiselectPrompt.prototype.down = function () {
                    if (this.cursor === this.value.length - 1) {
                        this.cursor = 0;
                    }
                    else {
                        this.cursor++;
                    }
                    this.render();
                };
                MultiselectPrompt.prototype.left = function () {
                    this.value[this.cursor].selected = false;
                    this.render();
                };
                MultiselectPrompt.prototype.right = function () {
                    if (this.value.filter(function (e) { return e.selected; }).length >= this.maxChoices)
                        return this.bell();
                    this.value[this.cursor].selected = true;
                    this.render();
                };
                MultiselectPrompt.prototype.handleSpaceToggle = function () {
                    var v = this.value[this.cursor];
                    if (v.selected) {
                        v.selected = false;
                        this.render();
                    }
                    else if (v.disabled || this.value.filter(function (e) { return e.selected; }).length >= this.maxChoices) {
                        return this.bell();
                    }
                    else {
                        v.selected = true;
                        this.render();
                    }
                };
                MultiselectPrompt.prototype.toggleAll = function () {
                    if (this.maxChoices !== undefined || this.value[this.cursor].disabled) {
                        return this.bell();
                    }
                    var newSelected = !this.value[this.cursor].selected;
                    this.value.filter(function (v) { return !v.disabled; }).forEach(function (v) { return v.selected = newSelected; });
                    this.render();
                };
                MultiselectPrompt.prototype._ = function (c, key) {
                    if (c === ' ') {
                        this.handleSpaceToggle();
                    }
                    else if (c === 'a') {
                        this.toggleAll();
                    }
                    else {
                        return this.bell();
                    }
                };
                MultiselectPrompt.prototype.renderInstructions = function () {
                    if (this.instructions === undefined || this.instructions) {
                        if (typeof this.instructions === 'string') {
                            return this.instructions;
                        }
                        return '\nInstructions:\n'
                            + "    ".concat(figures.arrowUp, "/").concat(figures.arrowDown, ": Highlight option\n")
                            + "    ".concat(figures.arrowLeft, "/").concat(figures.arrowRight, "/[space]: Toggle selection\n")
                            + (this.maxChoices === undefined ? "    a: Toggle all\n" : '')
                            + "    enter/return: Complete answer";
                    }
                    return '';
                };
                MultiselectPrompt.prototype.renderOption = function (cursor, v, i, arrowIndicator) {
                    var prefix = (v.selected ? color.green(figures.radioOn) : figures.radioOff) + ' ' + arrowIndicator + ' ';
                    var title, desc;
                    if (v.disabled) {
                        title = cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
                    }
                    else {
                        title = cursor === i ? color.cyan().underline(v.title) : v.title;
                        if (cursor === i && v.description) {
                            desc = " - ".concat(v.description);
                            if (prefix.length + title.length + desc.length >= this.out.columns
                                || v.description.split(/\r?\n/).length > 1) {
                                desc = '\n' + wrap(v.description, { margin: prefix.length, width: this.out.columns });
                            }
                        }
                    }
                    return prefix + title + color.gray(desc || '');
                };
                // shared with autocompleteMultiselect
                MultiselectPrompt.prototype.paginateOptions = function (options) {
                    if (options.length === 0) {
                        return color.red('No matches for this query.');
                    }
                    var _1 = entriesToDisplay(this.cursor, options.length, this.optionsPerPage), startIndex = _1.startIndex, endIndex = _1.endIndex;
                    var prefix, styledOptions = [];
                    for (var i = startIndex; i < endIndex; i++) {
                        if (i === startIndex && startIndex > 0) {
                            prefix = figures.arrowUp;
                        }
                        else if (i === endIndex - 1 && endIndex < options.length) {
                            prefix = figures.arrowDown;
                        }
                        else {
                            prefix = ' ';
                        }
                        styledOptions.push(this.renderOption(this.cursor, options[i], i, prefix));
                    }
                    return '\n' + styledOptions.join('\n');
                };
                // shared with autocomleteMultiselect
                MultiselectPrompt.prototype.renderOptions = function (options) {
                    if (!this.done) {
                        return this.paginateOptions(options);
                    }
                    return '';
                };
                MultiselectPrompt.prototype.renderDoneOrInstructions = function () {
                    if (this.done) {
                        return this.value
                            .filter(function (e) { return e.selected; })
                            .map(function (v) { return v.title; })
                            .join(', ');
                    }
                    var output = [color.gray(this.hint), this.renderInstructions()];
                    if (this.value[this.cursor].disabled) {
                        output.push(color.yellow(this.warn));
                    }
                    return output.join(' ');
                };
                MultiselectPrompt.prototype.render = function () {
                    if (this.closed)
                        return;
                    if (this.firstRender)
                        this.out.write(cursor.hide);
                    _super.prototype.render.call(this);
                    // print prompt
                    var prompt = [
                        style.symbol(this.done, this.aborted),
                        color.bold(this.msg),
                        style.delimiter(false),
                        this.renderDoneOrInstructions()
                    ].join(' ');
                    if (this.showMinError) {
                        prompt += color.red("You must select a minimum of ".concat(this.minSelected, " choices."));
                        this.showMinError = false;
                    }
                    prompt += this.renderOptions(this.value);
                    this.out.write(this.clear + prompt);
                    this.clear = clear(prompt, this.out.columns);
                };
                return MultiselectPrompt;
            }(Prompt));
            module.exports = MultiselectPrompt;
            /***/ 
        }),
        /***/ 2952: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var color = __nccwpck_require__(9407);
            var Prompt = __nccwpck_require__(4185);
            var _1 = __nccwpck_require__(9571), cursor = _1.cursor, erase = _1.erase;
            var _2 = __nccwpck_require__(9501), style = _2.style, figures = _2.figures, clear = _2.clear, lines = _2.lines;
            var isNumber = /[0-9]/;
            var isDef = function (any) { return any !== undefined; };
            var round = function (number, precision) {
                var factor = Math.pow(10, precision);
                return Math.round(number * factor) / factor;
            };
            /**
             * NumberPrompt Base Element
             * @param {Object} opts Options
             * @param {String} opts.message Message
             * @param {String} [opts.style='default'] Render style
             * @param {Number} [opts.initial] Default value
             * @param {Number} [opts.max=+Infinity] Max value
             * @param {Number} [opts.min=-Infinity] Min value
             * @param {Boolean} [opts.float=false] Parse input as floats
             * @param {Number} [opts.round=2] Round floats to x decimals
             * @param {Number} [opts.increment=1] Number to increment by when using arrow-keys
             * @param {Function} [opts.validate] Validate function
             * @param {Stream} [opts.stdin] The Readable stream to listen to
             * @param {Stream} [opts.stdout] The Writable stream to write readline data to
             * @param {String} [opts.error] The invalid error label
             */
            var NumberPrompt = /** @class */ (function (_super) {
                __extends(NumberPrompt, _super);
                function NumberPrompt(opts) {
                    if (opts === void 0) { opts = {}; }
                    var _this_1 = _super.call(this, opts) || this;
                    _this_1.transform = style.render(opts.style);
                    _this_1.msg = opts.message;
                    _this_1.initial = isDef(opts.initial) ? opts.initial : '';
                    _this_1.float = !!opts.float;
                    _this_1.round = opts.round || 2;
                    _this_1.inc = opts.increment || 1;
                    _this_1.min = isDef(opts.min) ? opts.min : -Infinity;
                    _this_1.max = isDef(opts.max) ? opts.max : Infinity;
                    _this_1.errorMsg = opts.error || "Please Enter A Valid Value";
                    _this_1.validator = opts.validate || (function () { return true; });
                    _this_1.color = "cyan";
                    _this_1.value = "";
                    _this_1.typed = "";
                    _this_1.lastHit = 0;
                    _this_1.render();
                    return _this_1;
                }
                Object.defineProperty(NumberPrompt.prototype, "value", {
                    get: function () {
                        return this._value;
                    },
                    set: function (v) {
                        if (!v && v !== 0) {
                            this.placeholder = true;
                            this.rendered = color.gray(this.transform.render("".concat(this.initial)));
                            this._value = "";
                        }
                        else {
                            this.placeholder = false;
                            this.rendered = this.transform.render("".concat(round(v, this.round)));
                            this._value = round(v, this.round);
                        }
                        this.fire();
                    },
                    enumerable: false,
                    configurable: true
                });
                NumberPrompt.prototype.parse = function (x) {
                    return this.float ? parseFloat(x) : parseInt(x);
                };
                NumberPrompt.prototype.valid = function (c) {
                    return c === "-" || c === "." && this.float || isNumber.test(c);
                };
                NumberPrompt.prototype.reset = function () {
                    this.typed = "";
                    this.value = "";
                    this.fire();
                    this.render();
                };
                NumberPrompt.prototype.exit = function () {
                    this.abort();
                };
                NumberPrompt.prototype.abort = function () {
                    var x = this.value;
                    this.value = x !== "" ? x : this.initial;
                    this.done = this.aborted = true;
                    this.error = false;
                    this.fire();
                    this.render();
                    this.out.write("\n");
                    this.close();
                };
                NumberPrompt.prototype.validate = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var valid;
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0: return [4 /*yield*/, this.validator(this.value)];
                                case 1:
                                    valid = _1.sent();
                                    if (typeof valid === "string") {
                                        this.errorMsg = valid;
                                        valid = false;
                                    }
                                    this.error = !valid;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                NumberPrompt.prototype.submit = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var x;
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0: return [4 /*yield*/, this.validate()];
                                case 1:
                                    _1.sent();
                                    if (this.error) {
                                        this.color = "red";
                                        this.fire();
                                        this.render();
                                        return [2 /*return*/];
                                    }
                                    x = this.value;
                                    this.value = x !== "" ? x : this.initial;
                                    this.done = true;
                                    this.aborted = false;
                                    this.error = false;
                                    this.fire();
                                    this.render();
                                    this.out.write("\n");
                                    this.close();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                NumberPrompt.prototype.up = function () {
                    this.typed = "";
                    if (this.value === '') {
                        this.value = this.min - this.inc;
                    }
                    if (this.value >= this.max)
                        return this.bell();
                    this.value += this.inc;
                    this.color = "cyan";
                    this.fire();
                    this.render();
                };
                NumberPrompt.prototype.down = function () {
                    this.typed = "";
                    if (this.value === '') {
                        this.value = this.min + this.inc;
                    }
                    if (this.value <= this.min)
                        return this.bell();
                    this.value -= this.inc;
                    this.color = "cyan";
                    this.fire();
                    this.render();
                };
                NumberPrompt.prototype["delete"] = function () {
                    var val = this.value.toString();
                    if (val.length === 0)
                        return this.bell();
                    this.value = this.parse((val = val.slice(0, -1))) || "";
                    if (this.value !== '' && this.value < this.min) {
                        this.value = this.min;
                    }
                    this.color = "cyan";
                    this.fire();
                    this.render();
                };
                NumberPrompt.prototype.next = function () {
                    this.value = this.initial;
                    this.fire();
                    this.render();
                };
                NumberPrompt.prototype._ = function (c, key) {
                    if (!this.valid(c))
                        return this.bell();
                    var now = Date.now();
                    if (now - this.lastHit > 1000)
                        this.typed = ""; // 1s elapsed
                    this.typed += c;
                    this.lastHit = now;
                    this.color = "cyan";
                    if (c === ".")
                        return this.fire();
                    this.value = Math.min(this.parse(this.typed), this.max);
                    if (this.value > this.max)
                        this.value = this.max;
                    if (this.value < this.min)
                        this.value = this.min;
                    this.fire();
                    this.render();
                };
                NumberPrompt.prototype.render = function () {
                    if (this.closed)
                        return;
                    if (!this.firstRender) {
                        if (this.outputError)
                            this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
                        this.out.write(clear(this.outputText, this.out.columns));
                    }
                    _super.prototype.render.call(this);
                    this.outputError = '';
                    // Print prompt
                    this.outputText = [
                        style.symbol(this.done, this.aborted),
                        color.bold(this.msg),
                        style.delimiter(this.done),
                        !this.done || (!this.done && !this.placeholder)
                            ? color[this.color]().underline(this.rendered) : this.rendered
                    ].join(" ");
                    // Print error
                    if (this.error) {
                        this.outputError += this.errorMsg.split("\n")
                            .reduce(function (a, l, i) { return a + "\n".concat(i ? " " : figures.pointerSmall, " ").concat(color.red().italic(l)); }, "");
                    }
                    this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore);
                };
                return NumberPrompt;
            }(Prompt));
            module.exports = NumberPrompt;
            /***/ 
        }),
        /***/ 4185: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var readline = __nccwpck_require__(4521);
            var action = __nccwpck_require__(9501).action;
            var EventEmitter = __nccwpck_require__(2361);
            var _1 = __nccwpck_require__(9571), beep = _1.beep, cursor = _1.cursor;
            var color = __nccwpck_require__(9407);
            /**
             * Base prompt skeleton
             * @param {Stream} [opts.stdin] The Readable stream to listen to
             * @param {Stream} [opts.stdout] The Writable stream to write readline data to
             */
            var Prompt = /** @class */ (function (_super) {
                __extends(Prompt, _super);
                function Prompt(opts) {
                    if (opts === void 0) { opts = {}; }
                    var _this_1 = _super.call(this) || this;
                    _this_1.firstRender = true;
                    _this_1["in"] = opts.stdin || process.stdin;
                    _this_1.out = opts.stdout || process.stdout;
                    _this_1.onRender = (opts.onRender || (function () { return void 0; })).bind(_this_1);
                    var rl = readline.createInterface({ input: _this_1["in"], escapeCodeTimeout: 50 });
                    readline.emitKeypressEvents(_this_1["in"], rl);
                    if (_this_1["in"].isTTY)
                        _this_1["in"].setRawMode(true);
                    var isSelect = ['SelectPrompt', 'MultiselectPrompt'].indexOf(_this_1.constructor.name) > -1;
                    var keypress = function (str, key) {
                        var a = action(key, isSelect);
                        if (a === false) {
                            _this_1._ && _this_1._(str, key);
                        }
                        else if (typeof _this_1[a] === 'function') {
                            _this_1[a](key);
                        }
                        else {
                            _this_1.bell();
                        }
                    };
                    _this_1.close = function () {
                        _this_1.out.write(cursor.show);
                        _this_1["in"].removeListener('keypress', keypress);
                        if (_this_1["in"].isTTY)
                            _this_1["in"].setRawMode(false);
                        rl.close();
                        _this_1.emit(_this_1.aborted ? 'abort' : _this_1.exited ? 'exit' : 'submit', _this_1.value);
                        _this_1.closed = true;
                    };
                    _this_1["in"].on('keypress', keypress);
                    return _this_1;
                }
                Prompt.prototype.fire = function () {
                    this.emit('state', {
                        value: this.value,
                        aborted: !!this.aborted,
                        exited: !!this.exited
                    });
                };
                Prompt.prototype.bell = function () {
                    this.out.write(beep);
                };
                Prompt.prototype.render = function () {
                    this.onRender(color);
                    if (this.firstRender)
                        this.firstRender = false;
                };
                return Prompt;
            }(EventEmitter));
            module.exports = Prompt;
            /***/ 
        }),
        /***/ 6514: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var color = __nccwpck_require__(9407);
            var Prompt = __nccwpck_require__(4185);
            var _1 = __nccwpck_require__(9501), style = _1.style, clear = _1.clear, figures = _1.figures, wrap = _1.wrap, entriesToDisplay = _1.entriesToDisplay;
            var cursor = __nccwpck_require__(9571).cursor;
            /**
             * SelectPrompt Base Element
             * @param {Object} opts Options
             * @param {String} opts.message Message
             * @param {Array} opts.choices Array of choice objects
             * @param {String} [opts.hint] Hint to display
             * @param {Number} [opts.initial] Index of default value
             * @param {Stream} [opts.stdin] The Readable stream to listen to
             * @param {Stream} [opts.stdout] The Writable stream to write readline data to
             * @param {Number} [opts.optionsPerPage=10] Max options to display at once
             */
            var SelectPrompt = /** @class */ (function (_super) {
                __extends(SelectPrompt, _super);
                function SelectPrompt(opts) {
                    if (opts === void 0) { opts = {}; }
                    var _this_1 = _super.call(this, opts) || this;
                    _this_1.msg = opts.message;
                    _this_1.hint = opts.hint || '- Use arrow-keys. Return to submit.';
                    _this_1.warn = opts.warn || '- This option is disabled';
                    _this_1.cursor = opts.initial || 0;
                    _this_1.choices = opts.choices.map(function (ch, idx) {
                        if (typeof ch === 'string')
                            ch = { title: ch, value: idx };
                        return {
                            title: ch && (ch.title || ch.value || ch),
                            value: ch && (ch.value === undefined ? idx : ch.value),
                            description: ch && ch.description,
                            selected: ch && ch.selected,
                            disabled: ch && ch.disabled
                        };
                    });
                    _this_1.optionsPerPage = opts.optionsPerPage || 10;
                    _this_1.value = (_this_1.choices[_this_1.cursor] || {}).value;
                    _this_1.clear = clear('', _this_1.out.columns);
                    _this_1.render();
                    return _this_1;
                }
                SelectPrompt.prototype.moveCursor = function (n) {
                    this.cursor = n;
                    this.value = this.choices[n].value;
                    this.fire();
                };
                SelectPrompt.prototype.reset = function () {
                    this.moveCursor(0);
                    this.fire();
                    this.render();
                };
                SelectPrompt.prototype.exit = function () {
                    this.abort();
                };
                SelectPrompt.prototype.abort = function () {
                    this.done = this.aborted = true;
                    this.fire();
                    this.render();
                    this.out.write('\n');
                    this.close();
                };
                SelectPrompt.prototype.submit = function () {
                    if (!this.selection.disabled) {
                        this.done = true;
                        this.aborted = false;
                        this.fire();
                        this.render();
                        this.out.write('\n');
                        this.close();
                    }
                    else
                        this.bell();
                };
                SelectPrompt.prototype.first = function () {
                    this.moveCursor(0);
                    this.render();
                };
                SelectPrompt.prototype.last = function () {
                    this.moveCursor(this.choices.length - 1);
                    this.render();
                };
                SelectPrompt.prototype.up = function () {
                    if (this.cursor === 0) {
                        this.moveCursor(this.choices.length - 1);
                    }
                    else {
                        this.moveCursor(this.cursor - 1);
                    }
                    this.render();
                };
                SelectPrompt.prototype.down = function () {
                    if (this.cursor === this.choices.length - 1) {
                        this.moveCursor(0);
                    }
                    else {
                        this.moveCursor(this.cursor + 1);
                    }
                    this.render();
                };
                SelectPrompt.prototype.next = function () {
                    this.moveCursor((this.cursor + 1) % this.choices.length);
                    this.render();
                };
                SelectPrompt.prototype._ = function (c, key) {
                    if (c === ' ')
                        return this.submit();
                };
                Object.defineProperty(SelectPrompt.prototype, "selection", {
                    get: function () {
                        return this.choices[this.cursor];
                    },
                    enumerable: false,
                    configurable: true
                });
                SelectPrompt.prototype.render = function () {
                    if (this.closed)
                        return;
                    if (this.firstRender)
                        this.out.write(cursor.hide);
                    else
                        this.out.write(clear(this.outputText, this.out.columns));
                    _super.prototype.render.call(this);
                    var _1 = entriesToDisplay(this.cursor, this.choices.length, this.optionsPerPage), startIndex = _1.startIndex, endIndex = _1.endIndex;
                    // Print prompt
                    this.outputText = [
                        style.symbol(this.done, this.aborted),
                        color.bold(this.msg),
                        style.delimiter(false),
                        this.done ? this.selection.title : this.selection.disabled
                            ? color.yellow(this.warn) : color.gray(this.hint)
                    ].join(' ');
                    // Print choices
                    if (!this.done) {
                        this.outputText += '\n';
                        for (var i = startIndex; i < endIndex; i++) {
                            var title = void 0, prefix = void 0, desc = '', v = this.choices[i];
                            // Determine whether to display "more choices" indicators
                            if (i === startIndex && startIndex > 0) {
                                prefix = figures.arrowUp;
                            }
                            else if (i === endIndex - 1 && endIndex < this.choices.length) {
                                prefix = figures.arrowDown;
                            }
                            else {
                                prefix = ' ';
                            }
                            if (v.disabled) {
                                title = this.cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
                                prefix = (this.cursor === i ? color.bold().gray(figures.pointer) + ' ' : '  ') + prefix;
                            }
                            else {
                                title = this.cursor === i ? color.cyan().underline(v.title) : v.title;
                                prefix = (this.cursor === i ? color.cyan(figures.pointer) + ' ' : '  ') + prefix;
                                if (v.description && this.cursor === i) {
                                    desc = " - ".concat(v.description);
                                    if (prefix.length + title.length + desc.length >= this.out.columns
                                        || v.description.split(/\r?\n/).length > 1) {
                                        desc = '\n' + wrap(v.description, { margin: 3, width: this.out.columns });
                                    }
                                }
                            }
                            this.outputText += "".concat(prefix, " ").concat(title).concat(color.gray(desc), "\n");
                        }
                    }
                    this.out.write(this.outputText);
                };
                return SelectPrompt;
            }(Prompt));
            module.exports = SelectPrompt;
            /***/ 
        }),
        /***/ 5387: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var color = __nccwpck_require__(9407);
            var Prompt = __nccwpck_require__(4185);
            var _1 = __nccwpck_require__(9571), erase = _1.erase, cursor = _1.cursor;
            var _2 = __nccwpck_require__(9501), style = _2.style, clear = _2.clear, lines = _2.lines, figures = _2.figures;
            /**
             * TextPrompt Base Element
             * @param {Object} opts Options
             * @param {String} opts.message Message
             * @param {String} [opts.style='default'] Render style
             * @param {String} [opts.initial] Default value
             * @param {Function} [opts.validate] Validate function
             * @param {Stream} [opts.stdin] The Readable stream to listen to
             * @param {Stream} [opts.stdout] The Writable stream to write readline data to
             * @param {String} [opts.error] The invalid error label
             */
            var TextPrompt = /** @class */ (function (_super) {
                __extends(TextPrompt, _super);
                function TextPrompt(opts) {
                    if (opts === void 0) { opts = {}; }
                    var _this_1 = _super.call(this, opts) || this;
                    _this_1.transform = style.render(opts.style);
                    _this_1.scale = _this_1.transform.scale;
                    _this_1.msg = opts.message;
                    _this_1.initial = opts.initial || "";
                    _this_1.validator = opts.validate || (function () { return true; });
                    _this_1.value = "";
                    _this_1.errorMsg = opts.error || "Please Enter A Valid Value";
                    _this_1.cursor = Number(!!_this_1.initial);
                    _this_1.cursorOffset = 0;
                    _this_1.clear = clear("", _this_1.out.columns);
                    _this_1.render();
                    return _this_1;
                }
                Object.defineProperty(TextPrompt.prototype, "value", {
                    get: function () {
                        return this._value;
                    },
                    set: function (v) {
                        if (!v && this.initial) {
                            this.placeholder = true;
                            this.rendered = color.gray(this.transform.render(this.initial));
                        }
                        else {
                            this.placeholder = false;
                            this.rendered = this.transform.render(v);
                        }
                        this._value = v;
                        this.fire();
                    },
                    enumerable: false,
                    configurable: true
                });
                TextPrompt.prototype.reset = function () {
                    this.value = "";
                    this.cursor = Number(!!this.initial);
                    this.cursorOffset = 0;
                    this.fire();
                    this.render();
                };
                TextPrompt.prototype.exit = function () {
                    this.abort();
                };
                TextPrompt.prototype.abort = function () {
                    this.value = this.value || this.initial;
                    this.done = this.aborted = true;
                    this.error = false;
                    this.red = false;
                    this.fire();
                    this.render();
                    this.out.write('\n');
                    this.close();
                };
                TextPrompt.prototype.validate = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var valid;
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0: return [4 /*yield*/, this.validator(this.value)];
                                case 1:
                                    valid = _1.sent();
                                    if (typeof valid === "string") {
                                        this.errorMsg = valid;
                                        valid = false;
                                    }
                                    this.error = !valid;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                TextPrompt.prototype.submit = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0:
                                    this.value = this.value || this.initial;
                                    this.cursorOffset = 0;
                                    this.cursor = this.rendered.length;
                                    return [4 /*yield*/, this.validate()];
                                case 1:
                                    _1.sent();
                                    if (this.error) {
                                        this.red = true;
                                        this.fire();
                                        this.render();
                                        return [2 /*return*/];
                                    }
                                    this.done = true;
                                    this.aborted = false;
                                    this.fire();
                                    this.render();
                                    this.out.write('\n');
                                    this.close();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                TextPrompt.prototype.next = function () {
                    if (!this.placeholder)
                        return this.bell();
                    this.value = this.initial;
                    this.cursor = this.rendered.length;
                    this.fire();
                    this.render();
                };
                TextPrompt.prototype.moveCursor = function (n) {
                    if (this.placeholder)
                        return;
                    this.cursor = this.cursor + n;
                    this.cursorOffset += n;
                };
                TextPrompt.prototype._ = function (c, key) {
                    var s1 = this.value.slice(0, this.cursor);
                    var s2 = this.value.slice(this.cursor);
                    this.value = "".concat(s1).concat(c).concat(s2);
                    this.red = false;
                    this.cursor = this.placeholder ? 0 : s1.length + 1;
                    this.render();
                };
                TextPrompt.prototype["delete"] = function () {
                    if (this.isCursorAtStart())
                        return this.bell();
                    var s1 = this.value.slice(0, this.cursor - 1);
                    var s2 = this.value.slice(this.cursor);
                    this.value = "".concat(s1).concat(s2);
                    this.red = false;
                    if (this.isCursorAtStart()) {
                        this.cursorOffset = 0;
                    }
                    else {
                        this.cursorOffset++;
                        this.moveCursor(-1);
                    }
                    this.render();
                };
                TextPrompt.prototype.deleteForward = function () {
                    if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
                        return this.bell();
                    var s1 = this.value.slice(0, this.cursor);
                    var s2 = this.value.slice(this.cursor + 1);
                    this.value = "".concat(s1).concat(s2);
                    this.red = false;
                    if (this.isCursorAtEnd()) {
                        this.cursorOffset = 0;
                    }
                    else {
                        this.cursorOffset++;
                    }
                    this.render();
                };
                TextPrompt.prototype.first = function () {
                    this.cursor = 0;
                    this.render();
                };
                TextPrompt.prototype.last = function () {
                    this.cursor = this.value.length;
                    this.render();
                };
                TextPrompt.prototype.left = function () {
                    if (this.cursor <= 0 || this.placeholder)
                        return this.bell();
                    this.moveCursor(-1);
                    this.render();
                };
                TextPrompt.prototype.right = function () {
                    if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
                        return this.bell();
                    this.moveCursor(1);
                    this.render();
                };
                TextPrompt.prototype.isCursorAtStart = function () {
                    return this.cursor === 0 || (this.placeholder && this.cursor === 1);
                };
                TextPrompt.prototype.isCursorAtEnd = function () {
                    return this.cursor === this.rendered.length || (this.placeholder && this.cursor === this.rendered.length + 1);
                };
                TextPrompt.prototype.render = function () {
                    if (this.closed)
                        return;
                    if (!this.firstRender) {
                        if (this.outputError)
                            this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
                        this.out.write(clear(this.outputText, this.out.columns));
                    }
                    _super.prototype.render.call(this);
                    this.outputError = '';
                    this.outputText = [
                        style.symbol(this.done, this.aborted),
                        color.bold(this.msg),
                        style.delimiter(this.done),
                        this.red ? color.red(this.rendered) : this.rendered
                    ].join(" ");
                    if (this.error) {
                        this.outputError += this.errorMsg.split("\n")
                            .reduce(function (a, l, i) { return a + "\n".concat(i ? ' ' : figures.pointerSmall, " ").concat(color.red().italic(l)); }, "");
                    }
                    this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore + cursor.move(this.cursorOffset, 0));
                };
                return TextPrompt;
            }(Prompt));
            module.exports = TextPrompt;
            /***/ 
        }),
        /***/ 2093: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var color = __nccwpck_require__(9407);
            var Prompt = __nccwpck_require__(4185);
            var _1 = __nccwpck_require__(9501), style = _1.style, clear = _1.clear;
            var _2 = __nccwpck_require__(9571), cursor = _2.cursor, erase = _2.erase;
            /**
             * TogglePrompt Base Element
             * @param {Object} opts Options
             * @param {String} opts.message Message
             * @param {Boolean} [opts.initial=false] Default value
             * @param {String} [opts.active='no'] Active label
             * @param {String} [opts.inactive='off'] Inactive label
             * @param {Stream} [opts.stdin] The Readable stream to listen to
             * @param {Stream} [opts.stdout] The Writable stream to write readline data to
             */
            var TogglePrompt = /** @class */ (function (_super) {
                __extends(TogglePrompt, _super);
                function TogglePrompt(opts) {
                    if (opts === void 0) { opts = {}; }
                    var _this_1 = _super.call(this, opts) || this;
                    _this_1.msg = opts.message;
                    _this_1.value = !!opts.initial;
                    _this_1.active = opts.active || 'on';
                    _this_1.inactive = opts.inactive || 'off';
                    _this_1.initialValue = _this_1.value;
                    _this_1.render();
                    return _this_1;
                }
                TogglePrompt.prototype.reset = function () {
                    this.value = this.initialValue;
                    this.fire();
                    this.render();
                };
                TogglePrompt.prototype.exit = function () {
                    this.abort();
                };
                TogglePrompt.prototype.abort = function () {
                    this.done = this.aborted = true;
                    this.fire();
                    this.render();
                    this.out.write('\n');
                    this.close();
                };
                TogglePrompt.prototype.submit = function () {
                    this.done = true;
                    this.aborted = false;
                    this.fire();
                    this.render();
                    this.out.write('\n');
                    this.close();
                };
                TogglePrompt.prototype.deactivate = function () {
                    if (this.value === false)
                        return this.bell();
                    this.value = false;
                    this.render();
                };
                TogglePrompt.prototype.activate = function () {
                    if (this.value === true)
                        return this.bell();
                    this.value = true;
                    this.render();
                };
                TogglePrompt.prototype["delete"] = function () {
                    this.deactivate();
                };
                TogglePrompt.prototype.left = function () {
                    this.deactivate();
                };
                TogglePrompt.prototype.right = function () {
                    this.activate();
                };
                TogglePrompt.prototype.down = function () {
                    this.deactivate();
                };
                TogglePrompt.prototype.up = function () {
                    this.activate();
                };
                TogglePrompt.prototype.next = function () {
                    this.value = !this.value;
                    this.fire();
                    this.render();
                };
                TogglePrompt.prototype._ = function (c, key) {
                    if (c === ' ') {
                        this.value = !this.value;
                    }
                    else if (c === '1') {
                        this.value = true;
                    }
                    else if (c === '0') {
                        this.value = false;
                    }
                    else
                        return this.bell();
                    this.render();
                };
                TogglePrompt.prototype.render = function () {
                    if (this.closed)
                        return;
                    if (this.firstRender)
                        this.out.write(cursor.hide);
                    else
                        this.out.write(clear(this.outputText, this.out.columns));
                    _super.prototype.render.call(this);
                    this.outputText = [
                        style.symbol(this.done, this.aborted),
                        color.bold(this.msg),
                        style.delimiter(this.done),
                        this.value ? this.inactive : color.cyan().underline(this.inactive),
                        color.gray('/'),
                        this.value ? color.cyan().underline(this.active) : this.active
                    ].join(' ');
                    this.out.write(erase.line + cursor.to(0) + this.outputText);
                };
                return TogglePrompt;
            }(Prompt));
            module.exports = TogglePrompt;
            /***/ 
        }),
        /***/ 5379: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var prompts = __nccwpck_require__(1558);
            var passOn = ['suggest', 'format', 'onState', 'validate', 'onRender', 'type'];
            var noop = function () { };
            /**
             * Prompt for a series of questions
             * @param {Array|Object} questions Single question object or Array of question objects
             * @param {Function} [onSubmit] Callback function called on prompt submit
             * @param {Function} [onCancel] Callback function called on cancel/abort
             * @returns {Object} Object with values from user input
             */
            function prompt(questions, _1) {
                if (questions === void 0) { questions = []; }
                var _2 = _1 === void 0 ? {} : _1, _3 = _2.onSubmit, onSubmit = _3 === void 0 ? noop : _3, _4 = _2.onCancel, onCancel = _4 === void 0 ? noop : _4;
                return __awaiter(this, void 0, void 0, function () {
                    var answers, override, answer, question, quit, name, type, lastPrompt, getFormattedAnswer, _5, questions_1, _6, _7, _8, _9, key, value, _10, _11, _12, _13, _14, _15, err_4;
                    var _this_1 = this;
                    return __generator(this, function (_16) {
                        switch (_16.label) {
                            case 0:
                                answers = {};
                                override = prompt._override || {};
                                questions = [].concat(questions);
                                getFormattedAnswer = function (question, answer, skipValidation) {
                                    if (skipValidation === void 0) { skipValidation = false; }
                                    return __awaiter(_this_1, void 0, void 0, function () {
                                        var _1;
                                        return __generator(this, function (_2) {
                                            switch (_2.label) {
                                                case 0:
                                                    if (!skipValidation && question.validate && question.validate(answer) !== true) {
                                                        return [2 /*return*/];
                                                    }
                                                    if (!question.format) return [3 /*break*/, 2];
                                                    return [4 /*yield*/, question.format(answer, answers)];
                                                case 1:
                                                    _1 = _2.sent();
                                                    return [3 /*break*/, 3];
                                                case 2:
                                                    _1 = answer;
                                                    _2.label = 3;
                                                case 3: return [2 /*return*/, _1];
                                            }
                                        });
                                    });
                                };
                                _5 = 0, questions_1 = questions;
                                _16.label = 1;
                            case 1:
                                if (!(_5 < questions_1.length)) return [3 /*break*/, 21];
                                question = questions_1[_5];
                                (name = question.name, type = question.type);
                                if (!(typeof type === 'function')) return [3 /*break*/, 3];
                                return [4 /*yield*/, type(answer, __assign({}, answers), question)];
                            case 2:
                                type = _16.sent();
                                question['type'] = type;
                                _16.label = 3;
                            case 3:
                                if (!type)
                                    return [3 /*break*/, 20];
                                _6 = question;
                                _7 = [];
                                for (_8 in _6)
                                    _7.push(_8);
                                _9 = 0;
                                _16.label = 4;
                            case 4:
                                if (!(_9 < _7.length)) return [3 /*break*/, 9];
                                _8 = _7[_9];
                                if (!(_8 in _6)) return [3 /*break*/, 8];
                                key = _8;
                                if (passOn.includes(key))
                                    return [3 /*break*/, 8];
                                value = question[key];
                                _10 = question;
                                _11 = key;
                                if (!(typeof value === 'function')) return [3 /*break*/, 6];
                                return [4 /*yield*/, value(answer, __assign({}, answers), lastPrompt)];
                            case 5:
                                _12 = _16.sent();
                                return [3 /*break*/, 7];
                            case 6:
                                _12 = value;
                                _16.label = 7;
                            case 7:
                                _10[_11] = _12;
                                _16.label = 8;
                            case 8:
                                _9++;
                                return [3 /*break*/, 4];
                            case 9:
                                lastPrompt = question;
                                if (typeof question.message !== 'string') {
                                    throw new Error('prompt message is required');
                                }
                                // update vars in case they changed
                                (name = question.name, type = question.type);
                                if (prompts[type] === void 0) {
                                    throw new Error("prompt type (".concat(type, ") is not defined"));
                                }
                                if (!(override[question.name] !== undefined)) return [3 /*break*/, 11];
                                return [4 /*yield*/, getFormattedAnswer(question, override[question.name])];
                            case 10:
                                answer = _16.sent();
                                if (answer !== undefined) {
                                    answers[name] = answer;
                                    return [3 /*break*/, 20];
                                }
                                _16.label = 11;
                            case 11:
                                _16.trys.push([11, 17, , 19]);
                                if (!prompt._injected) return [3 /*break*/, 12];
                                _13 = getInjectedAnswer(prompt._injected, question.initial);
                                return [3 /*break*/, 14];
                            case 12: return [4 /*yield*/, prompts[type](question)];
                            case 13:
                                _13 = _16.sent();
                                _16.label = 14;
                            case 14:
                                // Get the injected answer if there is one or prompt the user
                                answer = _13;
                                _14 = answers;
                                _15 = name;
                                return [4 /*yield*/, getFormattedAnswer(question, answer, true)];
                            case 15:
                                _14[_15] = answer = _16.sent();
                                return [4 /*yield*/, onSubmit(question, answer, answers)];
                            case 16:
                                quit = _16.sent();
                                return [3 /*break*/, 19];
                            case 17:
                                err_4 = _16.sent();
                                return [4 /*yield*/, onCancel(question, answers)];
                            case 18:
                                quit = !(_16.sent());
                                return [3 /*break*/, 19];
                            case 19:
                                if (quit)
                                    return [2 /*return*/, answers];
                                _16.label = 20;
                            case 20:
                                _5++;
                                return [3 /*break*/, 1];
                            case 21: return [2 /*return*/, answers];
                        }
                    });
                });
            }
            function getInjectedAnswer(injected, deafultValue) {
                var answer = injected.shift();
                if (answer instanceof Error) {
                    throw answer;
                }
                return (answer === undefined) ? deafultValue : answer;
            }
            function inject(answers) {
                prompt._injected = (prompt._injected || []).concat(answers);
            }
            function override(answers) {
                prompt._override = Object.assign({}, answers);
            }
            module.exports = Object.assign(prompt, { prompt: prompt, prompts: prompts, inject: inject, override: override });
            /***/ 
        }),
        /***/ 1558: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var $ = exports;
            var el = __nccwpck_require__(9098);
            var noop = function (v) { return v; };
            function toPrompt(type, args, opts) {
                if (opts === void 0) { opts = {}; }
                return new Promise(function (res, rej) {
                    var p = new el[type](args);
                    var onAbort = opts.onAbort || noop;
                    var onSubmit = opts.onSubmit || noop;
                    var onExit = opts.onExit || noop;
                    p.on('state', args.onState || noop);
                    p.on('submit', function (x) { return res(onSubmit(x)); });
                    p.on('exit', function (x) { return res(onExit(x)); });
                    p.on('abort', function (x) { return rej(onAbort(x)); });
                });
            }
            /**
             * Text prompt
             * @param {string} args.message Prompt message to display
             * @param {string} [args.initial] Default string value
             * @param {string} [args.style="default"] Render style ('default', 'password', 'invisible')
             * @param {function} [args.onState] On state change callback
             * @param {function} [args.validate] Function to validate user input
             * @param {Stream} [args.stdin] The Readable stream to listen to
             * @param {Stream} [args.stdout] The Writable stream to write readline data to
             * @returns {Promise} Promise with user input
             */
            $.text = function (args) { return toPrompt('TextPrompt', args); };
            /**
             * Password prompt with masked input
             * @param {string} args.message Prompt message to display
             * @param {string} [args.initial] Default string value
             * @param {function} [args.onState] On state change callback
             * @param {function} [args.validate] Function to validate user input
             * @param {Stream} [args.stdin] The Readable stream to listen to
             * @param {Stream} [args.stdout] The Writable stream to write readline data to
             * @returns {Promise} Promise with user input
             */
            $.password = function (args) {
                args.style = 'password';
                return $.text(args);
            };
            /**
             * Prompt where input is invisible, like sudo
             * @param {string} args.message Prompt message to display
             * @param {string} [args.initial] Default string value
             * @param {function} [args.onState] On state change callback
             * @param {function} [args.validate] Function to validate user input
             * @param {Stream} [args.stdin] The Readable stream to listen to
             * @param {Stream} [args.stdout] The Writable stream to write readline data to
             * @returns {Promise} Promise with user input
             */
            $.invisible = function (args) {
                args.style = 'invisible';
                return $.text(args);
            };
            /**
             * Number prompt
             * @param {string} args.message Prompt message to display
             * @param {number} args.initial Default number value
             * @param {function} [args.onState] On state change callback
             * @param {number} [args.max] Max value
             * @param {number} [args.min] Min value
             * @param {string} [args.style="default"] Render style ('default', 'password', 'invisible')
             * @param {Boolean} [opts.float=false] Parse input as floats
             * @param {Number} [opts.round=2] Round floats to x decimals
             * @param {Number} [opts.increment=1] Number to increment by when using arrow-keys
             * @param {function} [args.validate] Function to validate user input
             * @param {Stream} [args.stdin] The Readable stream to listen to
             * @param {Stream} [args.stdout] The Writable stream to write readline data to
             * @returns {Promise} Promise with user input
             */
            $.number = function (args) { return toPrompt('NumberPrompt', args); };
            /**
             * Date prompt
             * @param {string} args.message Prompt message to display
             * @param {number} args.initial Default number value
             * @param {function} [args.onState] On state change callback
             * @param {number} [args.max] Max value
             * @param {number} [args.min] Min value
             * @param {string} [args.style="default"] Render style ('default', 'password', 'invisible')
             * @param {Boolean} [opts.float=false] Parse input as floats
             * @param {Number} [opts.round=2] Round floats to x decimals
             * @param {Number} [opts.increment=1] Number to increment by when using arrow-keys
             * @param {function} [args.validate] Function to validate user input
             * @param {Stream} [args.stdin] The Readable stream to listen to
             * @param {Stream} [args.stdout] The Writable stream to write readline data to
             * @returns {Promise} Promise with user input
             */
            $.date = function (args) { return toPrompt('DatePrompt', args); };
            /**
             * Classic yes/no prompt
             * @param {string} args.message Prompt message to display
             * @param {boolean} [args.initial=false] Default value
             * @param {function} [args.onState] On state change callback
             * @param {Stream} [args.stdin] The Readable stream to listen to
             * @param {Stream} [args.stdout] The Writable stream to write readline data to
             * @returns {Promise} Promise with user input
             */
            $.confirm = function (args) { return toPrompt('ConfirmPrompt', args); };
            /**
             * List prompt, split intput string by `seperator`
             * @param {string} args.message Prompt message to display
             * @param {string} [args.initial] Default string value
             * @param {string} [args.style="default"] Render style ('default', 'password', 'invisible')
             * @param {string} [args.separator] String separator
             * @param {function} [args.onState] On state change callback
             * @param {Stream} [args.stdin] The Readable stream to listen to
             * @param {Stream} [args.stdout] The Writable stream to write readline data to
             * @returns {Promise} Promise with user input, in form of an `Array`
             */
            $.list = function (args) {
                var sep = args.separator || ',';
                return toPrompt('TextPrompt', args, {
                    onSubmit: function (str) { return str.split(sep).map(function (s) { return s.trim(); }); }
                });
            };
            /**
             * Toggle/switch prompt
             * @param {string} args.message Prompt message to display
             * @param {boolean} [args.initial=false] Default value
             * @param {string} [args.active="on"] Text for `active` state
             * @param {string} [args.inactive="off"] Text for `inactive` state
             * @param {function} [args.onState] On state change callback
             * @param {Stream} [args.stdin] The Readable stream to listen to
             * @param {Stream} [args.stdout] The Writable stream to write readline data to
             * @returns {Promise} Promise with user input
             */
            $.toggle = function (args) { return toPrompt('TogglePrompt', args); };
            /**
             * Interactive select prompt
             * @param {string} args.message Prompt message to display
             * @param {Array} args.choices Array of choices objects `[{ title, value }, ...]`
             * @param {number} [args.initial] Index of default value
             * @param {String} [args.hint] Hint to display
             * @param {function} [args.onState] On state change callback
             * @param {Stream} [args.stdin] The Readable stream to listen to
             * @param {Stream} [args.stdout] The Writable stream to write readline data to
             * @returns {Promise} Promise with user input
             */
            $.select = function (args) { return toPrompt('SelectPrompt', args); };
            /**
             * Interactive multi-select / autocompleteMultiselect prompt
             * @param {string} args.message Prompt message to display
             * @param {Array} args.choices Array of choices objects `[{ title, value, [selected] }, ...]`
             * @param {number} [args.max] Max select
             * @param {string} [args.hint] Hint to display user
             * @param {Number} [args.cursor=0] Cursor start position
             * @param {function} [args.onState] On state change callback
             * @param {Stream} [args.stdin] The Readable stream to listen to
             * @param {Stream} [args.stdout] The Writable stream to write readline data to
             * @returns {Promise} Promise with user input
             */
            $.multiselect = function (args) {
                args.choices = [].concat(args.choices || []);
                var toSelected = function (items) { return items.filter(function (item) { return item.selected; }).map(function (item) { return item.value; }); };
                return toPrompt('MultiselectPrompt', args, {
                    onAbort: toSelected,
                    onSubmit: toSelected
                });
            };
            $.autocompleteMultiselect = function (args) {
                args.choices = [].concat(args.choices || []);
                var toSelected = function (items) { return items.filter(function (item) { return item.selected; }).map(function (item) { return item.value; }); };
                return toPrompt('AutocompleteMultiselectPrompt', args, {
                    onAbort: toSelected,
                    onSubmit: toSelected
                });
            };
            var byTitle = function (input, choices) { return Promise.resolve(choices.filter(function (item) { return item.title.slice(0, input.length).toLowerCase() === input.toLowerCase(); })); };
            /**
             * Interactive auto-complete prompt
             * @param {string} args.message Prompt message to display
             * @param {Array} args.choices Array of auto-complete choices objects `[{ title, value }, ...]`
             * @param {Function} [args.suggest] Function to filter results based on user input. Defaults to sort by `title`
             * @param {number} [args.limit=10] Max number of results to show
             * @param {string} [args.style="default"] Render style ('default', 'password', 'invisible')
             * @param {String} [args.initial] Index of the default value
             * @param {boolean} [opts.clearFirst] The first ESCAPE keypress will clear the input
             * @param {String} [args.fallback] Fallback message - defaults to initial value
             * @param {function} [args.onState] On state change callback
             * @param {Stream} [args.stdin] The Readable stream to listen to
             * @param {Stream} [args.stdout] The Writable stream to write readline data to
             * @returns {Promise} Promise with user input
             */
            $.autocomplete = function (args) {
                args.suggest = args.suggest || byTitle;
                args.choices = [].concat(args.choices || []);
                return toPrompt('AutocompletePrompt', args);
            };
            /***/ 
        }),
        /***/ 2337: 
        /***/ (function (module) {
            "use strict";
            module.exports = function (key, isSelect) {
                if (key.meta && key.name !== 'escape')
                    return;
                if (key.ctrl) {
                    if (key.name === 'a')
                        return 'first';
                    if (key.name === 'c')
                        return 'abort';
                    if (key.name === 'd')
                        return 'abort';
                    if (key.name === 'e')
                        return 'last';
                    if (key.name === 'g')
                        return 'reset';
                }
                if (isSelect) {
                    if (key.name === 'j')
                        return 'down';
                    if (key.name === 'k')
                        return 'up';
                }
                if (key.name === 'return')
                    return 'submit';
                if (key.name === 'enter')
                    return 'submit'; // ctrl + J
                if (key.name === 'backspace')
                    return 'delete';
                if (key.name === 'delete')
                    return 'deleteForward';
                if (key.name === 'abort')
                    return 'abort';
                if (key.name === 'escape')
                    return 'exit';
                if (key.name === 'tab')
                    return 'next';
                if (key.name === 'pagedown')
                    return 'nextPage';
                if (key.name === 'pageup')
                    return 'prevPage';
                // TODO create home() in prompt types (e.g. TextPrompt)
                if (key.name === 'home')
                    return 'home';
                // TODO create end() in prompt types (e.g. TextPrompt)
                if (key.name === 'end')
                    return 'end';
                if (key.name === 'up')
                    return 'up';
                if (key.name === 'down')
                    return 'down';
                if (key.name === 'right')
                    return 'right';
                if (key.name === 'left')
                    return 'left';
                return false;
            };
            /***/ 
        }),
        /***/ 4679: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var strip = __nccwpck_require__(6439);
            var _1 = __nccwpck_require__(9571), erase = _1.erase, cursor = _1.cursor;
            var width = function (str) { return __spreadArray([], strip(str), true).length; };
            /**
             * @param {string} prompt
             * @param {number} perLine
             */
            module.exports = function (prompt, perLine) {
                if (!perLine)
                    return erase.line + cursor.to(0);
                var rows = 0;
                var lines = prompt.split(/\r?\n/);
                for (var _1 = 0, lines_1 = lines; _1 < lines_1.length; _1++) {
                    var line = lines_1[_1];
                    rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / perLine);
                }
                return erase.lines(rows);
            };
            /***/ 
        }),
        /***/ 6740: 
        /***/ (function (module) {
            "use strict";
            /**
             * Determine what entries should be displayed on the screen, based on the
             * currently selected index and the maximum visible. Used in list-based
             * prompts like `select` and `multiselect`.
             *
             * @param {number} cursor the currently selected entry
             * @param {number} total the total entries available to display
             * @param {number} [maxVisible] the number of entries that can be displayed
             */
            module.exports = function (cursor, total, maxVisible) {
                maxVisible = maxVisible || total;
                var startIndex = Math.min(total - maxVisible, cursor - Math.floor(maxVisible / 2));
                if (startIndex < 0)
                    startIndex = 0;
                var endIndex = Math.min(startIndex + maxVisible, total);
                return { startIndex: startIndex, endIndex: endIndex };
            };
            /***/ 
        }),
        /***/ 1918: 
        /***/ (function (module) {
            "use strict";
            var main = {
                arrowUp: '',
                arrowDown: '',
                arrowLeft: '',
                arrowRight: '',
                radioOn: '',
                radioOff: '',
                tick: '',
                cross: '',
                ellipsis: '',
                pointerSmall: '',
                line: '',
                pointer: ''
            };
            var win = {
                arrowUp: main.arrowUp,
                arrowDown: main.arrowDown,
                arrowLeft: main.arrowLeft,
                arrowRight: main.arrowRight,
                radioOn: '(*)',
                radioOff: '( )',
                tick: '',
                cross: '',
                ellipsis: '...',
                pointerSmall: '',
                line: '',
                pointer: '>'
            };
            var figures = process.platform === 'win32' ? win : main;
            module.exports = figures;
            /***/ 
        }),
        /***/ 9501: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            module.exports = {
                action: __nccwpck_require__(2337),
                clear: __nccwpck_require__(4679),
                style: __nccwpck_require__(5290),
                strip: __nccwpck_require__(6439),
                figures: __nccwpck_require__(1918),
                lines: __nccwpck_require__(409),
                wrap: __nccwpck_require__(8861),
                entriesToDisplay: __nccwpck_require__(6740)
            };
            /***/ 
        }),
        /***/ 409: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var strip = __nccwpck_require__(6439);
            /**
             * @param {string} msg
             * @param {number} perLine
             */
            module.exports = function (msg, perLine) {
                var lines = String(strip(msg) || '').split(/\r?\n/);
                if (!perLine)
                    return lines.length;
                return lines.map(function (l) { return Math.ceil(l.length / perLine); })
                    .reduce(function (a, b) { return a + b; });
            };
            /***/ 
        }),
        /***/ 6439: 
        /***/ (function (module) {
            "use strict";
            module.exports = function (str) {
                var pattern = [
                    '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
                    '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))'
                ].join('|');
                var RGX = new RegExp(pattern, 'g');
                return typeof str === 'string' ? str.replace(RGX, '') : str;
            };
            /***/ 
        }),
        /***/ 5290: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var c = __nccwpck_require__(9407);
            var figures = __nccwpck_require__(1918);
            // rendering user input.
            var styles = Object.freeze({
                password: { scale: 1, render: function (input) { return '*'.repeat(input.length); } },
                emoji: { scale: 2, render: function (input) { return ''.repeat(input.length); } },
                invisible: { scale: 0, render: function (input) { return ''; } },
                "default": { scale: 1, render: function (input) { return "".concat(input); } }
            });
            var render = function (type) { return styles[type] || styles["default"]; };
            // icon to signalize a prompt.
            var symbols = Object.freeze({
                aborted: c.red(figures.cross),
                done: c.green(figures.tick),
                exited: c.yellow(figures.cross),
                "default": c.cyan('?')
            });
            var symbol = function (done, aborted, exited) {
                return aborted ? symbols.aborted : exited ? symbols.exited : done ? symbols.done : symbols["default"];
            };
            // between the question and the user's input.
            var delimiter = function (completing) {
                return c.gray(completing ? figures.ellipsis : figures.pointerSmall);
            };
            var item = function (expandable, expanded) {
                return c.gray(expandable ? (expanded ? figures.pointerSmall : '+') : figures.line);
            };
            module.exports = {
                styles: styles,
                render: render,
                symbols: symbols,
                symbol: symbol,
                delimiter: delimiter,
                item: item
            };
            /***/ 
        }),
        /***/ 8861: 
        /***/ (function (module) {
            "use strict";
            /**
             * @param {string} msg The message to wrap
             * @param {object} opts
             * @param {number|string} [opts.margin] Left margin
             * @param {number} opts.width Maximum characters per line including the margin
             */
            module.exports = function (msg, opts) {
                if (opts === void 0) { opts = {}; }
                var tab = Number.isSafeInteger(parseInt(opts.margin))
                    ? new Array(parseInt(opts.margin)).fill(' ').join('')
                    : (opts.margin || '');
                var width = opts.width;
                return (msg || '').split(/\r?\n/g)
                    .map(function (line) { return line
                    .split(/\s+/g)
                    .reduce(function (arr, w) {
                    if (w.length + tab.length >= width || arr[arr.length - 1].length + w.length + 1 < width)
                        arr[arr.length - 1] += " ".concat(w);
                    else
                        arr.push("".concat(tab).concat(w));
                    return arr;
                }, [tab])
                    .join('\n'); })
                    .join('\n');
            };
            /***/ 
        }),
        /***/ 9407: 
        /***/ (function (module) {
            "use strict";
            var _1 = process.env, FORCE_COLOR = _1.FORCE_COLOR, NODE_DISABLE_COLORS = _1.NODE_DISABLE_COLORS, TERM = _1.TERM;
            var $ = {
                enabled: !NODE_DISABLE_COLORS && TERM !== 'dumb' && FORCE_COLOR !== '0',
                // modifiers
                reset: init(0, 0),
                bold: init(1, 22),
                dim: init(2, 22),
                italic: init(3, 23),
                underline: init(4, 24),
                inverse: init(7, 27),
                hidden: init(8, 28),
                strikethrough: init(9, 29),
                // colors
                black: init(30, 39),
                red: init(31, 39),
                green: init(32, 39),
                yellow: init(33, 39),
                blue: init(34, 39),
                magenta: init(35, 39),
                cyan: init(36, 39),
                white: init(37, 39),
                gray: init(90, 39),
                grey: init(90, 39),
                // background colors
                bgBlack: init(40, 49),
                bgRed: init(41, 49),
                bgGreen: init(42, 49),
                bgYellow: init(43, 49),
                bgBlue: init(44, 49),
                bgMagenta: init(45, 49),
                bgCyan: init(46, 49),
                bgWhite: init(47, 49)
            };
            function run(arr, str) {
                var i = 0, tmp, beg = '', end = '';
                for (; i < arr.length; i++) {
                    tmp = arr[i];
                    beg += tmp.open;
                    end += tmp.close;
                    if (str.includes(tmp.close)) {
                        str = str.replace(tmp.rgx, tmp.close + tmp.open);
                    }
                }
                return beg + str + end;
            }
            function chain(has, keys) {
                var ctx = { has: has, keys: keys };
                ctx.reset = $.reset.bind(ctx);
                ctx.bold = $.bold.bind(ctx);
                ctx.dim = $.dim.bind(ctx);
                ctx.italic = $.italic.bind(ctx);
                ctx.underline = $.underline.bind(ctx);
                ctx.inverse = $.inverse.bind(ctx);
                ctx.hidden = $.hidden.bind(ctx);
                ctx.strikethrough = $.strikethrough.bind(ctx);
                ctx.black = $.black.bind(ctx);
                ctx.red = $.red.bind(ctx);
                ctx.green = $.green.bind(ctx);
                ctx.yellow = $.yellow.bind(ctx);
                ctx.blue = $.blue.bind(ctx);
                ctx.magenta = $.magenta.bind(ctx);
                ctx.cyan = $.cyan.bind(ctx);
                ctx.white = $.white.bind(ctx);
                ctx.gray = $.gray.bind(ctx);
                ctx.grey = $.grey.bind(ctx);
                ctx.bgBlack = $.bgBlack.bind(ctx);
                ctx.bgRed = $.bgRed.bind(ctx);
                ctx.bgGreen = $.bgGreen.bind(ctx);
                ctx.bgYellow = $.bgYellow.bind(ctx);
                ctx.bgBlue = $.bgBlue.bind(ctx);
                ctx.bgMagenta = $.bgMagenta.bind(ctx);
                ctx.bgCyan = $.bgCyan.bind(ctx);
                ctx.bgWhite = $.bgWhite.bind(ctx);
                return ctx;
            }
            function init(open, close) {
                var blk = {
                    open: "\u001B[".concat(open, "m"),
                    close: "\u001B[".concat(close, "m"),
                    rgx: new RegExp("\\x1b\\[".concat(close, "m"), 'g')
                };
                return function (txt) {
                    if (this !== void 0 && this.has !== void 0) {
                        this.has.includes(open) || (this.has.push(open), this.keys.push(blk));
                        return txt === void 0 ? this : $.enabled ? run(this.keys, txt + '') : txt + '';
                    }
                    return txt === void 0 ? chain([open], [blk]) : $.enabled ? run([blk], txt + '') : txt + '';
                };
            }
            module.exports = $;
            /***/ 
        }),
        /***/ 1532: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var ANY = Symbol('SemVer ANY');
            // hoisted class for cyclic dependency
            var Comparator = /** @class */ (function () {
                function Comparator(comp, options) {
                    options = parseOptions(options);
                    if (comp instanceof Comparator) {
                        if (comp.loose === !!options.loose) {
                            return comp;
                        }
                        else {
                            comp = comp.value;
                        }
                    }
                    comp = comp.trim().split(/\s+/).join(' ');
                    debug('comparator', comp, options);
                    this.options = options;
                    this.loose = !!options.loose;
                    this.parse(comp);
                    if (this.semver === ANY) {
                        this.value = '';
                    }
                    else {
                        this.value = this.operator + this.semver.version;
                    }
                    debug('comp', this);
                }
                Object.defineProperty(Comparator, "ANY", {
                    get: function () {
                        return ANY;
                    },
                    enumerable: false,
                    configurable: true
                });
                Comparator.prototype.parse = function (comp) {
                    var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
                    var m = comp.match(r);
                    if (!m) {
                        throw new TypeError("Invalid comparator: ".concat(comp));
                    }
                    this.operator = m[1] !== undefined ? m[1] : '';
                    if (this.operator === '=') {
                        this.operator = '';
                    }
                    // if it literally is just '>' or '' then allow anything.
                    if (!m[2]) {
                        this.semver = ANY;
                    }
                    else {
                        this.semver = new SemVer(m[2], this.options.loose);
                    }
                };
                Comparator.prototype.toString = function () {
                    return this.value;
                };
                Comparator.prototype.test = function (version) {
                    debug('Comparator.test', version, this.options.loose);
                    if (this.semver === ANY || version === ANY) {
                        return true;
                    }
                    if (typeof version === 'string') {
                        try {
                            version = new SemVer(version, this.options);
                        }
                        catch (er) {
                            return false;
                        }
                    }
                    return cmp(version, this.operator, this.semver, this.options);
                };
                Comparator.prototype.intersects = function (comp, options) {
                    if (!(comp instanceof Comparator)) {
                        throw new TypeError('a Comparator is required');
                    }
                    if (this.operator === '') {
                        if (this.value === '') {
                            return true;
                        }
                        return new Range(comp.value, options).test(this.value);
                    }
                    else if (comp.operator === '') {
                        if (comp.value === '') {
                            return true;
                        }
                        return new Range(this.value, options).test(comp.semver);
                    }
                    options = parseOptions(options);
                    // Special cases where nothing can possibly be lower
                    if (options.includePrerelease &&
                        (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
                        return false;
                    }
                    if (!options.includePrerelease &&
                        (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
                        return false;
                    }
                    // Same direction increasing (> or >=)
                    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
                        return true;
                    }
                    // Same direction decreasing (< or <=)
                    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
                        return true;
                    }
                    // same SemVer and both sides are inclusive (<= or >=)
                    if ((this.semver.version === comp.semver.version) &&
                        this.operator.includes('=') && comp.operator.includes('=')) {
                        return true;
                    }
                    // opposite directions less than
                    if (cmp(this.semver, '<', comp.semver, options) &&
                        this.operator.startsWith('>') && comp.operator.startsWith('<')) {
                        return true;
                    }
                    // opposite directions greater than
                    if (cmp(this.semver, '>', comp.semver, options) &&
                        this.operator.startsWith('<') && comp.operator.startsWith('>')) {
                        return true;
                    }
                    return false;
                };
                return Comparator;
            }());
            module.exports = Comparator;
            var parseOptions = __nccwpck_require__(785);
            var _1 = __nccwpck_require__(9523), re = _1.safeRe, t = _1.t;
            var cmp = __nccwpck_require__(5098);
            var debug = __nccwpck_require__(427);
            var SemVer = __nccwpck_require__(8088);
            var Range = __nccwpck_require__(9828);
            /***/ 
        }),
        /***/ 9828: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            // hoisted class for cyclic dependency
            var Range = /** @class */ (function () {
                function Range(range, options) {
                    var _this_1 = this;
                    options = parseOptions(options);
                    if (range instanceof Range) {
                        if (range.loose === !!options.loose &&
                            range.includePrerelease === !!options.includePrerelease) {
                            return range;
                        }
                        else {
                            return new Range(range.raw, options);
                        }
                    }
                    if (range instanceof Comparator) {
                        // just put it in the set and return
                        this.raw = range.value;
                        this.set = [[range]];
                        this.format();
                        return this;
                    }
                    this.options = options;
                    this.loose = !!options.loose;
                    this.includePrerelease = !!options.includePrerelease;
                    // First reduce all whitespace as much as possible so we do not have to rely
                    // on potentially slow regexes like \s*. This is then stored and used for
                    // future error messages as well.
                    this.raw = range
                        .trim()
                        .split(/\s+/)
                        .join(' ');
                    // First, split on ||
                    this.set = this.raw
                        .split('||')
                        // map the range to a 2d array of comparators
                        .map(function (r) { return _this_1.parseRange(r.trim()); })
                        // throw out any comparator lists that are empty
                        // this generally means that it was not a valid range, which is allowed
                        // in loose mode, but will still throw if the WHOLE range is invalid.
                        .filter(function (c) { return c.length; });
                    if (!this.set.length) {
                        throw new TypeError("Invalid SemVer Range: ".concat(this.raw));
                    }
                    // if we have any that are not the null set, throw out null sets.
                    if (this.set.length > 1) {
                        // keep the first one, in case they're all null sets
                        var first = this.set[0];
                        this.set = this.set.filter(function (c) { return !isNullSet(c[0]); });
                        if (this.set.length === 0) {
                            this.set = [first];
                        }
                        else if (this.set.length > 1) {
                            // if we have any that are *, then the range is just *
                            for (var _1 = 0, _2 = this.set; _1 < _2.length; _1++) {
                                var c = _2[_1];
                                if (c.length === 1 && isAny(c[0])) {
                                    this.set = [c];
                                    break;
                                }
                            }
                        }
                    }
                    this.format();
                }
                Range.prototype.format = function () {
                    this.range = this.set
                        .map(function (comps) { return comps.join(' ').trim(); })
                        .join('||')
                        .trim();
                    return this.range;
                };
                Range.prototype.toString = function () {
                    return this.range;
                };
                Range.prototype.parseRange = function (range) {
                    var _this_1 = this;
                    // memoize range parsing for performance.
                    // this is a very hot path, and fully deterministic.
                    var memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |
                        (this.options.loose && FLAG_LOOSE);
                    var memoKey = memoOpts + ':' + range;
                    var cached = cache.get(memoKey);
                    if (cached) {
                        return cached;
                    }
                    var loose = this.options.loose;
                    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
                    var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
                    range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
                    debug('hyphen replace', range);
                    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
                    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
                    debug('comparator trim', range);
                    // `~ 1.2.3` => `~1.2.3`
                    range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
                    debug('tilde trim', range);
                    // `^ 1.2.3` => `^1.2.3`
                    range = range.replace(re[t.CARETTRIM], caretTrimReplace);
                    debug('caret trim', range);
                    // At this point, the range is completely trimmed and
                    // ready to be split into comparators.
                    var rangeList = range
                        .split(' ')
                        .map(function (comp) { return parseComparator(comp, _this_1.options); })
                        .join(' ')
                        .split(/\s+/)
                        // >=0.0.0 is equivalent to *
                        .map(function (comp) { return replaceGTE0(comp, _this_1.options); });
                    if (loose) {
                        // in loose mode, throw out any that are not valid comparators
                        rangeList = rangeList.filter(function (comp) {
                            debug('loose invalid filter', comp, _this_1.options);
                            return !!comp.match(re[t.COMPARATORLOOSE]);
                        });
                    }
                    debug('range list', rangeList);
                    // if any comparators are the null set, then replace with JUST null set
                    // if more than one comparator, remove any * comparators
                    // also, don't include the same comparator more than once
                    var rangeMap = new Map();
                    var comparators = rangeList.map(function (comp) { return new Comparator(comp, _this_1.options); });
                    for (var _1 = 0, comparators_1 = comparators; _1 < comparators_1.length; _1++) {
                        var comp = comparators_1[_1];
                        if (isNullSet(comp)) {
                            return [comp];
                        }
                        rangeMap.set(comp.value, comp);
                    }
                    if (rangeMap.size > 1 && rangeMap.has('')) {
                        rangeMap["delete"]('');
                    }
                    var result = __spreadArray([], rangeMap.values(), true);
                    cache.set(memoKey, result);
                    return result;
                };
                Range.prototype.intersects = function (range, options) {
                    if (!(range instanceof Range)) {
                        throw new TypeError('a Range is required');
                    }
                    return this.set.some(function (thisComparators) {
                        return (isSatisfiable(thisComparators, options) &&
                            range.set.some(function (rangeComparators) {
                                return (isSatisfiable(rangeComparators, options) &&
                                    thisComparators.every(function (thisComparator) {
                                        return rangeComparators.every(function (rangeComparator) {
                                            return thisComparator.intersects(rangeComparator, options);
                                        });
                                    }));
                            }));
                    });
                };
                // if ANY of the sets match ALL of its comparators, then pass
                Range.prototype.test = function (version) {
                    if (!version) {
                        return false;
                    }
                    if (typeof version === 'string') {
                        try {
                            version = new SemVer(version, this.options);
                        }
                        catch (er) {
                            return false;
                        }
                    }
                    for (var i = 0; i < this.set.length; i++) {
                        if (testSet(this.set[i], version, this.options)) {
                            return true;
                        }
                    }
                    return false;
                };
                return Range;
            }());
            module.exports = Range;
            var LRU = __nccwpck_require__(7129);
            var cache = new LRU({ max: 1000 });
            var parseOptions = __nccwpck_require__(785);
            var Comparator = __nccwpck_require__(1532);
            var debug = __nccwpck_require__(427);
            var SemVer = __nccwpck_require__(8088);
            var _1 = __nccwpck_require__(9523), re = _1.safeRe, t = _1.t, comparatorTrimReplace = _1.comparatorTrimReplace, tildeTrimReplace = _1.tildeTrimReplace, caretTrimReplace = _1.caretTrimReplace;
            var _2 = __nccwpck_require__(2293), FLAG_INCLUDE_PRERELEASE = _2.FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE = _2.FLAG_LOOSE;
            var isNullSet = function (c) { return c.value === '<0.0.0-0'; };
            var isAny = function (c) { return c.value === ''; };
            // take a set of comparators and determine whether there
            // exists a version which can satisfy it
            var isSatisfiable = function (comparators, options) {
                var result = true;
                var remainingComparators = comparators.slice();
                var testComparator = remainingComparators.pop();
                while (result && remainingComparators.length) {
                    result = remainingComparators.every(function (otherComparator) {
                        return testComparator.intersects(otherComparator, options);
                    });
                    testComparator = remainingComparators.pop();
                }
                return result;
            };
            // comprised of xranges, tildes, stars, and gtlt's at this point.
            // already replaced the hyphen ranges
            // turn into a set of JUST comparators.
            var parseComparator = function (comp, options) {
                debug('comp', comp, options);
                comp = replaceCarets(comp, options);
                debug('caret', comp);
                comp = replaceTildes(comp, options);
                debug('tildes', comp);
                comp = replaceXRanges(comp, options);
                debug('xrange', comp);
                comp = replaceStars(comp, options);
                debug('stars', comp);
                return comp;
            };
            var isX = function (id) { return !id || id.toLowerCase() === 'x' || id === '*'; };
            // ~, ~> --> * (any, kinda silly)
            // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
            // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
            // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
            // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
            // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
            // ~0.0.1 --> >=0.0.1 <0.1.0-0
            var replaceTildes = function (comp, options) {
                return comp
                    .trim()
                    .split(/\s+/)
                    .map(function (c) { return replaceTilde(c, options); })
                    .join(' ');
            };
            var replaceTilde = function (comp, options) {
                var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
                return comp.replace(r, function (_, M, m, p, pr) {
                    debug('tilde', comp, _, M, m, p, pr);
                    var ret;
                    if (isX(M)) {
                        ret = '';
                    }
                    else if (isX(m)) {
                        ret = ">=".concat(M, ".0.0 <").concat(+M + 1, ".0.0-0");
                    }
                    else if (isX(p)) {
                        // ~1.2 == >=1.2.0 <1.3.0-0
                        ret = ">=".concat(M, ".").concat(m, ".0 <").concat(M, ".").concat(+m + 1, ".0-0");
                    }
                    else if (pr) {
                        debug('replaceTilde pr', pr);
                        ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
                    }
                    else {
                        // ~1.2.3 == >=1.2.3 <1.3.0-0
                        ret = ">=".concat(M, ".").concat(m, ".").concat(p, " <").concat(M, ".").concat(+m + 1, ".0-0");
                    }
                    debug('tilde return', ret);
                    return ret;
                });
            };
            // ^ --> * (any, kinda silly)
            // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
            // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
            // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
            // ^1.2.3 --> >=1.2.3 <2.0.0-0
            // ^1.2.0 --> >=1.2.0 <2.0.0-0
            // ^0.0.1 --> >=0.0.1 <0.0.2-0
            // ^0.1.0 --> >=0.1.0 <0.2.0-0
            var replaceCarets = function (comp, options) {
                return comp
                    .trim()
                    .split(/\s+/)
                    .map(function (c) { return replaceCaret(c, options); })
                    .join(' ');
            };
            var replaceCaret = function (comp, options) {
                debug('caret', comp, options);
                var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
                var z = options.includePrerelease ? '-0' : '';
                return comp.replace(r, function (_, M, m, p, pr) {
                    debug('caret', comp, _, M, m, p, pr);
                    var ret;
                    if (isX(M)) {
                        ret = '';
                    }
                    else if (isX(m)) {
                        ret = ">=".concat(M, ".0.0").concat(z, " <").concat(+M + 1, ".0.0-0");
                    }
                    else if (isX(p)) {
                        if (M === '0') {
                            ret = ">=".concat(M, ".").concat(m, ".0").concat(z, " <").concat(M, ".").concat(+m + 1, ".0-0");
                        }
                        else {
                            ret = ">=".concat(M, ".").concat(m, ".0").concat(z, " <").concat(+M + 1, ".0.0-0");
                        }
                    }
                    else if (pr) {
                        debug('replaceCaret pr', pr);
                        if (M === '0') {
                            if (m === '0') {
                                ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(m, ".").concat(+p + 1, "-0");
                            }
                            else {
                                ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
                            }
                        }
                        else {
                            ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(+M + 1, ".0.0-0");
                        }
                    }
                    else {
                        debug('no pr');
                        if (M === '0') {
                            if (m === '0') {
                                ret = ">=".concat(M, ".").concat(m, ".").concat(p).concat(z, " <").concat(M, ".").concat(m, ".").concat(+p + 1, "-0");
                            }
                            else {
                                ret = ">=".concat(M, ".").concat(m, ".").concat(p).concat(z, " <").concat(M, ".").concat(+m + 1, ".0-0");
                            }
                        }
                        else {
                            ret = ">=".concat(M, ".").concat(m, ".").concat(p, " <").concat(+M + 1, ".0.0-0");
                        }
                    }
                    debug('caret return', ret);
                    return ret;
                });
            };
            var replaceXRanges = function (comp, options) {
                debug('replaceXRanges', comp, options);
                return comp
                    .split(/\s+/)
                    .map(function (c) { return replaceXRange(c, options); })
                    .join(' ');
            };
            var replaceXRange = function (comp, options) {
                comp = comp.trim();
                var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
                return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
                    debug('xRange', comp, ret, gtlt, M, m, p, pr);
                    var xM = isX(M);
                    var xm = xM || isX(m);
                    var xp = xm || isX(p);
                    var anyX = xp;
                    if (gtlt === '=' && anyX) {
                        gtlt = '';
                    }
                    // if we're including prereleases in the match, then we need
                    // to fix this to -0, the lowest possible prerelease value
                    pr = options.includePrerelease ? '-0' : '';
                    if (xM) {
                        if (gtlt === '>' || gtlt === '<') {
                            // nothing is allowed
                            ret = '<0.0.0-0';
                        }
                        else {
                            // nothing is forbidden
                            ret = '*';
                        }
                    }
                    else if (gtlt && anyX) {
                        // we know patch is an x, because we have any x at all.
                        // replace X with 0
                        if (xm) {
                            m = 0;
                        }
                        p = 0;
                        if (gtlt === '>') {
                            // >1 => >=2.0.0
                            // >1.2 => >=1.3.0
                            gtlt = '>=';
                            if (xm) {
                                M = +M + 1;
                                m = 0;
                                p = 0;
                            }
                            else {
                                m = +m + 1;
                                p = 0;
                            }
                        }
                        else if (gtlt === '<=') {
                            // <=0.7.x is actually <0.8.0, since any 0.7.x should
                            // pass.  Similarly, <=7.x is actually <8.0.0, etc.
                            gtlt = '<';
                            if (xm) {
                                M = +M + 1;
                            }
                            else {
                                m = +m + 1;
                            }
                        }
                        if (gtlt === '<') {
                            pr = '-0';
                        }
                        ret = "".concat(gtlt + M, ".").concat(m, ".").concat(p).concat(pr);
                    }
                    else if (xm) {
                        ret = ">=".concat(M, ".0.0").concat(pr, " <").concat(+M + 1, ".0.0-0");
                    }
                    else if (xp) {
                        ret = ">=".concat(M, ".").concat(m, ".0").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
                    }
                    debug('xRange return', ret);
                    return ret;
                });
            };
            // Because * is AND-ed with everything else in the comparator,
            // and '' means "any version", just remove the *s entirely.
            var replaceStars = function (comp, options) {
                debug('replaceStars', comp, options);
                // Looseness is ignored here.  star is always as loose as it gets!
                return comp
                    .trim()
                    .replace(re[t.STAR], '');
            };
            var replaceGTE0 = function (comp, options) {
                debug('replaceGTE0', comp, options);
                return comp
                    .trim()
                    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '');
            };
            // This function is passed to string.replace(re[t.HYPHENRANGE])
            // M, m, patch, prerelease, build
            // 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
            // 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
            // 1.2 - 3.4 => >=1.2.0 <3.5.0-0
            var hyphenReplace = function (incPr) { return function ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
                if (isX(fM)) {
                    from = '';
                }
                else if (isX(fm)) {
                    from = ">=".concat(fM, ".0.0").concat(incPr ? '-0' : '');
                }
                else if (isX(fp)) {
                    from = ">=".concat(fM, ".").concat(fm, ".0").concat(incPr ? '-0' : '');
                }
                else if (fpr) {
                    from = ">=".concat(from);
                }
                else {
                    from = ">=".concat(from).concat(incPr ? '-0' : '');
                }
                if (isX(tM)) {
                    to = '';
                }
                else if (isX(tm)) {
                    to = "<".concat(+tM + 1, ".0.0-0");
                }
                else if (isX(tp)) {
                    to = "<".concat(tM, ".").concat(+tm + 1, ".0-0");
                }
                else if (tpr) {
                    to = "<=".concat(tM, ".").concat(tm, ".").concat(tp, "-").concat(tpr);
                }
                else if (incPr) {
                    to = "<".concat(tM, ".").concat(tm, ".").concat(+tp + 1, "-0");
                }
                else {
                    to = "<=".concat(to);
                }
                return "".concat(from, " ").concat(to).trim();
            }; };
            var testSet = function (set, version, options) {
                for (var i = 0; i < set.length; i++) {
                    if (!set[i].test(version)) {
                        return false;
                    }
                }
                if (version.prerelease.length && !options.includePrerelease) {
                    // Find the set of versions that are allowed to have prereleases
                    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
                    // That should allow `1.2.3-pr.2` to pass.
                    // However, `1.2.4-alpha.notready` should NOT be allowed,
                    // even though it's within the range set by the comparators.
                    for (var i = 0; i < set.length; i++) {
                        debug(set[i].semver);
                        if (set[i].semver === Comparator.ANY) {
                            continue;
                        }
                        if (set[i].semver.prerelease.length > 0) {
                            var allowed = set[i].semver;
                            if (allowed.major === version.major &&
                                allowed.minor === version.minor &&
                                allowed.patch === version.patch) {
                                return true;
                            }
                        }
                    }
                    // Version has a -pre, but it's not one of the ones we like.
                    return false;
                }
                return true;
            };
            /***/ 
        }),
        /***/ 8088: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var debug = __nccwpck_require__(427);
            var _1 = __nccwpck_require__(2293), MAX_LENGTH = _1.MAX_LENGTH, MAX_SAFE_INTEGER = _1.MAX_SAFE_INTEGER;
            var _2 = __nccwpck_require__(9523), re = _2.safeRe, t = _2.t;
            var parseOptions = __nccwpck_require__(785);
            var compareIdentifiers = __nccwpck_require__(2463).compareIdentifiers;
            var SemVer = /** @class */ (function () {
                function SemVer(version, options) {
                    options = parseOptions(options);
                    if (version instanceof SemVer) {
                        if (version.loose === !!options.loose &&
                            version.includePrerelease === !!options.includePrerelease) {
                            return version;
                        }
                        else {
                            version = version.version;
                        }
                    }
                    else if (typeof version !== 'string') {
                        throw new TypeError("Invalid version. Must be a string. Got type \"".concat(typeof version, "\"."));
                    }
                    if (version.length > MAX_LENGTH) {
                        throw new TypeError("version is longer than ".concat(MAX_LENGTH, " characters"));
                    }
                    debug('SemVer', version, options);
                    this.options = options;
                    this.loose = !!options.loose;
                    // this isn't actually relevant for versions, but keep it so that we
                    // don't run into trouble passing this.options around.
                    this.includePrerelease = !!options.includePrerelease;
                    var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
                    if (!m) {
                        throw new TypeError("Invalid Version: ".concat(version));
                    }
                    this.raw = version;
                    // these are actually numbers
                    this.major = +m[1];
                    this.minor = +m[2];
                    this.patch = +m[3];
                    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
                        throw new TypeError('Invalid major version');
                    }
                    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
                        throw new TypeError('Invalid minor version');
                    }
                    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
                        throw new TypeError('Invalid patch version');
                    }
                    // numberify any prerelease numeric ids
                    if (!m[4]) {
                        this.prerelease = [];
                    }
                    else {
                        this.prerelease = m[4].split('.').map(function (id) {
                            if (/^[0-9]+$/.test(id)) {
                                var num = +id;
                                if (num >= 0 && num < MAX_SAFE_INTEGER) {
                                    return num;
                                }
                            }
                            return id;
                        });
                    }
                    this.build = m[5] ? m[5].split('.') : [];
                    this.format();
                }
                SemVer.prototype.format = function () {
                    this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch);
                    if (this.prerelease.length) {
                        this.version += "-".concat(this.prerelease.join('.'));
                    }
                    return this.version;
                };
                SemVer.prototype.toString = function () {
                    return this.version;
                };
                SemVer.prototype.compare = function (other) {
                    debug('SemVer.compare', this.version, this.options, other);
                    if (!(other instanceof SemVer)) {
                        if (typeof other === 'string' && other === this.version) {
                            return 0;
                        }
                        other = new SemVer(other, this.options);
                    }
                    if (other.version === this.version) {
                        return 0;
                    }
                    return this.compareMain(other) || this.comparePre(other);
                };
                SemVer.prototype.compareMain = function (other) {
                    if (!(other instanceof SemVer)) {
                        other = new SemVer(other, this.options);
                    }
                    return (compareIdentifiers(this.major, other.major) ||
                        compareIdentifiers(this.minor, other.minor) ||
                        compareIdentifiers(this.patch, other.patch));
                };
                SemVer.prototype.comparePre = function (other) {
                    if (!(other instanceof SemVer)) {
                        other = new SemVer(other, this.options);
                    }
                    // NOT having a prerelease is > having one
                    if (this.prerelease.length && !other.prerelease.length) {
                        return -1;
                    }
                    else if (!this.prerelease.length && other.prerelease.length) {
                        return 1;
                    }
                    else if (!this.prerelease.length && !other.prerelease.length) {
                        return 0;
                    }
                    var i = 0;
                    do {
                        var a = this.prerelease[i];
                        var b = other.prerelease[i];
                        debug('prerelease compare', i, a, b);
                        if (a === undefined && b === undefined) {
                            return 0;
                        }
                        else if (b === undefined) {
                            return 1;
                        }
                        else if (a === undefined) {
                            return -1;
                        }
                        else if (a === b) {
                            continue;
                        }
                        else {
                            return compareIdentifiers(a, b);
                        }
                    } while (++i);
                };
                SemVer.prototype.compareBuild = function (other) {
                    if (!(other instanceof SemVer)) {
                        other = new SemVer(other, this.options);
                    }
                    var i = 0;
                    do {
                        var a = this.build[i];
                        var b = other.build[i];
                        debug('prerelease compare', i, a, b);
                        if (a === undefined && b === undefined) {
                            return 0;
                        }
                        else if (b === undefined) {
                            return 1;
                        }
                        else if (a === undefined) {
                            return -1;
                        }
                        else if (a === b) {
                            continue;
                        }
                        else {
                            return compareIdentifiers(a, b);
                        }
                    } while (++i);
                };
                // preminor will bump the version up to the next minor release, and immediately
                // down to pre-release. premajor and prepatch work the same way.
                SemVer.prototype.inc = function (release, identifier, identifierBase) {
                    switch (release) {
                        case 'premajor':
                            this.prerelease.length = 0;
                            this.patch = 0;
                            this.minor = 0;
                            this.major++;
                            this.inc('pre', identifier, identifierBase);
                            break;
                        case 'preminor':
                            this.prerelease.length = 0;
                            this.patch = 0;
                            this.minor++;
                            this.inc('pre', identifier, identifierBase);
                            break;
                        case 'prepatch':
                            // If this is already a prerelease, it will bump to the next version
                            // drop any prereleases that might already exist, since they are not
                            // relevant at this point.
                            this.prerelease.length = 0;
                            this.inc('patch', identifier, identifierBase);
                            this.inc('pre', identifier, identifierBase);
                            break;
                        // If the input is a non-prerelease version, this acts the same as
                        // prepatch.
                        case 'prerelease':
                            if (this.prerelease.length === 0) {
                                this.inc('patch', identifier, identifierBase);
                            }
                            this.inc('pre', identifier, identifierBase);
                            break;
                        case 'major':
                            // If this is a pre-major version, bump up to the same major version.
                            // Otherwise increment major.
                            // 1.0.0-5 bumps to 1.0.0
                            // 1.1.0 bumps to 2.0.0
                            if (this.minor !== 0 ||
                                this.patch !== 0 ||
                                this.prerelease.length === 0) {
                                this.major++;
                            }
                            this.minor = 0;
                            this.patch = 0;
                            this.prerelease = [];
                            break;
                        case 'minor':
                            // If this is a pre-minor version, bump up to the same minor version.
                            // Otherwise increment minor.
                            // 1.2.0-5 bumps to 1.2.0
                            // 1.2.1 bumps to 1.3.0
                            if (this.patch !== 0 || this.prerelease.length === 0) {
                                this.minor++;
                            }
                            this.patch = 0;
                            this.prerelease = [];
                            break;
                        case 'patch':
                            // If this is not a pre-release version, it will increment the patch.
                            // If it is a pre-release it will bump up to the same patch version.
                            // 1.2.0-5 patches to 1.2.0
                            // 1.2.0 patches to 1.2.1
                            if (this.prerelease.length === 0) {
                                this.patch++;
                            }
                            this.prerelease = [];
                            break;
                        // This probably shouldn't be used publicly.
                        // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
                        case 'pre': {
                            var base = Number(identifierBase) ? 1 : 0;
                            if (!identifier && identifierBase === false) {
                                throw new Error('invalid increment argument: identifier is empty');
                            }
                            if (this.prerelease.length === 0) {
                                this.prerelease = [base];
                            }
                            else {
                                var i = this.prerelease.length;
                                while (--i >= 0) {
                                    if (typeof this.prerelease[i] === 'number') {
                                        this.prerelease[i]++;
                                        i = -2;
                                    }
                                }
                                if (i === -1) {
                                    // didn't increment anything
                                    if (identifier === this.prerelease.join('.') && identifierBase === false) {
                                        throw new Error('invalid increment argument: identifier already exists');
                                    }
                                    this.prerelease.push(base);
                                }
                            }
                            if (identifier) {
                                // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
                                // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
                                var prerelease = [identifier, base];
                                if (identifierBase === false) {
                                    prerelease = [identifier];
                                }
                                if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                                    if (isNaN(this.prerelease[1])) {
                                        this.prerelease = prerelease;
                                    }
                                }
                                else {
                                    this.prerelease = prerelease;
                                }
                            }
                            break;
                        }
                        default:
                            throw new Error("invalid increment argument: ".concat(release));
                    }
                    this.raw = this.format();
                    if (this.build.length) {
                        this.raw += "+".concat(this.build.join('.'));
                    }
                    return this;
                };
                return SemVer;
            }());
            module.exports = SemVer;
            /***/ 
        }),
        /***/ 8848: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var parse = __nccwpck_require__(5925);
            var clean = function (version, options) {
                var s = parse(version.trim().replace(/^[=v]+/, ''), options);
                return s ? s.version : null;
            };
            module.exports = clean;
            /***/ 
        }),
        /***/ 5098: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var eq = __nccwpck_require__(1898);
            var neq = __nccwpck_require__(6017);
            var gt = __nccwpck_require__(4123);
            var gte = __nccwpck_require__(5522);
            var lt = __nccwpck_require__(194);
            var lte = __nccwpck_require__(7520);
            var cmp = function (a, op, b, loose) {
                switch (op) {
                    case '===':
                        if (typeof a === 'object') {
                            a = a.version;
                        }
                        if (typeof b === 'object') {
                            b = b.version;
                        }
                        return a === b;
                    case '!==':
                        if (typeof a === 'object') {
                            a = a.version;
                        }
                        if (typeof b === 'object') {
                            b = b.version;
                        }
                        return a !== b;
                    case '':
                    case '=':
                    case '==':
                        return eq(a, b, loose);
                    case '!=':
                        return neq(a, b, loose);
                    case '>':
                        return gt(a, b, loose);
                    case '>=':
                        return gte(a, b, loose);
                    case '<':
                        return lt(a, b, loose);
                    case '<=':
                        return lte(a, b, loose);
                    default:
                        throw new TypeError("Invalid operator: ".concat(op));
                }
            };
            module.exports = cmp;
            /***/ 
        }),
        /***/ 3466: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var SemVer = __nccwpck_require__(8088);
            var parse = __nccwpck_require__(5925);
            var _1 = __nccwpck_require__(9523), re = _1.safeRe, t = _1.t;
            var coerce = function (version, options) {
                if (version instanceof SemVer) {
                    return version;
                }
                if (typeof version === 'number') {
                    version = String(version);
                }
                if (typeof version !== 'string') {
                    return null;
                }
                options = options || {};
                var match = null;
                if (!options.rtl) {
                    match = version.match(re[t.COERCE]);
                }
                else {
                    // Find the right-most coercible string that does not share
                    // a terminus with a more left-ward coercible string.
                    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
                    //
                    // Walk through the string checking with a /g regexp
                    // Manually set the index so as to pick up overlapping matches.
                    // Stop when we get a match that ends at the string end, since no
                    // coercible string can be more right-ward without the same terminus.
                    var next = void 0;
                    while ((next = re[t.COERCERTL].exec(version)) &&
                        (!match || match.index + match[0].length !== version.length)) {
                        if (!match ||
                            next.index + next[0].length !== match.index + match[0].length) {
                            match = next;
                        }
                        re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
                    }
                    // leave it in a clean state
                    re[t.COERCERTL].lastIndex = -1;
                }
                if (match === null) {
                    return null;
                }
                return parse("".concat(match[2], ".").concat(match[3] || '0', ".").concat(match[4] || '0'), options);
            };
            module.exports = coerce;
            /***/ 
        }),
        /***/ 2156: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var SemVer = __nccwpck_require__(8088);
            var compareBuild = function (a, b, loose) {
                var versionA = new SemVer(a, loose);
                var versionB = new SemVer(b, loose);
                return versionA.compare(versionB) || versionA.compareBuild(versionB);
            };
            module.exports = compareBuild;
            /***/ 
        }),
        /***/ 2804: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var compare = __nccwpck_require__(4309);
            var compareLoose = function (a, b) { return compare(a, b, true); };
            module.exports = compareLoose;
            /***/ 
        }),
        /***/ 4309: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var SemVer = __nccwpck_require__(8088);
            var compare = function (a, b, loose) {
                return new SemVer(a, loose).compare(new SemVer(b, loose));
            };
            module.exports = compare;
            /***/ 
        }),
        /***/ 4297: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var parse = __nccwpck_require__(5925);
            var diff = function (version1, version2) {
                var v1 = parse(version1, null, true);
                var v2 = parse(version2, null, true);
                var comparison = v1.compare(v2);
                if (comparison === 0) {
                    return null;
                }
                var v1Higher = comparison > 0;
                var highVersion = v1Higher ? v1 : v2;
                var lowVersion = v1Higher ? v2 : v1;
                var highHasPre = !!highVersion.prerelease.length;
                var lowHasPre = !!lowVersion.prerelease.length;
                if (lowHasPre && !highHasPre) {
                    // Going from prerelease -> no prerelease requires some special casing
                    // If the low version has only a major, then it will always be a major
                    // Some examples:
                    // 1.0.0-1 -> 1.0.0
                    // 1.0.0-1 -> 1.1.1
                    // 1.0.0-1 -> 2.0.0
                    if (!lowVersion.patch && !lowVersion.minor) {
                        return 'major';
                    }
                    // Otherwise it can be determined by checking the high version
                    if (highVersion.patch) {
                        // anything higher than a patch bump would result in the wrong version
                        return 'patch';
                    }
                    if (highVersion.minor) {
                        // anything higher than a minor bump would result in the wrong version
                        return 'minor';
                    }
                    // bumping major/minor/patch all have same result
                    return 'major';
                }
                // add the `pre` prefix if we are going to a prerelease version
                var prefix = highHasPre ? 'pre' : '';
                if (v1.major !== v2.major) {
                    return prefix + 'major';
                }
                if (v1.minor !== v2.minor) {
                    return prefix + 'minor';
                }
                if (v1.patch !== v2.patch) {
                    return prefix + 'patch';
                }
                // high and low are preleases
                return 'prerelease';
            };
            module.exports = diff;
            /***/ 
        }),
        /***/ 1898: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var compare = __nccwpck_require__(4309);
            var eq = function (a, b, loose) { return compare(a, b, loose) === 0; };
            module.exports = eq;
            /***/ 
        }),
        /***/ 4123: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var compare = __nccwpck_require__(4309);
            var gt = function (a, b, loose) { return compare(a, b, loose) > 0; };
            module.exports = gt;
            /***/ 
        }),
        /***/ 5522: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var compare = __nccwpck_require__(4309);
            var gte = function (a, b, loose) { return compare(a, b, loose) >= 0; };
            module.exports = gte;
            /***/ 
        }),
        /***/ 900: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var SemVer = __nccwpck_require__(8088);
            var inc = function (version, release, options, identifier, identifierBase) {
                if (typeof (options) === 'string') {
                    identifierBase = identifier;
                    identifier = options;
                    options = undefined;
                }
                try {
                    return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier, identifierBase).version;
                }
                catch (er) {
                    return null;
                }
            };
            module.exports = inc;
            /***/ 
        }),
        /***/ 194: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var compare = __nccwpck_require__(4309);
            var lt = function (a, b, loose) { return compare(a, b, loose) < 0; };
            module.exports = lt;
            /***/ 
        }),
        /***/ 7520: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var compare = __nccwpck_require__(4309);
            var lte = function (a, b, loose) { return compare(a, b, loose) <= 0; };
            module.exports = lte;
            /***/ 
        }),
        /***/ 6688: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var SemVer = __nccwpck_require__(8088);
            var major = function (a, loose) { return new SemVer(a, loose).major; };
            module.exports = major;
            /***/ 
        }),
        /***/ 8447: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var SemVer = __nccwpck_require__(8088);
            var minor = function (a, loose) { return new SemVer(a, loose).minor; };
            module.exports = minor;
            /***/ 
        }),
        /***/ 6017: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var compare = __nccwpck_require__(4309);
            var neq = function (a, b, loose) { return compare(a, b, loose) !== 0; };
            module.exports = neq;
            /***/ 
        }),
        /***/ 5925: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var SemVer = __nccwpck_require__(8088);
            var parse = function (version, options, throwErrors) {
                if (throwErrors === void 0) { throwErrors = false; }
                if (version instanceof SemVer) {
                    return version;
                }
                try {
                    return new SemVer(version, options);
                }
                catch (er) {
                    if (!throwErrors) {
                        return null;
                    }
                    throw er;
                }
            };
            module.exports = parse;
            /***/ 
        }),
        /***/ 2866: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var SemVer = __nccwpck_require__(8088);
            var patch = function (a, loose) { return new SemVer(a, loose).patch; };
            module.exports = patch;
            /***/ 
        }),
        /***/ 4016: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var parse = __nccwpck_require__(5925);
            var prerelease = function (version, options) {
                var parsed = parse(version, options);
                return (parsed && parsed.prerelease.length) ? parsed.prerelease : null;
            };
            module.exports = prerelease;
            /***/ 
        }),
        /***/ 6417: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var compare = __nccwpck_require__(4309);
            var rcompare = function (a, b, loose) { return compare(b, a, loose); };
            module.exports = rcompare;
            /***/ 
        }),
        /***/ 8701: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var compareBuild = __nccwpck_require__(2156);
            var rsort = function (list, loose) { return list.sort(function (a, b) { return compareBuild(b, a, loose); }); };
            module.exports = rsort;
            /***/ 
        }),
        /***/ 6055: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var Range = __nccwpck_require__(9828);
            var satisfies = function (version, range, options) {
                try {
                    range = new Range(range, options);
                }
                catch (er) {
                    return false;
                }
                return range.test(version);
            };
            module.exports = satisfies;
            /***/ 
        }),
        /***/ 1426: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var compareBuild = __nccwpck_require__(2156);
            var sort = function (list, loose) { return list.sort(function (a, b) { return compareBuild(a, b, loose); }); };
            module.exports = sort;
            /***/ 
        }),
        /***/ 9601: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var parse = __nccwpck_require__(5925);
            var valid = function (version, options) {
                var v = parse(version, options);
                return v ? v.version : null;
            };
            module.exports = valid;
            /***/ 
        }),
        /***/ 1383: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            // just pre-load all the stuff that index.js lazily exports
            var internalRe = __nccwpck_require__(9523);
            var constants = __nccwpck_require__(2293);
            var SemVer = __nccwpck_require__(8088);
            var identifiers = __nccwpck_require__(2463);
            var parse = __nccwpck_require__(5925);
            var valid = __nccwpck_require__(9601);
            var clean = __nccwpck_require__(8848);
            var inc = __nccwpck_require__(900);
            var diff = __nccwpck_require__(4297);
            var major = __nccwpck_require__(6688);
            var minor = __nccwpck_require__(8447);
            var patch = __nccwpck_require__(2866);
            var prerelease = __nccwpck_require__(4016);
            var compare = __nccwpck_require__(4309);
            var rcompare = __nccwpck_require__(6417);
            var compareLoose = __nccwpck_require__(2804);
            var compareBuild = __nccwpck_require__(2156);
            var sort = __nccwpck_require__(1426);
            var rsort = __nccwpck_require__(8701);
            var gt = __nccwpck_require__(4123);
            var lt = __nccwpck_require__(194);
            var eq = __nccwpck_require__(1898);
            var neq = __nccwpck_require__(6017);
            var gte = __nccwpck_require__(5522);
            var lte = __nccwpck_require__(7520);
            var cmp = __nccwpck_require__(5098);
            var coerce = __nccwpck_require__(3466);
            var Comparator = __nccwpck_require__(1532);
            var Range = __nccwpck_require__(9828);
            var satisfies = __nccwpck_require__(6055);
            var toComparators = __nccwpck_require__(2706);
            var maxSatisfying = __nccwpck_require__(579);
            var minSatisfying = __nccwpck_require__(832);
            var minVersion = __nccwpck_require__(4179);
            var validRange = __nccwpck_require__(2098);
            var outside = __nccwpck_require__(420);
            var gtr = __nccwpck_require__(9380);
            var ltr = __nccwpck_require__(3323);
            var intersects = __nccwpck_require__(7008);
            var simplifyRange = __nccwpck_require__(5297);
            var subset = __nccwpck_require__(7863);
            module.exports = {
                parse: parse,
                valid: valid,
                clean: clean,
                inc: inc,
                diff: diff,
                major: major,
                minor: minor,
                patch: patch,
                prerelease: prerelease,
                compare: compare,
                rcompare: rcompare,
                compareLoose: compareLoose,
                compareBuild: compareBuild,
                sort: sort,
                rsort: rsort,
                gt: gt,
                lt: lt,
                eq: eq,
                neq: neq,
                gte: gte,
                lte: lte,
                cmp: cmp,
                coerce: coerce,
                Comparator: Comparator,
                Range: Range,
                satisfies: satisfies,
                toComparators: toComparators,
                maxSatisfying: maxSatisfying,
                minSatisfying: minSatisfying,
                minVersion: minVersion,
                validRange: validRange,
                outside: outside,
                gtr: gtr,
                ltr: ltr,
                intersects: intersects,
                simplifyRange: simplifyRange,
                subset: subset,
                SemVer: SemVer,
                re: internalRe.re,
                src: internalRe.src,
                tokens: internalRe.t,
                SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
                RELEASE_TYPES: constants.RELEASE_TYPES,
                compareIdentifiers: identifiers.compareIdentifiers,
                rcompareIdentifiers: identifiers.rcompareIdentifiers
            };
            /***/ 
        }),
        /***/ 2293: 
        /***/ (function (module) {
            // Note: this is the semver.org version of the spec that it implements
            // Not necessarily the package version of this code.
            var SEMVER_SPEC_VERSION = '2.0.0';
            var MAX_LENGTH = 256;
            var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
                /* istanbul ignore next */ 9007199254740991;
            // Max safe segment length for coercion.
            var MAX_SAFE_COMPONENT_LENGTH = 16;
            // Max safe length for a build identifier. The max length minus 6 characters for
            // the shortest version with a build 0.0.0+BUILD.
            var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
            var RELEASE_TYPES = [
                'major',
                'premajor',
                'minor',
                'preminor',
                'patch',
                'prepatch',
                'prerelease',
            ];
            module.exports = {
                MAX_LENGTH: MAX_LENGTH,
                MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH,
                MAX_SAFE_BUILD_LENGTH: MAX_SAFE_BUILD_LENGTH,
                MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,
                RELEASE_TYPES: RELEASE_TYPES,
                SEMVER_SPEC_VERSION: SEMVER_SPEC_VERSION,
                FLAG_INCLUDE_PRERELEASE: 1,
                FLAG_LOOSE: 2
            };
            /***/ 
        }),
        /***/ 427: 
        /***/ (function (module) {
            var debug = (typeof process === 'object' &&
                process.env &&
                process.env.NODE_DEBUG &&
                /\bsemver\b/i.test(process.env.NODE_DEBUG)) ? function () {
                var args = [];
                for (var _1 = 0; _1 < arguments.length; _1++) {
                    args[_1] = arguments[_1];
                }
                return console.error.apply(console, __spreadArray(['SEMVER'], args, false));
            }
                : function () { };
            module.exports = debug;
            /***/ 
        }),
        /***/ 2463: 
        /***/ (function (module) {
            var numeric = /^[0-9]+$/;
            var compareIdentifiers = function (a, b) {
                var anum = numeric.test(a);
                var bnum = numeric.test(b);
                if (anum && bnum) {
                    a = +a;
                    b = +b;
                }
                return a === b ? 0
                    : (anum && !bnum) ? -1
                        : (bnum && !anum) ? 1
                            : a < b ? -1
                                : 1;
            };
            var rcompareIdentifiers = function (a, b) { return compareIdentifiers(b, a); };
            module.exports = {
                compareIdentifiers: compareIdentifiers,
                rcompareIdentifiers: rcompareIdentifiers
            };
            /***/ 
        }),
        /***/ 785: 
        /***/ (function (module) {
            // parse out just the options we care about
            var looseOption = Object.freeze({ loose: true });
            var emptyOpts = Object.freeze({});
            var parseOptions = function (options) {
                if (!options) {
                    return emptyOpts;
                }
                if (typeof options !== 'object') {
                    return looseOption;
                }
                return options;
            };
            module.exports = parseOptions;
            /***/ 
        }),
        /***/ 9523: 
        /***/ (function (module, exports, __nccwpck_require__) {
            var _1 = __nccwpck_require__(2293), MAX_SAFE_COMPONENT_LENGTH = _1.MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH = _1.MAX_SAFE_BUILD_LENGTH, MAX_LENGTH = _1.MAX_LENGTH;
            var debug = __nccwpck_require__(427);
            exports = module.exports = {};
            // The actual regexps go on exports.re
            var re = exports.re = [];
            var safeRe = exports.safeRe = [];
            var src = exports.src = [];
            var t = exports.t = {};
            var R = 0;
            var LETTERDASHNUMBER = '[a-zA-Z0-9-]';
            // Replace some greedy regex tokens to prevent regex dos issues. These regex are
            // used internally via the safeRe object since all inputs in this library get
            // normalized first to trim and collapse all extra whitespace. The original
            // regexes are exported for userland consumption and lower level usage. A
            // future breaking change could export the safer regex only with a note that
            // all input should have extra whitespace removed.
            var safeRegexReplacements = [
                ['\\s', 1],
                ['\\d', MAX_LENGTH],
                [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
            ];
            var makeSafeRegex = function (value) {
                for (var _1 = 0, safeRegexReplacements_1 = safeRegexReplacements; _1 < safeRegexReplacements_1.length; _1++) {
                    var _2 = safeRegexReplacements_1[_1], token = _2[0], max = _2[1];
                    value = value
                        .split("".concat(token, "*")).join("".concat(token, "{0,").concat(max, "}"))
                        .split("".concat(token, "+")).join("".concat(token, "{1,").concat(max, "}"));
                }
                return value;
            };
            var createToken = function (name, value, isGlobal) {
                var safe = makeSafeRegex(value);
                var index = R++;
                debug(name, index, value);
                t[name] = index;
                src[index] = value;
                re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
                safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined);
            };
            // The following Regular Expressions can be used for tokenizing,
            // validating, and parsing SemVer version strings.
            // ## Numeric Identifier
            // A single `0`, or a non-zero digit followed by zero or more digits.
            createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
            createToken('NUMERICIDENTIFIERLOOSE', '\\d+');
            // ## Non-numeric Identifier
            // Zero or more digits, followed by a letter or hyphen, and then zero or
            // more letters, digits, or hyphens.
            createToken('NONNUMERICIDENTIFIER', "\\d*[a-zA-Z-]".concat(LETTERDASHNUMBER, "*"));
            // ## Main Version
            // Three dot-separated numeric identifiers.
            createToken('MAINVERSION', "(".concat(src[t.NUMERICIDENTIFIER], ")\\.") +
                "(".concat(src[t.NUMERICIDENTIFIER], ")\\.") +
                "(".concat(src[t.NUMERICIDENTIFIER], ")"));
            createToken('MAINVERSIONLOOSE', "(".concat(src[t.NUMERICIDENTIFIERLOOSE], ")\\.") +
                "(".concat(src[t.NUMERICIDENTIFIERLOOSE], ")\\.") +
                "(".concat(src[t.NUMERICIDENTIFIERLOOSE], ")"));
            // ## Pre-release Version Identifier
            // A numeric identifier, or a non-numeric identifier.
            createToken('PRERELEASEIDENTIFIER', "(?:".concat(src[t.NUMERICIDENTIFIER], "|").concat(src[t.NONNUMERICIDENTIFIER], ")"));
            createToken('PRERELEASEIDENTIFIERLOOSE', "(?:".concat(src[t.NUMERICIDENTIFIERLOOSE], "|").concat(src[t.NONNUMERICIDENTIFIER], ")"));
            // ## Pre-release Version
            // Hyphen, followed by one or more dot-separated pre-release version
            // identifiers.
            createToken('PRERELEASE', "(?:-(".concat(src[t.PRERELEASEIDENTIFIER], "(?:\\.").concat(src[t.PRERELEASEIDENTIFIER], ")*))"));
            createToken('PRERELEASELOOSE', "(?:-?(".concat(src[t.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(src[t.PRERELEASEIDENTIFIERLOOSE], ")*))"));
            // ## Build Metadata Identifier
            // Any combination of digits, letters, or hyphens.
            createToken('BUILDIDENTIFIER', "".concat(LETTERDASHNUMBER, "+"));
            // ## Build Metadata
            // Plus sign, followed by one or more period-separated build metadata
            // identifiers.
            createToken('BUILD', "(?:\\+(".concat(src[t.BUILDIDENTIFIER], "(?:\\.").concat(src[t.BUILDIDENTIFIER], ")*))"));
            // ## Full Version String
            // A main version, followed optionally by a pre-release version and
            // build metadata.
            // Note that the only major, minor, patch, and pre-release sections of
            // the version string are capturing groups.  The build metadata is not a
            // capturing group, because it should not ever be used in version
            // comparison.
            createToken('FULLPLAIN', "v?".concat(src[t.MAINVERSION]).concat(src[t.PRERELEASE], "?").concat(src[t.BUILD], "?"));
            createToken('FULL', "^".concat(src[t.FULLPLAIN], "$"));
            // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
            // also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
            // common in the npm registry.
            createToken('LOOSEPLAIN', "[v=\\s]*".concat(src[t.MAINVERSIONLOOSE]).concat(src[t.PRERELEASELOOSE], "?").concat(src[t.BUILD], "?"));
            createToken('LOOSE', "^".concat(src[t.LOOSEPLAIN], "$"));
            createToken('GTLT', '((?:<|>)?=?)');
            // Something like "2.*" or "1.2.x".
            // Note that "x.x" is a valid xRange identifer, meaning "any version"
            // Only the first item is strictly required.
            createToken('XRANGEIDENTIFIERLOOSE', "".concat(src[t.NUMERICIDENTIFIERLOOSE], "|x|X|\\*"));
            createToken('XRANGEIDENTIFIER', "".concat(src[t.NUMERICIDENTIFIER], "|x|X|\\*"));
            createToken('XRANGEPLAIN', "[v=\\s]*(".concat(src[t.XRANGEIDENTIFIER], ")") +
                "(?:\\.(".concat(src[t.XRANGEIDENTIFIER], ")") +
                "(?:\\.(".concat(src[t.XRANGEIDENTIFIER], ")") +
                "(?:".concat(src[t.PRERELEASE], ")?").concat(src[t.BUILD], "?") +
                ")?)?");
            createToken('XRANGEPLAINLOOSE', "[v=\\s]*(".concat(src[t.XRANGEIDENTIFIERLOOSE], ")") +
                "(?:\\.(".concat(src[t.XRANGEIDENTIFIERLOOSE], ")") +
                "(?:\\.(".concat(src[t.XRANGEIDENTIFIERLOOSE], ")") +
                "(?:".concat(src[t.PRERELEASELOOSE], ")?").concat(src[t.BUILD], "?") +
                ")?)?");
            createToken('XRANGE', "^".concat(src[t.GTLT], "\\s*").concat(src[t.XRANGEPLAIN], "$"));
            createToken('XRANGELOOSE', "^".concat(src[t.GTLT], "\\s*").concat(src[t.XRANGEPLAINLOOSE], "$"));
            // Coercion.
            // Extract anything that could conceivably be a part of a valid semver
            createToken('COERCE', "".concat('(^|[^\\d])' +
                '(\\d{1,').concat(MAX_SAFE_COMPONENT_LENGTH, "})") +
                "(?:\\.(\\d{1,".concat(MAX_SAFE_COMPONENT_LENGTH, "}))?") +
                "(?:\\.(\\d{1,".concat(MAX_SAFE_COMPONENT_LENGTH, "}))?") +
                "(?:$|[^\\d])");
            createToken('COERCERTL', src[t.COERCE], true);
            // Tilde ranges.
            // Meaning is "reasonably at or greater than"
            createToken('LONETILDE', '(?:~>?)');
            createToken('TILDETRIM', "(\\s*)".concat(src[t.LONETILDE], "\\s+"), true);
            exports.tildeTrimReplace = '$1~';
            createToken('TILDE', "^".concat(src[t.LONETILDE]).concat(src[t.XRANGEPLAIN], "$"));
            createToken('TILDELOOSE', "^".concat(src[t.LONETILDE]).concat(src[t.XRANGEPLAINLOOSE], "$"));
            // Caret ranges.
            // Meaning is "at least and backwards compatible with"
            createToken('LONECARET', '(?:\\^)');
            createToken('CARETTRIM', "(\\s*)".concat(src[t.LONECARET], "\\s+"), true);
            exports.caretTrimReplace = '$1^';
            createToken('CARET', "^".concat(src[t.LONECARET]).concat(src[t.XRANGEPLAIN], "$"));
            createToken('CARETLOOSE', "^".concat(src[t.LONECARET]).concat(src[t.XRANGEPLAINLOOSE], "$"));
            // A simple gt/lt/eq thing, or just "" to indicate "any version"
            createToken('COMPARATORLOOSE', "^".concat(src[t.GTLT], "\\s*(").concat(src[t.LOOSEPLAIN], ")$|^$"));
            createToken('COMPARATOR', "^".concat(src[t.GTLT], "\\s*(").concat(src[t.FULLPLAIN], ")$|^$"));
            // An expression to strip any whitespace between the gtlt and the thing
            // it modifies, so that `> 1.2.3` ==> `>1.2.3`
            createToken('COMPARATORTRIM', "(\\s*)".concat(src[t.GTLT], "\\s*(").concat(src[t.LOOSEPLAIN], "|").concat(src[t.XRANGEPLAIN], ")"), true);
            exports.comparatorTrimReplace = '$1$2$3';
            // Something like `1.2.3 - 1.2.4`
            // Note that these all use the loose form, because they'll be
            // checked against either the strict or loose comparator form
            // later.
            createToken('HYPHENRANGE', "^\\s*(".concat(src[t.XRANGEPLAIN], ")") +
                "\\s+-\\s+" +
                "(".concat(src[t.XRANGEPLAIN], ")") +
                "\\s*$");
            createToken('HYPHENRANGELOOSE', "^\\s*(".concat(src[t.XRANGEPLAINLOOSE], ")") +
                "\\s+-\\s+" +
                "(".concat(src[t.XRANGEPLAINLOOSE], ")") +
                "\\s*$");
            // Star ranges basically just allow anything at all.
            createToken('STAR', '(<|>)?=?\\s*\\*');
            // >=0.0.0 is like a star
            createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
            createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$');
            /***/ 
        }),
        /***/ 9380: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            // Determine if version is greater than all the versions possible in the range.
            var outside = __nccwpck_require__(420);
            var gtr = function (version, range, options) { return outside(version, range, '>', options); };
            module.exports = gtr;
            /***/ 
        }),
        /***/ 7008: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var Range = __nccwpck_require__(9828);
            var intersects = function (r1, r2, options) {
                r1 = new Range(r1, options);
                r2 = new Range(r2, options);
                return r1.intersects(r2, options);
            };
            module.exports = intersects;
            /***/ 
        }),
        /***/ 3323: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var outside = __nccwpck_require__(420);
            // Determine if version is less than all the versions possible in the range
            var ltr = function (version, range, options) { return outside(version, range, '<', options); };
            module.exports = ltr;
            /***/ 
        }),
        /***/ 579: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var SemVer = __nccwpck_require__(8088);
            var Range = __nccwpck_require__(9828);
            var maxSatisfying = function (versions, range, options) {
                var max = null;
                var maxSV = null;
                var rangeObj = null;
                try {
                    rangeObj = new Range(range, options);
                }
                catch (er) {
                    return null;
                }
                versions.forEach(function (v) {
                    if (rangeObj.test(v)) {
                        // satisfies(v, range, options)
                        if (!max || maxSV.compare(v) === -1) {
                            // compare(max, v, true)
                            max = v;
                            maxSV = new SemVer(max, options);
                        }
                    }
                });
                return max;
            };
            module.exports = maxSatisfying;
            /***/ 
        }),
        /***/ 832: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var SemVer = __nccwpck_require__(8088);
            var Range = __nccwpck_require__(9828);
            var minSatisfying = function (versions, range, options) {
                var min = null;
                var minSV = null;
                var rangeObj = null;
                try {
                    rangeObj = new Range(range, options);
                }
                catch (er) {
                    return null;
                }
                versions.forEach(function (v) {
                    if (rangeObj.test(v)) {
                        // satisfies(v, range, options)
                        if (!min || minSV.compare(v) === 1) {
                            // compare(min, v, true)
                            min = v;
                            minSV = new SemVer(min, options);
                        }
                    }
                });
                return min;
            };
            module.exports = minSatisfying;
            /***/ 
        }),
        /***/ 4179: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var SemVer = __nccwpck_require__(8088);
            var Range = __nccwpck_require__(9828);
            var gt = __nccwpck_require__(4123);
            var minVersion = function (range, loose) {
                range = new Range(range, loose);
                var minver = new SemVer('0.0.0');
                if (range.test(minver)) {
                    return minver;
                }
                minver = new SemVer('0.0.0-0');
                if (range.test(minver)) {
                    return minver;
                }
                minver = null;
                var _loop_11 = function (i) {
                    var comparators = range.set[i];
                    var setMin = null;
                    comparators.forEach(function (comparator) {
                        // Clone to avoid manipulating the comparator's semver object.
                        var compver = new SemVer(comparator.semver.version);
                        switch (comparator.operator) {
                            case '>':
                                if (compver.prerelease.length === 0) {
                                    compver.patch++;
                                }
                                else {
                                    compver.prerelease.push(0);
                                }
                                compver.raw = compver.format();
                            /* fallthrough */
                            case '':
                            case '>=':
                                if (!setMin || gt(compver, setMin)) {
                                    setMin = compver;
                                }
                                break;
                            case '<':
                            case '<=':
                                /* Ignore maximum versions */
                                break;
                            /* istanbul ignore next */
                            default:
                                throw new Error("Unexpected operation: ".concat(comparator.operator));
                        }
                    });
                    if (setMin && (!minver || gt(minver, setMin))) {
                        minver = setMin;
                    }
                };
                for (var i = 0; i < range.set.length; ++i) {
                    _loop_11(i);
                }
                if (minver && range.test(minver)) {
                    return minver;
                }
                return null;
            };
            module.exports = minVersion;
            /***/ 
        }),
        /***/ 420: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var SemVer = __nccwpck_require__(8088);
            var Comparator = __nccwpck_require__(1532);
            var ANY = Comparator.ANY;
            var Range = __nccwpck_require__(9828);
            var satisfies = __nccwpck_require__(6055);
            var gt = __nccwpck_require__(4123);
            var lt = __nccwpck_require__(194);
            var lte = __nccwpck_require__(7520);
            var gte = __nccwpck_require__(5522);
            var outside = function (version, range, hilo, options) {
                version = new SemVer(version, options);
                range = new Range(range, options);
                var gtfn, ltefn, ltfn, comp, ecomp;
                switch (hilo) {
                    case '>':
                        gtfn = gt;
                        ltefn = lte;
                        ltfn = lt;
                        comp = '>';
                        ecomp = '>=';
                        break;
                    case '<':
                        gtfn = lt;
                        ltefn = gte;
                        ltfn = gt;
                        comp = '<';
                        ecomp = '<=';
                        break;
                    default:
                        throw new TypeError('Must provide a hilo val of "<" or ">"');
                }
                // If it satisfies the range it is not outside
                if (satisfies(version, range, options)) {
                    return false;
                }
                var _loop_12 = function (i) {
                    var comparators = range.set[i];
                    var high = null;
                    var low = null;
                    comparators.forEach(function (comparator) {
                        if (comparator.semver === ANY) {
                            comparator = new Comparator('>=0.0.0');
                        }
                        high = high || comparator;
                        low = low || comparator;
                        if (gtfn(comparator.semver, high.semver, options)) {
                            high = comparator;
                        }
                        else if (ltfn(comparator.semver, low.semver, options)) {
                            low = comparator;
                        }
                    });
                    // If the edge version comparator has a operator then our version
                    // isn't outside it
                    if (high.operator === comp || high.operator === ecomp) {
                        return { value: false };
                    }
                    // If the lowest version comparator has an operator and our version
                    // is less than it then it isn't higher than the range
                    if ((!low.operator || low.operator === comp) &&
                        ltefn(version, low.semver)) {
                        return { value: false };
                    }
                    else if (low.operator === ecomp && ltfn(version, low.semver)) {
                        return { value: false };
                    }
                };
                // From now on, variable terms are as if we're in "gtr" mode.
                // but note that everything is flipped for the "ltr" function.
                for (var i = 0; i < range.set.length; ++i) {
                    var state_2 = _loop_12(i);
                    if (typeof state_2 === "object")
                        return state_2.value;
                }
                return true;
            };
            module.exports = outside;
            /***/ 
        }),
        /***/ 5297: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            // given a set of versions and a range, create a "simplified" range
            // that includes the same versions that the original range does
            // If the original range is shorter than the simplified one, return that.
            var satisfies = __nccwpck_require__(6055);
            var compare = __nccwpck_require__(4309);
            module.exports = function (versions, range, options) {
                var set = [];
                var first = null;
                var prev = null;
                var v = versions.sort(function (a, b) { return compare(a, b, options); });
                for (var _1 = 0, v_1 = v; _1 < v_1.length; _1++) {
                    var version = v_1[_1];
                    var included = satisfies(version, range, options);
                    if (included) {
                        prev = version;
                        if (!first) {
                            first = version;
                        }
                    }
                    else {
                        if (prev) {
                            set.push([first, prev]);
                        }
                        prev = null;
                        first = null;
                    }
                }
                if (first) {
                    set.push([first, null]);
                }
                var ranges = [];
                for (var _2 = 0, set_1 = set; _2 < set_1.length; _2++) {
                    var _3 = set_1[_2], min = _3[0], max = _3[1];
                    if (min === max) {
                        ranges.push(min);
                    }
                    else if (!max && min === v[0]) {
                        ranges.push('*');
                    }
                    else if (!max) {
                        ranges.push(">=".concat(min));
                    }
                    else if (min === v[0]) {
                        ranges.push("<=".concat(max));
                    }
                    else {
                        ranges.push("".concat(min, " - ").concat(max));
                    }
                }
                var simplified = ranges.join(' || ');
                var original = typeof range.raw === 'string' ? range.raw : String(range);
                return simplified.length < original.length ? simplified : range;
            };
            /***/ 
        }),
        /***/ 7863: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var Range = __nccwpck_require__(9828);
            var Comparator = __nccwpck_require__(1532);
            var ANY = Comparator.ANY;
            var satisfies = __nccwpck_require__(6055);
            var compare = __nccwpck_require__(4309);
            // Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
            // - Every simple range `r1, r2, ...` is a null set, OR
            // - Every simple range `r1, r2, ...` which is not a null set is a subset of
            //   some `R1, R2, ...`
            //
            // Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
            // - If c is only the ANY comparator
            //   - If C is only the ANY comparator, return true
            //   - Else if in prerelease mode, return false
            //   - else replace c with `[>=0.0.0]`
            // - If C is only the ANY comparator
            //   - if in prerelease mode, return true
            //   - else replace C with `[>=0.0.0]`
            // - Let EQ be the set of = comparators in c
            // - If EQ is more than one, return true (null set)
            // - Let GT be the highest > or >= comparator in c
            // - Let LT be the lowest < or <= comparator in c
            // - If GT and LT, and GT.semver > LT.semver, return true (null set)
            // - If any C is a = range, and GT or LT are set, return false
            // - If EQ
            //   - If GT, and EQ does not satisfy GT, return true (null set)
            //   - If LT, and EQ does not satisfy LT, return true (null set)
            //   - If EQ satisfies every C, return true
            //   - Else return false
            // - If GT
            //   - If GT.semver is lower than any > or >= comp in C, return false
            //   - If GT is >=, and GT.semver does not satisfy every C, return false
            //   - If GT.semver has a prerelease, and not in prerelease mode
            //     - If no C has a prerelease and the GT.semver tuple, return false
            // - If LT
            //   - If LT.semver is greater than any < or <= comp in C, return false
            //   - If LT is <=, and LT.semver does not satisfy every C, return false
            //   - If GT.semver has a prerelease, and not in prerelease mode
            //     - If no C has a prerelease and the LT.semver tuple, return false
            // - Else return true
            var subset = function (sub, dom, options) {
                if (options === void 0) { options = {}; }
                if (sub === dom) {
                    return true;
                }
                sub = new Range(sub, options);
                dom = new Range(dom, options);
                var sawNonNull = false;
                OUTER: for (var _1 = 0, _2 = sub.set; _1 < _2.length; _1++) {
                    var simpleSub = _2[_1];
                    for (var _3 = 0, _4 = dom.set; _3 < _4.length; _3++) {
                        var simpleDom = _4[_3];
                        var isSub = simpleSubset(simpleSub, simpleDom, options);
                        sawNonNull = sawNonNull || isSub !== null;
                        if (isSub) {
                            continue OUTER;
                        }
                    }
                    // the null set is a subset of everything, but null simple ranges in
                    // a complex range should be ignored.  so if we saw a non-null range,
                    // then we know this isn't a subset, but if EVERY simple range was null,
                    // then it is a subset.
                    if (sawNonNull) {
                        return false;
                    }
                }
                return true;
            };
            var minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')];
            var minimumVersion = [new Comparator('>=0.0.0')];
            var simpleSubset = function (sub, dom, options) {
                if (sub === dom) {
                    return true;
                }
                if (sub.length === 1 && sub[0].semver === ANY) {
                    if (dom.length === 1 && dom[0].semver === ANY) {
                        return true;
                    }
                    else if (options.includePrerelease) {
                        sub = minimumVersionWithPreRelease;
                    }
                    else {
                        sub = minimumVersion;
                    }
                }
                if (dom.length === 1 && dom[0].semver === ANY) {
                    if (options.includePrerelease) {
                        return true;
                    }
                    else {
                        dom = minimumVersion;
                    }
                }
                var eqSet = new Set();
                var gt, lt;
                for (var _1 = 0, sub_1 = sub; _1 < sub_1.length; _1++) {
                    var c = sub_1[_1];
                    if (c.operator === '>' || c.operator === '>=') {
                        gt = higherGT(gt, c, options);
                    }
                    else if (c.operator === '<' || c.operator === '<=') {
                        lt = lowerLT(lt, c, options);
                    }
                    else {
                        eqSet.add(c.semver);
                    }
                }
                if (eqSet.size > 1) {
                    return null;
                }
                var gtltComp;
                if (gt && lt) {
                    gtltComp = compare(gt.semver, lt.semver, options);
                    if (gtltComp > 0) {
                        return null;
                    }
                    else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
                        return null;
                    }
                }
                // will iterate one or zero times
                for (var _2 = 0, eqSet_1 = eqSet; _2 < eqSet_1.length; _2++) {
                    var eq = eqSet_1[_2];
                    if (gt && !satisfies(eq, String(gt), options)) {
                        return null;
                    }
                    if (lt && !satisfies(eq, String(lt), options)) {
                        return null;
                    }
                    for (var _3 = 0, dom_1 = dom; _3 < dom_1.length; _3++) {
                        var c = dom_1[_3];
                        if (!satisfies(eq, String(c), options)) {
                            return false;
                        }
                    }
                    return true;
                }
                var higher, lower;
                var hasDomLT, hasDomGT;
                // if the subset has a prerelease, we need a comparator in the superset
                // with the same tuple and a prerelease, or it's not a subset
                var needDomLTPre = lt &&
                    !options.includePrerelease &&
                    lt.semver.prerelease.length ? lt.semver : false;
                var needDomGTPre = gt &&
                    !options.includePrerelease &&
                    gt.semver.prerelease.length ? gt.semver : false;
                // exception: <1.2.3-0 is the same as <1.2.3
                if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
                    lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
                    needDomLTPre = false;
                }
                for (var _4 = 0, dom_2 = dom; _4 < dom_2.length; _4++) {
                    var c = dom_2[_4];
                    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>=';
                    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<=';
                    if (gt) {
                        if (needDomGTPre) {
                            if (c.semver.prerelease && c.semver.prerelease.length &&
                                c.semver.major === needDomGTPre.major &&
                                c.semver.minor === needDomGTPre.minor &&
                                c.semver.patch === needDomGTPre.patch) {
                                needDomGTPre = false;
                            }
                        }
                        if (c.operator === '>' || c.operator === '>=') {
                            higher = higherGT(gt, c, options);
                            if (higher === c && higher !== gt) {
                                return false;
                            }
                        }
                        else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {
                            return false;
                        }
                    }
                    if (lt) {
                        if (needDomLTPre) {
                            if (c.semver.prerelease && c.semver.prerelease.length &&
                                c.semver.major === needDomLTPre.major &&
                                c.semver.minor === needDomLTPre.minor &&
                                c.semver.patch === needDomLTPre.patch) {
                                needDomLTPre = false;
                            }
                        }
                        if (c.operator === '<' || c.operator === '<=') {
                            lower = lowerLT(lt, c, options);
                            if (lower === c && lower !== lt) {
                                return false;
                            }
                        }
                        else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {
                            return false;
                        }
                    }
                    if (!c.operator && (lt || gt) && gtltComp !== 0) {
                        return false;
                    }
                }
                // if there was a < or >, and nothing in the dom, then must be false
                // UNLESS it was limited by another range in the other direction.
                // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
                if (gt && hasDomLT && !lt && gtltComp !== 0) {
                    return false;
                }
                if (lt && hasDomGT && !gt && gtltComp !== 0) {
                    return false;
                }
                // we needed a prerelease range in a specific tuple, but didn't get one
                // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
                // because it includes prereleases in the 1.2.3 tuple
                if (needDomGTPre || needDomLTPre) {
                    return false;
                }
                return true;
            };
            // >=1.2.3 is lower than >1.2.3
            var higherGT = function (a, b, options) {
                if (!a) {
                    return b;
                }
                var comp = compare(a.semver, b.semver, options);
                return comp > 0 ? a
                    : comp < 0 ? b
                        : b.operator === '>' && a.operator === '>=' ? b
                            : a;
            };
            // <=1.2.3 is higher than <1.2.3
            var lowerLT = function (a, b, options) {
                if (!a) {
                    return b;
                }
                var comp = compare(a.semver, b.semver, options);
                return comp < 0 ? a
                    : comp > 0 ? b
                        : b.operator === '<' && a.operator === '<=' ? b
                            : a;
            };
            module.exports = subset;
            /***/ 
        }),
        /***/ 2706: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var Range = __nccwpck_require__(9828);
            // Mostly just for testing and legacy API reasons
            var toComparators = function (range, options) {
                return new Range(range, options).set
                    .map(function (comp) { return comp.map(function (c) { return c.value; }).join(' ').trim().split(' '); });
            };
            module.exports = toComparators;
            /***/ 
        }),
        /***/ 2098: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var Range = __nccwpck_require__(9828);
            var validRange = function (range, options) {
                try {
                    // Return '*' instead of '' so that truthiness works.
                    // This will throw if it's invalid anyway
                    return new Range(range, options).range || '*';
                }
                catch (er) {
                    return null;
                }
            };
            module.exports = validRange;
            /***/ 
        }),
        /***/ 9571: 
        /***/ (function (module) {
            "use strict";
            var ESC = '\x1B';
            var CSI = "".concat(ESC, "[");
            var beep = '\u0007';
            var cursor = {
                to: function (x, y) {
                    if (!y)
                        return "".concat(CSI).concat(x + 1, "G");
                    return "".concat(CSI).concat(y + 1, ";").concat(x + 1, "H");
                },
                move: function (x, y) {
                    var ret = '';
                    if (x < 0)
                        ret += "".concat(CSI).concat(-x, "D");
                    else if (x > 0)
                        ret += "".concat(CSI).concat(x, "C");
                    if (y < 0)
                        ret += "".concat(CSI).concat(-y, "A");
                    else if (y > 0)
                        ret += "".concat(CSI).concat(y, "B");
                    return ret;
                },
                up: function (count) {
                    if (count === void 0) { count = 1; }
                    return "".concat(CSI).concat(count, "A");
                },
                down: function (count) {
                    if (count === void 0) { count = 1; }
                    return "".concat(CSI).concat(count, "B");
                },
                forward: function (count) {
                    if (count === void 0) { count = 1; }
                    return "".concat(CSI).concat(count, "C");
                },
                backward: function (count) {
                    if (count === void 0) { count = 1; }
                    return "".concat(CSI).concat(count, "D");
                },
                nextLine: function (count) {
                    if (count === void 0) { count = 1; }
                    return "".concat(CSI, "E").repeat(count);
                },
                prevLine: function (count) {
                    if (count === void 0) { count = 1; }
                    return "".concat(CSI, "F").repeat(count);
                },
                left: "".concat(CSI, "G"),
                hide: "".concat(CSI, "?25l"),
                show: "".concat(CSI, "?25h"),
                save: "".concat(ESC, "7"),
                restore: "".concat(ESC, "8")
            };
            var scroll = {
                up: function (count) {
                    if (count === void 0) { count = 1; }
                    return "".concat(CSI, "S").repeat(count);
                },
                down: function (count) {
                    if (count === void 0) { count = 1; }
                    return "".concat(CSI, "T").repeat(count);
                }
            };
            var erase = {
                screen: "".concat(CSI, "2J"),
                up: function (count) {
                    if (count === void 0) { count = 1; }
                    return "".concat(CSI, "1J").repeat(count);
                },
                down: function (count) {
                    if (count === void 0) { count = 1; }
                    return "".concat(CSI, "J").repeat(count);
                },
                line: "".concat(CSI, "2K"),
                lineEnd: "".concat(CSI, "K"),
                lineStart: "".concat(CSI, "1K"),
                lines: function (count) {
                    var clear = '';
                    for (var i = 0; i < count; i++)
                        clear += this.line + (i < count - 1 ? cursor.up() : '');
                    if (count)
                        clear += cursor.left;
                    return clear;
                }
            };
            module.exports = { cursor: cursor, scroll: scroll, erase: erase, beep: beep };
            /***/ 
        }),
        /***/ 9318: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var os = __nccwpck_require__(2037);
            var hasFlag = __nccwpck_require__(1621);
            var env = process.env;
            var forceColor;
            if (hasFlag('no-color') ||
                hasFlag('no-colors') ||
                hasFlag('color=false')) {
                forceColor = false;
            }
            else if (hasFlag('color') ||
                hasFlag('colors') ||
                hasFlag('color=true') ||
                hasFlag('color=always')) {
                forceColor = true;
            }
            if ('FORCE_COLOR' in env) {
                forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
            }
            function translateLevel(level) {
                if (level === 0) {
                    return false;
                }
                return {
                    level: level,
                    hasBasic: true,
                    has256: level >= 2,
                    has16m: level >= 3
                };
            }
            function supportsColor(stream) {
                if (forceColor === false) {
                    return 0;
                }
                if (hasFlag('color=16m') ||
                    hasFlag('color=full') ||
                    hasFlag('color=truecolor')) {
                    return 3;
                }
                if (hasFlag('color=256')) {
                    return 2;
                }
                if (stream && !stream.isTTY && forceColor !== true) {
                    return 0;
                }
                var min = forceColor ? 1 : 0;
                if (process.platform === 'win32') {
                    // Node.js 7.5.0 is the first version of Node.js to include a patch to
                    // libuv that enables 256 color output on Windows. Anything earlier and it
                    // won't work. However, here we target Node.js 8 at minimum as it is an LTS
                    // release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
                    // release that supports 256 colors. Windows 10 build 14931 is the first release
                    // that supports 16m/TrueColor.
                    var osRelease = os.release().split('.');
                    if (Number(process.versions.node.split('.')[0]) >= 8 &&
                        Number(osRelease[0]) >= 10 &&
                        Number(osRelease[2]) >= 10586) {
                        return Number(osRelease[2]) >= 14931 ? 3 : 2;
                    }
                    return 1;
                }
                if ('CI' in env) {
                    if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(function (sign) { return sign in env; }) || env.CI_NAME === 'codeship') {
                        return 1;
                    }
                    return min;
                }
                if ('TEAMCITY_VERSION' in env) {
                    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
                }
                if (env.COLORTERM === 'truecolor') {
                    return 3;
                }
                if ('TERM_PROGRAM' in env) {
                    var version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
                    switch (env.TERM_PROGRAM) {
                        case 'iTerm.app':
                            return version >= 3 ? 3 : 2;
                        case 'Apple_Terminal':
                            return 2;
                        // No default
                    }
                }
                if (/-256(color)?$/i.test(env.TERM)) {
                    return 2;
                }
                if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
                    return 1;
                }
                if ('COLORTERM' in env) {
                    return 1;
                }
                if (env.TERM === 'dumb') {
                    return min;
                }
                return min;
            }
            function getSupportLevel(stream) {
                var level = supportsColor(stream);
                return translateLevel(level);
            }
            module.exports = {
                supportsColor: getSupportLevel,
                stdout: getSupportLevel(process.stdout),
                stderr: getSupportLevel(process.stderr)
            };
            /***/ 
        }),
        /***/ 4256: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var punycode = __nccwpck_require__(5477);
            var mappingTable = __nccwpck_require__(2020);
            var PROCESSING_OPTIONS = {
                TRANSITIONAL: 0,
                NONTRANSITIONAL: 1
            };
            function normalize(str) {
                return str.split('\u0000').map(function (s) { return s.normalize('NFC'); }).join('\u0000');
            }
            function findStatus(val) {
                var start = 0;
                var end = mappingTable.length - 1;
                while (start <= end) {
                    var mid = Math.floor((start + end) / 2);
                    var target = mappingTable[mid];
                    if (target[0][0] <= val && target[0][1] >= val) {
                        return target;
                    }
                    else if (target[0][0] > val) {
                        end = mid - 1;
                    }
                    else {
                        start = mid + 1;
                    }
                }
                return null;
            }
            var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
            function countSymbols(string) {
                return string
                    // replace every surrogate pair with a BMP symbol
                    .replace(regexAstralSymbols, '_')
                    // then get the length
                    .length;
            }
            function mapChars(domain_name, useSTD3, processing_option) {
                var hasError = false;
                var processed = "";
                var len = countSymbols(domain_name);
                for (var i = 0; i < len; ++i) {
                    var codePoint = domain_name.codePointAt(i);
                    var status = findStatus(codePoint);
                    switch (status[1]) {
                        case "disallowed":
                            hasError = true;
                            processed += String.fromCodePoint(codePoint);
                            break;
                        case "ignored":
                            break;
                        case "mapped":
                            processed += String.fromCodePoint.apply(String, status[2]);
                            break;
                        case "deviation":
                            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
                                processed += String.fromCodePoint.apply(String, status[2]);
                            }
                            else {
                                processed += String.fromCodePoint(codePoint);
                            }
                            break;
                        case "valid":
                            processed += String.fromCodePoint(codePoint);
                            break;
                        case "disallowed_STD3_mapped":
                            if (useSTD3) {
                                hasError = true;
                                processed += String.fromCodePoint(codePoint);
                            }
                            else {
                                processed += String.fromCodePoint.apply(String, status[2]);
                            }
                            break;
                        case "disallowed_STD3_valid":
                            if (useSTD3) {
                                hasError = true;
                            }
                            processed += String.fromCodePoint(codePoint);
                            break;
                    }
                }
                return {
                    string: processed,
                    error: hasError
                };
            }
            var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
            function validateLabel(label, processing_option) {
                if (label.substr(0, 4) === "xn--") {
                    label = punycode.toUnicode(label);
                    processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
                }
                var error = false;
                if (normalize(label) !== label ||
                    (label[3] === "-" && label[4] === "-") ||
                    label[0] === "-" || label[label.length - 1] === "-" ||
                    label.indexOf(".") !== -1 ||
                    label.search(combiningMarksRegex) === 0) {
                    error = true;
                }
                var len = countSymbols(label);
                for (var i = 0; i < len; ++i) {
                    var status = findStatus(label.codePointAt(i));
                    if ((processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid") ||
                        (processing === PROCESSING_OPTIONS.NONTRANSITIONAL &&
                            status[1] !== "valid" && status[1] !== "deviation")) {
                        error = true;
                        break;
                    }
                }
                return {
                    label: label,
                    error: error
                };
            }
            function processing(domain_name, useSTD3, processing_option) {
                var result = mapChars(domain_name, useSTD3, processing_option);
                result.string = normalize(result.string);
                var labels = result.string.split(".");
                for (var i = 0; i < labels.length; ++i) {
                    try {
                        var validation = validateLabel(labels[i]);
                        labels[i] = validation.label;
                        result.error = result.error || validation.error;
                    }
                    catch (e) {
                        result.error = true;
                    }
                }
                return {
                    string: labels.join("."),
                    error: result.error
                };
            }
            module.exports.toASCII = function (domain_name, useSTD3, processing_option, verifyDnsLength) {
                var result = processing(domain_name, useSTD3, processing_option);
                var labels = result.string.split(".");
                labels = labels.map(function (l) {
                    try {
                        return punycode.toASCII(l);
                    }
                    catch (e) {
                        result.error = true;
                        return l;
                    }
                });
                if (verifyDnsLength) {
                    var total = labels.slice(0, labels.length - 1).join(".").length;
                    if (total.length > 253 || total.length === 0) {
                        result.error = true;
                    }
                    for (var i = 0; i < labels.length; ++i) {
                        if (labels.length > 63 || labels.length === 0) {
                            result.error = true;
                            break;
                        }
                    }
                }
                if (result.error)
                    return null;
                return labels.join(".");
            };
            module.exports.toUnicode = function (domain_name, useSTD3) {
                var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
                return {
                    domain: result.string,
                    error: result.error
                };
            };
            module.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
            /***/ 
        }),
        /***/ 4294: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            module.exports = __nccwpck_require__(4219);
            /***/ 
        }),
        /***/ 4219: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var net = __nccwpck_require__(1808);
            var tls = __nccwpck_require__(4404);
            var http = __nccwpck_require__(3685);
            var https = __nccwpck_require__(5687);
            var events = __nccwpck_require__(2361);
            var assert = __nccwpck_require__(9491);
            var util = __nccwpck_require__(3837);
            exports.httpOverHttp = httpOverHttp;
            exports.httpsOverHttp = httpsOverHttp;
            exports.httpOverHttps = httpOverHttps;
            exports.httpsOverHttps = httpsOverHttps;
            function httpOverHttp(options) {
                var agent = new TunnelingAgent(options);
                agent.request = http.request;
                return agent;
            }
            function httpsOverHttp(options) {
                var agent = new TunnelingAgent(options);
                agent.request = http.request;
                agent.createSocket = createSecureSocket;
                agent.defaultPort = 443;
                return agent;
            }
            function httpOverHttps(options) {
                var agent = new TunnelingAgent(options);
                agent.request = https.request;
                return agent;
            }
            function httpsOverHttps(options) {
                var agent = new TunnelingAgent(options);
                agent.request = https.request;
                agent.createSocket = createSecureSocket;
                agent.defaultPort = 443;
                return agent;
            }
            function TunnelingAgent(options) {
                var self = this;
                self.options = options || {};
                self.proxyOptions = self.options.proxy || {};
                self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
                self.requests = [];
                self.sockets = [];
                self.on('free', function onFree(socket, host, port, localAddress) {
                    var options = toOptions(host, port, localAddress);
                    for (var i = 0, len = self.requests.length; i < len; ++i) {
                        var pending = self.requests[i];
                        if (pending.host === options.host && pending.port === options.port) {
                            // Detect the request to connect same origin server,
                            // reuse the connection.
                            self.requests.splice(i, 1);
                            pending.request.onSocket(socket);
                            return;
                        }
                    }
                    socket.destroy();
                    self.removeSocket(socket);
                });
            }
            util.inherits(TunnelingAgent, events.EventEmitter);
            TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
                var self = this;
                var options = mergeOptions({ request: req }, self.options, toOptions(host, port, localAddress));
                if (self.sockets.length >= this.maxSockets) {
                    // We are over limit so we'll add it to the queue.
                    self.requests.push(options);
                    return;
                }
                // If we are under maxSockets create a new one.
                self.createSocket(options, function (socket) {
                    socket.on('free', onFree);
                    socket.on('close', onCloseOrRemove);
                    socket.on('agentRemove', onCloseOrRemove);
                    req.onSocket(socket);
                    function onFree() {
                        self.emit('free', socket, options);
                    }
                    function onCloseOrRemove(err) {
                        self.removeSocket(socket);
                        socket.removeListener('free', onFree);
                        socket.removeListener('close', onCloseOrRemove);
                        socket.removeListener('agentRemove', onCloseOrRemove);
                    }
                });
            };
            TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
                var self = this;
                var placeholder = {};
                self.sockets.push(placeholder);
                var connectOptions = mergeOptions({}, self.proxyOptions, {
                    method: 'CONNECT',
                    path: options.host + ':' + options.port,
                    agent: false,
                    headers: {
                        host: options.host + ':' + options.port
                    }
                });
                if (options.localAddress) {
                    connectOptions.localAddress = options.localAddress;
                }
                if (connectOptions.proxyAuth) {
                    connectOptions.headers = connectOptions.headers || {};
                    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
                        new Buffer(connectOptions.proxyAuth).toString('base64');
                }
                debug('making CONNECT request');
                var connectReq = self.request(connectOptions);
                connectReq.useChunkedEncodingByDefault = false; // for v0.6
                connectReq.once('response', onResponse); // for v0.6
                connectReq.once('upgrade', onUpgrade); // for v0.6
                connectReq.once('connect', onConnect); // for v0.7 or later
                connectReq.once('error', onError);
                connectReq.end();
                function onResponse(res) {
                    // Very hacky. This is necessary to avoid http-parser leaks.
                    res.upgrade = true;
                }
                function onUpgrade(res, socket, head) {
                    // Hacky.
                    process.nextTick(function () {
                        onConnect(res, socket, head);
                    });
                }
                function onConnect(res, socket, head) {
                    connectReq.removeAllListeners();
                    socket.removeAllListeners();
                    if (res.statusCode !== 200) {
                        debug('tunneling socket could not be established, statusCode=%d', res.statusCode);
                        socket.destroy();
                        var error = new Error('tunneling socket could not be established, ' +
                            'statusCode=' + res.statusCode);
                        error.code = 'ECONNRESET';
                        options.request.emit('error', error);
                        self.removeSocket(placeholder);
                        return;
                    }
                    if (head.length > 0) {
                        debug('got illegal response body from proxy');
                        socket.destroy();
                        var error = new Error('got illegal response body from proxy');
                        error.code = 'ECONNRESET';
                        options.request.emit('error', error);
                        self.removeSocket(placeholder);
                        return;
                    }
                    debug('tunneling connection has established');
                    self.sockets[self.sockets.indexOf(placeholder)] = socket;
                    return cb(socket);
                }
                function onError(cause) {
                    connectReq.removeAllListeners();
                    debug('tunneling socket could not be established, cause=%s\n', cause.message, cause.stack);
                    var error = new Error('tunneling socket could not be established, ' +
                        'cause=' + cause.message);
                    error.code = 'ECONNRESET';
                    options.request.emit('error', error);
                    self.removeSocket(placeholder);
                }
            };
            TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
                var pos = this.sockets.indexOf(socket);
                if (pos === -1) {
                    return;
                }
                this.sockets.splice(pos, 1);
                var pending = this.requests.shift();
                if (pending) {
                    // If we have pending requests and a socket gets closed a new one
                    // needs to be created to take over in the pool for the one that closed.
                    this.createSocket(pending, function (socket) {
                        pending.request.onSocket(socket);
                    });
                }
            };
            function createSecureSocket(options, cb) {
                var self = this;
                TunnelingAgent.prototype.createSocket.call(self, options, function (socket) {
                    var hostHeader = options.request.getHeader('host');
                    var tlsOptions = mergeOptions({}, self.options, {
                        socket: socket,
                        servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
                    });
                    // 0 is dummy port for v0.6
                    var secureSocket = tls.connect(0, tlsOptions);
                    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
                    cb(secureSocket);
                });
            }
            function toOptions(host, port, localAddress) {
                if (typeof host === 'string') { // since v0.10
                    return {
                        host: host,
                        port: port,
                        localAddress: localAddress
                    };
                }
                return host; // for v0.11 or later
            }
            function mergeOptions(target) {
                for (var i = 1, len = arguments.length; i < len; ++i) {
                    var overrides = arguments[i];
                    if (typeof overrides === 'object') {
                        var keys = Object.keys(overrides);
                        for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
                            var k = keys[j];
                            if (overrides[k] !== undefined) {
                                target[k] = overrides[k];
                            }
                        }
                    }
                }
                return target;
            }
            var debug;
            if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
                debug = function () {
                    var args = Array.prototype.slice.call(arguments);
                    if (typeof args[0] === 'string') {
                        args[0] = 'TUNNEL: ' + args[0];
                    }
                    else {
                        args.unshift('TUNNEL:');
                    }
                    console.error.apply(console, args);
                };
            }
            else {
                debug = function () { };
            }
            exports.debug = debug; // for test
            /***/ 
        }),
        /***/ 5030: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            function getUserAgent() {
                if (typeof navigator === "object" && "userAgent" in navigator) {
                    return navigator.userAgent;
                }
                if (typeof process === "object" && "version" in process) {
                    return "Node.js/".concat(process.version.substr(1), " (").concat(process.platform, "; ").concat(process.arch, ")");
                }
                return "<environment undetectable>";
            }
            exports.getUserAgent = getUserAgent;
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 20: 
        /***/ (function (__unused_webpack_module, exports) {
            /** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
            (function (global, factory) {
                true ? factory(exports) :
                    0;
            }(this, (function (exports) {
                'use strict';
                function merge() {
                    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
                        sets[_key] = arguments[_key];
                    }
                    if (sets.length > 1) {
                        sets[0] = sets[0].slice(0, -1);
                        var xl = sets.length - 1;
                        for (var x = 1; x < xl; ++x) {
                            sets[x] = sets[x].slice(1, -1);
                        }
                        sets[xl] = sets[xl].slice(1);
                        return sets.join('');
                    }
                    else {
                        return sets[0];
                    }
                }
                function subexp(str) {
                    return "(?:" + str + ")";
                }
                function typeOf(o) {
                    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
                }
                function toUpperCase(str) {
                    return str.toUpperCase();
                }
                function toArray(obj) {
                    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
                }
                function assign(target, source) {
                    var obj = target;
                    if (source) {
                        for (var key in source) {
                            obj[key] = source[key];
                        }
                    }
                    return obj;
                }
                function buildExps(isIRI) {
                    var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"), 
                    //case-insensitive
                    LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)), 
                    //expanded
                    GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", 
                    //subset, excludes bidi control characters
                    IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", 
                    //subset
                    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), 
                    //relaxed parsing rules
                    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$ + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), 
                    //                           6( h16 ":" ) ls32
                    IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), 
                    //                      "::" 5( h16 ":" ) ls32
                    IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), 
                    //[               h16 ] "::" 4( h16 ":" ) ls32
                    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), 
                    //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
                    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), 
                    //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
                    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), 
                    //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
                    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), 
                    //[ *4( h16 ":" ) h16 ] "::"              ls32
                    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), 
                    //[ *5( h16 ":" ) h16 ] "::"              h16
                    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), 
                    //[ *6( h16 ":" ) h16 ] "::"
                    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"), 
                    //RFC 6874
                    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), 
                    //RFC 6874
                    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + ZONEID$), 
                    //RFC 6874, with relaxed parsing rules
                    IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), 
                    //RFC 6874
                    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")" + "|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), 
                    //simplified
                    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), 
                    //simplified
                    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), 
                    //simplified
                    PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
                    return {
                        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
                        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
                        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
                        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
                        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
                        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
                        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
                        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
                        UNRESERVED: new RegExp(UNRESERVED$$, "g"),
                        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
                        PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
                        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
                        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules
                    };
                }
                var URI_PROTOCOL = buildExps(false);
                var IRI_PROTOCOL = buildExps(true);
                var slicedToArray = function () {
                    function sliceIterator(arr, i) {
                        var _arr = [];
                        var _n = true;
                        var _d = false;
                        var _e = undefined;
                        try {
                            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                                _arr.push(_s.value);
                                if (i && _arr.length === i)
                                    break;
                            }
                        }
                        catch (err) {
                            _d = true;
                            _e = err;
                        }
                        finally {
                            try {
                                if (!_n && _i["return"])
                                    _i["return"]();
                            }
                            finally {
                                if (_d)
                                    throw _e;
                            }
                        }
                        return _arr;
                    }
                    return function (arr, i) {
                        if (Array.isArray(arr)) {
                            return arr;
                        }
                        else if (Symbol.iterator in Object(arr)) {
                            return sliceIterator(arr, i);
                        }
                        else {
                            throw new TypeError("Invalid attempt to destructure non-iterable instance");
                        }
                    };
                }();
                var toConsumableArray = function (arr) {
                    if (Array.isArray(arr)) {
                        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
                            arr2[i] = arr[i];
                        return arr2;
                    }
                    else {
                        return Array.from(arr);
                    }
                };
                /** Highest positive signed 32-bit float value */
                var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
                /** Bootstring parameters */
                var base = 36;
                var tMin = 1;
                var tMax = 26;
                var skew = 38;
                var damp = 700;
                var initialBias = 72;
                var initialN = 128; // 0x80
                var delimiter = '-'; // '\x2D'
                /** Regular expressions */
                var regexPunycode = /^xn--/;
                var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
                var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
                /** Error messages */
                var errors = {
                    'overflow': 'Overflow: input needs wider integers to process',
                    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
                    'invalid-input': 'Invalid input'
                };
                /** Convenience shortcuts */
                var baseMinusTMin = base - tMin;
                var floor = Math.floor;
                var stringFromCharCode = String.fromCharCode;
                /*--------------------------------------------------------------------------*/
                /**
                 * A generic error utility function.
                 * @private
                 * @param {String} type The error type.
                 * @returns {Error} Throws a `RangeError` with the applicable error message.
                 */
                function error$1(type) {
                    throw new RangeError(errors[type]);
                }
                /**
                 * A generic `Array#map` utility function.
                 * @private
                 * @param {Array} array The array to iterate over.
                 * @param {Function} callback The function that gets called for every array
                 * item.
                 * @returns {Array} A new array of values returned by the callback function.
                 */
                function map(array, fn) {
                    var result = [];
                    var length = array.length;
                    while (length--) {
                        result[length] = fn(array[length]);
                    }
                    return result;
                }
                /**
                 * A simple `Array#map`-like wrapper to work with domain name strings or email
                 * addresses.
                 * @private
                 * @param {String} domain The domain name or email address.
                 * @param {Function} callback The function that gets called for every
                 * character.
                 * @returns {Array} A new string of characters returned by the callback
                 * function.
                 */
                function mapDomain(string, fn) {
                    var parts = string.split('@');
                    var result = '';
                    if (parts.length > 1) {
                        // In email addresses, only the domain name should be punycoded. Leave
                        // the local part (i.e. everything up to `@`) intact.
                        result = parts[0] + '@';
                        string = parts[1];
                    }
                    // Avoid `split(regex)` for IE8 compatibility. See #17.
                    string = string.replace(regexSeparators, '\x2E');
                    var labels = string.split('.');
                    var encoded = map(labels, fn).join('.');
                    return result + encoded;
                }
                /**
                 * Creates an array containing the numeric code points of each Unicode
                 * character in the string. While JavaScript uses UCS-2 internally,
                 * this function will convert a pair of surrogate halves (each of which
                 * UCS-2 exposes as separate characters) into a single code point,
                 * matching UTF-16.
                 * @see `punycode.ucs2.encode`
                 * @see <https://mathiasbynens.be/notes/javascript-encoding>
                 * @memberOf punycode.ucs2
                 * @name decode
                 * @param {String} string The Unicode input string (UCS-2).
                 * @returns {Array} The new array of code points.
                 */
                function ucs2decode(string) {
                    var output = [];
                    var counter = 0;
                    var length = string.length;
                    while (counter < length) {
                        var value = string.charCodeAt(counter++);
                        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                            // It's a high surrogate, and there is a next character.
                            var extra = string.charCodeAt(counter++);
                            if ((extra & 0xFC00) == 0xDC00) {
                                // Low surrogate.
                                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                            }
                            else {
                                // It's an unmatched surrogate; only append this code unit, in case the
                                // next code unit is the high surrogate of a surrogate pair.
                                output.push(value);
                                counter--;
                            }
                        }
                        else {
                            output.push(value);
                        }
                    }
                    return output;
                }
                /**
                 * Creates a string based on an array of numeric code points.
                 * @see `punycode.ucs2.decode`
                 * @memberOf punycode.ucs2
                 * @name encode
                 * @param {Array} codePoints The array of numeric code points.
                 * @returns {String} The new Unicode string (UCS-2).
                 */
                var ucs2encode = function ucs2encode(array) {
                    return String.fromCodePoint.apply(String, toConsumableArray(array));
                };
                /**
                 * Converts a basic code point into a digit/integer.
                 * @see `digitToBasic()`
                 * @private
                 * @param {Number} codePoint The basic numeric code point value.
                 * @returns {Number} The numeric value of a basic code point (for use in
                 * representing integers) in the range `0` to `base - 1`, or `base` if
                 * the code point does not represent a value.
                 */
                var basicToDigit = function basicToDigit(codePoint) {
                    if (codePoint - 0x30 < 0x0A) {
                        return codePoint - 0x16;
                    }
                    if (codePoint - 0x41 < 0x1A) {
                        return codePoint - 0x41;
                    }
                    if (codePoint - 0x61 < 0x1A) {
                        return codePoint - 0x61;
                    }
                    return base;
                };
                /**
                 * Converts a digit/integer into a basic code point.
                 * @see `basicToDigit()`
                 * @private
                 * @param {Number} digit The numeric value of a basic code point.
                 * @returns {Number} The basic code point whose value (when used for
                 * representing integers) is `digit`, which needs to be in the range
                 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
                 * used; else, the lowercase form is used. The behavior is undefined
                 * if `flag` is non-zero and `digit` has no uppercase form.
                 */
                var digitToBasic = function digitToBasic(digit, flag) {
                    //  0..25 map to ASCII a..z or A..Z
                    // 26..35 map to ASCII 0..9
                    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
                };
                /**
                 * Bias adaptation function as per section 3.4 of RFC 3492.
                 * https://tools.ietf.org/html/rfc3492#section-3.4
                 * @private
                 */
                var adapt = function adapt(delta, numPoints, firstTime) {
                    var k = 0;
                    delta = firstTime ? floor(delta / damp) : delta >> 1;
                    delta += floor(delta / numPoints);
                    for (; /* no initialization */ delta > baseMinusTMin * tMax >> 1; k += base) {
                        delta = floor(delta / baseMinusTMin);
                    }
                    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
                };
                /**
                 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
                 * symbols.
                 * @memberOf punycode
                 * @param {String} input The Punycode string of ASCII-only symbols.
                 * @returns {String} The resulting string of Unicode symbols.
                 */
                var decode = function decode(input) {
                    // Don't use UCS-2.
                    var output = [];
                    var inputLength = input.length;
                    var i = 0;
                    var n = initialN;
                    var bias = initialBias;
                    // Handle the basic code points: let `basic` be the number of input code
                    // points before the last delimiter, or `0` if there is none, then copy
                    // the first basic code points to the output.
                    var basic = input.lastIndexOf(delimiter);
                    if (basic < 0) {
                        basic = 0;
                    }
                    for (var j = 0; j < basic; ++j) {
                        // if it's not a basic code point
                        if (input.charCodeAt(j) >= 0x80) {
                            error$1('not-basic');
                        }
                        output.push(input.charCodeAt(j));
                    }
                    // Main decoding loop: start just after the last delimiter if any basic code
                    // points were copied; start at the beginning otherwise.
                    for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */ {
                        // `index` is the index of the next character to be consumed.
                        // Decode a generalized variable-length integer into `delta`,
                        // which gets added to `i`. The overflow checking is easier
                        // if we increase `i` as we go, then subtract off its starting
                        // value at the end to obtain `delta`.
                        var oldi = i;
                        for (var w = 1, k = base;; /* no condition */ k += base) {
                            if (index >= inputLength) {
                                error$1('invalid-input');
                            }
                            var digit = basicToDigit(input.charCodeAt(index++));
                            if (digit >= base || digit > floor((maxInt - i) / w)) {
                                error$1('overflow');
                            }
                            i += digit * w;
                            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                            if (digit < t) {
                                break;
                            }
                            var baseMinusT = base - t;
                            if (w > floor(maxInt / baseMinusT)) {
                                error$1('overflow');
                            }
                            w *= baseMinusT;
                        }
                        var out = output.length + 1;
                        bias = adapt(i - oldi, out, oldi == 0);
                        // `i` was supposed to wrap around from `out` to `0`,
                        // incrementing `n` each time, so we'll fix that now:
                        if (floor(i / out) > maxInt - n) {
                            error$1('overflow');
                        }
                        n += floor(i / out);
                        i %= out;
                        // Insert `n` at position `i` of the output.
                        output.splice(i++, 0, n);
                    }
                    return String.fromCodePoint.apply(String, output);
                };
                /**
                 * Converts a string of Unicode symbols (e.g. a domain name label) to a
                 * Punycode string of ASCII-only symbols.
                 * @memberOf punycode
                 * @param {String} input The string of Unicode symbols.
                 * @returns {String} The resulting Punycode string of ASCII-only symbols.
                 */
                var encode = function encode(input) {
                    var output = [];
                    // Convert the input in UCS-2 to an array of Unicode code points.
                    input = ucs2decode(input);
                    // Cache the length.
                    var inputLength = input.length;
                    // Initialize the state.
                    var n = initialN;
                    var delta = 0;
                    var bias = initialBias;
                    // Handle the basic code points.
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;
                    try {
                        for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var _currentValue2 = _step.value;
                            if (_currentValue2 < 0x80) {
                                output.push(stringFromCharCode(_currentValue2));
                            }
                        }
                    }
                    catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    }
                    finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator["return"]) {
                                _iterator["return"]();
                            }
                        }
                        finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                    var basicLength = output.length;
                    var handledCPCount = basicLength;
                    // `handledCPCount` is the number of code points that have been handled;
                    // `basicLength` is the number of basic code points.
                    // Finish the basic string with a delimiter unless it's empty.
                    if (basicLength) {
                        output.push(delimiter);
                    }
                    // Main encoding loop:
                    while (handledCPCount < inputLength) {
                        // All non-basic code points < n have been handled already. Find the next
                        // larger one:
                        var m = maxInt;
                        var _iteratorNormalCompletion2 = true;
                        var _didIteratorError2 = false;
                        var _iteratorError2 = undefined;
                        try {
                            for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                var currentValue = _step2.value;
                                if (currentValue >= n && currentValue < m) {
                                    m = currentValue;
                                }
                            }
                            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                            // but guard against overflow.
                        }
                        catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                        }
                        finally {
                            try {
                                if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                                    _iterator2["return"]();
                                }
                            }
                            finally {
                                if (_didIteratorError2) {
                                    throw _iteratorError2;
                                }
                            }
                        }
                        var handledCPCountPlusOne = handledCPCount + 1;
                        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                            error$1('overflow');
                        }
                        delta += (m - n) * handledCPCountPlusOne;
                        n = m;
                        var _iteratorNormalCompletion3 = true;
                        var _didIteratorError3 = false;
                        var _iteratorError3 = undefined;
                        try {
                            for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                                var _currentValue = _step3.value;
                                if (_currentValue < n && ++delta > maxInt) {
                                    error$1('overflow');
                                }
                                if (_currentValue == n) {
                                    // Represent delta as a generalized variable-length integer.
                                    var q = delta;
                                    for (var k = base;; /* no condition */ k += base) {
                                        var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                                        if (q < t) {
                                            break;
                                        }
                                        var qMinusT = q - t;
                                        var baseMinusT = base - t;
                                        output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                                        q = floor(qMinusT / baseMinusT);
                                    }
                                    output.push(stringFromCharCode(digitToBasic(q, 0)));
                                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                                    delta = 0;
                                    ++handledCPCount;
                                }
                            }
                        }
                        catch (err) {
                            _didIteratorError3 = true;
                            _iteratorError3 = err;
                        }
                        finally {
                            try {
                                if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
                                    _iterator3["return"]();
                                }
                            }
                            finally {
                                if (_didIteratorError3) {
                                    throw _iteratorError3;
                                }
                            }
                        }
                        ++delta;
                        ++n;
                    }
                    return output.join('');
                };
                /**
                 * Converts a Punycode string representing a domain name or an email address
                 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
                 * it doesn't matter if you call it on a string that has already been
                 * converted to Unicode.
                 * @memberOf punycode
                 * @param {String} input The Punycoded domain name or email address to
                 * convert to Unicode.
                 * @returns {String} The Unicode representation of the given Punycode
                 * string.
                 */
                var toUnicode = function toUnicode(input) {
                    return mapDomain(input, function (string) {
                        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
                    });
                };
                /**
                 * Converts a Unicode string representing a domain name or an email address to
                 * Punycode. Only the non-ASCII parts of the domain name will be converted,
                 * i.e. it doesn't matter if you call it with a domain that's already in
                 * ASCII.
                 * @memberOf punycode
                 * @param {String} input The domain name or email address to convert, as a
                 * Unicode string.
                 * @returns {String} The Punycode representation of the given domain name or
                 * email address.
                 */
                var toASCII = function toASCII(input) {
                    return mapDomain(input, function (string) {
                        return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
                    });
                };
                /*--------------------------------------------------------------------------*/
                /** Define the public API */
                var punycode = {
                    /**
                  * A string representing the current Punycode.js version number.
                  * @memberOf punycode
                  * @type String
                  */
                    'version': '2.1.0',
                    /**
                  * An object of methods to convert from JavaScript's internal character
                  * representation (UCS-2) to Unicode code points, and back.
                  * @see <https://mathiasbynens.be/notes/javascript-encoding>
                  * @memberOf punycode
                  * @type Object
                  */
                    'ucs2': {
                        'decode': ucs2decode,
                        'encode': ucs2encode
                    },
                    'decode': decode,
                    'encode': encode,
                    'toASCII': toASCII,
                    'toUnicode': toUnicode
                };
                /**
                 * URI.js
                 *
                 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
                 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
                 * @see http://github.com/garycourt/uri-js
                 */
                /**
                 * Copyright 2011 Gary Court. All rights reserved.
                 *
                 * Redistribution and use in source and binary forms, with or without modification, are
                 * permitted provided that the following conditions are met:
                 *
                 *    1. Redistributions of source code must retain the above copyright notice, this list of
                 *       conditions and the following disclaimer.
                 *
                 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
                 *       of conditions and the following disclaimer in the documentation and/or other materials
                 *       provided with the distribution.
                 *
                 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
                 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
                 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
                 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
                 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
                 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                 *
                 * The views and conclusions contained in the software and documentation are those of the
                 * authors and should not be interpreted as representing official policies, either expressed
                 * or implied, of Gary Court.
                 */
                var SCHEMES = {};
                function pctEncChar(chr) {
                    var c = chr.charCodeAt(0);
                    var e = void 0;
                    if (c < 16)
                        e = "%0" + c.toString(16).toUpperCase();
                    else if (c < 128)
                        e = "%" + c.toString(16).toUpperCase();
                    else if (c < 2048)
                        e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
                    else
                        e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
                    return e;
                }
                function pctDecChars(str) {
                    var newStr = "";
                    var i = 0;
                    var il = str.length;
                    while (i < il) {
                        var c = parseInt(str.substr(i + 1, 2), 16);
                        if (c < 128) {
                            newStr += String.fromCharCode(c);
                            i += 3;
                        }
                        else if (c >= 194 && c < 224) {
                            if (il - i >= 6) {
                                var c2 = parseInt(str.substr(i + 4, 2), 16);
                                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
                            }
                            else {
                                newStr += str.substr(i, 6);
                            }
                            i += 6;
                        }
                        else if (c >= 224) {
                            if (il - i >= 9) {
                                var _c = parseInt(str.substr(i + 4, 2), 16);
                                var c3 = parseInt(str.substr(i + 7, 2), 16);
                                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
                            }
                            else {
                                newStr += str.substr(i, 9);
                            }
                            i += 9;
                        }
                        else {
                            newStr += str.substr(i, 3);
                            i += 3;
                        }
                    }
                    return newStr;
                }
                function _normalizeComponentEncoding(components, protocol) {
                    function decodeUnreserved(str) {
                        var decStr = pctDecChars(str);
                        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
                    }
                    if (components.scheme)
                        components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
                    if (components.userinfo !== undefined)
                        components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
                    if (components.host !== undefined)
                        components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
                    if (components.path !== undefined)
                        components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
                    if (components.query !== undefined)
                        components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
                    if (components.fragment !== undefined)
                        components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
                    return components;
                }
                function _stripLeadingZeros(str) {
                    return str.replace(/^0*(.*)/, "$1") || "0";
                }
                function _normalizeIPv4(host, protocol) {
                    var matches = host.match(protocol.IPV4ADDRESS) || [];
                    var _matches = slicedToArray(matches, 2), address = _matches[1];
                    if (address) {
                        return address.split(".").map(_stripLeadingZeros).join(".");
                    }
                    else {
                        return host;
                    }
                }
                function _normalizeIPv6(host, protocol) {
                    var matches = host.match(protocol.IPV6ADDRESS) || [];
                    var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
                    if (address) {
                        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
                        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
                        var lastFields = last.split(":").map(_stripLeadingZeros);
                        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
                        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
                        var lastFieldsStart = lastFields.length - fieldCount;
                        var fields = Array(fieldCount);
                        for (var x = 0; x < fieldCount; ++x) {
                            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
                        }
                        if (isLastFieldIPv4Address) {
                            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
                        }
                        var allZeroFields = fields.reduce(function (acc, field, index) {
                            if (!field || field === "0") {
                                var lastLongest = acc[acc.length - 1];
                                if (lastLongest && lastLongest.index + lastLongest.length === index) {
                                    lastLongest.length++;
                                }
                                else {
                                    acc.push({ index: index, length: 1 });
                                }
                            }
                            return acc;
                        }, []);
                        var longestZeroFields = allZeroFields.sort(function (a, b) {
                            return b.length - a.length;
                        })[0];
                        var newHost = void 0;
                        if (longestZeroFields && longestZeroFields.length > 1) {
                            var newFirst = fields.slice(0, longestZeroFields.index);
                            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
                            newHost = newFirst.join(":") + "::" + newLast.join(":");
                        }
                        else {
                            newHost = fields.join(":");
                        }
                        if (zone) {
                            newHost += "%" + zone;
                        }
                        return newHost;
                    }
                    else {
                        return host;
                    }
                }
                var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
                var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
                function parse(uriString) {
                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                    var components = {};
                    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
                    if (options.reference === "suffix")
                        uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
                    var matches = uriString.match(URI_PARSE);
                    if (matches) {
                        if (NO_MATCH_IS_UNDEFINED) {
                            //store each component
                            components.scheme = matches[1];
                            components.userinfo = matches[3];
                            components.host = matches[4];
                            components.port = parseInt(matches[5], 10);
                            components.path = matches[6] || "";
                            components.query = matches[7];
                            components.fragment = matches[8];
                            //fix port number
                            if (isNaN(components.port)) {
                                components.port = matches[5];
                            }
                        }
                        else {
                            //IE FIX for improper RegExp matching
                            //store each component
                            components.scheme = matches[1] || undefined;
                            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
                            components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
                            components.port = parseInt(matches[5], 10);
                            components.path = matches[6] || "";
                            components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
                            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
                            //fix port number
                            if (isNaN(components.port)) {
                                components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
                            }
                        }
                        if (components.host) {
                            //normalize IP hosts
                            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
                        }
                        //determine reference type
                        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
                            components.reference = "same-document";
                        }
                        else if (components.scheme === undefined) {
                            components.reference = "relative";
                        }
                        else if (components.fragment === undefined) {
                            components.reference = "absolute";
                        }
                        else {
                            components.reference = "uri";
                        }
                        //check for reference errors
                        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
                            components.error = components.error || "URI is not a " + options.reference + " reference.";
                        }
                        //find scheme handler
                        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
                        //check if scheme can't handle IRIs
                        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
                            //if host component is a domain name
                            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
                                //convert Unicode IDN -> ASCII IDN
                                try {
                                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                                }
                                catch (e) {
                                    components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                                }
                            }
                            //convert IRI -> URI
                            _normalizeComponentEncoding(components, URI_PROTOCOL);
                        }
                        else {
                            //normalize encodings
                            _normalizeComponentEncoding(components, protocol);
                        }
                        //perform scheme specific parsing
                        if (schemeHandler && schemeHandler.parse) {
                            schemeHandler.parse(components, options);
                        }
                    }
                    else {
                        components.error = components.error || "URI can not be parsed.";
                    }
                    return components;
                }
                function _recomposeAuthority(components, options) {
                    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
                    var uriTokens = [];
                    if (components.userinfo !== undefined) {
                        uriTokens.push(components.userinfo);
                        uriTokens.push("@");
                    }
                    if (components.host !== undefined) {
                        //normalize IP hosts, add brackets and escape zone separator for IPv6
                        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
                            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
                        }));
                    }
                    if (typeof components.port === "number" || typeof components.port === "string") {
                        uriTokens.push(":");
                        uriTokens.push(String(components.port));
                    }
                    return uriTokens.length ? uriTokens.join("") : undefined;
                }
                var RDS1 = /^\.\.?\//;
                var RDS2 = /^\/\.(\/|$)/;
                var RDS3 = /^\/\.\.(\/|$)/;
                var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
                function removeDotSegments(input) {
                    var output = [];
                    while (input.length) {
                        if (input.match(RDS1)) {
                            input = input.replace(RDS1, "");
                        }
                        else if (input.match(RDS2)) {
                            input = input.replace(RDS2, "/");
                        }
                        else if (input.match(RDS3)) {
                            input = input.replace(RDS3, "/");
                            output.pop();
                        }
                        else if (input === "." || input === "..") {
                            input = "";
                        }
                        else {
                            var im = input.match(RDS5);
                            if (im) {
                                var s = im[0];
                                input = input.slice(s.length);
                                output.push(s);
                            }
                            else {
                                throw new Error("Unexpected dot segment condition");
                            }
                        }
                    }
                    return output.join("");
                }
                function serialize(components) {
                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
                    var uriTokens = [];
                    //find scheme handler
                    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
                    //perform scheme specific serialization
                    if (schemeHandler && schemeHandler.serialize)
                        schemeHandler.serialize(components, options);
                    if (components.host) {
                        //if host component is an IPv6 address
                        if (protocol.IPV6ADDRESS.test(components.host)) { }
                        //TODO: normalize IPv6 address as per RFC 5952
                        //if host component is a domain name
                        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
                            //convert IDN via punycode
                            try {
                                components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
                            }
                            catch (e) {
                                components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                            }
                        }
                    }
                    //normalize encoding
                    _normalizeComponentEncoding(components, protocol);
                    if (options.reference !== "suffix" && components.scheme) {
                        uriTokens.push(components.scheme);
                        uriTokens.push(":");
                    }
                    var authority = _recomposeAuthority(components, options);
                    if (authority !== undefined) {
                        if (options.reference !== "suffix") {
                            uriTokens.push("//");
                        }
                        uriTokens.push(authority);
                        if (components.path && components.path.charAt(0) !== "/") {
                            uriTokens.push("/");
                        }
                    }
                    if (components.path !== undefined) {
                        var s = components.path;
                        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
                            s = removeDotSegments(s);
                        }
                        if (authority === undefined) {
                            s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
                        }
                        uriTokens.push(s);
                    }
                    if (components.query !== undefined) {
                        uriTokens.push("?");
                        uriTokens.push(components.query);
                    }
                    if (components.fragment !== undefined) {
                        uriTokens.push("#");
                        uriTokens.push(components.fragment);
                    }
                    return uriTokens.join(""); //merge tokens into a string
                }
                function resolveComponents(base, relative) {
                    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                    var skipNormalization = arguments[3];
                    var target = {};
                    if (!skipNormalization) {
                        base = parse(serialize(base, options), options); //normalize base components
                        relative = parse(serialize(relative, options), options); //normalize relative components
                    }
                    options = options || {};
                    if (!options.tolerant && relative.scheme) {
                        target.scheme = relative.scheme;
                        //target.authority = relative.authority;
                        target.userinfo = relative.userinfo;
                        target.host = relative.host;
                        target.port = relative.port;
                        target.path = removeDotSegments(relative.path || "");
                        target.query = relative.query;
                    }
                    else {
                        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
                            //target.authority = relative.authority;
                            target.userinfo = relative.userinfo;
                            target.host = relative.host;
                            target.port = relative.port;
                            target.path = removeDotSegments(relative.path || "");
                            target.query = relative.query;
                        }
                        else {
                            if (!relative.path) {
                                target.path = base.path;
                                if (relative.query !== undefined) {
                                    target.query = relative.query;
                                }
                                else {
                                    target.query = base.query;
                                }
                            }
                            else {
                                if (relative.path.charAt(0) === "/") {
                                    target.path = removeDotSegments(relative.path);
                                }
                                else {
                                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
                                        target.path = "/" + relative.path;
                                    }
                                    else if (!base.path) {
                                        target.path = relative.path;
                                    }
                                    else {
                                        target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
                                    }
                                    target.path = removeDotSegments(target.path);
                                }
                                target.query = relative.query;
                            }
                            //target.authority = base.authority;
                            target.userinfo = base.userinfo;
                            target.host = base.host;
                            target.port = base.port;
                        }
                        target.scheme = base.scheme;
                    }
                    target.fragment = relative.fragment;
                    return target;
                }
                function resolve(baseURI, relativeURI, options) {
                    var schemelessOptions = assign({ scheme: 'null' }, options);
                    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
                }
                function normalize(uri, options) {
                    if (typeof uri === "string") {
                        uri = serialize(parse(uri, options), options);
                    }
                    else if (typeOf(uri) === "object") {
                        uri = parse(serialize(uri, options), options);
                    }
                    return uri;
                }
                function equal(uriA, uriB, options) {
                    if (typeof uriA === "string") {
                        uriA = serialize(parse(uriA, options), options);
                    }
                    else if (typeOf(uriA) === "object") {
                        uriA = serialize(uriA, options);
                    }
                    if (typeof uriB === "string") {
                        uriB = serialize(parse(uriB, options), options);
                    }
                    else if (typeOf(uriB) === "object") {
                        uriB = serialize(uriB, options);
                    }
                    return uriA === uriB;
                }
                function escapeComponent(str, options) {
                    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
                }
                function unescapeComponent(str, options) {
                    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
                }
                var handler = {
                    scheme: "http",
                    domainHost: true,
                    parse: function parse(components, options) {
                        //report missing host
                        if (!components.host) {
                            components.error = components.error || "HTTP URIs must have a host.";
                        }
                        return components;
                    },
                    serialize: function serialize(components, options) {
                        var secure = String(components.scheme).toLowerCase() === "https";
                        //normalize the default port
                        if (components.port === (secure ? 443 : 80) || components.port === "") {
                            components.port = undefined;
                        }
                        //normalize the empty path
                        if (!components.path) {
                            components.path = "/";
                        }
                        //NOTE: We do not parse query strings for HTTP URIs
                        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
                        //and not the HTTP spec.
                        return components;
                    }
                };
                var handler$1 = {
                    scheme: "https",
                    domainHost: handler.domainHost,
                    parse: handler.parse,
                    serialize: handler.serialize
                };
                function isSecure(wsComponents) {
                    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
                }
                //RFC 6455
                var handler$2 = {
                    scheme: "ws",
                    domainHost: true,
                    parse: function parse(components, options) {
                        var wsComponents = components;
                        //indicate if the secure flag is set
                        wsComponents.secure = isSecure(wsComponents);
                        //construct resouce name
                        wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');
                        wsComponents.path = undefined;
                        wsComponents.query = undefined;
                        return wsComponents;
                    },
                    serialize: function serialize(wsComponents, options) {
                        //normalize the default port
                        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
                            wsComponents.port = undefined;
                        }
                        //ensure scheme matches secure flag
                        if (typeof wsComponents.secure === 'boolean') {
                            wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';
                            wsComponents.secure = undefined;
                        }
                        //reconstruct path from resource name
                        if (wsComponents.resourceName) {
                            var _wsComponents$resourc = wsComponents.resourceName.split('?'), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
                            wsComponents.path = path && path !== '/' ? path : undefined;
                            wsComponents.query = query;
                            wsComponents.resourceName = undefined;
                        }
                        //forbid fragment component
                        wsComponents.fragment = undefined;
                        return wsComponents;
                    }
                };
                var handler$3 = {
                    scheme: "wss",
                    domainHost: handler$2.domainHost,
                    parse: handler$2.parse,
                    serialize: handler$2.serialize
                };
                var O = {};
                var isIRI = true;
                //RFC 3986
                var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
                var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
                var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
                //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
                //const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
                //const WSP$$ = "[\\x20\\x09]";
                //const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
                //const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
                //const VCHAR$$ = "[\\x21-\\x7E]";
                //const WSP$$ = "[\\x20\\x09]";
                //const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
                //const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
                //const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
                //const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
                var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
                var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
                var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
                var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
                var UNRESERVED = new RegExp(UNRESERVED$$, "g");
                var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
                var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
                var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
                var NOT_HFVALUE = NOT_HFNAME;
                function decodeUnreserved(str) {
                    var decStr = pctDecChars(str);
                    return !decStr.match(UNRESERVED) ? str : decStr;
                }
                var handler$4 = {
                    scheme: "mailto",
                    parse: function parse$$1(components, options) {
                        var mailtoComponents = components;
                        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
                        mailtoComponents.path = undefined;
                        if (mailtoComponents.query) {
                            var unknownHeaders = false;
                            var headers = {};
                            var hfields = mailtoComponents.query.split("&");
                            for (var x = 0, xl = hfields.length; x < xl; ++x) {
                                var hfield = hfields[x].split("=");
                                switch (hfield[0]) {
                                    case "to":
                                        var toAddrs = hfield[1].split(",");
                                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                                            to.push(toAddrs[_x]);
                                        }
                                        break;
                                    case "subject":
                                        mailtoComponents.subject = unescapeComponent(hfield[1], options);
                                        break;
                                    case "body":
                                        mailtoComponents.body = unescapeComponent(hfield[1], options);
                                        break;
                                    default:
                                        unknownHeaders = true;
                                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                                        break;
                                }
                            }
                            if (unknownHeaders)
                                mailtoComponents.headers = headers;
                        }
                        mailtoComponents.query = undefined;
                        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
                            var addr = to[_x2].split("@");
                            addr[0] = unescapeComponent(addr[0]);
                            if (!options.unicodeSupport) {
                                //convert Unicode IDN -> ASCII IDN
                                try {
                                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                                }
                                catch (e) {
                                    mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                                }
                            }
                            else {
                                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
                            }
                            to[_x2] = addr.join("@");
                        }
                        return mailtoComponents;
                    },
                    serialize: function serialize$$1(mailtoComponents, options) {
                        var components = mailtoComponents;
                        var to = toArray(mailtoComponents.to);
                        if (to) {
                            for (var x = 0, xl = to.length; x < xl; ++x) {
                                var toAddr = String(to[x]);
                                var atIdx = toAddr.lastIndexOf("@");
                                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                                var domain = toAddr.slice(atIdx + 1);
                                //convert IDN via punycode
                                try {
                                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                                }
                                catch (e) {
                                    components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                                }
                                to[x] = localPart + "@" + domain;
                            }
                            components.path = to.join(",");
                        }
                        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
                        if (mailtoComponents.subject)
                            headers["subject"] = mailtoComponents.subject;
                        if (mailtoComponents.body)
                            headers["body"] = mailtoComponents.body;
                        var fields = [];
                        for (var name in headers) {
                            if (headers[name] !== O[name]) {
                                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
                            }
                        }
                        if (fields.length) {
                            components.query = fields.join("&");
                        }
                        return components;
                    }
                };
                var URN_PARSE = /^([^\:]+)\:(.*)/;
                //RFC 2141
                var handler$5 = {
                    scheme: "urn",
                    parse: function parse$$1(components, options) {
                        var matches = components.path && components.path.match(URN_PARSE);
                        var urnComponents = components;
                        if (matches) {
                            var scheme = options.scheme || urnComponents.scheme || "urn";
                            var nid = matches[1].toLowerCase();
                            var nss = matches[2];
                            var urnScheme = scheme + ":" + (options.nid || nid);
                            var schemeHandler = SCHEMES[urnScheme];
                            urnComponents.nid = nid;
                            urnComponents.nss = nss;
                            urnComponents.path = undefined;
                            if (schemeHandler) {
                                urnComponents = schemeHandler.parse(urnComponents, options);
                            }
                        }
                        else {
                            urnComponents.error = urnComponents.error || "URN can not be parsed.";
                        }
                        return urnComponents;
                    },
                    serialize: function serialize$$1(urnComponents, options) {
                        var scheme = options.scheme || urnComponents.scheme || "urn";
                        var nid = urnComponents.nid;
                        var urnScheme = scheme + ":" + (options.nid || nid);
                        var schemeHandler = SCHEMES[urnScheme];
                        if (schemeHandler) {
                            urnComponents = schemeHandler.serialize(urnComponents, options);
                        }
                        var uriComponents = urnComponents;
                        var nss = urnComponents.nss;
                        uriComponents.path = (nid || options.nid) + ":" + nss;
                        return uriComponents;
                    }
                };
                var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
                //RFC 4122
                var handler$6 = {
                    scheme: "urn:uuid",
                    parse: function parse(urnComponents, options) {
                        var uuidComponents = urnComponents;
                        uuidComponents.uuid = uuidComponents.nss;
                        uuidComponents.nss = undefined;
                        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
                            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
                        }
                        return uuidComponents;
                    },
                    serialize: function serialize(uuidComponents, options) {
                        var urnComponents = uuidComponents;
                        //normalize UUID
                        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
                        return urnComponents;
                    }
                };
                SCHEMES[handler.scheme] = handler;
                SCHEMES[handler$1.scheme] = handler$1;
                SCHEMES[handler$2.scheme] = handler$2;
                SCHEMES[handler$3.scheme] = handler$3;
                SCHEMES[handler$4.scheme] = handler$4;
                SCHEMES[handler$5.scheme] = handler$5;
                SCHEMES[handler$6.scheme] = handler$6;
                exports.SCHEMES = SCHEMES;
                exports.pctEncChar = pctEncChar;
                exports.pctDecChars = pctDecChars;
                exports.parse = parse;
                exports.removeDotSegments = removeDotSegments;
                exports.serialize = serialize;
                exports.resolveComponents = resolveComponents;
                exports.resolve = resolve;
                exports.normalize = normalize;
                exports.equal = equal;
                exports.escapeComponent = escapeComponent;
                exports.unescapeComponent = unescapeComponent;
                Object.defineProperty(exports, '__esModule', { value: true });
            })));
            //# sourceMappingURL=uri.all.js.map
            /***/ 
        }),
        /***/ 5840: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({
                value: true
            }));
            Object.defineProperty(exports, "v1", ({
                enumerable: true,
                get: function () {
                    return _v["default"];
                }
            }));
            Object.defineProperty(exports, "v3", ({
                enumerable: true,
                get: function () {
                    return _v2["default"];
                }
            }));
            Object.defineProperty(exports, "v4", ({
                enumerable: true,
                get: function () {
                    return _v3["default"];
                }
            }));
            Object.defineProperty(exports, "v5", ({
                enumerable: true,
                get: function () {
                    return _v4["default"];
                }
            }));
            Object.defineProperty(exports, "NIL", ({
                enumerable: true,
                get: function () {
                    return _nil["default"];
                }
            }));
            Object.defineProperty(exports, "version", ({
                enumerable: true,
                get: function () {
                    return _version["default"];
                }
            }));
            Object.defineProperty(exports, "validate", ({
                enumerable: true,
                get: function () {
                    return _validate["default"];
                }
            }));
            Object.defineProperty(exports, "stringify", ({
                enumerable: true,
                get: function () {
                    return _stringify["default"];
                }
            }));
            Object.defineProperty(exports, "parse", ({
                enumerable: true,
                get: function () {
                    return _parse["default"];
                }
            }));
            var _v = _interopRequireDefault(__nccwpck_require__(8628));
            var _v2 = _interopRequireDefault(__nccwpck_require__(6409));
            var _v3 = _interopRequireDefault(__nccwpck_require__(5122));
            var _v4 = _interopRequireDefault(__nccwpck_require__(9120));
            var _nil = _interopRequireDefault(__nccwpck_require__(5332));
            var _version = _interopRequireDefault(__nccwpck_require__(1595));
            var _validate = _interopRequireDefault(__nccwpck_require__(6900));
            var _stringify = _interopRequireDefault(__nccwpck_require__(8950));
            var _parse = _interopRequireDefault(__nccwpck_require__(2746));
            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
            /***/ 
        }),
        /***/ 4569: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({
                value: true
            }));
            exports["default"] = void 0;
            var _crypto = _interopRequireDefault(__nccwpck_require__(6113));
            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
            function md5(bytes) {
                if (Array.isArray(bytes)) {
                    bytes = Buffer.from(bytes);
                }
                else if (typeof bytes === 'string') {
                    bytes = Buffer.from(bytes, 'utf8');
                }
                return _crypto["default"].createHash('md5').update(bytes).digest();
            }
            var _default = md5;
            exports["default"] = _default;
            /***/ 
        }),
        /***/ 5332: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({
                value: true
            }));
            exports["default"] = void 0;
            var _default = '00000000-0000-0000-0000-000000000000';
            exports["default"] = _default;
            /***/ 
        }),
        /***/ 2746: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({
                value: true
            }));
            exports["default"] = void 0;
            var _validate = _interopRequireDefault(__nccwpck_require__(6900));
            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
            function parse(uuid) {
                if (!(0, _validate["default"])(uuid)) {
                    throw TypeError('Invalid UUID');
                }
                var v;
                var arr = new Uint8Array(16); // Parse ########-....-....-....-............
                arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
                arr[1] = v >>> 16 & 0xff;
                arr[2] = v >>> 8 & 0xff;
                arr[3] = v & 0xff; // Parse ........-####-....-....-............
                arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
                arr[5] = v & 0xff; // Parse ........-....-####-....-............
                arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
                arr[7] = v & 0xff; // Parse ........-....-....-####-............
                arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
                arr[9] = v & 0xff; // Parse ........-....-....-....-############
                // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)
                arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
                arr[11] = v / 0x100000000 & 0xff;
                arr[12] = v >>> 24 & 0xff;
                arr[13] = v >>> 16 & 0xff;
                arr[14] = v >>> 8 & 0xff;
                arr[15] = v & 0xff;
                return arr;
            }
            var _default = parse;
            exports["default"] = _default;
            /***/ 
        }),
        /***/ 814: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({
                value: true
            }));
            exports["default"] = void 0;
            var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
            exports["default"] = _default;
            /***/ 
        }),
        /***/ 807: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({
                value: true
            }));
            exports["default"] = rng;
            var _crypto = _interopRequireDefault(__nccwpck_require__(6113));
            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
            var rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate
            var poolPtr = rnds8Pool.length;
            function rng() {
                if (poolPtr > rnds8Pool.length - 16) {
                    _crypto["default"].randomFillSync(rnds8Pool);
                    poolPtr = 0;
                }
                return rnds8Pool.slice(poolPtr, poolPtr += 16);
            }
            /***/ 
        }),
        /***/ 5274: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({
                value: true
            }));
            exports["default"] = void 0;
            var _crypto = _interopRequireDefault(__nccwpck_require__(6113));
            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
            function sha1(bytes) {
                if (Array.isArray(bytes)) {
                    bytes = Buffer.from(bytes);
                }
                else if (typeof bytes === 'string') {
                    bytes = Buffer.from(bytes, 'utf8');
                }
                return _crypto["default"].createHash('sha1').update(bytes).digest();
            }
            var _default = sha1;
            exports["default"] = _default;
            /***/ 
        }),
        /***/ 8950: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({
                value: true
            }));
            exports["default"] = void 0;
            var _validate = _interopRequireDefault(__nccwpck_require__(6900));
            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
            /**
             * Convert array of 16 byte values to UUID string format of the form:
             * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
             */
            var byteToHex = [];
            for (var i = 0; i < 256; ++i) {
                byteToHex.push((i + 0x100).toString(16).substr(1));
            }
            function stringify(arr, offset) {
                if (offset === void 0) { offset = 0; }
                // Note: Be careful editing this code!  It's been tuned for performance
                // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
                var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
                // of the following:
                // - One or more input array values don't map to a hex octet (leading to
                // "undefined" in the uuid)
                // - Invalid input values for the RFC `version` or `variant` fields
                if (!(0, _validate["default"])(uuid)) {
                    throw TypeError('Stringified UUID is invalid');
                }
                return uuid;
            }
            var _default = stringify;
            exports["default"] = _default;
            /***/ 
        }),
        /***/ 8628: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({
                value: true
            }));
            exports["default"] = void 0;
            var _rng = _interopRequireDefault(__nccwpck_require__(807));
            var _stringify = _interopRequireDefault(__nccwpck_require__(8950));
            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
            // **`v1()` - Generate time-based UUID**
            //
            // Inspired by https://github.com/LiosK/UUID.js
            // and http://docs.python.org/library/uuid.html
            var _nodeId;
            var _clockseq; // Previous uuid creation time
            var _lastMSecs = 0;
            var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details
            function v1(options, buf, offset) {
                var i = buf && offset || 0;
                var b = buf || new Array(16);
                options = options || {};
                var node = options.node || _nodeId;
                var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
                // specified.  We do this lazily to minimize issues related to insufficient
                // system entropy.  See #189
                if (node == null || clockseq == null) {
                    var seedBytes = options.random || (options.rng || _rng["default"])();
                    if (node == null) {
                        // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
                        node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
                    }
                    if (clockseq == null) {
                        // Per 4.2.2, randomize (14 bit) clockseq
                        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
                    }
                } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
                // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
                // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
                // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
                var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
                // cycle to simulate higher resolution clock
                var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)
                var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression
                if (dt < 0 && options.clockseq === undefined) {
                    clockseq = clockseq + 1 & 0x3fff;
                } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
                // time interval
                if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
                    nsecs = 0;
                } // Per 4.2.1.2 Throw error if too many uuids are requested
                if (nsecs >= 10000) {
                    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
                }
                _lastMSecs = msecs;
                _lastNSecs = nsecs;
                _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
                msecs += 12219292800000; // `time_low`
                var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
                b[i++] = tl >>> 24 & 0xff;
                b[i++] = tl >>> 16 & 0xff;
                b[i++] = tl >>> 8 & 0xff;
                b[i++] = tl & 0xff; // `time_mid`
                var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
                b[i++] = tmh >>> 8 & 0xff;
                b[i++] = tmh & 0xff; // `time_high_and_version`
                b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
                b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
                b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`
                b[i++] = clockseq & 0xff; // `node`
                for (var n = 0; n < 6; ++n) {
                    b[i + n] = node[n];
                }
                return buf || (0, _stringify["default"])(b);
            }
            var _default = v1;
            exports["default"] = _default;
            /***/ 
        }),
        /***/ 6409: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({
                value: true
            }));
            exports["default"] = void 0;
            var _v = _interopRequireDefault(__nccwpck_require__(5998));
            var _md = _interopRequireDefault(__nccwpck_require__(4569));
            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
            var v3 = (0, _v["default"])('v3', 0x30, _md["default"]);
            var _default = v3;
            exports["default"] = _default;
            /***/ 
        }),
        /***/ 5998: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({
                value: true
            }));
            exports["default"] = _default;
            exports.URL = exports.DNS = void 0;
            var _stringify = _interopRequireDefault(__nccwpck_require__(8950));
            var _parse = _interopRequireDefault(__nccwpck_require__(2746));
            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
            function stringToBytes(str) {
                str = unescape(encodeURIComponent(str)); // UTF8 escape
                var bytes = [];
                for (var i = 0; i < str.length; ++i) {
                    bytes.push(str.charCodeAt(i));
                }
                return bytes;
            }
            var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
            exports.DNS = DNS;
            var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
            exports.URL = URL;
            function _default(name, version, hashfunc) {
                function generateUUID(value, namespace, buf, offset) {
                    if (typeof value === 'string') {
                        value = stringToBytes(value);
                    }
                    if (typeof namespace === 'string') {
                        namespace = (0, _parse["default"])(namespace);
                    }
                    if (namespace.length !== 16) {
                        throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
                    } // Compute hash of namespace and value, Per 4.3
                    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
                    // hashfunc([...namespace, ... value])`
                    var bytes = new Uint8Array(16 + value.length);
                    bytes.set(namespace);
                    bytes.set(value, namespace.length);
                    bytes = hashfunc(bytes);
                    bytes[6] = bytes[6] & 0x0f | version;
                    bytes[8] = bytes[8] & 0x3f | 0x80;
                    if (buf) {
                        offset = offset || 0;
                        for (var i = 0; i < 16; ++i) {
                            buf[offset + i] = bytes[i];
                        }
                        return buf;
                    }
                    return (0, _stringify["default"])(bytes);
                } // Function#name is not settable on some platforms (#270)
                try {
                    generateUUID.name = name; // eslint-disable-next-line no-empty
                }
                catch (err) { } // For CommonJS default export support
                generateUUID.DNS = DNS;
                generateUUID.URL = URL;
                return generateUUID;
            }
            /***/ 
        }),
        /***/ 5122: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({
                value: true
            }));
            exports["default"] = void 0;
            var _rng = _interopRequireDefault(__nccwpck_require__(807));
            var _stringify = _interopRequireDefault(__nccwpck_require__(8950));
            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
            function v4(options, buf, offset) {
                options = options || {};
                var rnds = options.random || (options.rng || _rng["default"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
                rnds[6] = rnds[6] & 0x0f | 0x40;
                rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided
                if (buf) {
                    offset = offset || 0;
                    for (var i = 0; i < 16; ++i) {
                        buf[offset + i] = rnds[i];
                    }
                    return buf;
                }
                return (0, _stringify["default"])(rnds);
            }
            var _default = v4;
            exports["default"] = _default;
            /***/ 
        }),
        /***/ 9120: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({
                value: true
            }));
            exports["default"] = void 0;
            var _v = _interopRequireDefault(__nccwpck_require__(5998));
            var _sha = _interopRequireDefault(__nccwpck_require__(5274));
            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
            var v5 = (0, _v["default"])('v5', 0x50, _sha["default"]);
            var _default = v5;
            exports["default"] = _default;
            /***/ 
        }),
        /***/ 6900: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({
                value: true
            }));
            exports["default"] = void 0;
            var _regex = _interopRequireDefault(__nccwpck_require__(814));
            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
            function validate(uuid) {
                return typeof uuid === 'string' && _regex["default"].test(uuid);
            }
            var _default = validate;
            exports["default"] = _default;
            /***/ 
        }),
        /***/ 1595: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({
                value: true
            }));
            exports["default"] = void 0;
            var _validate = _interopRequireDefault(__nccwpck_require__(6900));
            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
            function version(uuid) {
                if (!(0, _validate["default"])(uuid)) {
                    throw TypeError('Invalid UUID');
                }
                return parseInt(uuid.substr(14, 1), 16);
            }
            var _default = version;
            exports["default"] = _default;
            /***/ 
        }),
        /***/ 9112: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var __importDefault = (this && this.__importDefault) || function (mod) {
                return (mod && mod.__esModule) ? mod : { "default": mod };
            };
            var validate_text_1 = __importDefault(__nccwpck_require__(7459));
            var validate_url_1 = __importDefault(__nccwpck_require__(516));
            var cssValidator = {
                validateText: validate_text_1["default"],
                validateURL: validate_url_1["default"]
            };
            module.exports = cssValidator;
            /***/ 
        }),
        /***/ 2023: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var BadStatusError = /** @class */ (function (_super) {
                __extends(BadStatusError, _super);
                function BadStatusError(message, statusCode) {
                    var _this_1 = _super.call(this, message) || this;
                    _this_1.statusCode = statusCode;
                    _this_1.name = 'BadStatusError';
                    return _this_1;
                }
                return BadStatusError;
            }(Error));
            exports["default"] = BadStatusError;
            /***/ 
        }),
        /***/ 5546: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
                function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) { try {
                        step(generator.next(value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function rejected(value) { try {
                        step(generator["throw"](value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
            };
            var __importDefault = (this && this.__importDefault) || function (mod) {
                return (mod && mod.__esModule) ? mod : { "default": mod };
            };
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var bad_status_error_1 = __importDefault(__nccwpck_require__(2023));
            var get_boundary_1 = __nccwpck_require__(142);
            var retrieveInBrowser = function (method, parameters, timeout) { return __awaiter(void 0, void 0, void 0, function () {
                var controller, res, err_5, data;
                return __generator(this, function (_1) {
                    switch (_1.label) {
                        case 0:
                            controller = new AbortController();
                            setTimeout(function () {
                                controller.abort();
                            }, timeout);
                            res = null;
                            _1.label = 1;
                        case 1:
                            _1.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, fetch("https://jigsaw.w3.org/css-validator/validator".concat(method === 'GET' ? parameters : ''), Object.assign({ method: method, signal: controller.signal }, (method === 'POST'
                                    ? {
                                        headers: {
                                            'Content-Type': "multipart/form-data; boundary=".concat(parameters.slice(2, get_boundary_1.boundaryLength + 2)),
                                            'Content-Length': String(new TextEncoder().encode(parameters).byteLength)
                                        },
                                        body: parameters
                                    }
                                    : {})))];
                        case 2:
                            res = _1.sent();
                            if (!res.ok) {
                                throw new bad_status_error_1["default"](res.statusText, res.status);
                            }
                            return [3 /*break*/, 4];
                        case 3:
                            err_5 = _1.sent();
                            if (err_5 instanceof Error && err_5.name === 'AbortError') {
                                throw new Error("The request took longer than ".concat(timeout, "ms"));
                            }
                            throw err_5;
                        case 4:
                            if (!res) {
                                throw new Error('Response expected');
                            }
                            return [4 /*yield*/, res.json()];
                        case 5:
                            data = (_1.sent());
                            return [2 /*return*/, data.cssvalidation];
                    }
                });
            }); };
            exports["default"] = retrieveInBrowser;
            /***/ 
        }),
        /***/ 6398: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var __importDefault = (this && this.__importDefault) || function (mod) {
                return (mod && mod.__esModule) ? mod : { "default": mod };
            };
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var get_boundary_1 = __importDefault(__nccwpck_require__(142));
            var buildFormData = function (parameters) {
                var _a;
                var CRLF = '\r\n';
                var boundary = "--".concat((0, get_boundary_1["default"])());
                var pieces = [
                    "Content-Disposition: form-data; name=\"text\"".concat(CRLF).concat(CRLF).concat(parameters.text).concat(CRLF),
                    "Content-Disposition: form-data; name=\"profile\"".concat(CRLF).concat(CRLF, "css3").concat(CRLF),
                    "Content-Disposition: form-data; name=\"output\"".concat(CRLF).concat(CRLF, "application/json").concat(CRLF),
                    "Content-Disposition: form-data; name=\"usermedium\"".concat(CRLF).concat(CRLF).concat((_a = parameters.medium) !== null && _a !== void 0 ? _a : 'all').concat(CRLF),
                    "Content-Disposition: form-data; name=\"warning\"".concat(CRLF).concat(CRLF).concat((parameters === null || parameters === void 0 ? void 0 : parameters.warningLevel) ? String(parameters.warningLevel - 1) : 'no').concat(CRLF),
                ];
                return "".concat(boundary).concat(CRLF).concat(pieces.join("".concat(boundary).concat(CRLF))).concat(boundary);
            };
            exports["default"] = buildFormData;
            /***/ 
        }),
        /***/ 4000: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            function buildRequestURLParameters(parameters) {
                var _a;
                var params = {
                    uri: encodeURIComponent(parameters.url),
                    usermedium: (_a = parameters === null || parameters === void 0 ? void 0 : parameters.medium) !== null && _a !== void 0 ? _a : 'all',
                    warning: (parameters === null || parameters === void 0 ? void 0 : parameters.warningLevel) ? parameters.warningLevel - 1 : 'no',
                    output: 'application/json',
                    profile: 'css3'
                };
                return "?".concat(Object.entries(params)
                    .map(function (_1) {
                    var key = _1[0], val = _1[1];
                    return "".concat(key, "=").concat(val);
                })
                    .join('&'));
            }
            exports["default"] = buildRequestURLParameters;
            /***/ 
        }),
        /***/ 142: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.boundaryLength = void 0;
            exports.boundaryLength = 34;
            var getBoundary = function () {
                var allowedChars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                var randomBoundaryPiece = '';
                for (var i = 0; i < 10; i += 1) {
                    randomBoundaryPiece += allowedChars[Math.floor(Math.random() * allowedChars.length)];
                }
                return "----CSSValidatorBoundary".concat(randomBoundaryPiece);
            };
            exports["default"] = getBoundary;
            /***/ 
        }),
        /***/ 3902: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
                function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) { try {
                        step(generator.next(value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function rejected(value) { try {
                        step(generator["throw"](value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
            };
            var __importDefault = (this && this.__importDefault) || function (mod) {
                return (mod && mod.__esModule) ? mod : { "default": mod };
            };
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var validate_options_1 = __importDefault(__nccwpck_require__(9821));
            var browser_1 = __importDefault(__nccwpck_require__(5546));
            var node_1 = __importDefault(__nccwpck_require__(5031));
            var process_parameters_1 = __importDefault(__nccwpck_require__(5022));
            var retrieveValidation = function (method, unprocessedParameters, timeout) { return __awaiter(void 0, void 0, void 0, function () {
                var parameters;
                return __generator(this, function (_1) {
                    switch (_1.label) {
                        case 0:
                            (0, validate_options_1["default"])({
                                timeout: timeout,
                                medium: unprocessedParameters.medium,
                                warningLevel: unprocessedParameters.warningLevel
                            });
                            parameters = (0, process_parameters_1["default"])(method, unprocessedParameters);
                            if (!(typeof window !== 'undefined' && typeof (window === null || window === void 0 ? void 0 : window.fetch) === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, (0, browser_1["default"])(method, parameters, timeout)];
                        case 1: return [2 /*return*/, _1.sent()];
                        case 2: return [4 /*yield*/, (0, node_1["default"])(method, parameters, timeout)];
                        case 3: return [2 /*return*/, _1.sent()];
                    }
                });
            }); };
            exports["default"] = retrieveValidation;
            /***/ 
        }),
        /***/ 5031: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
                if (k2 === undefined)
                    k2 = k;
                var desc = Object.getOwnPropertyDescriptor(m, k);
                if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                    desc = { enumerable: true, get: function () { return m[k]; } };
                }
                Object.defineProperty(o, k2, desc);
            }) : (function (o, m, k, k2) {
                if (k2 === undefined)
                    k2 = k;
                o[k2] = m[k];
            }));
            var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {
                Object.defineProperty(o, "default", { enumerable: true, value: v });
            }) : function (o, v) {
                o["default"] = v;
            });
            var __importStar = (this && this.__importStar) || function (mod) {
                if (mod && mod.__esModule)
                    return mod;
                var result = {};
                if (mod != null)
                    for (var k in mod)
                        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                            __createBinding(result, mod, k);
                __setModuleDefault(result, mod);
                return result;
            };
            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
                function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) { try {
                        step(generator.next(value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function rejected(value) { try {
                        step(generator["throw"](value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
            };
            var __importDefault = (this && this.__importDefault) || function (mod) {
                return (mod && mod.__esModule) ? mod : { "default": mod };
            };
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var https = __importStar(__nccwpck_require__(5687));
            var bad_status_error_1 = __importDefault(__nccwpck_require__(2023));
            var get_boundary_1 = __nccwpck_require__(142);
            var util_1 = __nccwpck_require__(3837);
            var retrieveInNode = function (method, parameters, timeout) { return __awaiter(void 0, void 0, void 0, function () {
                return __generator(this, function (_1) {
                    return [2 /*return*/, new Promise(function (resolve, reject) {
                            var req = https.request("https://jigsaw.w3.org/css-validator/validator".concat(method === 'GET' ? parameters : ''), Object.assign({ method: method, timeout: timeout }, (method === 'POST'
                                ? {
                                    headers: {
                                        'Content-Type': "multipart/form-data; boundary=".concat(parameters.slice(2, get_boundary_1.boundaryLength + 2)),
                                        'Content-Length': String(new util_1.TextEncoder().encode(parameters).byteLength)
                                    }
                                }
                                : {})), function (res) {
                                var _a;
                                if (typeof res.statusCode === 'number' && (res.statusCode < 200 || res.statusCode >= 300)) {
                                    reject(new bad_status_error_1["default"]((_a = res.statusMessage) !== null && _a !== void 0 ? _a : '', res.statusCode));
                                }
                                var data = '';
                                res.on('data', function (chunk) {
                                    try {
                                        data += chunk;
                                    }
                                    catch (error) {
                                        reject(error);
                                    }
                                });
                                res.on('end', function () {
                                    try {
                                        resolve(JSON.parse(data).cssvalidation);
                                    }
                                    catch (error) {
                                        reject(error);
                                    }
                                });
                            });
                            if (method === 'POST') {
                                req.write(parameters);
                            }
                            req.on('timeout', function () {
                                reject(new Error("The request took longer than ".concat(timeout, "ms")));
                            });
                            req.end();
                        })];
                });
            }); };
            exports["default"] = retrieveInNode;
            /***/ 
        }),
        /***/ 5022: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var __importDefault = (this && this.__importDefault) || function (mod) {
                return (mod && mod.__esModule) ? mod : { "default": mod };
            };
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var build_request_url_parameters_1 = __importDefault(__nccwpck_require__(4000));
            var build_form_data_1 = __importDefault(__nccwpck_require__(6398));
            var processParameters = function (method, parameters) {
                if (method === 'GET') {
                    if ('text' in parameters) {
                        throw new Error('A GET request is not supported with validation by text');
                    }
                    return (0, build_request_url_parameters_1["default"])(parameters);
                }
                if (method === 'POST') {
                    if ('url' in parameters) {
                        throw new Error('A POST request is not supported with validation by URL');
                    }
                    return (0, build_form_data_1["default"])(parameters);
                }
                throw new Error("Parameter processing called with unrecognized method: ".concat(method));
            };
            exports["default"] = processParameters;
            /***/ 
        }),
        /***/ 9821: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var allowedMediums = [
                'all',
                'braille',
                'embossed',
                'handheld',
                'print',
                'projection',
                'screen',
                'speech',
                'tty',
                'tv',
            ];
            var allowedWarningLevels = [0, 1, 2, 3];
            function validateOptions(options) {
                if (options) {
                    if (options.medium && !allowedMediums.includes(options.medium)) {
                        throw new Error("The medium must be one of the following: ".concat(allowedMediums.join(', ')));
                    }
                    if (options.warningLevel && !allowedWarningLevels.includes(options.warningLevel)) {
                        throw new Error("The warning level must be one of the following: ".concat(allowedWarningLevels.join(', ')));
                    }
                    if (options.timeout !== undefined && !Number.isInteger(options.timeout)) {
                        throw new Error('The timeout must be an integer');
                    }
                    if (options.timeout && options.timeout < 0) {
                        throw new Error('The timeout must be a positive integer');
                    }
                }
            }
            exports["default"] = validateOptions;
            /***/ 
        }),
        /***/ 7459: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
                function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) { try {
                        step(generator.next(value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function rejected(value) { try {
                        step(generator["throw"](value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
            };
            var __importDefault = (this && this.__importDefault) || function (mod) {
                return (mod && mod.__esModule) ? mod : { "default": mod };
            };
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var retrieve_validation_1 = __importDefault(__nccwpck_require__(3902));
            function validateText(textToBeValidated, options) {
                var _a, _b, _c;
                return __awaiter(this, void 0, void 0, function () {
                    var cssValidationResponse, base, result;
                    return __generator(this, function (_1) {
                        switch (_1.label) {
                            case 0:
                                if (!textToBeValidated) {
                                    throw new Error('You must pass in text to be validated');
                                }
                                if (typeof textToBeValidated !== 'string') {
                                    throw new Error('The text to be validated must be a string');
                                }
                                return [4 /*yield*/, (0, retrieve_validation_1["default"])('POST', {
                                        text: textToBeValidated,
                                        medium: options === null || options === void 0 ? void 0 : options.medium,
                                        warningLevel: options === null || options === void 0 ? void 0 : options.warningLevel
                                    }, (_a = options === null || options === void 0 ? void 0 : options.timeout) !== null && _a !== void 0 ? _a : 10000)];
                            case 1:
                                cssValidationResponse = _1.sent();
                                base = {
                                    valid: false,
                                    errors: []
                                };
                                result = (options === null || options === void 0 ? void 0 : options.warningLevel)
                                    ? Object.assign(Object.assign({}, base), { warnings: [] }) : base;
                                result.valid = cssValidationResponse.validity;
                                (_b = cssValidationResponse.errors) === null || _b === void 0 ? void 0 : _b.forEach(function (error) {
                                    result.errors.push({
                                        line: error.line,
                                        message: error.message.replace(/[ :]+$/, '').trim()
                                    });
                                });
                                if ('warnings' in result) {
                                    (_c = cssValidationResponse.warnings) === null || _c === void 0 ? void 0 : _c.forEach(function (warning) {
                                        result.warnings.push({
                                            line: warning.line,
                                            message: warning.message.replace(/[ :]+$/, '').trim(),
                                            level: (warning.level + 1)
                                        });
                                    });
                                }
                                return [2 /*return*/, result];
                        }
                    });
                });
            }
            exports["default"] = validateText;
            /***/ 
        }),
        /***/ 516: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
                function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) { try {
                        step(generator.next(value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function rejected(value) { try {
                        step(generator["throw"](value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
            };
            var __importDefault = (this && this.__importDefault) || function (mod) {
                return (mod && mod.__esModule) ? mod : { "default": mod };
            };
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var retrieve_validation_1 = __importDefault(__nccwpck_require__(3902));
            function validateURL(urlToBeValidated, options) {
                var _a, _b, _c;
                return __awaiter(this, void 0, void 0, function () {
                    var cssValidationResponse, base, result;
                    return __generator(this, function (_1) {
                        switch (_1.label) {
                            case 0:
                                if (!urlToBeValidated) {
                                    throw new Error('You must pass in a URL to be validated');
                                }
                                if (typeof urlToBeValidated !== 'string') {
                                    throw new Error('The URL to be validated must be a string');
                                }
                                return [4 /*yield*/, (0, retrieve_validation_1["default"])('GET', {
                                        url: urlToBeValidated,
                                        medium: options === null || options === void 0 ? void 0 : options.medium,
                                        warningLevel: options === null || options === void 0 ? void 0 : options.warningLevel
                                    }, (_a = options === null || options === void 0 ? void 0 : options.timeout) !== null && _a !== void 0 ? _a : 10000)];
                            case 1:
                                cssValidationResponse = _1.sent();
                                base = {
                                    valid: false,
                                    errors: []
                                };
                                result = (options === null || options === void 0 ? void 0 : options.warningLevel)
                                    ? Object.assign(Object.assign({}, base), { warnings: [] }) : base;
                                result.valid = cssValidationResponse.validity;
                                (_b = cssValidationResponse.errors) === null || _b === void 0 ? void 0 : _b.forEach(function (error) {
                                    var _a;
                                    result.errors.push({
                                        line: error.line,
                                        message: error.message.replace(/[ :]+$/, '').trim(),
                                        url: (_a = error.source) !== null && _a !== void 0 ? _a : null
                                    });
                                });
                                if ('warnings' in result) {
                                    (_c = cssValidationResponse.warnings) === null || _c === void 0 ? void 0 : _c.forEach(function (warning) {
                                        var _a;
                                        result.warnings.push({
                                            line: warning.line,
                                            message: warning.message.replace(/[ :]+$/, '').trim(),
                                            level: (warning.level + 1),
                                            url: (_a = warning.source) !== null && _a !== void 0 ? _a : null
                                        });
                                    });
                                }
                                return [2 /*return*/, result];
                        }
                    });
                });
            }
            exports["default"] = validateURL;
            /***/ 
        }),
        /***/ 4886: 
        /***/ (function (module) {
            "use strict";
            var conversions = {};
            module.exports = conversions;
            function sign(x) {
                return x < 0 ? -1 : 1;
            }
            function evenRound(x) {
                // Round x to the nearest integer, choosing the even integer if it lies halfway between two.
                if ((x % 1) === 0.5 && (x & 1) === 0) { // [even number].5; round down (i.e. floor)
                    return Math.floor(x);
                }
                else {
                    return Math.round(x);
                }
            }
            function createNumberConversion(bitLength, typeOpts) {
                if (!typeOpts.unsigned) {
                    --bitLength;
                }
                var lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
                var upperBound = Math.pow(2, bitLength) - 1;
                var moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
                var moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
                return function (V, opts) {
                    if (!opts)
                        opts = {};
                    var x = +V;
                    if (opts.enforceRange) {
                        if (!Number.isFinite(x)) {
                            throw new TypeError("Argument is not a finite number");
                        }
                        x = sign(x) * Math.floor(Math.abs(x));
                        if (x < lowerBound || x > upperBound) {
                            throw new TypeError("Argument is not in byte range");
                        }
                        return x;
                    }
                    if (!isNaN(x) && opts.clamp) {
                        x = evenRound(x);
                        if (x < lowerBound)
                            x = lowerBound;
                        if (x > upperBound)
                            x = upperBound;
                        return x;
                    }
                    if (!Number.isFinite(x) || x === 0) {
                        return 0;
                    }
                    x = sign(x) * Math.floor(Math.abs(x));
                    x = x % moduloVal;
                    if (!typeOpts.unsigned && x >= moduloBound) {
                        return x - moduloVal;
                    }
                    else if (typeOpts.unsigned) {
                        if (x < 0) {
                            x += moduloVal;
                        }
                        else if (x === -0) { // don't return negative zero
                            return 0;
                        }
                    }
                    return x;
                };
            }
            conversions["void"] = function () {
                return undefined;
            };
            conversions["boolean"] = function (val) {
                return !!val;
            };
            conversions["byte"] = createNumberConversion(8, { unsigned: false });
            conversions["octet"] = createNumberConversion(8, { unsigned: true });
            conversions["short"] = createNumberConversion(16, { unsigned: false });
            conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
            conversions["long"] = createNumberConversion(32, { unsigned: false });
            conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
            conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
            conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
            conversions["double"] = function (V) {
                var x = +V;
                if (!Number.isFinite(x)) {
                    throw new TypeError("Argument is not a finite floating-point value");
                }
                return x;
            };
            conversions["unrestricted double"] = function (V) {
                var x = +V;
                if (isNaN(x)) {
                    throw new TypeError("Argument is NaN");
                }
                return x;
            };
            // not quite valid, but good enough for JS
            conversions["float"] = conversions["double"];
            conversions["unrestricted float"] = conversions["unrestricted double"];
            conversions["DOMString"] = function (V, opts) {
                if (!opts)
                    opts = {};
                if (opts.treatNullAsEmptyString && V === null) {
                    return "";
                }
                return String(V);
            };
            conversions["ByteString"] = function (V, opts) {
                var x = String(V);
                var c = undefined;
                for (var i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {
                    if (c > 255) {
                        throw new TypeError("Argument is not a valid bytestring");
                    }
                }
                return x;
            };
            conversions["USVString"] = function (V) {
                var S = String(V);
                var n = S.length;
                var U = [];
                for (var i = 0; i < n; ++i) {
                    var c = S.charCodeAt(i);
                    if (c < 0xD800 || c > 0xDFFF) {
                        U.push(String.fromCodePoint(c));
                    }
                    else if (0xDC00 <= c && c <= 0xDFFF) {
                        U.push(String.fromCodePoint(0xFFFD));
                    }
                    else {
                        if (i === n - 1) {
                            U.push(String.fromCodePoint(0xFFFD));
                        }
                        else {
                            var d = S.charCodeAt(i + 1);
                            if (0xDC00 <= d && d <= 0xDFFF) {
                                var a = c & 0x3FF;
                                var b = d & 0x3FF;
                                U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
                                ++i;
                            }
                            else {
                                U.push(String.fromCodePoint(0xFFFD));
                            }
                        }
                    }
                }
                return U.join('');
            };
            conversions["Date"] = function (V, opts) {
                if (!(V instanceof Date)) {
                    throw new TypeError("Argument is not a Date object");
                }
                if (isNaN(V)) {
                    return undefined;
                }
                return V;
            };
            conversions["RegExp"] = function (V, opts) {
                if (!(V instanceof RegExp)) {
                    V = new RegExp(V);
                }
                return V;
            };
            /***/ 
        }),
        /***/ 7537: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var usm = __nccwpck_require__(2158);
            exports.implementation = /** @class */ (function () {
                function URLImpl(constructorArgs) {
                    var url = constructorArgs[0];
                    var base = constructorArgs[1];
                    var parsedBase = null;
                    if (base !== undefined) {
                        parsedBase = usm.basicURLParse(base);
                        if (parsedBase === "failure") {
                            throw new TypeError("Invalid base URL");
                        }
                    }
                    var parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
                    if (parsedURL === "failure") {
                        throw new TypeError("Invalid URL");
                    }
                    this._url = parsedURL;
                    // TODO: query stuff
                }
                Object.defineProperty(URLImpl.prototype, "href", {
                    get: function () {
                        return usm.serializeURL(this._url);
                    },
                    set: function (v) {
                        var parsedURL = usm.basicURLParse(v);
                        if (parsedURL === "failure") {
                            throw new TypeError("Invalid URL");
                        }
                        this._url = parsedURL;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(URLImpl.prototype, "origin", {
                    get: function () {
                        return usm.serializeURLOrigin(this._url);
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(URLImpl.prototype, "protocol", {
                    get: function () {
                        return this._url.scheme + ":";
                    },
                    set: function (v) {
                        usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(URLImpl.prototype, "username", {
                    get: function () {
                        return this._url.username;
                    },
                    set: function (v) {
                        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
                            return;
                        }
                        usm.setTheUsername(this._url, v);
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(URLImpl.prototype, "password", {
                    get: function () {
                        return this._url.password;
                    },
                    set: function (v) {
                        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
                            return;
                        }
                        usm.setThePassword(this._url, v);
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(URLImpl.prototype, "host", {
                    get: function () {
                        var url = this._url;
                        if (url.host === null) {
                            return "";
                        }
                        if (url.port === null) {
                            return usm.serializeHost(url.host);
                        }
                        return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
                    },
                    set: function (v) {
                        if (this._url.cannotBeABaseURL) {
                            return;
                        }
                        usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(URLImpl.prototype, "hostname", {
                    get: function () {
                        if (this._url.host === null) {
                            return "";
                        }
                        return usm.serializeHost(this._url.host);
                    },
                    set: function (v) {
                        if (this._url.cannotBeABaseURL) {
                            return;
                        }
                        usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(URLImpl.prototype, "port", {
                    get: function () {
                        if (this._url.port === null) {
                            return "";
                        }
                        return usm.serializeInteger(this._url.port);
                    },
                    set: function (v) {
                        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
                            return;
                        }
                        if (v === "") {
                            this._url.port = null;
                        }
                        else {
                            usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
                        }
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(URLImpl.prototype, "pathname", {
                    get: function () {
                        if (this._url.cannotBeABaseURL) {
                            return this._url.path[0];
                        }
                        if (this._url.path.length === 0) {
                            return "";
                        }
                        return "/" + this._url.path.join("/");
                    },
                    set: function (v) {
                        if (this._url.cannotBeABaseURL) {
                            return;
                        }
                        this._url.path = [];
                        usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(URLImpl.prototype, "search", {
                    get: function () {
                        if (this._url.query === null || this._url.query === "") {
                            return "";
                        }
                        return "?" + this._url.query;
                    },
                    set: function (v) {
                        // TODO: query stuff
                        var url = this._url;
                        if (v === "") {
                            url.query = null;
                            return;
                        }
                        var input = v[0] === "?" ? v.substring(1) : v;
                        url.query = "";
                        usm.basicURLParse(input, { url: url, stateOverride: "query" });
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(URLImpl.prototype, "hash", {
                    get: function () {
                        if (this._url.fragment === null || this._url.fragment === "") {
                            return "";
                        }
                        return "#" + this._url.fragment;
                    },
                    set: function (v) {
                        if (v === "") {
                            this._url.fragment = null;
                            return;
                        }
                        var input = v[0] === "#" ? v.substring(1) : v;
                        this._url.fragment = "";
                        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
                    },
                    enumerable: false,
                    configurable: true
                });
                URLImpl.prototype.toJSON = function () {
                    return this.href;
                };
                return URLImpl;
            }());
            /***/ 
        }),
        /***/ 3394: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var conversions = __nccwpck_require__(4886);
            var utils = __nccwpck_require__(3185);
            var Impl = __nccwpck_require__(7537);
            var impl = utils.implSymbol;
            function URL(url) {
                if (!this || this[impl] || !(this instanceof URL)) {
                    throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
                }
                if (arguments.length < 1) {
                    throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
                }
                var args = [];
                for (var i = 0; i < arguments.length && i < 2; ++i) {
                    args[i] = arguments[i];
                }
                args[0] = conversions["USVString"](args[0]);
                if (args[1] !== undefined) {
                    args[1] = conversions["USVString"](args[1]);
                }
                module.exports.setup(this, args);
            }
            URL.prototype.toJSON = function toJSON() {
                if (!this || !module.exports.is(this)) {
                    throw new TypeError("Illegal invocation");
                }
                var args = [];
                for (var i = 0; i < arguments.length && i < 0; ++i) {
                    args[i] = arguments[i];
                }
                return this[impl].toJSON.apply(this[impl], args);
            };
            Object.defineProperty(URL.prototype, "href", {
                get: function () {
                    return this[impl].href;
                },
                set: function (V) {
                    V = conversions["USVString"](V);
                    this[impl].href = V;
                },
                enumerable: true,
                configurable: true
            });
            URL.prototype.toString = function () {
                if (!this || !module.exports.is(this)) {
                    throw new TypeError("Illegal invocation");
                }
                return this.href;
            };
            Object.defineProperty(URL.prototype, "origin", {
                get: function () {
                    return this[impl].origin;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URL.prototype, "protocol", {
                get: function () {
                    return this[impl].protocol;
                },
                set: function (V) {
                    V = conversions["USVString"](V);
                    this[impl].protocol = V;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URL.prototype, "username", {
                get: function () {
                    return this[impl].username;
                },
                set: function (V) {
                    V = conversions["USVString"](V);
                    this[impl].username = V;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URL.prototype, "password", {
                get: function () {
                    return this[impl].password;
                },
                set: function (V) {
                    V = conversions["USVString"](V);
                    this[impl].password = V;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URL.prototype, "host", {
                get: function () {
                    return this[impl].host;
                },
                set: function (V) {
                    V = conversions["USVString"](V);
                    this[impl].host = V;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URL.prototype, "hostname", {
                get: function () {
                    return this[impl].hostname;
                },
                set: function (V) {
                    V = conversions["USVString"](V);
                    this[impl].hostname = V;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URL.prototype, "port", {
                get: function () {
                    return this[impl].port;
                },
                set: function (V) {
                    V = conversions["USVString"](V);
                    this[impl].port = V;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URL.prototype, "pathname", {
                get: function () {
                    return this[impl].pathname;
                },
                set: function (V) {
                    V = conversions["USVString"](V);
                    this[impl].pathname = V;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URL.prototype, "search", {
                get: function () {
                    return this[impl].search;
                },
                set: function (V) {
                    V = conversions["USVString"](V);
                    this[impl].search = V;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URL.prototype, "hash", {
                get: function () {
                    return this[impl].hash;
                },
                set: function (V) {
                    V = conversions["USVString"](V);
                    this[impl].hash = V;
                },
                enumerable: true,
                configurable: true
            });
            module.exports = {
                is: function (obj) {
                    return !!obj && obj[impl] instanceof Impl.implementation;
                },
                create: function (constructorArgs, privateData) {
                    var obj = Object.create(URL.prototype);
                    this.setup(obj, constructorArgs, privateData);
                    return obj;
                },
                setup: function (obj, constructorArgs, privateData) {
                    if (!privateData)
                        privateData = {};
                    privateData.wrapper = obj;
                    obj[impl] = new Impl.implementation(constructorArgs, privateData);
                    obj[impl][utils.wrapperSymbol] = obj;
                },
                interface: URL,
                expose: {
                    Window: { URL: URL },
                    Worker: { URL: URL }
                }
            };
            /***/ 
        }),
        /***/ 8665: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            exports.URL = __nccwpck_require__(3394)["interface"];
            exports.serializeURL = __nccwpck_require__(2158).serializeURL;
            exports.serializeURLOrigin = __nccwpck_require__(2158).serializeURLOrigin;
            exports.basicURLParse = __nccwpck_require__(2158).basicURLParse;
            exports.setTheUsername = __nccwpck_require__(2158).setTheUsername;
            exports.setThePassword = __nccwpck_require__(2158).setThePassword;
            exports.serializeHost = __nccwpck_require__(2158).serializeHost;
            exports.serializeInteger = __nccwpck_require__(2158).serializeInteger;
            exports.parseURL = __nccwpck_require__(2158).parseURL;
            /***/ 
        }),
        /***/ 2158: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var punycode = __nccwpck_require__(5477);
            var tr46 = __nccwpck_require__(4256);
            var specialSchemes = {
                ftp: 21,
                file: null,
                gopher: 70,
                http: 80,
                https: 443,
                ws: 80,
                wss: 443
            };
            var failure = Symbol("failure");
            function countSymbols(str) {
                return punycode.ucs2.decode(str).length;
            }
            function at(input, idx) {
                var c = input[idx];
                return isNaN(c) ? undefined : String.fromCodePoint(c);
            }
            function isASCIIDigit(c) {
                return c >= 0x30 && c <= 0x39;
            }
            function isASCIIAlpha(c) {
                return (c >= 0x41 && c <= 0x5A) || (c >= 0x61 && c <= 0x7A);
            }
            function isASCIIAlphanumeric(c) {
                return isASCIIAlpha(c) || isASCIIDigit(c);
            }
            function isASCIIHex(c) {
                return isASCIIDigit(c) || (c >= 0x41 && c <= 0x46) || (c >= 0x61 && c <= 0x66);
            }
            function isSingleDot(buffer) {
                return buffer === "." || buffer.toLowerCase() === "%2e";
            }
            function isDoubleDot(buffer) {
                buffer = buffer.toLowerCase();
                return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
            }
            function isWindowsDriveLetterCodePoints(cp1, cp2) {
                return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
            }
            function isWindowsDriveLetterString(string) {
                return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
            }
            function isNormalizedWindowsDriveLetterString(string) {
                return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
            }
            function containsForbiddenHostCodePoint(string) {
                return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
            }
            function containsForbiddenHostCodePointExcludingPercent(string) {
                return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
            }
            function isSpecialScheme(scheme) {
                return specialSchemes[scheme] !== undefined;
            }
            function isSpecial(url) {
                return isSpecialScheme(url.scheme);
            }
            function defaultPort(scheme) {
                return specialSchemes[scheme];
            }
            function percentEncode(c) {
                var hex = c.toString(16).toUpperCase();
                if (hex.length === 1) {
                    hex = "0" + hex;
                }
                return "%" + hex;
            }
            function utf8PercentEncode(c) {
                var buf = new Buffer(c);
                var str = "";
                for (var i = 0; i < buf.length; ++i) {
                    str += percentEncode(buf[i]);
                }
                return str;
            }
            function utf8PercentDecode(str) {
                var input = new Buffer(str);
                var output = [];
                for (var i = 0; i < input.length; ++i) {
                    if (input[i] !== 37) {
                        output.push(input[i]);
                    }
                    else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
                        output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
                        i += 2;
                    }
                    else {
                        output.push(input[i]);
                    }
                }
                return new Buffer(output).toString();
            }
            function isC0ControlPercentEncode(c) {
                return c <= 0x1F || c > 0x7E;
            }
            var extraPathPercentEncodeSet = new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
            function isPathPercentEncode(c) {
                return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
            }
            var extraUserinfoPercentEncodeSet = new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
            function isUserinfoPercentEncode(c) {
                return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
            }
            function percentEncodeChar(c, encodeSetPredicate) {
                var cStr = String.fromCodePoint(c);
                if (encodeSetPredicate(c)) {
                    return utf8PercentEncode(cStr);
                }
                return cStr;
            }
            function parseIPv4Number(input) {
                var R = 10;
                if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
                    input = input.substring(2);
                    R = 16;
                }
                else if (input.length >= 2 && input.charAt(0) === "0") {
                    input = input.substring(1);
                    R = 8;
                }
                if (input === "") {
                    return 0;
                }
                var regex = R === 10 ? /[^0-9]/ : (R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/);
                if (regex.test(input)) {
                    return failure;
                }
                return parseInt(input, R);
            }
            function parseIPv4(input) {
                var parts = input.split(".");
                if (parts[parts.length - 1] === "") {
                    if (parts.length > 1) {
                        parts.pop();
                    }
                }
                if (parts.length > 4) {
                    return input;
                }
                var numbers = [];
                for (var _1 = 0, parts_1 = parts; _1 < parts_1.length; _1++) {
                    var part = parts_1[_1];
                    if (part === "") {
                        return input;
                    }
                    var n = parseIPv4Number(part);
                    if (n === failure) {
                        return input;
                    }
                    numbers.push(n);
                }
                for (var i = 0; i < numbers.length - 1; ++i) {
                    if (numbers[i] > 255) {
                        return failure;
                    }
                }
                if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
                    return failure;
                }
                var ipv4 = numbers.pop();
                var counter = 0;
                for (var _2 = 0, numbers_1 = numbers; _2 < numbers_1.length; _2++) {
                    var n = numbers_1[_2];
                    ipv4 += n * Math.pow(256, 3 - counter);
                    ++counter;
                }
                return ipv4;
            }
            function serializeIPv4(address) {
                var output = "";
                var n = address;
                for (var i = 1; i <= 4; ++i) {
                    output = String(n % 256) + output;
                    if (i !== 4) {
                        output = "." + output;
                    }
                    n = Math.floor(n / 256);
                }
                return output;
            }
            function parseIPv6(input) {
                var address = [0, 0, 0, 0, 0, 0, 0, 0];
                var pieceIndex = 0;
                var compress = null;
                var pointer = 0;
                input = punycode.ucs2.decode(input);
                if (input[pointer] === 58) {
                    if (input[pointer + 1] !== 58) {
                        return failure;
                    }
                    pointer += 2;
                    ++pieceIndex;
                    compress = pieceIndex;
                }
                while (pointer < input.length) {
                    if (pieceIndex === 8) {
                        return failure;
                    }
                    if (input[pointer] === 58) {
                        if (compress !== null) {
                            return failure;
                        }
                        ++pointer;
                        ++pieceIndex;
                        compress = pieceIndex;
                        continue;
                    }
                    var value = 0;
                    var length_2 = 0;
                    while (length_2 < 4 && isASCIIHex(input[pointer])) {
                        value = value * 0x10 + parseInt(at(input, pointer), 16);
                        ++pointer;
                        ++length_2;
                    }
                    if (input[pointer] === 46) {
                        if (length_2 === 0) {
                            return failure;
                        }
                        pointer -= length_2;
                        if (pieceIndex > 6) {
                            return failure;
                        }
                        var numbersSeen = 0;
                        while (input[pointer] !== undefined) {
                            var ipv4Piece = null;
                            if (numbersSeen > 0) {
                                if (input[pointer] === 46 && numbersSeen < 4) {
                                    ++pointer;
                                }
                                else {
                                    return failure;
                                }
                            }
                            if (!isASCIIDigit(input[pointer])) {
                                return failure;
                            }
                            while (isASCIIDigit(input[pointer])) {
                                var number = parseInt(at(input, pointer));
                                if (ipv4Piece === null) {
                                    ipv4Piece = number;
                                }
                                else if (ipv4Piece === 0) {
                                    return failure;
                                }
                                else {
                                    ipv4Piece = ipv4Piece * 10 + number;
                                }
                                if (ipv4Piece > 255) {
                                    return failure;
                                }
                                ++pointer;
                            }
                            address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;
                            ++numbersSeen;
                            if (numbersSeen === 2 || numbersSeen === 4) {
                                ++pieceIndex;
                            }
                        }
                        if (numbersSeen !== 4) {
                            return failure;
                        }
                        break;
                    }
                    else if (input[pointer] === 58) {
                        ++pointer;
                        if (input[pointer] === undefined) {
                            return failure;
                        }
                    }
                    else if (input[pointer] !== undefined) {
                        return failure;
                    }
                    address[pieceIndex] = value;
                    ++pieceIndex;
                }
                if (compress !== null) {
                    var swaps = pieceIndex - compress;
                    pieceIndex = 7;
                    while (pieceIndex !== 0 && swaps > 0) {
                        var temp = address[compress + swaps - 1];
                        address[compress + swaps - 1] = address[pieceIndex];
                        address[pieceIndex] = temp;
                        --pieceIndex;
                        --swaps;
                    }
                }
                else if (compress === null && pieceIndex !== 8) {
                    return failure;
                }
                return address;
            }
            function serializeIPv6(address) {
                var output = "";
                var seqResult = findLongestZeroSequence(address);
                var compress = seqResult.idx;
                var ignore0 = false;
                for (var pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
                    if (ignore0 && address[pieceIndex] === 0) {
                        continue;
                    }
                    else if (ignore0) {
                        ignore0 = false;
                    }
                    if (compress === pieceIndex) {
                        var separator = pieceIndex === 0 ? "::" : ":";
                        output += separator;
                        ignore0 = true;
                        continue;
                    }
                    output += address[pieceIndex].toString(16);
                    if (pieceIndex !== 7) {
                        output += ":";
                    }
                }
                return output;
            }
            function parseHost(input, isSpecialArg) {
                if (input[0] === "[") {
                    if (input[input.length - 1] !== "]") {
                        return failure;
                    }
                    return parseIPv6(input.substring(1, input.length - 1));
                }
                if (!isSpecialArg) {
                    return parseOpaqueHost(input);
                }
                var domain = utf8PercentDecode(input);
                var asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
                if (asciiDomain === null) {
                    return failure;
                }
                if (containsForbiddenHostCodePoint(asciiDomain)) {
                    return failure;
                }
                var ipv4Host = parseIPv4(asciiDomain);
                if (typeof ipv4Host === "number" || ipv4Host === failure) {
                    return ipv4Host;
                }
                return asciiDomain;
            }
            function parseOpaqueHost(input) {
                if (containsForbiddenHostCodePointExcludingPercent(input)) {
                    return failure;
                }
                var output = "";
                var decoded = punycode.ucs2.decode(input);
                for (var i = 0; i < decoded.length; ++i) {
                    output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
                }
                return output;
            }
            function findLongestZeroSequence(arr) {
                var maxIdx = null;
                var maxLen = 1; // only find elements > 1
                var currStart = null;
                var currLen = 0;
                for (var i = 0; i < arr.length; ++i) {
                    if (arr[i] !== 0) {
                        if (currLen > maxLen) {
                            maxIdx = currStart;
                            maxLen = currLen;
                        }
                        currStart = null;
                        currLen = 0;
                    }
                    else {
                        if (currStart === null) {
                            currStart = i;
                        }
                        ++currLen;
                    }
                }
                // if trailing zeros
                if (currLen > maxLen) {
                    maxIdx = currStart;
                    maxLen = currLen;
                }
                return {
                    idx: maxIdx,
                    len: maxLen
                };
            }
            function serializeHost(host) {
                if (typeof host === "number") {
                    return serializeIPv4(host);
                }
                // IPv6 serializer
                if (host instanceof Array) {
                    return "[" + serializeIPv6(host) + "]";
                }
                return host;
            }
            function trimControlChars(url) {
                return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
            }
            function trimTabAndNewline(url) {
                return url.replace(/\u0009|\u000A|\u000D/g, "");
            }
            function shortenPath(url) {
                var path = url.path;
                if (path.length === 0) {
                    return;
                }
                if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
                    return;
                }
                path.pop();
            }
            function includesCredentials(url) {
                return url.username !== "" || url.password !== "";
            }
            function cannotHaveAUsernamePasswordPort(url) {
                return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
            }
            function isNormalizedWindowsDriveLetter(string) {
                return /^[A-Za-z]:$/.test(string);
            }
            function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
                this.pointer = 0;
                this.input = input;
                this.base = base || null;
                this.encodingOverride = encodingOverride || "utf-8";
                this.stateOverride = stateOverride;
                this.url = url;
                this.failure = false;
                this.parseError = false;
                if (!this.url) {
                    this.url = {
                        scheme: "",
                        username: "",
                        password: "",
                        host: null,
                        port: null,
                        path: [],
                        query: null,
                        fragment: null,
                        cannotBeABaseURL: false
                    };
                    var res_1 = trimControlChars(this.input);
                    if (res_1 !== this.input) {
                        this.parseError = true;
                    }
                    this.input = res_1;
                }
                var res = trimTabAndNewline(this.input);
                if (res !== this.input) {
                    this.parseError = true;
                }
                this.input = res;
                this.state = stateOverride || "scheme start";
                this.buffer = "";
                this.atFlag = false;
                this.arrFlag = false;
                this.passwordTokenSeenFlag = false;
                this.input = punycode.ucs2.decode(this.input);
                for (; this.pointer <= this.input.length; ++this.pointer) {
                    var c = this.input[this.pointer];
                    var cStr = isNaN(c) ? undefined : String.fromCodePoint(c);
                    // exec state machine
                    var ret = this["parse " + this.state](c, cStr);
                    if (!ret) {
                        break; // terminate algorithm
                    }
                    else if (ret === failure) {
                        this.failure = true;
                        break;
                    }
                }
            }
            URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
                if (isASCIIAlpha(c)) {
                    this.buffer += cStr.toLowerCase();
                    this.state = "scheme";
                }
                else if (!this.stateOverride) {
                    this.state = "no scheme";
                    --this.pointer;
                }
                else {
                    this.parseError = true;
                    return failure;
                }
                return true;
            };
            URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
                if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
                    this.buffer += cStr.toLowerCase();
                }
                else if (c === 58) {
                    if (this.stateOverride) {
                        if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
                            return false;
                        }
                        if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
                            return false;
                        }
                        if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
                            return false;
                        }
                        if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
                            return false;
                        }
                    }
                    this.url.scheme = this.buffer;
                    this.buffer = "";
                    if (this.stateOverride) {
                        return false;
                    }
                    if (this.url.scheme === "file") {
                        if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
                            this.parseError = true;
                        }
                        this.state = "file";
                    }
                    else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
                        this.state = "special relative or authority";
                    }
                    else if (isSpecial(this.url)) {
                        this.state = "special authority slashes";
                    }
                    else if (this.input[this.pointer + 1] === 47) {
                        this.state = "path or authority";
                        ++this.pointer;
                    }
                    else {
                        this.url.cannotBeABaseURL = true;
                        this.url.path.push("");
                        this.state = "cannot-be-a-base-URL path";
                    }
                }
                else if (!this.stateOverride) {
                    this.buffer = "";
                    this.state = "no scheme";
                    this.pointer = -1;
                }
                else {
                    this.parseError = true;
                    return failure;
                }
                return true;
            };
            URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
                if (this.base === null || (this.base.cannotBeABaseURL && c !== 35)) {
                    return failure;
                }
                else if (this.base.cannotBeABaseURL && c === 35) {
                    this.url.scheme = this.base.scheme;
                    this.url.path = this.base.path.slice();
                    this.url.query = this.base.query;
                    this.url.fragment = "";
                    this.url.cannotBeABaseURL = true;
                    this.state = "fragment";
                }
                else if (this.base.scheme === "file") {
                    this.state = "file";
                    --this.pointer;
                }
                else {
                    this.state = "relative";
                    --this.pointer;
                }
                return true;
            };
            URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
                if (c === 47 && this.input[this.pointer + 1] === 47) {
                    this.state = "special authority ignore slashes";
                    ++this.pointer;
                }
                else {
                    this.parseError = true;
                    this.state = "relative";
                    --this.pointer;
                }
                return true;
            };
            URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
                if (c === 47) {
                    this.state = "authority";
                }
                else {
                    this.state = "path";
                    --this.pointer;
                }
                return true;
            };
            URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
                this.url.scheme = this.base.scheme;
                if (isNaN(c)) {
                    this.url.username = this.base.username;
                    this.url.password = this.base.password;
                    this.url.host = this.base.host;
                    this.url.port = this.base.port;
                    this.url.path = this.base.path.slice();
                    this.url.query = this.base.query;
                }
                else if (c === 47) {
                    this.state = "relative slash";
                }
                else if (c === 63) {
                    this.url.username = this.base.username;
                    this.url.password = this.base.password;
                    this.url.host = this.base.host;
                    this.url.port = this.base.port;
                    this.url.path = this.base.path.slice();
                    this.url.query = "";
                    this.state = "query";
                }
                else if (c === 35) {
                    this.url.username = this.base.username;
                    this.url.password = this.base.password;
                    this.url.host = this.base.host;
                    this.url.port = this.base.port;
                    this.url.path = this.base.path.slice();
                    this.url.query = this.base.query;
                    this.url.fragment = "";
                    this.state = "fragment";
                }
                else if (isSpecial(this.url) && c === 92) {
                    this.parseError = true;
                    this.state = "relative slash";
                }
                else {
                    this.url.username = this.base.username;
                    this.url.password = this.base.password;
                    this.url.host = this.base.host;
                    this.url.port = this.base.port;
                    this.url.path = this.base.path.slice(0, this.base.path.length - 1);
                    this.state = "path";
                    --this.pointer;
                }
                return true;
            };
            URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
                if (isSpecial(this.url) && (c === 47 || c === 92)) {
                    if (c === 92) {
                        this.parseError = true;
                    }
                    this.state = "special authority ignore slashes";
                }
                else if (c === 47) {
                    this.state = "authority";
                }
                else {
                    this.url.username = this.base.username;
                    this.url.password = this.base.password;
                    this.url.host = this.base.host;
                    this.url.port = this.base.port;
                    this.state = "path";
                    --this.pointer;
                }
                return true;
            };
            URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
                if (c === 47 && this.input[this.pointer + 1] === 47) {
                    this.state = "special authority ignore slashes";
                    ++this.pointer;
                }
                else {
                    this.parseError = true;
                    this.state = "special authority ignore slashes";
                    --this.pointer;
                }
                return true;
            };
            URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
                if (c !== 47 && c !== 92) {
                    this.state = "authority";
                    --this.pointer;
                }
                else {
                    this.parseError = true;
                }
                return true;
            };
            URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
                if (c === 64) {
                    this.parseError = true;
                    if (this.atFlag) {
                        this.buffer = "%40" + this.buffer;
                    }
                    this.atFlag = true;
                    // careful, this is based on buffer and has its own pointer (this.pointer != pointer) and inner chars
                    var len = countSymbols(this.buffer);
                    for (var pointer = 0; pointer < len; ++pointer) {
                        var codePoint = this.buffer.codePointAt(pointer);
                        if (codePoint === 58 && !this.passwordTokenSeenFlag) {
                            this.passwordTokenSeenFlag = true;
                            continue;
                        }
                        var encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
                        if (this.passwordTokenSeenFlag) {
                            this.url.password += encodedCodePoints;
                        }
                        else {
                            this.url.username += encodedCodePoints;
                        }
                    }
                    this.buffer = "";
                }
                else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||
                    (isSpecial(this.url) && c === 92)) {
                    if (this.atFlag && this.buffer === "") {
                        this.parseError = true;
                        return failure;
                    }
                    this.pointer -= countSymbols(this.buffer) + 1;
                    this.buffer = "";
                    this.state = "host";
                }
                else {
                    this.buffer += cStr;
                }
                return true;
            };
            URLStateMachine.prototype["parse hostname"] =
                URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
                    if (this.stateOverride && this.url.scheme === "file") {
                        --this.pointer;
                        this.state = "file host";
                    }
                    else if (c === 58 && !this.arrFlag) {
                        if (this.buffer === "") {
                            this.parseError = true;
                            return failure;
                        }
                        var host = parseHost(this.buffer, isSpecial(this.url));
                        if (host === failure) {
                            return failure;
                        }
                        this.url.host = host;
                        this.buffer = "";
                        this.state = "port";
                        if (this.stateOverride === "hostname") {
                            return false;
                        }
                    }
                    else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||
                        (isSpecial(this.url) && c === 92)) {
                        --this.pointer;
                        if (isSpecial(this.url) && this.buffer === "") {
                            this.parseError = true;
                            return failure;
                        }
                        else if (this.stateOverride && this.buffer === "" &&
                            (includesCredentials(this.url) || this.url.port !== null)) {
                            this.parseError = true;
                            return false;
                        }
                        var host = parseHost(this.buffer, isSpecial(this.url));
                        if (host === failure) {
                            return failure;
                        }
                        this.url.host = host;
                        this.buffer = "";
                        this.state = "path start";
                        if (this.stateOverride) {
                            return false;
                        }
                    }
                    else {
                        if (c === 91) {
                            this.arrFlag = true;
                        }
                        else if (c === 93) {
                            this.arrFlag = false;
                        }
                        this.buffer += cStr;
                    }
                    return true;
                };
            URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
                if (isASCIIDigit(c)) {
                    this.buffer += cStr;
                }
                else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||
                    (isSpecial(this.url) && c === 92) ||
                    this.stateOverride) {
                    if (this.buffer !== "") {
                        var port = parseInt(this.buffer);
                        if (port > Math.pow(2, 16) - 1) {
                            this.parseError = true;
                            return failure;
                        }
                        this.url.port = port === defaultPort(this.url.scheme) ? null : port;
                        this.buffer = "";
                    }
                    if (this.stateOverride) {
                        return false;
                    }
                    this.state = "path start";
                    --this.pointer;
                }
                else {
                    this.parseError = true;
                    return failure;
                }
                return true;
            };
            var fileOtherwiseCodePoints = new Set([47, 92, 63, 35]);
            URLStateMachine.prototype["parse file"] = function parseFile(c) {
                this.url.scheme = "file";
                if (c === 47 || c === 92) {
                    if (c === 92) {
                        this.parseError = true;
                    }
                    this.state = "file slash";
                }
                else if (this.base !== null && this.base.scheme === "file") {
                    if (isNaN(c)) {
                        this.url.host = this.base.host;
                        this.url.path = this.base.path.slice();
                        this.url.query = this.base.query;
                    }
                    else if (c === 63) {
                        this.url.host = this.base.host;
                        this.url.path = this.base.path.slice();
                        this.url.query = "";
                        this.state = "query";
                    }
                    else if (c === 35) {
                        this.url.host = this.base.host;
                        this.url.path = this.base.path.slice();
                        this.url.query = this.base.query;
                        this.url.fragment = "";
                        this.state = "fragment";
                    }
                    else {
                        if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
                            !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) ||
                            (this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
                                !fileOtherwiseCodePoints.has(this.input[this.pointer + 2]))) {
                            this.url.host = this.base.host;
                            this.url.path = this.base.path.slice();
                            shortenPath(this.url);
                        }
                        else {
                            this.parseError = true;
                        }
                        this.state = "path";
                        --this.pointer;
                    }
                }
                else {
                    this.state = "path";
                    --this.pointer;
                }
                return true;
            };
            URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
                if (c === 47 || c === 92) {
                    if (c === 92) {
                        this.parseError = true;
                    }
                    this.state = "file host";
                }
                else {
                    if (this.base !== null && this.base.scheme === "file") {
                        if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
                            this.url.path.push(this.base.path[0]);
                        }
                        else {
                            this.url.host = this.base.host;
                        }
                    }
                    this.state = "path";
                    --this.pointer;
                }
                return true;
            };
            URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
                if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
                    --this.pointer;
                    if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
                        this.parseError = true;
                        this.state = "path";
                    }
                    else if (this.buffer === "") {
                        this.url.host = "";
                        if (this.stateOverride) {
                            return false;
                        }
                        this.state = "path start";
                    }
                    else {
                        var host = parseHost(this.buffer, isSpecial(this.url));
                        if (host === failure) {
                            return failure;
                        }
                        if (host === "localhost") {
                            host = "";
                        }
                        this.url.host = host;
                        if (this.stateOverride) {
                            return false;
                        }
                        this.buffer = "";
                        this.state = "path start";
                    }
                }
                else {
                    this.buffer += cStr;
                }
                return true;
            };
            URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
                if (isSpecial(this.url)) {
                    if (c === 92) {
                        this.parseError = true;
                    }
                    this.state = "path";
                    if (c !== 47 && c !== 92) {
                        --this.pointer;
                    }
                }
                else if (!this.stateOverride && c === 63) {
                    this.url.query = "";
                    this.state = "query";
                }
                else if (!this.stateOverride && c === 35) {
                    this.url.fragment = "";
                    this.state = "fragment";
                }
                else if (c !== undefined) {
                    this.state = "path";
                    if (c !== 47) {
                        --this.pointer;
                    }
                }
                return true;
            };
            URLStateMachine.prototype["parse path"] = function parsePath(c) {
                if (isNaN(c) || c === 47 || (isSpecial(this.url) && c === 92) ||
                    (!this.stateOverride && (c === 63 || c === 35))) {
                    if (isSpecial(this.url) && c === 92) {
                        this.parseError = true;
                    }
                    if (isDoubleDot(this.buffer)) {
                        shortenPath(this.url);
                        if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
                            this.url.path.push("");
                        }
                    }
                    else if (isSingleDot(this.buffer) && c !== 47 &&
                        !(isSpecial(this.url) && c === 92)) {
                        this.url.path.push("");
                    }
                    else if (!isSingleDot(this.buffer)) {
                        if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
                            if (this.url.host !== "" && this.url.host !== null) {
                                this.parseError = true;
                                this.url.host = "";
                            }
                            this.buffer = this.buffer[0] + ":";
                        }
                        this.url.path.push(this.buffer);
                    }
                    this.buffer = "";
                    if (this.url.scheme === "file" && (c === undefined || c === 63 || c === 35)) {
                        while (this.url.path.length > 1 && this.url.path[0] === "") {
                            this.parseError = true;
                            this.url.path.shift();
                        }
                    }
                    if (c === 63) {
                        this.url.query = "";
                        this.state = "query";
                    }
                    if (c === 35) {
                        this.url.fragment = "";
                        this.state = "fragment";
                    }
                }
                else {
                    // TODO: If c is not a URL code point and not "%", parse error.
                    if (c === 37 &&
                        (!isASCIIHex(this.input[this.pointer + 1]) ||
                            !isASCIIHex(this.input[this.pointer + 2]))) {
                        this.parseError = true;
                    }
                    this.buffer += percentEncodeChar(c, isPathPercentEncode);
                }
                return true;
            };
            URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
                if (c === 63) {
                    this.url.query = "";
                    this.state = "query";
                }
                else if (c === 35) {
                    this.url.fragment = "";
                    this.state = "fragment";
                }
                else {
                    // TODO: Add: not a URL code point
                    if (!isNaN(c) && c !== 37) {
                        this.parseError = true;
                    }
                    if (c === 37 &&
                        (!isASCIIHex(this.input[this.pointer + 1]) ||
                            !isASCIIHex(this.input[this.pointer + 2]))) {
                        this.parseError = true;
                    }
                    if (!isNaN(c)) {
                        this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
                    }
                }
                return true;
            };
            URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
                if (isNaN(c) || (!this.stateOverride && c === 35)) {
                    if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
                        this.encodingOverride = "utf-8";
                    }
                    var buffer = new Buffer(this.buffer); // TODO: Use encoding override instead
                    for (var i = 0; i < buffer.length; ++i) {
                        if (buffer[i] < 0x21 || buffer[i] > 0x7E || buffer[i] === 0x22 || buffer[i] === 0x23 ||
                            buffer[i] === 0x3C || buffer[i] === 0x3E) {
                            this.url.query += percentEncode(buffer[i]);
                        }
                        else {
                            this.url.query += String.fromCodePoint(buffer[i]);
                        }
                    }
                    this.buffer = "";
                    if (c === 35) {
                        this.url.fragment = "";
                        this.state = "fragment";
                    }
                }
                else {
                    // TODO: If c is not a URL code point and not "%", parse error.
                    if (c === 37 &&
                        (!isASCIIHex(this.input[this.pointer + 1]) ||
                            !isASCIIHex(this.input[this.pointer + 2]))) {
                        this.parseError = true;
                    }
                    this.buffer += cStr;
                }
                return true;
            };
            URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
                if (isNaN(c)) { // do nothing
                }
                else if (c === 0x0) {
                    this.parseError = true;
                }
                else {
                    // TODO: If c is not a URL code point and not "%", parse error.
                    if (c === 37 &&
                        (!isASCIIHex(this.input[this.pointer + 1]) ||
                            !isASCIIHex(this.input[this.pointer + 2]))) {
                        this.parseError = true;
                    }
                    this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
                }
                return true;
            };
            function serializeURL(url, excludeFragment) {
                var output = url.scheme + ":";
                if (url.host !== null) {
                    output += "//";
                    if (url.username !== "" || url.password !== "") {
                        output += url.username;
                        if (url.password !== "") {
                            output += ":" + url.password;
                        }
                        output += "@";
                    }
                    output += serializeHost(url.host);
                    if (url.port !== null) {
                        output += ":" + url.port;
                    }
                }
                else if (url.host === null && url.scheme === "file") {
                    output += "//";
                }
                if (url.cannotBeABaseURL) {
                    output += url.path[0];
                }
                else {
                    for (var _1 = 0, _2 = url.path; _1 < _2.length; _1++) {
                        var string = _2[_1];
                        output += "/" + string;
                    }
                }
                if (url.query !== null) {
                    output += "?" + url.query;
                }
                if (!excludeFragment && url.fragment !== null) {
                    output += "#" + url.fragment;
                }
                return output;
            }
            function serializeOrigin(tuple) {
                var result = tuple.scheme + "://";
                result += serializeHost(tuple.host);
                if (tuple.port !== null) {
                    result += ":" + tuple.port;
                }
                return result;
            }
            module.exports.serializeURL = serializeURL;
            module.exports.serializeURLOrigin = function (url) {
                // https://url.spec.whatwg.org/#concept-url-origin
                switch (url.scheme) {
                    case "blob":
                        try {
                            return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
                        }
                        catch (e) {
                            // serializing an opaque origin returns "null"
                            return "null";
                        }
                    case "ftp":
                    case "gopher":
                    case "http":
                    case "https":
                    case "ws":
                    case "wss":
                        return serializeOrigin({
                            scheme: url.scheme,
                            host: url.host,
                            port: url.port
                        });
                    case "file":
                        // spec says "exercise to the reader", chrome says "file://"
                        return "file://";
                    default:
                        // serializing an opaque origin returns "null"
                        return "null";
                }
            };
            module.exports.basicURLParse = function (input, options) {
                if (options === undefined) {
                    options = {};
                }
                var usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
                if (usm.failure) {
                    return "failure";
                }
                return usm.url;
            };
            module.exports.setTheUsername = function (url, username) {
                url.username = "";
                var decoded = punycode.ucs2.decode(username);
                for (var i = 0; i < decoded.length; ++i) {
                    url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
                }
            };
            module.exports.setThePassword = function (url, password) {
                url.password = "";
                var decoded = punycode.ucs2.decode(password);
                for (var i = 0; i < decoded.length; ++i) {
                    url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
                }
            };
            module.exports.serializeHost = serializeHost;
            module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
            module.exports.serializeInteger = function (integer) {
                return String(integer);
            };
            module.exports.parseURL = function (input, options) {
                if (options === undefined) {
                    options = {};
                }
                // We don't handle blobs, so this just delegates:
                return module.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
            };
            /***/ 
        }),
        /***/ 3185: 
        /***/ (function (module) {
            "use strict";
            module.exports.mixin = function mixin(target, source) {
                var keys = Object.getOwnPropertyNames(source);
                for (var i = 0; i < keys.length; ++i) {
                    Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
                }
            };
            module.exports.wrapperSymbol = Symbol("wrapper");
            module.exports.implSymbol = Symbol("impl");
            module.exports.wrapperForImpl = function (impl) {
                return impl[module.exports.wrapperSymbol];
            };
            module.exports.implForWrapper = function (wrapper) {
                return wrapper[module.exports.implSymbol];
            };
            /***/ 
        }),
        /***/ 2940: 
        /***/ (function (module) {
            // Returns a wrapper function that returns a wrapped callback
            // The wrapper function should do some stuff, and return a
            // presumably different callback function.
            // This makes sure that own properties are retained, so that
            // decorations and such are not lost along the way.
            module.exports = wrappy;
            function wrappy(fn, cb) {
                if (fn && cb)
                    return wrappy(fn)(cb);
                if (typeof fn !== 'function')
                    throw new TypeError('need wrapper function');
                Object.keys(fn).forEach(function (k) {
                    wrapper[k] = fn[k];
                });
                return wrapper;
                function wrapper() {
                    var args = new Array(arguments.length);
                    for (var i = 0; i < args.length; i++) {
                        args[i] = arguments[i];
                    }
                    var ret = fn.apply(this, args);
                    var cb = args[args.length - 1];
                    if (typeof ret === 'function' && ret !== cb) {
                        Object.keys(cb).forEach(function (k) {
                            ret[k] = cb[k];
                        });
                    }
                    return ret;
                }
            }
            /***/ 
        }),
        /***/ 4091: 
        /***/ (function (module) {
            "use strict";
            module.exports = function (Yallist) {
                Yallist.prototype[Symbol.iterator] = function () {
                    var walker;
                    return __generator(this, function (_1) {
                        switch (_1.label) {
                            case 0:
                                walker = this.head;
                                _1.label = 1;
                            case 1:
                                if (!walker) return [3 /*break*/, 4];
                                return [4 /*yield*/, walker.value];
                            case 2:
                                _1.sent();
                                _1.label = 3;
                            case 3:
                                walker = walker.next;
                                return [3 /*break*/, 1];
                            case 4: return [2 /*return*/];
                        }
                    });
                };
            };
            /***/ 
        }),
        /***/ 665: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            module.exports = Yallist;
            Yallist.Node = Node;
            Yallist.create = Yallist;
            function Yallist(list) {
                var self = this;
                if (!(self instanceof Yallist)) {
                    self = new Yallist();
                }
                self.tail = null;
                self.head = null;
                self.length = 0;
                if (list && typeof list.forEach === 'function') {
                    list.forEach(function (item) {
                        self.push(item);
                    });
                }
                else if (arguments.length > 0) {
                    for (var i = 0, l = arguments.length; i < l; i++) {
                        self.push(arguments[i]);
                    }
                }
                return self;
            }
            Yallist.prototype.removeNode = function (node) {
                if (node.list !== this) {
                    throw new Error('removing node which does not belong to this list');
                }
                var next = node.next;
                var prev = node.prev;
                if (next) {
                    next.prev = prev;
                }
                if (prev) {
                    prev.next = next;
                }
                if (node === this.head) {
                    this.head = next;
                }
                if (node === this.tail) {
                    this.tail = prev;
                }
                node.list.length--;
                node.next = null;
                node.prev = null;
                node.list = null;
                return next;
            };
            Yallist.prototype.unshiftNode = function (node) {
                if (node === this.head) {
                    return;
                }
                if (node.list) {
                    node.list.removeNode(node);
                }
                var head = this.head;
                node.list = this;
                node.next = head;
                if (head) {
                    head.prev = node;
                }
                this.head = node;
                if (!this.tail) {
                    this.tail = node;
                }
                this.length++;
            };
            Yallist.prototype.pushNode = function (node) {
                if (node === this.tail) {
                    return;
                }
                if (node.list) {
                    node.list.removeNode(node);
                }
                var tail = this.tail;
                node.list = this;
                node.prev = tail;
                if (tail) {
                    tail.next = node;
                }
                this.tail = node;
                if (!this.head) {
                    this.head = node;
                }
                this.length++;
            };
            Yallist.prototype.push = function () {
                for (var i = 0, l = arguments.length; i < l; i++) {
                    push(this, arguments[i]);
                }
                return this.length;
            };
            Yallist.prototype.unshift = function () {
                for (var i = 0, l = arguments.length; i < l; i++) {
                    unshift(this, arguments[i]);
                }
                return this.length;
            };
            Yallist.prototype.pop = function () {
                if (!this.tail) {
                    return undefined;
                }
                var res = this.tail.value;
                this.tail = this.tail.prev;
                if (this.tail) {
                    this.tail.next = null;
                }
                else {
                    this.head = null;
                }
                this.length--;
                return res;
            };
            Yallist.prototype.shift = function () {
                if (!this.head) {
                    return undefined;
                }
                var res = this.head.value;
                this.head = this.head.next;
                if (this.head) {
                    this.head.prev = null;
                }
                else {
                    this.tail = null;
                }
                this.length--;
                return res;
            };
            Yallist.prototype.forEach = function (fn, thisp) {
                thisp = thisp || this;
                for (var walker = this.head, i = 0; walker !== null; i++) {
                    fn.call(thisp, walker.value, i, this);
                    walker = walker.next;
                }
            };
            Yallist.prototype.forEachReverse = function (fn, thisp) {
                thisp = thisp || this;
                for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
                    fn.call(thisp, walker.value, i, this);
                    walker = walker.prev;
                }
            };
            Yallist.prototype.get = function (n) {
                for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
                    // abort out of the list early if we hit a cycle
                    walker = walker.next;
                }
                if (i === n && walker !== null) {
                    return walker.value;
                }
            };
            Yallist.prototype.getReverse = function (n) {
                for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
                    // abort out of the list early if we hit a cycle
                    walker = walker.prev;
                }
                if (i === n && walker !== null) {
                    return walker.value;
                }
            };
            Yallist.prototype.map = function (fn, thisp) {
                thisp = thisp || this;
                var res = new Yallist();
                for (var walker = this.head; walker !== null;) {
                    res.push(fn.call(thisp, walker.value, this));
                    walker = walker.next;
                }
                return res;
            };
            Yallist.prototype.mapReverse = function (fn, thisp) {
                thisp = thisp || this;
                var res = new Yallist();
                for (var walker = this.tail; walker !== null;) {
                    res.push(fn.call(thisp, walker.value, this));
                    walker = walker.prev;
                }
                return res;
            };
            Yallist.prototype.reduce = function (fn, initial) {
                var acc;
                var walker = this.head;
                if (arguments.length > 1) {
                    acc = initial;
                }
                else if (this.head) {
                    walker = this.head.next;
                    acc = this.head.value;
                }
                else {
                    throw new TypeError('Reduce of empty list with no initial value');
                }
                for (var i = 0; walker !== null; i++) {
                    acc = fn(acc, walker.value, i);
                    walker = walker.next;
                }
                return acc;
            };
            Yallist.prototype.reduceReverse = function (fn, initial) {
                var acc;
                var walker = this.tail;
                if (arguments.length > 1) {
                    acc = initial;
                }
                else if (this.tail) {
                    walker = this.tail.prev;
                    acc = this.tail.value;
                }
                else {
                    throw new TypeError('Reduce of empty list with no initial value');
                }
                for (var i = this.length - 1; walker !== null; i--) {
                    acc = fn(acc, walker.value, i);
                    walker = walker.prev;
                }
                return acc;
            };
            Yallist.prototype.toArray = function () {
                var arr = new Array(this.length);
                for (var i = 0, walker = this.head; walker !== null; i++) {
                    arr[i] = walker.value;
                    walker = walker.next;
                }
                return arr;
            };
            Yallist.prototype.toArrayReverse = function () {
                var arr = new Array(this.length);
                for (var i = 0, walker = this.tail; walker !== null; i++) {
                    arr[i] = walker.value;
                    walker = walker.prev;
                }
                return arr;
            };
            Yallist.prototype.slice = function (from, to) {
                to = to || this.length;
                if (to < 0) {
                    to += this.length;
                }
                from = from || 0;
                if (from < 0) {
                    from += this.length;
                }
                var ret = new Yallist();
                if (to < from || to < 0) {
                    return ret;
                }
                if (from < 0) {
                    from = 0;
                }
                if (to > this.length) {
                    to = this.length;
                }
                for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
                    walker = walker.next;
                }
                for (; walker !== null && i < to; i++, walker = walker.next) {
                    ret.push(walker.value);
                }
                return ret;
            };
            Yallist.prototype.sliceReverse = function (from, to) {
                to = to || this.length;
                if (to < 0) {
                    to += this.length;
                }
                from = from || 0;
                if (from < 0) {
                    from += this.length;
                }
                var ret = new Yallist();
                if (to < from || to < 0) {
                    return ret;
                }
                if (from < 0) {
                    from = 0;
                }
                if (to > this.length) {
                    to = this.length;
                }
                for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
                    walker = walker.prev;
                }
                for (; walker !== null && i > from; i--, walker = walker.prev) {
                    ret.push(walker.value);
                }
                return ret;
            };
            Yallist.prototype.splice = function (start, deleteCount) {
                var nodes = [];
                for (var _1 = 2; _1 < arguments.length; _1++) {
                    nodes[_1 - 2] = arguments[_1];
                }
                if (start > this.length) {
                    start = this.length - 1;
                }
                if (start < 0) {
                    start = this.length + start;
                }
                for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
                    walker = walker.next;
                }
                var ret = [];
                for (var i = 0; walker && i < deleteCount; i++) {
                    ret.push(walker.value);
                    walker = this.removeNode(walker);
                }
                if (walker === null) {
                    walker = this.tail;
                }
                if (walker !== this.head && walker !== this.tail) {
                    walker = walker.prev;
                }
                for (var i = 0; i < nodes.length; i++) {
                    walker = insert(this, walker, nodes[i]);
                }
                return ret;
            };
            Yallist.prototype.reverse = function () {
                var head = this.head;
                var tail = this.tail;
                for (var walker = head; walker !== null; walker = walker.prev) {
                    var p = walker.prev;
                    walker.prev = walker.next;
                    walker.next = p;
                }
                this.head = tail;
                this.tail = head;
                return this;
            };
            function insert(self, node, value) {
                var inserted = node === self.head ?
                    new Node(value, null, node, self) :
                    new Node(value, node, node.next, self);
                if (inserted.next === null) {
                    self.tail = inserted;
                }
                if (inserted.prev === null) {
                    self.head = inserted;
                }
                self.length++;
                return inserted;
            }
            function push(self, item) {
                self.tail = new Node(item, self.tail, null, self);
                if (!self.head) {
                    self.head = self.tail;
                }
                self.length++;
            }
            function unshift(self, item) {
                self.head = new Node(item, null, self.head, self);
                if (!self.tail) {
                    self.tail = self.head;
                }
                self.length++;
            }
            function Node(value, prev, next, list) {
                if (!(this instanceof Node)) {
                    return new Node(value, prev, next, list);
                }
                this.list = list;
                this.value = value;
                if (prev) {
                    prev.next = this;
                    this.prev = prev;
                }
                else {
                    this.prev = null;
                }
                if (next) {
                    next.prev = this;
                    this.next = next;
                }
                else {
                    this.next = null;
                }
            }
            try {
                // add if support for Symbol.iterator is present
                __nccwpck_require__(4091)(Yallist);
            }
            catch (er) { }
            /***/ 
        }),
        /***/ 1583: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var __importDefault = (this && this.__importDefault) || function (mod) {
                return (mod && mod.__esModule) ? mod : { "default": mod };
            };
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var w3c_css_validator_1 = __importDefault(__nccwpck_require__(9112));
            function validateCSS(content) {
                return __awaiter(this, void 0, void 0, function () {
                    var warnings, errors, result;
                    return __generator(this, function (_1) {
                        switch (_1.label) {
                            case 0:
                                warnings = [];
                                errors = [];
                                return [4 /*yield*/, w3c_css_validator_1["default"].validateText(content, {
                                        medium: "print",
                                        warningLevel: 3
                                    })];
                            case 1:
                                result = _1.sent();
                                if (!result.valid) {
                                    errors.push(result.errors.map(function (x) { return "Line ".concat(x.line, ": ").concat(x.message); }).join("\n"));
                                    warnings.push(result.warnings.map(function (x) { return "Line ".concat(x.line, " (").concat(x.level, "): ").concat(x.message); }).join("\n"));
                                }
                                return [2 /*return*/, {
                                        warnings: warnings,
                                        errors: errors
                                    }];
                        }
                    });
                });
            }
            exports["default"] = validateCSS;
            /***/ 
        }),
        /***/ 2051: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var node_1 = __nccwpck_require__(9886);
            function validateHTML(content) {
                return __awaiter(this, void 0, void 0, function () {
                    var warnings, errors, htmlvalidate, report;
                    return __generator(this, function (_1) {
                        switch (_1.label) {
                            case 0:
                                warnings = [];
                                errors = [];
                                htmlvalidate = new node_1.HtmlValidate();
                                return [4 /*yield*/, htmlvalidate.validateString(content)];
                            case 1:
                                report = _1.sent();
                                console.log(report);
                                return [2 /*return*/, {
                                        warnings: warnings,
                                        errors: errors
                                    }];
                        }
                    });
                });
            }
            exports["default"] = validateHTML;
            /***/ 
        }),
        /***/ 6144: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var __importDefault = (this && this.__importDefault) || function (mod) {
                return (mod && mod.__esModule) ? mod : { "default": mod };
            };
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var core_1 = __nccwpck_require__(2186);
            var github_1 = __nccwpck_require__(5438);
            var css_1 = __importDefault(__nccwpck_require__(1583));
            var html_1 = __importDefault(__nccwpck_require__(2051));
            var token = process.env.GITHUB_TOKEN;
            function run() {
                return __awaiter(this, void 0, void 0, function () {
                    var octokit, _1, owner, repo, payload, commitSha, commit, files, validation, _2, files_1, file, fileBlob, content, _3, warnings, errors, _4, warnings, errors, msg, problem, error_3;
                    return __generator(this, function (_5) {
                        switch (_5.label) {
                            case 0:
                                _5.trys.push([0, 11, , 12]);
                                if (!token)
                                    return [2 /*return*/, (0, core_1.setFailed)("Invalid GITHUB_TOKEN")];
                                octokit = (0, github_1.getOctokit)(token);
                                _1 = github_1.context.repo, owner = _1.owner, repo = _1.repo;
                                if (github_1.context.eventName !== "push")
                                    return [2 /*return*/];
                                payload = github_1.context.payload;
                                commitSha = payload.after;
                                return [4 /*yield*/, octokit.rest.repos.getCommit({
                                        owner: owner,
                                        repo: repo,
                                        ref: commitSha
                                    })];
                            case 1:
                                commit = _5.sent();
                                files = commit.data.files;
                                validation = {
                                    css: {
                                        errors: [],
                                        warnings: []
                                    },
                                    html: {
                                        errors: [],
                                        warnings: []
                                    }
                                };
                                _2 = 0, files_1 = files;
                                _5.label = 2;
                            case 2:
                                if (!(_2 < files_1.length)) return [3 /*break*/, 8];
                                file = files_1[_2];
                                return [4 /*yield*/, octokit.rest.git.getBlob({
                                        owner: owner,
                                        repo: repo,
                                        file_sha: file.sha
                                    })];
                            case 3:
                                fileBlob = _5.sent();
                                content = Buffer.from(fileBlob.data.content, "base64").toString("utf8");
                                if (!file.filename.endsWith(".css")) return [3 /*break*/, 5];
                                return [4 /*yield*/, (0, css_1["default"])(content)];
                            case 4:
                                _3 = _5.sent(), warnings = _3.warnings, errors = _3.errors;
                                validation.css.errors = errors;
                                validation.css.warnings = warnings;
                                return [3 /*break*/, 7];
                            case 5:
                                if (!file.filename.endsWith(".html")) return [3 /*break*/, 7];
                                return [4 /*yield*/, (0, html_1["default"])(content)];
                            case 6:
                                _4 = _5.sent(), warnings = _4.warnings, errors = _4.errors;
                                validation.html.errors = errors;
                                validation.html.warnings = warnings;
                                _5.label = 7;
                            case 7:
                                _2++;
                                return [3 /*break*/, 2];
                            case 8:
                                msg = [];
                                problem = false;
                                if (validation.css.errors.length > 0 || validation.css.warnings.length > 0) {
                                    problem = true;
                                    msg.push("# CSS Validation Problem\n");
                                    if (validation.css.errors.length > 0) {
                                        msg.push("### Errors");
                                        msg.push(validation.css.errors.join("\n"));
                                    }
                                    if (validation.css.warnings.length > 0) {
                                        msg.push("### Warnings");
                                        msg.push(validation.css.warnings.join("\n"));
                                    }
                                }
                                else if (validation.html.errors.length > 0 || validation.html.warnings.length > 0) {
                                    if (problem) {
                                        msg.push("---");
                                    }
                                    problem = true;
                                    msg.push("# HTML Validation Problem\n");
                                    if (validation.html.errors.length > 0) {
                                        msg.push("### Errors");
                                        msg.push(validation.html.errors.join("\n"));
                                    }
                                    if (validation.html.warnings.length > 0) {
                                        msg.push("### Warnings");
                                        msg.push(validation.html.warnings.join("\n"));
                                    }
                                }
                                if (!problem) return [3 /*break*/, 10];
                                return [4 /*yield*/, octokit.rest.repos.createCommitComment({
                                        owner: owner,
                                        repo: repo,
                                        commit_sha: commitSha,
                                        body: msg.join("\n")
                                    })];
                            case 9:
                                _5.sent();
                                return [2 /*return*/, (0, core_1.error)("Validation errors was found, commented on the commit")];
                            case 10: return [2 /*return*/, (0, core_1.info)("No validation errors was found")];
                            case 11:
                                error_3 = _5.sent();
                                (0, core_1.setFailed)((0, core_1.isDebug)() ? error_3.stack : error_3.message);
                                return [3 /*break*/, 12];
                            case 12: return [2 /*return*/];
                        }
                    });
                });
            }
            run();
            /***/ 
        }),
        /***/ 2877: 
        /***/ (function (module) {
            module.exports = eval("require")("encoding");
            /***/ 
        }),
        /***/ 9491: 
        /***/ (function (module) {
            "use strict";
            module.exports = require("assert");
            /***/ 
        }),
        /***/ 6113: 
        /***/ (function (module) {
            "use strict";
            module.exports = require("crypto");
            /***/ 
        }),
        /***/ 2361: 
        /***/ (function (module) {
            "use strict";
            module.exports = require("events");
            /***/ 
        }),
        /***/ 7147: 
        /***/ (function (module) {
            "use strict";
            module.exports = require("fs");
            /***/ 
        }),
        /***/ 3292: 
        /***/ (function (module) {
            "use strict";
            module.exports = require("fs/promises");
            /***/ 
        }),
        /***/ 3685: 
        /***/ (function (module) {
            "use strict";
            module.exports = require("http");
            /***/ 
        }),
        /***/ 5687: 
        /***/ (function (module) {
            "use strict";
            module.exports = require("https");
            /***/ 
        }),
        /***/ 1808: 
        /***/ (function (module) {
            "use strict";
            module.exports = require("net");
            /***/ 
        }),
        /***/ 7561: 
        /***/ (function (module) {
            "use strict";
            module.exports = require("node:fs");
            /***/ 
        }),
        /***/ 9411: 
        /***/ (function (module) {
            "use strict";
            module.exports = require("node:path");
            /***/ 
        }),
        /***/ 2037: 
        /***/ (function (module) {
            "use strict";
            module.exports = require("os");
            /***/ 
        }),
        /***/ 1017: 
        /***/ (function (module) {
            "use strict";
            module.exports = require("path");
            /***/ 
        }),
        /***/ 5477: 
        /***/ (function (module) {
            "use strict";
            module.exports = require("punycode");
            /***/ 
        }),
        /***/ 4521: 
        /***/ (function (module) {
            "use strict";
            module.exports = require("readline");
            /***/ 
        }),
        /***/ 2781: 
        /***/ (function (module) {
            "use strict";
            module.exports = require("stream");
            /***/ 
        }),
        /***/ 1576: 
        /***/ (function (module) {
            "use strict";
            module.exports = require("string_decoder");
            /***/ 
        }),
        /***/ 4404: 
        /***/ (function (module) {
            "use strict";
            module.exports = require("tls");
            /***/ 
        }),
        /***/ 6224: 
        /***/ (function (module) {
            "use strict";
            module.exports = require("tty");
            /***/ 
        }),
        /***/ 7310: 
        /***/ (function (module) {
            "use strict";
            module.exports = require("url");
            /***/ 
        }),
        /***/ 3837: 
        /***/ (function (module) {
            "use strict";
            module.exports = require("util");
            /***/ 
        }),
        /***/ 9796: 
        /***/ (function (module) {
            "use strict";
            module.exports = require("zlib");
            /***/ 
        }),
        /***/ 1322: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({
                value: true
            }));
            exports.codeFrameColumns = codeFrameColumns;
            exports["default"] = _default;
            var _highlight = __nccwpck_require__(7654);
            var _chalk = _interopRequireWildcard(__nccwpck_require__(8707), true);
            function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function")
                return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
            function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) {
                return obj;
            } if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
                return { "default": obj };
            } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) {
                return cache.get(obj);
            } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) {
                if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
                    if (desc && (desc.get || desc.set)) {
                        Object.defineProperty(newObj, key, desc);
                    }
                    else {
                        newObj[key] = obj[key];
                    }
                }
            } newObj["default"] = obj; if (cache) {
                cache.set(obj, newObj);
            } return newObj; }
            var chalkWithForcedColor = undefined;
            function getChalk(forceColor) {
                if (forceColor) {
                    var _chalkWithForcedColor;
                    (_chalkWithForcedColor = chalkWithForcedColor) != null ? _chalkWithForcedColor : chalkWithForcedColor = new _chalk["default"].constructor({
                        enabled: true,
                        level: 1
                    });
                    return chalkWithForcedColor;
                }
                return _chalk["default"];
            }
            var deprecationWarningShown = false;
            function getDefs(chalk) {
                return {
                    gutter: chalk.grey,
                    marker: chalk.red.bold,
                    message: chalk.red.bold
                };
            }
            var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
            function getMarkerLines(loc, source, opts) {
                var startLoc = Object.assign({
                    column: 0,
                    line: -1
                }, loc.start);
                var endLoc = Object.assign({}, startLoc, loc.end);
                var _1 = opts || {}, _2 = _1.linesAbove, linesAbove = _2 === void 0 ? 2 : _2, _3 = _1.linesBelow, linesBelow = _3 === void 0 ? 3 : _3;
                var startLine = startLoc.line;
                var startColumn = startLoc.column;
                var endLine = endLoc.line;
                var endColumn = endLoc.column;
                var start = Math.max(startLine - (linesAbove + 1), 0);
                var end = Math.min(source.length, endLine + linesBelow);
                if (startLine === -1) {
                    start = 0;
                }
                if (endLine === -1) {
                    end = source.length;
                }
                var lineDiff = endLine - startLine;
                var markerLines = {};
                if (lineDiff) {
                    for (var i = 0; i <= lineDiff; i++) {
                        var lineNumber = i + startLine;
                        if (!startColumn) {
                            markerLines[lineNumber] = true;
                        }
                        else if (i === 0) {
                            var sourceLength = source[lineNumber - 1].length;
                            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
                        }
                        else if (i === lineDiff) {
                            markerLines[lineNumber] = [0, endColumn];
                        }
                        else {
                            var sourceLength = source[lineNumber - i].length;
                            markerLines[lineNumber] = [0, sourceLength];
                        }
                    }
                }
                else {
                    if (startColumn === endColumn) {
                        if (startColumn) {
                            markerLines[startLine] = [startColumn, 0];
                        }
                        else {
                            markerLines[startLine] = true;
                        }
                    }
                    else {
                        markerLines[startLine] = [startColumn, endColumn - startColumn];
                    }
                }
                return {
                    start: start,
                    end: end,
                    markerLines: markerLines
                };
            }
            function codeFrameColumns(rawLines, loc, opts) {
                if (opts === void 0) { opts = {}; }
                var highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts);
                var chalk = getChalk(opts.forceColor);
                var defs = getDefs(chalk);
                var maybeHighlight = function (chalkFn, string) {
                    return highlighted ? chalkFn(string) : string;
                };
                var lines = rawLines.split(NEWLINE);
                var _1 = getMarkerLines(loc, lines, opts), start = _1.start, end = _1.end, markerLines = _1.markerLines;
                var hasColumns = loc.start && typeof loc.start.column === "number";
                var numberMaxWidth = String(end).length;
                var highlightedLines = highlighted ? (0, _highlight["default"])(rawLines, opts) : rawLines;
                var frame = highlightedLines.split(NEWLINE, end).slice(start, end).map(function (line, index) {
                    var number = start + 1 + index;
                    var paddedNumber = " ".concat(number).slice(-numberMaxWidth);
                    var gutter = " ".concat(paddedNumber, " |");
                    var hasMarker = markerLines[number];
                    var lastMarkerLine = !markerLines[number + 1];
                    if (hasMarker) {
                        var markerLine = "";
                        if (Array.isArray(hasMarker)) {
                            var markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
                            var numberOfMarkers = hasMarker[1] || 1;
                            markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), " ", markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");
                            if (lastMarkerLine && opts.message) {
                                markerLine += " " + maybeHighlight(defs.message, opts.message);
                            }
                        }
                        return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line.length > 0 ? " ".concat(line) : "", markerLine].join("");
                    }
                    else {
                        return " ".concat(maybeHighlight(defs.gutter, gutter)).concat(line.length > 0 ? " ".concat(line) : "");
                    }
                }).join("\n");
                if (opts.message && !hasColumns) {
                    frame = "".concat(" ".repeat(numberMaxWidth + 1)).concat(opts.message, "\n").concat(frame);
                }
                if (highlighted) {
                    return chalk.reset(frame);
                }
                else {
                    return frame;
                }
            }
            function _default(rawLines, lineNumber, colNumber, opts) {
                if (opts === void 0) { opts = {}; }
                if (!deprecationWarningShown) {
                    deprecationWarningShown = true;
                    var message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
                    if (process.emitWarning) {
                        process.emitWarning(message, "DeprecationWarning");
                    }
                    else {
                        var deprecationError = new Error(message);
                        deprecationError.name = "DeprecationWarning";
                        console.warn(new Error(message));
                    }
                }
                colNumber = Math.max(colNumber, 0);
                var location = {
                    start: {
                        column: colNumber,
                        line: lineNumber
                    }
                };
                return codeFrameColumns(rawLines, location, opts);
            }
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 8875: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({
                value: true
            }));
            exports.isIdentifierChar = isIdentifierChar;
            exports.isIdentifierName = isIdentifierName;
            exports.isIdentifierStart = isIdentifierStart;
            var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ca\ua7d0\ua7d1\ua7d3\ua7d5-\ua7d9\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
            var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0898-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0cf3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ece\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\u30fb\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f\uff65";
            var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
            var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
            nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
            var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
            var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
            function isInAstralSet(code, set) {
                var pos = 0x10000;
                for (var i = 0, length_3 = set.length; i < length_3; i += 2) {
                    pos += set[i];
                    if (pos > code)
                        return false;
                    pos += set[i + 1];
                    if (pos >= code)
                        return true;
                }
                return false;
            }
            function isIdentifierStart(code) {
                if (code < 65)
                    return code === 36;
                if (code <= 90)
                    return true;
                if (code < 97)
                    return code === 95;
                if (code <= 122)
                    return true;
                if (code <= 0xffff) {
                    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
                }
                return isInAstralSet(code, astralIdentifierStartCodes);
            }
            function isIdentifierChar(code) {
                if (code < 48)
                    return code === 36;
                if (code < 58)
                    return true;
                if (code < 65)
                    return false;
                if (code <= 90)
                    return true;
                if (code < 97)
                    return code === 95;
                if (code <= 122)
                    return true;
                if (code <= 0xffff) {
                    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
                }
                return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
            }
            function isIdentifierName(name) {
                var isFirst = true;
                for (var i = 0; i < name.length; i++) {
                    var cp = name.charCodeAt(i);
                    if ((cp & 0xfc00) === 0xd800 && i + 1 < name.length) {
                        var trail = name.charCodeAt(++i);
                        if ((trail & 0xfc00) === 0xdc00) {
                            cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);
                        }
                    }
                    if (isFirst) {
                        isFirst = false;
                        if (!isIdentifierStart(cp)) {
                            return false;
                        }
                    }
                    else if (!isIdentifierChar(cp)) {
                        return false;
                    }
                }
                return !isFirst;
            }
            //# sourceMappingURL=identifier.js.map
            /***/ 
        }),
        /***/ 2738: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({
                value: true
            }));
            Object.defineProperty(exports, "isIdentifierChar", ({
                enumerable: true,
                get: function () {
                    return _identifier.isIdentifierChar;
                }
            }));
            Object.defineProperty(exports, "isIdentifierName", ({
                enumerable: true,
                get: function () {
                    return _identifier.isIdentifierName;
                }
            }));
            Object.defineProperty(exports, "isIdentifierStart", ({
                enumerable: true,
                get: function () {
                    return _identifier.isIdentifierStart;
                }
            }));
            Object.defineProperty(exports, "isKeyword", ({
                enumerable: true,
                get: function () {
                    return _keyword.isKeyword;
                }
            }));
            Object.defineProperty(exports, "isReservedWord", ({
                enumerable: true,
                get: function () {
                    return _keyword.isReservedWord;
                }
            }));
            Object.defineProperty(exports, "isStrictBindOnlyReservedWord", ({
                enumerable: true,
                get: function () {
                    return _keyword.isStrictBindOnlyReservedWord;
                }
            }));
            Object.defineProperty(exports, "isStrictBindReservedWord", ({
                enumerable: true,
                get: function () {
                    return _keyword.isStrictBindReservedWord;
                }
            }));
            Object.defineProperty(exports, "isStrictReservedWord", ({
                enumerable: true,
                get: function () {
                    return _keyword.isStrictReservedWord;
                }
            }));
            var _identifier = __nccwpck_require__(8875);
            var _keyword = __nccwpck_require__(17);
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 17: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({
                value: true
            }));
            exports.isKeyword = isKeyword;
            exports.isReservedWord = isReservedWord;
            exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
            exports.isStrictBindReservedWord = isStrictBindReservedWord;
            exports.isStrictReservedWord = isStrictReservedWord;
            var reservedWords = {
                keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
                strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
                strictBind: ["eval", "arguments"]
            };
            var keywords = new Set(reservedWords.keyword);
            var reservedWordsStrictSet = new Set(reservedWords.strict);
            var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
            function isReservedWord(word, inModule) {
                return inModule && word === "await" || word === "enum";
            }
            function isStrictReservedWord(word, inModule) {
                return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
            }
            function isStrictBindOnlyReservedWord(word) {
                return reservedWordsStrictBindSet.has(word);
            }
            function isStrictBindReservedWord(word, inModule) {
                return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
            }
            function isKeyword(word) {
                return keywords.has(word);
            }
            //# sourceMappingURL=keyword.js.map
            /***/ 
        }),
        /***/ 7654: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({
                value: true
            }));
            exports["default"] = highlight;
            exports.shouldHighlight = shouldHighlight;
            var _jsTokens = __nccwpck_require__(1531);
            var _helperValidatorIdentifier = __nccwpck_require__(2738);
            var _chalk = _interopRequireWildcard(__nccwpck_require__(8707), true);
            function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function")
                return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
            function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) {
                return obj;
            } if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
                return { "default": obj };
            } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) {
                return cache.get(obj);
            } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) {
                if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
                    if (desc && (desc.get || desc.set)) {
                        Object.defineProperty(newObj, key, desc);
                    }
                    else {
                        newObj[key] = obj[key];
                    }
                }
            } newObj["default"] = obj; if (cache) {
                cache.set(obj, newObj);
            } return newObj; }
            var sometimesKeywords = new Set(["as", "async", "from", "get", "of", "set"]);
            function getDefs(chalk) {
                return {
                    keyword: chalk.cyan,
                    capitalized: chalk.yellow,
                    jsxIdentifier: chalk.yellow,
                    punctuator: chalk.yellow,
                    number: chalk.magenta,
                    string: chalk.green,
                    regex: chalk.magenta,
                    comment: chalk.grey,
                    invalid: chalk.white.bgRed.bold
                };
            }
            var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
            var BRACKET = /^[()[\]{}]$/;
            var tokenize;
            {
                var JSX_TAG_1 = /^[a-z][\w-]*$/i;
                var getTokenType_1 = function (token, offset, text) {
                    if (token.type === "name") {
                        if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, true) || sometimesKeywords.has(token.value)) {
                            return "keyword";
                        }
                        if (JSX_TAG_1.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) == "</")) {
                            return "jsxIdentifier";
                        }
                        if (token.value[0] !== token.value[0].toLowerCase()) {
                            return "capitalized";
                        }
                    }
                    if (token.type === "punctuator" && BRACKET.test(token.value)) {
                        return "bracket";
                    }
                    if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
                        return "punctuator";
                    }
                    return token.type;
                };
                tokenize = function (text) {
                    var match, token;
                    return __generator(this, function (_1) {
                        switch (_1.label) {
                            case 0:
                                if (!(match = _jsTokens["default"].exec(text))) return [3 /*break*/, 2];
                                token = _jsTokens.matchToToken(match);
                                return [4 /*yield*/, {
                                        type: getTokenType_1(token, match.index, text),
                                        value: token.value
                                    }];
                            case 1:
                                _1.sent();
                                return [3 /*break*/, 0];
                            case 2: return [2 /*return*/];
                        }
                    });
                };
            }
            function highlightTokens(defs, text) {
                var highlighted = "";
                var _loop_13 = function (type, value) {
                    var colorize = defs[type];
                    if (colorize) {
                        highlighted += value.split(NEWLINE).map(function (str) { return colorize(str); }).join("\n");
                    }
                    else {
                        highlighted += value;
                    }
                };
                for (var _1 = 0, _2 = tokenize(text); _1 < _2.length; _1++) {
                    var _3 = _2[_1], type = _3.type, value = _3.value;
                    _loop_13(type, value);
                }
                return highlighted;
            }
            function shouldHighlight(options) {
                return _chalk["default"].level > 0 || options.forceColor;
            }
            var chalkWithForcedColor = undefined;
            function getChalk(forceColor) {
                if (forceColor) {
                    var _chalkWithForcedColor;
                    (_chalkWithForcedColor = chalkWithForcedColor) != null ? _chalkWithForcedColor : chalkWithForcedColor = new _chalk["default"].constructor({
                        enabled: true,
                        level: 1
                    });
                    return chalkWithForcedColor;
                }
                return _chalk["default"];
            }
            {
                exports.getChalk = function (options) { return getChalk(options.forceColor); };
            }
            function highlight(code, options) {
                if (options === void 0) { options = {}; }
                if (code !== "" && shouldHighlight(options)) {
                    var defs = getDefs(getChalk(options.forceColor));
                    return highlightTokens(defs, code);
                }
                else {
                    return code;
                }
            }
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 6962: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            "use strict";
            var __create = Object.create;
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __getOwnPropNames = Object.getOwnPropertyNames;
            var __getProtoOf = Object.getPrototypeOf;
            var __hasOwnProp = Object.prototype.hasOwnProperty;
            var __commonJS = function (cb, mod) { return function __require() {
                return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
            }; };
            var __export = function (target, all) {
                for (var name in all)
                    __defProp(target, name, { get: all[name], enumerable: true });
            };
            var __copyProps = function (to, from, except, desc) {
                if (from && typeof from === "object" || typeof from === "function") {
                    var _loop_14 = function (key) {
                        if (!__hasOwnProp.call(to, key) && key !== except)
                            __defProp(to, key, { get: function () { return from[key]; }, enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
                    };
                    for (var _1 = 0, _2 = __getOwnPropNames(from); _1 < _2.length; _1++) {
                        var key = _2[_1];
                        _loop_14(key);
                    }
                }
                return to;
            };
            var __toESM = function (mod, isNodeMode, target) { return (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
            // If the importer is in node compatibility mode or this is not an ESM
            // file that has been converted to a CommonJS file using a Babel-
            // compatible transform (i.e. "__esModule" has not been set), then set
            // "default" to the CommonJS "module.exports" for node compatibility.
            isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod)); };
            var __toCommonJS = function (mod) { return __copyProps(__defProp({}, "__esModule", { value: true }), mod); };
            // node_modules/text-table/index.js
            var require_text_table = __commonJS({
                "node_modules/text-table/index.js": function (exports, module2) {
                    module2.exports = function (rows_, opts) {
                        if (!opts)
                            opts = {};
                        var hsep = opts.hsep === void 0 ? "  " : opts.hsep;
                        var align = opts.align || [];
                        var stringLength = opts.stringLength || function (s) {
                            return String(s).length;
                        };
                        var dotsizes = reduce(rows_, function (acc, row) {
                            forEach(row, function (c, ix) {
                                var n = dotindex(c);
                                if (!acc[ix] || n > acc[ix])
                                    acc[ix] = n;
                            });
                            return acc;
                        }, []);
                        var rows = map(rows_, function (row) {
                            return map(row, function (c_, ix) {
                                var c = String(c_);
                                if (align[ix] === ".") {
                                    var index = dotindex(c);
                                    var size = dotsizes[ix] + (/\./.test(c) ? 1 : 2) - (stringLength(c) - index);
                                    return c + Array(size).join(" ");
                                }
                                else
                                    return c;
                            });
                        });
                        var sizes = reduce(rows, function (acc, row) {
                            forEach(row, function (c, ix) {
                                var n = stringLength(c);
                                if (!acc[ix] || n > acc[ix])
                                    acc[ix] = n;
                            });
                            return acc;
                        }, []);
                        return map(rows, function (row) {
                            return map(row, function (c, ix) {
                                var n = sizes[ix] - stringLength(c) || 0;
                                var s = Array(Math.max(n + 1, 1)).join(" ");
                                if (align[ix] === "r" || align[ix] === ".") {
                                    return s + c;
                                }
                                if (align[ix] === "c") {
                                    return Array(Math.ceil(n / 2 + 1)).join(" ") + c + Array(Math.floor(n / 2 + 1)).join(" ");
                                }
                                return c + s;
                            }).join(hsep).replace(/\s+$/, "");
                        }).join("\n");
                    };
                    function dotindex(c) {
                        var m = /\.[^.]*$/.exec(c);
                        return m ? m.index + 1 : c.length;
                    }
                    function reduce(xs, f, init) {
                        if (xs.reduce)
                            return xs.reduce(f, init);
                        var i = 0;
                        var acc = arguments.length >= 3 ? init : xs[i++];
                        for (; i < xs.length; i++) {
                            f(acc, xs[i], i);
                        }
                        return acc;
                    }
                    function forEach(xs, f) {
                        if (xs.forEach)
                            return xs.forEach(f);
                        for (var i = 0; i < xs.length; i++) {
                            f.call(xs, xs[i], i);
                        }
                    }
                    function map(xs, f) {
                        if (xs.map)
                            return xs.map(f);
                        var res = [];
                        for (var i = 0; i < xs.length; i++) {
                            res.push(f.call(xs, xs[i], i));
                        }
                        return res;
                    }
                }
            });
            // src/index.ts
            var src_exports = {};
            __export(src_exports, {
                Severity: function () { return Severity; },
                stylish: function () { return stylish; }
            });
            module.exports = __toCommonJS(src_exports);
            // src/stylish.ts
            var import_text_table = __toESM(require_text_table());
            // src/colors-node.ts
            var kleur = __toESM(__nccwpck_require__(68));
            var reset2 = kleur.reset;
            var bold2 = kleur.bold;
            var dim2 = kleur.dim;
            var underline2 = kleur.underline;
            var yellow2 = kleur.yellow;
            var red2 = kleur.red;
            // src/severity.ts
            var Severity = /* @__PURE__ */ (function (Severity2) {
                Severity2[Severity2["OFF"] = 0] = "OFF";
                Severity2[Severity2["WARN"] = 1] = "WARN";
                Severity2[Severity2["ERROR"] = 2] = "ERROR";
                return Severity2;
            })(Severity || {});
            // src/stylish.ts
            function pluralize(word, count) {
                return count === 1 ? word : "".concat(word, "s");
            }
            function centerLineColumn(el) {
                return el.replace(/(\d+)\s+(\d+)/u, function (_m, p1, p2) { return dim2("".concat(p1, ":").concat(p2)); });
            }
            function stripAnsi(text) {
                return text.replace(/\u001B\[[0-9;]*m/g, "");
            }
            function stylish(results) {
                var output = "\n";
                var errorCount = 0;
                var warningCount = 0;
                var fixableErrorCount = 0;
                var fixableWarningCount = 0;
                var summaryColor = yellow2;
                results.forEach(function (result) {
                    var messages = result.messages;
                    if (messages.length === 0) {
                        return;
                    }
                    errorCount += result.errorCount;
                    warningCount += result.warningCount;
                    fixableErrorCount += result.fixableErrorCount;
                    fixableWarningCount += result.fixableWarningCount;
                    var rows = messages.map(function (message) {
                        var _1, _2;
                        var messageType;
                        if (Boolean(message.fatal) || message.severity === 2 /* ERROR */) {
                            messageType = red2("error");
                            summaryColor = red2;
                        }
                        else {
                            messageType = yellow2("warning");
                        }
                        return [
                            "",
                            (_1 = message.line) !== null && _1 !== void 0 ? _1 : 0,
                            (_2 = message.column) !== null && _2 !== void 0 ? _2 : 0,
                            messageType,
                            message.message.replace(/([^ ])\.$/u, "$1"),
                            message.ruleId ? dim2(message.ruleId) : ""
                        ];
                    });
                    var options = {
                        align: ["l", "r", "l"],
                        stringLength: function (str) {
                            return stripAnsi(str).length;
                        }
                    };
                    var formattedTable = (0, import_text_table["default"])(rows, options).split("\n").map(centerLineColumn).join("\n");
                    output += "".concat(underline2(result.filePath), "\n");
                    output += "".concat(formattedTable, "\n\n");
                });
                var total = errorCount + warningCount;
                if (total > 0) {
                    output += summaryColor(bold2([
                        "\u2716 ",
                        total,
                        pluralize(" problem", total),
                        " (",
                        errorCount,
                        pluralize(" error", errorCount),
                        ", ",
                        warningCount,
                        pluralize(" warning", warningCount),
                        ")\n"
                    ].join("")));
                    if (fixableErrorCount > 0 || fixableWarningCount > 0) {
                        output += summaryColor(bold2([
                            "  ",
                            fixableErrorCount,
                            pluralize(" error", fixableErrorCount),
                            " and ",
                            fixableWarningCount,
                            pluralize(" warning", fixableWarningCount),
                            " potentially fixable with the `--fix` option.\n"
                        ].join("")));
                    }
                }
                return total > 0 ? reset2(output) : "";
            }
            // Annotate the CommonJS export names for ESM import in node:
            0 && (0);
            //# sourceMappingURL=node.js.map
            /***/ 
        }),
        /***/ 7963: 
        /***/ (function (module, __unused_webpack_exports, __nccwpck_require__) {
            var __create = Object.create;
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __getOwnPropNames = Object.getOwnPropertyNames;
            var __getProtoOf = Object.getPrototypeOf;
            var __hasOwnProp = Object.prototype.hasOwnProperty;
            var __commonJS = function (cb, mod) { return function __require() {
                return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
            }; };
            var __export = function (target, all) {
                for (var name in all)
                    __defProp(target, name, { get: all[name], enumerable: true });
            };
            var __copyProps = function (to, from, except, desc) {
                if (from && typeof from === "object" || typeof from === "function") {
                    var _loop_15 = function (key) {
                        if (!__hasOwnProp.call(to, key) && key !== except)
                            __defProp(to, key, { get: function () { return from[key]; }, enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
                    };
                    for (var _1 = 0, _2 = __getOwnPropNames(from); _1 < _2.length; _1++) {
                        var key = _2[_1];
                        _loop_15(key);
                    }
                }
                return to;
            };
            var __toESM = function (mod, isNodeMode, target) { return (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod)); };
            var __toCommonJS = function (mod) { return __copyProps(__defProp({}, "__esModule", { value: true }), mod); };
            // node_modules/@humanwhocodes/momoa/api.js
            var require_api = __commonJS({
                "node_modules/@humanwhocodes/momoa/api.js": function (exports) {
                    "use strict";
                    Object.defineProperty(exports, "__esModule", { value: true });
                    var LBRACKET = "[";
                    var RBRACKET = "]";
                    var LBRACE = "{";
                    var RBRACE = "}";
                    var COLON = ":";
                    var COMMA = ",";
                    var TRUE = "true";
                    var FALSE = "false";
                    var NULL = "null";
                    var QUOTE = '"';
                    var expectedKeywords = /* @__PURE__ */ new Map([
                        ["t", TRUE],
                        ["f", FALSE],
                        ["n", NULL]
                    ]);
                    var escapeToChar = /* @__PURE__ */ new Map([
                        [QUOTE, QUOTE],
                        ["\\", "\\"],
                        ["/", "/"],
                        ["b", "\b"],
                        ["n", "\n"],
                        ["f", "\f"],
                        ["r", "\r"],
                        ["t", "	"]
                    ]);
                    var knownTokenTypes = /* @__PURE__ */ new Map([
                        [LBRACKET, "Punctuator"],
                        [RBRACKET, "Punctuator"],
                        [LBRACE, "Punctuator"],
                        [RBRACE, "Punctuator"],
                        [COLON, "Punctuator"],
                        [COMMA, "Punctuator"],
                        [TRUE, "Boolean"],
                        [FALSE, "Boolean"],
                        [NULL, "Null"]
                    ]);
                    var ErrorWithLocation = /** @class */ (function (_super) {
                        __extends(ErrorWithLocation, _super);
                        function ErrorWithLocation(message, _1) {
                            var line = _1.line, column = _1.column, index = _1.index;
                            var _this_1 = _super.call(this, "".concat(message, " (").concat(line, ":").concat(column, ")")) || this;
                            _this_1.line = line;
                            _this_1.column = column;
                            _this_1.index = index;
                            return _this_1;
                        }
                        return ErrorWithLocation;
                    }(Error));
                    var UnexpectedChar = /** @class */ (function (_super) {
                        __extends(UnexpectedChar, _super);
                        function UnexpectedChar(unexpected, loc) {
                            return _super.call(this, "Unexpected character ".concat(unexpected, " found."), loc) || this;
                        }
                        return UnexpectedChar;
                    }(ErrorWithLocation));
                    var UnexpectedToken = /** @class */ (function (_super) {
                        __extends(UnexpectedToken, _super);
                        function UnexpectedToken(token) {
                            return _super.call(this, "Unexpected token ".concat(token.type, "(").concat(token.value, ") found."), token.loc.start) || this;
                        }
                        return UnexpectedToken;
                    }(ErrorWithLocation));
                    var UnexpectedEOF = /** @class */ (function (_super) {
                        __extends(UnexpectedEOF, _super);
                        function UnexpectedEOF(loc) {
                            return _super.call(this, "Unexpected end of input found.", loc) || this;
                        }
                        return UnexpectedEOF;
                    }(ErrorWithLocation));
                    var QUOTE$1 = '"';
                    var SLASH = "/";
                    var STAR = "*";
                    var DEFAULT_OPTIONS = {
                        comments: false,
                        ranges: false
                    };
                    function isWhitespace(c) {
                        return /[\s\n]/.test(c);
                    }
                    function isDigit(c) {
                        return c >= "0" && c <= "9";
                    }
                    function isHexDigit(c) {
                        return isDigit(c) || /[a-f]/i.test(c);
                    }
                    function isPositiveDigit(c) {
                        return c >= "1" && c <= "9";
                    }
                    function isKeywordStart(c) {
                        return /[tfn]/.test(c);
                    }
                    function isNumberStart(c) {
                        return isDigit(c) || c === "." || c === "-";
                    }
                    function tokenize(text, options) {
                        options = Object.freeze(__assign(__assign({}, DEFAULT_OPTIONS), options));
                        var offset = -1;
                        var line = 1;
                        var column = 0;
                        var newLine = false;
                        var tokens = [];
                        function createToken(tokenType, value, startLoc, endLoc) {
                            var endOffset = startLoc.offset + value.length;
                            var range = options.ranges ? {
                                range: [startLoc.offset, endOffset]
                            } : void 0;
                            return __assign({ type: tokenType, value: value, loc: {
                                    start: startLoc,
                                    end: endLoc || {
                                        line: startLoc.line,
                                        column: startLoc.column + value.length,
                                        offset: endOffset
                                    }
                                } }, range);
                        }
                        function next() {
                            var c2 = text.charAt(++offset);
                            if (newLine) {
                                line++;
                                column = 1;
                                newLine = false;
                            }
                            else {
                                column++;
                            }
                            if (c2 === "\r") {
                                newLine = true;
                                if (text.charAt(offset + 1) === "\n") {
                                    offset++;
                                }
                            }
                            else if (c2 === "\n") {
                                newLine = true;
                            }
                            return c2;
                        }
                        function locate() {
                            return {
                                line: line,
                                column: column,
                                offset: offset
                            };
                        }
                        function readKeyword(c2) {
                            var value = expectedKeywords.get(c2);
                            if (text.slice(offset, offset + value.length) === value) {
                                offset += value.length - 1;
                                column += value.length - 1;
                                return { value: value, c: next() };
                            }
                            for (var j = 1; j < value.length; j++) {
                                if (value[j] !== text.charAt(offset + j)) {
                                    unexpected(next());
                                }
                            }
                        }
                        function readString(c2) {
                            var value = c2;
                            c2 = next();
                            while (c2 && c2 !== QUOTE$1) {
                                if (c2 === "\\") {
                                    value += c2;
                                    c2 = next();
                                    if (escapeToChar.has(c2)) {
                                        value += c2;
                                    }
                                    else if (c2 === "u") {
                                        value += c2;
                                        for (var i = 0; i < 4; i++) {
                                            c2 = next();
                                            if (isHexDigit(c2)) {
                                                value += c2;
                                            }
                                            else {
                                                unexpected(c2);
                                            }
                                        }
                                    }
                                    else {
                                        unexpected(c2);
                                    }
                                }
                                else {
                                    value += c2;
                                }
                                c2 = next();
                            }
                            if (!c2) {
                                unexpectedEOF();
                            }
                            value += c2;
                            return { value: value, c: next() };
                        }
                        function readNumber(c2) {
                            var value = "";
                            if (c2 === "-") {
                                value += c2;
                                c2 = next();
                                if (!isDigit(c2)) {
                                    unexpected(c2);
                                }
                            }
                            if (c2 === "0") {
                                value += c2;
                                c2 = next();
                                if (isDigit(c2)) {
                                    unexpected(c2);
                                }
                            }
                            else {
                                if (!isPositiveDigit(c2)) {
                                    unexpected(c2);
                                }
                                do {
                                    value += c2;
                                    c2 = next();
                                } while (isDigit(c2));
                            }
                            if (c2 === ".") {
                                do {
                                    value += c2;
                                    c2 = next();
                                } while (isDigit(c2));
                            }
                            if (c2 === "e" || c2 === "E") {
                                value += c2;
                                c2 = next();
                                if (c2 === "+" || c2 === "-") {
                                    value += c2;
                                    c2 = next();
                                }
                                if (!isDigit(c2)) {
                                    unexpected(c2);
                                }
                                while (isDigit(c2)) {
                                    value += c2;
                                    c2 = next();
                                }
                            }
                            return { value: value, c: c2 };
                        }
                        function readComment(c2) {
                            var value = c2;
                            c2 = next();
                            if (c2 === "/") {
                                do {
                                    value += c2;
                                    c2 = next();
                                } while (c2 && c2 !== "\r" && c2 !== "\n");
                                return { value: value, c: c2 };
                            }
                            if (c2 === STAR) {
                                while (c2) {
                                    value += c2;
                                    c2 = next();
                                    if (c2 === STAR) {
                                        value += c2;
                                        c2 = next();
                                        if (c2 === SLASH) {
                                            value += c2;
                                            c2 = next();
                                            return { value: value, c: c2 };
                                        }
                                    }
                                }
                                unexpectedEOF();
                            }
                            unexpected(c2);
                        }
                        function unexpected(c2) {
                            throw new UnexpectedChar(c2, locate());
                        }
                        function unexpectedEOF() {
                            throw new UnexpectedEOF(locate());
                        }
                        var c = next();
                        while (offset < text.length) {
                            while (isWhitespace(c)) {
                                c = next();
                            }
                            if (!c) {
                                break;
                            }
                            var start = locate();
                            if (knownTokenTypes.has(c)) {
                                tokens.push(createToken(knownTokenTypes.get(c), c, start));
                                c = next();
                            }
                            else if (isKeywordStart(c)) {
                                var result = readKeyword(c);
                                var value = result.value;
                                c = result.c;
                                tokens.push(createToken(knownTokenTypes.get(value), value, start));
                            }
                            else if (isNumberStart(c)) {
                                var result = readNumber(c);
                                var value = result.value;
                                c = result.c;
                                tokens.push(createToken("Number", value, start));
                            }
                            else if (c === QUOTE$1) {
                                var result = readString(c);
                                var value = result.value;
                                c = result.c;
                                tokens.push(createToken("String", value, start));
                            }
                            else if (c === SLASH && options.comments) {
                                var result = readComment(c);
                                var value = result.value;
                                c = result.c;
                                tokens.push(createToken(value.startsWith("//") ? "LineComment" : "BlockComment", value, start, locate()));
                            }
                            else {
                                unexpected(c);
                            }
                        }
                        return tokens;
                    }
                    var types = {
                        document: function (body, parts) {
                            if (parts === void 0) { parts = {}; }
                            return __assign({ type: "Document", body: body }, parts);
                        },
                        string: function (value, parts) {
                            if (parts === void 0) { parts = {}; }
                            return __assign({ type: "String", value: value }, parts);
                        },
                        number: function (value, parts) {
                            if (parts === void 0) { parts = {}; }
                            return __assign({ type: "Number", value: value }, parts);
                        },
                        boolean: function (value, parts) {
                            if (parts === void 0) { parts = {}; }
                            return __assign({ type: "Boolean", value: value }, parts);
                        },
                        "null": function (parts) {
                            if (parts === void 0) { parts = {}; }
                            return __assign({ type: "Null", value: "null" }, parts);
                        },
                        array: function (elements, parts) {
                            if (parts === void 0) { parts = {}; }
                            return __assign({ type: "Array", elements: elements }, parts);
                        },
                        object: function (members, parts) {
                            if (parts === void 0) { parts = {}; }
                            return __assign({ type: "Object", members: members }, parts);
                        },
                        member: function (name, value, parts) {
                            if (parts === void 0) { parts = {}; }
                            return __assign({ type: "Member", name: name, value: value }, parts);
                        }
                    };
                    var DEFAULT_OPTIONS$1 = {
                        tokens: false,
                        comments: false,
                        ranges: false
                    };
                    function getStringValue(token) {
                        var value = token.value.slice(1, -1);
                        var result = "";
                        var escapeIndex = value.indexOf("\\");
                        var lastIndex = 0;
                        while (escapeIndex >= 0) {
                            result += value.slice(lastIndex, escapeIndex);
                            var escapeChar = value.charAt(escapeIndex + 1);
                            if (escapeToChar.has(escapeChar)) {
                                result += escapeToChar.get(escapeChar);
                                lastIndex = escapeIndex + 2;
                            }
                            else if (escapeChar === "u") {
                                var hexCode = value.slice(escapeIndex + 2, escapeIndex + 6);
                                if (hexCode.length < 4 || /[^0-9a-f]/i.test(hexCode)) {
                                    throw new ErrorWithLocation("Invalid unicode escape \\u".concat(hexCode, "."), {
                                        line: token.loc.start.line,
                                        column: token.loc.start.column + escapeIndex,
                                        offset: token.loc.start.offset + escapeIndex
                                    });
                                }
                                result += String.fromCharCode(parseInt(hexCode, 16));
                                lastIndex = escapeIndex + 6;
                            }
                            else {
                                throw new ErrorWithLocation("Invalid escape \\".concat(escapeChar, "."), {
                                    line: token.loc.start.line,
                                    column: token.loc.start.column + escapeIndex,
                                    offset: token.loc.start.offset + escapeIndex
                                });
                            }
                            escapeIndex = value.indexOf("\\", lastIndex);
                        }
                        result += value.slice(lastIndex);
                        return result;
                    }
                    function getLiteralValue(token) {
                        switch (token.type) {
                            case "Boolean":
                                return token.value === "true";
                            case "Number":
                                return Number(token.value);
                            case "Null":
                                return null;
                            case "String":
                                return getStringValue(token);
                        }
                    }
                    function parse2(text, options) {
                        options = Object.freeze(__assign(__assign({}, DEFAULT_OPTIONS$1), options));
                        var tokens = tokenize(text, {
                            comments: !!options.comments,
                            ranges: !!options.ranges
                        });
                        var tokenIndex = 0;
                        function nextNoComments() {
                            return tokens[tokenIndex++];
                        }
                        function nextSkipComments() {
                            var nextToken = tokens[tokenIndex++];
                            if (nextToken && nextToken.type.endsWith("Comment")) {
                                return nextSkipComments();
                            }
                            return nextToken;
                        }
                        var next = options.comments ? nextSkipComments : nextNoComments;
                        function assertTokenValue(token, value) {
                            if (!token || token.value !== value) {
                                throw new UnexpectedToken(token);
                            }
                        }
                        function assertTokenType(token, type) {
                            if (!token || token.type !== type) {
                                throw new UnexpectedToken(token);
                            }
                        }
                        function createRange(start, end) {
                            return options.ranges ? {
                                range: [start.offset, end.offset]
                            } : void 0;
                        }
                        function createLiteralNode(token) {
                            var range = createRange(token.loc.start, token.loc.end);
                            return __assign({ type: token.type, value: getLiteralValue(token), loc: {
                                    start: __assign({}, token.loc.start),
                                    end: __assign({}, token.loc.end)
                                } }, range);
                        }
                        function parseProperty(token) {
                            assertTokenType(token, "String");
                            var name = createLiteralNode(token);
                            token = next();
                            assertTokenValue(token, ":");
                            var value = parseValue();
                            var range = createRange(name.loc.start, value.loc.end);
                            return types.member(name, value, __assign({ loc: {
                                    start: __assign({}, name.loc.start),
                                    end: __assign({}, value.loc.end)
                                } }, range));
                        }
                        function parseObject(firstToken) {
                            assertTokenValue(firstToken, "{");
                            var members = [];
                            var token = next();
                            if (token && token.value !== "}") {
                                do {
                                    members.push(parseProperty(token));
                                    token = next();
                                    if (token.value === ",") {
                                        token = next();
                                    }
                                    else {
                                        break;
                                    }
                                } while (token);
                            }
                            assertTokenValue(token, "}");
                            var range = createRange(firstToken.loc.start, token.loc.end);
                            return types.object(members, __assign({ loc: {
                                    start: __assign({}, firstToken.loc.start),
                                    end: __assign({}, token.loc.end)
                                } }, range));
                        }
                        function parseArray(firstToken) {
                            assertTokenValue(firstToken, "[");
                            var elements = [];
                            var token = next();
                            if (token && token.value !== "]") {
                                do {
                                    elements.push(parseValue(token));
                                    token = next();
                                    if (token.value === ",") {
                                        token = next();
                                    }
                                    else {
                                        break;
                                    }
                                } while (token);
                            }
                            assertTokenValue(token, "]");
                            var range = createRange(firstToken.loc.start, token.loc.end);
                            return types.array(elements, __assign({ type: "Array", elements: elements, loc: {
                                    start: __assign({}, firstToken.loc.start),
                                    end: __assign({}, token.loc.end)
                                } }, range));
                        }
                        function parseValue(token) {
                            token = token || next();
                            switch (token.type) {
                                case "String":
                                case "Boolean":
                                case "Number":
                                case "Null":
                                    return createLiteralNode(token);
                                case "Punctuator":
                                    if (token.value === "{") {
                                        return parseObject(token);
                                    }
                                    else if (token.value === "[") {
                                        return parseArray(token);
                                    }
                                default:
                                    throw new UnexpectedToken(token);
                            }
                        }
                        var docBody = parseValue();
                        var unexpectedToken = next();
                        if (unexpectedToken) {
                            throw new UnexpectedToken(unexpectedToken);
                        }
                        var docParts = {
                            loc: {
                                start: {
                                    line: 1,
                                    column: 1,
                                    offset: 0
                                },
                                end: __assign({}, docBody.loc.end)
                            }
                        };
                        if (options.tokens) {
                            docParts.tokens = tokens;
                        }
                        if (options.ranges) {
                            docParts.range = createRange(docParts.loc.start, docParts.loc.end);
                        }
                        return types.document(docBody, docParts);
                    }
                    var childKeys = /* @__PURE__ */ new Map([
                        ["Document", ["body"]],
                        ["Object", ["members"]],
                        ["Member", ["name", "value"]],
                        ["Array", ["elements"]],
                        ["String", []],
                        ["Number", []],
                        ["Boolean", []],
                        ["Null", []]
                    ]);
                    function isObject(value) {
                        return value && typeof value === "object";
                    }
                    function isNode(value) {
                        return isObject(value) && typeof value.type === "string";
                    }
                    function traverse(root, visitor) {
                        function visitNode(node, parent) {
                            if (typeof visitor.enter === "function") {
                                visitor.enter(node, parent);
                            }
                            for (var _1 = 0, _2 = childKeys.get(node.type); _1 < _2.length; _1++) {
                                var key = _2[_1];
                                var value = node[key];
                                if (isObject(value)) {
                                    if (Array.isArray(value)) {
                                        value.forEach(function (child) { return visitNode(child, node); });
                                    }
                                    else if (isNode(value)) {
                                        visitNode(value, node);
                                    }
                                }
                            }
                            if (typeof visitor.exit === "function") {
                                visitor.exit(node, parent);
                            }
                        }
                        visitNode(root);
                    }
                    function iterator(root, filter) {
                        if (filter === void 0) { filter = function () { return true; }; }
                        var traversal = [];
                        traverse(root, {
                            enter: function (node, parent) {
                                traversal.push({ node: node, parent: parent, phase: "enter" });
                            },
                            exit: function (node, parent) {
                                traversal.push({ node: node, parent: parent, phase: "exit" });
                            }
                        });
                        return traversal.filter(filter).values();
                    }
                    function evaluate(node) {
                        switch (node.type) {
                            case "String":
                            case "Number":
                            case "Boolean":
                                return node.value;
                            case "Null":
                                return null;
                            case "Array":
                                return node.elements.map(evaluate);
                            case "Object": {
                                var object_1 = {};
                                node.members.forEach(function (member) {
                                    object_1[evaluate(member.name)] = evaluate(member.value);
                                });
                                return object_1;
                            }
                            case "Document":
                                return evaluate(node.body);
                            case "Property":
                                throw new Error("Cannot evaluate object property outside of an object.");
                            default:
                                throw new Error("Unknown node type ".concat(node.type, "."));
                        }
                    }
                    function print(node, _1) {
                        var _2 = _1 === void 0 ? {} : _1, _3 = _2.indent, indent = _3 === void 0 ? 0 : _3;
                        var value = evaluate(node);
                        return JSON.stringify(value, null, indent);
                    }
                    exports.evaluate = evaluate;
                    exports.iterator = iterator;
                    exports.parse = parse2;
                    exports.print = print;
                    exports.tokenize = tokenize;
                    exports.traverse = traverse;
                    exports.types = types;
                }
            });
            // node_modules/leven/index.js
            var require_leven = __commonJS({
                "node_modules/leven/index.js": function (exports, module2) {
                    "use strict";
                    var array = [];
                    var charCodeCache = [];
                    var leven2 = function (left, right) {
                        if (left === right) {
                            return 0;
                        }
                        var swap = left;
                        if (left.length > right.length) {
                            left = right;
                            right = swap;
                        }
                        var leftLength = left.length;
                        var rightLength = right.length;
                        while (leftLength > 0 && left.charCodeAt(~-leftLength) === right.charCodeAt(~-rightLength)) {
                            leftLength--;
                            rightLength--;
                        }
                        var start = 0;
                        while (start < leftLength && left.charCodeAt(start) === right.charCodeAt(start)) {
                            start++;
                        }
                        leftLength -= start;
                        rightLength -= start;
                        if (leftLength === 0) {
                            return rightLength;
                        }
                        var bCharCode;
                        var result;
                        var temp;
                        var temp2;
                        var i = 0;
                        var j = 0;
                        while (i < leftLength) {
                            charCodeCache[i] = left.charCodeAt(start + i);
                            array[i] = ++i;
                        }
                        while (j < rightLength) {
                            bCharCode = right.charCodeAt(start + j);
                            temp = j++;
                            result = j;
                            for (i = 0; i < leftLength; i++) {
                                temp2 = bCharCode === charCodeCache[i] ? temp : temp + 1;
                                temp = array[i];
                                result = array[i] = temp > result ? temp2 > result ? result + 1 : temp2 : temp2 > temp ? temp + 1 : temp2;
                            }
                        }
                        return result;
                    };
                    module2.exports = leven2;
                    module2.exports["default"] = leven2;
                }
            });
            // node_modules/jsonpointer/jsonpointer.js
            var require_jsonpointer = __commonJS({
                "node_modules/jsonpointer/jsonpointer.js": function (exports) {
                    var hasExcape = /~/;
                    var escapeMatcher = /~[01]/g;
                    function escapeReplacer(m) {
                        switch (m) {
                            case "~1":
                                return "/";
                            case "~0":
                                return "~";
                        }
                        throw new Error("Invalid tilde escape: " + m);
                    }
                    function untilde(str) {
                        if (!hasExcape.test(str))
                            return str;
                        return str.replace(escapeMatcher, escapeReplacer);
                    }
                    function setter(obj, pointer2, value) {
                        var part;
                        var hasNextPart;
                        for (var p = 1, len = pointer2.length; p < len;) {
                            if (pointer2[p] === "constructor" || pointer2[p] === "prototype" || pointer2[p] === "__proto__")
                                return obj;
                            part = untilde(pointer2[p++]);
                            hasNextPart = len > p;
                            if (typeof obj[part] === "undefined") {
                                if (Array.isArray(obj) && part === "-") {
                                    part = obj.length;
                                }
                                if (hasNextPart) {
                                    if (pointer2[p] !== "" && pointer2[p] < Infinity || pointer2[p] === "-")
                                        obj[part] = [];
                                    else
                                        obj[part] = {};
                                }
                            }
                            if (!hasNextPart)
                                break;
                            obj = obj[part];
                        }
                        var oldValue = obj[part];
                        if (value === void 0)
                            delete obj[part];
                        else
                            obj[part] = value;
                        return oldValue;
                    }
                    function compilePointer(pointer2) {
                        if (typeof pointer2 === "string") {
                            pointer2 = pointer2.split("/");
                            if (pointer2[0] === "")
                                return pointer2;
                            throw new Error("Invalid JSON pointer.");
                        }
                        else if (Array.isArray(pointer2)) {
                            for (var _1 = 0, pointer2_1 = pointer2; _1 < pointer2_1.length; _1++) {
                                var part = pointer2_1[_1];
                                if (typeof part !== "string" && typeof part !== "number") {
                                    throw new Error("Invalid JSON pointer. Must be of type string or number.");
                                }
                            }
                            return pointer2;
                        }
                        throw new Error("Invalid JSON pointer.");
                    }
                    function get(obj, pointer2) {
                        if (typeof obj !== "object")
                            throw new Error("Invalid input object.");
                        pointer2 = compilePointer(pointer2);
                        var len = pointer2.length;
                        if (len === 1)
                            return obj;
                        for (var p = 1; p < len;) {
                            obj = obj[untilde(pointer2[p++])];
                            if (len === p)
                                return obj;
                            if (typeof obj !== "object" || obj === null)
                                return void 0;
                        }
                    }
                    function set(obj, pointer2, value) {
                        if (typeof obj !== "object")
                            throw new Error("Invalid input object.");
                        pointer2 = compilePointer(pointer2);
                        if (pointer2.length === 0)
                            throw new Error("Invalid JSON pointer for set.");
                        return setter(obj, pointer2, value);
                    }
                    function compile(pointer2) {
                        var compiled = compilePointer(pointer2);
                        return {
                            get: function (object) {
                                return get(object, compiled);
                            },
                            set: function (object, value) {
                                return set(object, compiled, value);
                            }
                        };
                    }
                    exports.get = get;
                    exports.set = set;
                    exports.compile = compile;
                }
            });
            // src/index.js
            var src_exports = {};
            __export(src_exports, {
                "default": function () { return src_default; }
            });
            module.exports = __toCommonJS(src_exports);
            var import_momoa = __toESM(require_api());
            // src/utils.js
            var eq = function (x) { return function (y) { return x === y; }; };
            var not = function (fn) { return function (x) { return !fn(x); }; };
            var getValues = function (o) { return Object.values(o); };
            var notUndefined = function (x) { return x !== void 0; };
            var isXError = function (x) { return function (error) { return error.keyword === x; }; };
            var isRequiredError = isXError("required");
            var isAnyOfError = isXError("anyOf");
            var isEnumError = isXError("enum");
            var getErrors = function (node) { return node && node.errors ? node.errors.map(function (e) { return e.keyword === "errorMessage" ? __assign(__assign({}, e.params.errors[0]), { message: e.message }) : e; }) : []; };
            var getChildren = function (node) { return node && getValues(node.children) || []; };
            var getSiblings = function (parent) { return function (node) { return getChildren(parent).filter(not(eq(node))); }; };
            var concatAll = function (xs) { return function (ys) { return ys.reduce(function (zs, z) { return zs.concat(z); }, xs); }; };
            // src/validation-errors/required.js
            var import_chalk = __toESM(__nccwpck_require__(198));
            // src/validation-errors/base.js
            var import_code_frame = __nccwpck_require__(1322);
            // src/json/utils.js
            var getPointers = function (dataPath) {
                return dataPath.split("/").slice(1).map(function (pointer2) { return pointer2.split("~1").join("/").split("~0").join("~"); });
            };
            // src/json/get-meta-from-path.js
            function getMetaFromPath(jsonAst, dataPath, includeIdentifierLocation) {
                var pointers = getPointers(dataPath);
                var lastPointerIndex = pointers.length - 1;
                return pointers.reduce(function (obj, pointer2, idx) {
                    switch (obj.type) {
                        case "Object": {
                            var filtered = obj.members.filter(function (child) { return child.name.value === pointer2; });
                            if (filtered.length !== 1) {
                                throw new Error("Couldn't find property ".concat(pointer2, " of ").concat(dataPath));
                            }
                            var _1 = filtered[0], name_10 = _1.name, value = _1.value;
                            return includeIdentifierLocation && idx === lastPointerIndex ? name_10 : value;
                        }
                        case "Array":
                            return obj.elements[pointer2];
                        default:
                            console.log(obj);
                    }
                }, jsonAst.body);
            }
            // src/json/get-decorated-data-path.js
            function getDecoratedDataPath(jsonAst, dataPath) {
                var decoratedPath = "";
                getPointers(dataPath).reduce(function (obj, pointer2) {
                    switch (obj.type) {
                        case "Object": {
                            decoratedPath += "/".concat(pointer2);
                            var filtered = obj.members.filter(function (child) { return child.name.value === pointer2; });
                            if (filtered.length !== 1) {
                                throw new Error("Couldn't find property ".concat(pointer2, " of ").concat(dataPath));
                            }
                            return filtered[0].value;
                        }
                        case "Array": {
                            decoratedPath += "/".concat(pointer2).concat(getTypeName(obj.elements[pointer2]));
                            return obj.elements[pointer2];
                        }
                        default:
                            console.log(obj);
                    }
                }, jsonAst.body);
                return decoratedPath;
            }
            function getTypeName(obj) {
                if (!obj || !obj.elements) {
                    return "";
                }
                var type = obj.elements.filter(function (child) { return child && child.name && child.name.value === "type"; });
                if (!type.length) {
                    return "";
                }
                return type[0].value && ":".concat(type[0].value.value) || "";
            }
            // src/validation-errors/base.js
            var BaseValidationError = /** @class */ (function () {
                function BaseValidationError(options, _1) {
                    if (options === void 0) { options = { isIdentifierLocation: false }; }
                    var data = _1.data, schema = _1.schema, jsonAst = _1.jsonAst, jsonRaw = _1.jsonRaw;
                    this.options = options;
                    this.data = data;
                    this.schema = schema;
                    this.jsonAst = jsonAst;
                    this.jsonRaw = jsonRaw;
                }
                BaseValidationError.prototype.getLocation = function (dataPath) {
                    if (dataPath === void 0) { dataPath = this.instancePath; }
                    var _1 = this.options, isIdentifierLocation = _1.isIdentifierLocation, isSkipEndLocation = _1.isSkipEndLocation;
                    var loc = getMetaFromPath(this.jsonAst, dataPath, isIdentifierLocation).loc;
                    return {
                        start: loc.start,
                        end: isSkipEndLocation ? void 0 : loc.end
                    };
                };
                BaseValidationError.prototype.getDecoratedPath = function (dataPath) {
                    if (dataPath === void 0) { dataPath = this.instancePath; }
                    var decoratedPath = getDecoratedDataPath(this.jsonAst, dataPath);
                    return decoratedPath;
                };
                BaseValidationError.prototype.getCodeFrame = function (message, dataPath) {
                    if (dataPath === void 0) { dataPath = this.instancePath; }
                    return (0, import_code_frame.codeFrameColumns)(this.jsonRaw, this.getLocation(dataPath), {
                        highlightCode: true,
                        message: message
                    });
                };
                Object.defineProperty(BaseValidationError.prototype, "instancePath", {
                    get: function () {
                        return typeof this.options.instancePath !== "undefined" ? this.options.instancePath : this.options.dataPath;
                    },
                    enumerable: false,
                    configurable: true
                });
                BaseValidationError.prototype.print = function () {
                    throw new Error("Implement the 'print' method inside ".concat(this.constructor.name, "!"));
                };
                BaseValidationError.prototype.getError = function () {
                    throw new Error("Implement the 'getError' method inside ".concat(this.constructor.name, "!"));
                };
                return BaseValidationError;
            }());
            // src/validation-errors/required.js
            var RequiredValidationError = /** @class */ (function (_super) {
                __extends(class_1, _super);
                function class_1() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                class_1.prototype.getLocation = function (dataPath) {
                    if (dataPath === void 0) { dataPath = this.instancePath; }
                    var start = _super.prototype.getLocation.call(this, dataPath).start;
                    return { start: start };
                };
                class_1.prototype.print = function () {
                    var _1 = this.options, message = _1.message, params = _1.params;
                    var output = [import_chalk["default"](__makeTemplateObject(["{red {bold REQUIRED} ", "}\n"], ["{red {bold REQUIRED} ", "}\\n"]), message)];
                    return output.concat(this.getCodeFrame(import_chalk["default"](__makeTemplateObject(["\u2639\uFE0F  {magentaBright ", "} is missing here!"], ["\u2639\uFE0F  {magentaBright ", "} is missing here!"]), params.missingProperty)));
                };
                class_1.prototype.getError = function () {
                    var message = this.options.message;
                    return __assign(__assign({}, this.getLocation()), { error: "".concat(this.getDecoratedPath(), " ").concat(message), path: this.instancePath });
                };
                return class_1;
            }(BaseValidationError));
            // src/validation-errors/additional-prop.js
            var import_chalk2 = __toESM(__nccwpck_require__(198));
            var AdditionalPropValidationError = /** @class */ (function (_super) {
                __extends(class_2, _super);
                function class_2() {
                    var args = [];
                    for (var _1 = 0; _1 < arguments.length; _1++) {
                        args[_1] = arguments[_1];
                    }
                    var _this_1 = _super.apply(this, args) || this;
                    _this_1.options.isIdentifierLocation = true;
                    return _this_1;
                }
                class_2.prototype.print = function () {
                    var _1 = this.options, message = _1.message, params = _1.params;
                    var output = [import_chalk2["default"](__makeTemplateObject(["{red {bold ADDTIONAL PROPERTY} ", "}\n"], ["{red {bold ADDTIONAL PROPERTY} ", "}\\n"]), message)];
                    return output.concat(this.getCodeFrame(import_chalk2["default"](__makeTemplateObject(["\uD83D\uDE32  {magentaBright ", "} is not expected to be here!"], ["\uD83D\uDE32  {magentaBright ", "} is not expected to be here!"]), params.additionalProperty), "".concat(this.instancePath, "/").concat(params.additionalProperty)));
                };
                class_2.prototype.getError = function () {
                    var params = this.options.params;
                    return __assign(__assign({}, this.getLocation("".concat(this.instancePath, "/").concat(params.additionalProperty))), { error: "".concat(this.getDecoratedPath(), " Property ").concat(params.additionalProperty, " is not expected to be here"), path: this.instancePath });
                };
                return class_2;
            }(BaseValidationError));
            // src/validation-errors/enum.js
            var import_chalk3 = __toESM(__nccwpck_require__(198));
            var import_leven = __toESM(require_leven());
            var import_jsonpointer = __toESM(require_jsonpointer());
            var EnumValidationError = /** @class */ (function (_super) {
                __extends(class_3, _super);
                function class_3() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                class_3.prototype.print = function () {
                    var _1 = this.options, message = _1.message, allowedValues = _1.params.allowedValues;
                    var bestMatch = this.findBestMatch();
                    var output = [
                        import_chalk3["default"](__makeTemplateObject(["{red {bold ENUM} ", "}"], ["{red {bold ENUM} ", "}"]), message),
                        import_chalk3["default"](__makeTemplateObject(["{red (", ")}\n"], ["{red (", ")}\\n"]), allowedValues.join(", "))
                    ];
                    return output.concat(this.getCodeFrame(bestMatch !== null ? import_chalk3["default"](__makeTemplateObject(["\uD83D\uDC48\uD83C\uDFFD  Did you mean {magentaBright ", "} here?"], ["\uD83D\uDC48\uD83C\uDFFD  Did you mean {magentaBright ", "} here?"]), bestMatch) : import_chalk3["default"](__makeTemplateObject(["\uD83D\uDC48\uD83C\uDFFD  Unexpected value, should be equal to one of the allowed values"], ["\uD83D\uDC48\uD83C\uDFFD  Unexpected value, should be equal to one of the allowed values"]))));
                };
                class_3.prototype.getError = function () {
                    var _1 = this.options, message = _1.message, params = _1.params;
                    var bestMatch = this.findBestMatch();
                    var allowedValues = params.allowedValues.join(", ");
                    var output = __assign(__assign({}, this.getLocation()), { error: "".concat(this.getDecoratedPath(), " ").concat(message, ": ").concat(allowedValues), path: this.instancePath });
                    if (bestMatch !== null) {
                        output.suggestion = "Did you mean ".concat(bestMatch, "?");
                    }
                    return output;
                };
                class_3.prototype.findBestMatch = function () {
                    var allowedValues = this.options.params.allowedValues;
                    var currentValue = this.instancePath === "" ? this.data : import_jsonpointer["default"].get(this.data, this.instancePath);
                    if (!currentValue) {
                        return null;
                    }
                    var bestMatch = allowedValues.map(function (value) { return ({
                        value: value,
                        weight: (0, import_leven["default"])(value, currentValue.toString())
                    }); }).sort(function (x, y) { return x.weight > y.weight ? 1 : x.weight < y.weight ? -1 : 0; })[0];
                    return allowedValues.length === 1 || bestMatch.weight < bestMatch.value.length ? bestMatch.value : null;
                };
                return class_3;
            }(BaseValidationError));
            // src/validation-errors/default.js
            var import_chalk4 = __toESM(__nccwpck_require__(198));
            var DefaultValidationError = /** @class */ (function (_super) {
                __extends(class_4, _super);
                function class_4() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                class_4.prototype.print = function () {
                    var _1 = this.options, keyword = _1.keyword, message = _1.message;
                    var output = [import_chalk4["default"](__makeTemplateObject(["{red {bold ", "} ", "}\n"], ["{red {bold ", "} ", "}\\n"]), keyword.toUpperCase(), message)];
                    return output.concat(this.getCodeFrame(import_chalk4["default"](__makeTemplateObject(["\uD83D\uDC48\uD83C\uDFFD  {magentaBright ", "} ", ""], ["\uD83D\uDC48\uD83C\uDFFD  {magentaBright ", "} ", ""]), keyword, message)));
                };
                class_4.prototype.getError = function () {
                    var _1 = this.options, keyword = _1.keyword, message = _1.message;
                    return __assign(__assign({}, this.getLocation()), { error: "".concat(this.getDecoratedPath(), ": ").concat(keyword, " ").concat(message), path: this.instancePath });
                };
                return class_4;
            }(BaseValidationError));
            // src/helpers.js
            var JSON_POINTERS_REGEX = /\/[\w_-]+(\/\d+)?/g;
            function makeTree(ajvErrors) {
                if (ajvErrors === void 0) { ajvErrors = []; }
                var root = { children: {} };
                ajvErrors.forEach(function (ajvError) {
                    var instancePath = typeof ajvError.instancePath !== "undefined" ? ajvError.instancePath : ajvError.dataPath;
                    var paths = instancePath === "" ? [""] : instancePath.match(JSON_POINTERS_REGEX);
                    paths && paths.reduce(function (obj, path, i) {
                        obj.children[path] = obj.children[path] || { children: {}, errors: [] };
                        if (i === paths.length - 1) {
                            obj.children[path].errors.push(ajvError);
                        }
                        return obj.children[path];
                    }, root);
                });
                return root;
            }
            function filterRedundantErrors(root, parent, key) {
                getErrors(root).forEach(function (error) {
                    if (isRequiredError(error)) {
                        root.errors = [error];
                        root.children = {};
                    }
                });
                if (getErrors(root).some(isAnyOfError)) {
                    if (Object.keys(root.children).length > 0) {
                        delete root.errors;
                    }
                }
                if (root.errors && root.errors.length && getErrors(root).every(isEnumError)) {
                    if (getSiblings(parent)(root).filter(notUndefined).some(getErrors)) {
                        delete parent.children[key];
                    }
                }
                Object.entries(root.children).forEach(function (_1) {
                    var key2 = _1[0], child = _1[1];
                    return filterRedundantErrors(child, root, key2);
                });
            }
            function createErrorInstances(root, options) {
                var errors = getErrors(root);
                if (errors.length && errors.every(isEnumError)) {
                    var uniqueValues = new Set(concatAll([])(errors.map(function (e) { return e.params.allowedValues; })));
                    var allowedValues = __spreadArray([], uniqueValues, true);
                    var error = errors[0];
                    return [
                        new EnumValidationError(__assign(__assign({}, error), { params: { allowedValues: allowedValues } }), options)
                    ];
                }
                else {
                    return concatAll(errors.reduce(function (ret, error) {
                        switch (error.keyword) {
                            case "additionalProperties":
                                return ret.concat(new AdditionalPropValidationError(error, options));
                            case "enum":
                                return ret.concat(new EnumValidationError(error, options));
                            case "required":
                                return ret.concat(new RequiredValidationError(error, options));
                            default:
                                return ret.concat(new DefaultValidationError(error, options));
                        }
                    }, []))(getChildren(root).map(function (child) { return createErrorInstances(child, options); }));
                }
            }
            var helpers_default = function (ajvErrors, options) {
                var tree = makeTree(ajvErrors || []);
                filterRedundantErrors(tree);
                return createErrorInstances(tree, options);
            };
            // src/index.js
            var src_default = function (schema, data, errors, options) {
                if (options === void 0) { options = {}; }
                var _1 = options.format, format = _1 === void 0 ? "cli" : _1, _2 = options.indent, indent = _2 === void 0 ? null : _2, _3 = options.json, json = _3 === void 0 ? null : _3;
                var jsonRaw = json || JSON.stringify(data, null, indent);
                var jsonAst = (0, import_momoa.parse)(jsonRaw);
                var customErrorToText = function (error) { return error.print().join("\n"); };
                var customErrorToStructure = function (error) { return error.getError(); };
                var customErrors = helpers_default(errors, {
                    data: data,
                    schema: schema,
                    jsonAst: jsonAst,
                    jsonRaw: jsonRaw
                });
                if (format === "cli") {
                    return customErrors.map(customErrorToText).join("\n\n");
                }
                else {
                    return customErrors.map(customErrorToStructure);
                }
            };
            // Annotate the CommonJS export names for ESM import in node:
            0 && (0);
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 2487: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.Glob = void 0;
            var minimatch_1 = __nccwpck_require__(1953);
            var path_scurry_1 = __nccwpck_require__(9569);
            var url_1 = __nccwpck_require__(7310);
            var pattern_js_1 = __nccwpck_require__(6866);
            var walker_js_1 = __nccwpck_require__(153);
            // if no process global, just call it linux.
            // so we default to case-sensitive, / separators
            var defaultPlatform = typeof process === 'object' &&
                process &&
                typeof process.platform === 'string'
                ? process.platform
                : 'linux';
            /**
             * An object that can perform glob pattern traversals.
             */
            var Glob = /** @class */ (function () {
                /**
                 * All options are stored as properties on the `Glob` object.
                 *
                 * See {@link GlobOptions} for full options descriptions.
                 *
                 * Note that a previous `Glob` object can be passed as the
                 * `GlobOptions` to another `Glob` instantiation to re-use settings
                 * and caches with a new pattern.
                 *
                 * Traversal functions can be called multiple times to run the walk
                 * again.
                 */
                function Glob(pattern, opts) {
                    var _this_1 = this;
                    /* c8 ignore start */
                    if (!opts)
                        throw new TypeError('glob options required');
                    /* c8 ignore stop */
                    this.withFileTypes = !!opts.withFileTypes;
                    this.signal = opts.signal;
                    this.follow = !!opts.follow;
                    this.dot = !!opts.dot;
                    this.dotRelative = !!opts.dotRelative;
                    this.nodir = !!opts.nodir;
                    this.mark = !!opts.mark;
                    if (!opts.cwd) {
                        this.cwd = '';
                    }
                    else if (opts.cwd instanceof URL || opts.cwd.startsWith('file://')) {
                        opts.cwd = (0, url_1.fileURLToPath)(opts.cwd);
                    }
                    this.cwd = opts.cwd || '';
                    this.root = opts.root;
                    this.magicalBraces = !!opts.magicalBraces;
                    this.nobrace = !!opts.nobrace;
                    this.noext = !!opts.noext;
                    this.realpath = !!opts.realpath;
                    this.absolute = opts.absolute;
                    this.noglobstar = !!opts.noglobstar;
                    this.matchBase = !!opts.matchBase;
                    this.maxDepth =
                        typeof opts.maxDepth === 'number' ? opts.maxDepth : Infinity;
                    this.stat = !!opts.stat;
                    this.ignore = opts.ignore;
                    if (this.withFileTypes && this.absolute !== undefined) {
                        throw new Error('cannot set absolute and withFileTypes:true');
                    }
                    if (typeof pattern === 'string') {
                        pattern = [pattern];
                    }
                    this.windowsPathsNoEscape =
                        !!opts.windowsPathsNoEscape ||
                            opts.allowWindowsEscape === false;
                    if (this.windowsPathsNoEscape) {
                        pattern = pattern.map(function (p) { return p.replace(/\\/g, '/'); });
                    }
                    if (this.matchBase) {
                        if (opts.noglobstar) {
                            throw new TypeError('base matching requires globstar');
                        }
                        pattern = pattern.map(function (p) { return (p.includes('/') ? p : "./**/".concat(p)); });
                    }
                    this.pattern = pattern;
                    this.platform = opts.platform || defaultPlatform;
                    this.opts = __assign(__assign({}, opts), { platform: this.platform });
                    if (opts.scurry) {
                        this.scurry = opts.scurry;
                        if (opts.nocase !== undefined &&
                            opts.nocase !== opts.scurry.nocase) {
                            throw new Error('nocase option contradicts provided scurry option');
                        }
                    }
                    else {
                        var Scurry = opts.platform === 'win32'
                            ? path_scurry_1.PathScurryWin32
                            : opts.platform === 'darwin'
                                ? path_scurry_1.PathScurryDarwin
                                : opts.platform
                                    ? path_scurry_1.PathScurryPosix
                                    : path_scurry_1.PathScurry;
                        this.scurry = new Scurry(this.cwd, {
                            nocase: opts.nocase,
                            fs: opts.fs
                        });
                    }
                    this.nocase = this.scurry.nocase;
                    // If you do nocase:true on a case-sensitive file system, then
                    // we need to use regexps instead of strings for non-magic
                    // path portions, because statting `aBc` won't return results
                    // for the file `AbC` for example.
                    var nocaseMagicOnly = this.platform === 'darwin' || this.platform === 'win32';
                    var mmo = __assign(__assign({}, opts), { dot: this.dot, matchBase: this.matchBase, nobrace: this.nobrace, nocase: this.nocase, nocaseMagicOnly: nocaseMagicOnly, nocomment: true, noext: this.noext, nonegate: true, optimizationLevel: 2, platform: this.platform, windowsPathsNoEscape: this.windowsPathsNoEscape, debug: !!this.opts.debug });
                    var mms = this.pattern.map(function (p) { return new minimatch_1.Minimatch(p, mmo); });
                    var _1 = mms.reduce(function (set, m) {
                        var _1, _2;
                        (_1 = set[0]).push.apply(_1, m.set);
                        (_2 = set[1]).push.apply(_2, m.globParts);
                        return set;
                    }, [[], []]), matchSet = _1[0], globParts = _1[1];
                    this.patterns = matchSet.map(function (set, i) {
                        var g = globParts[i];
                        /* c8 ignore start */
                        if (!g)
                            throw new Error('invalid pattern object');
                        /* c8 ignore stop */
                        return new pattern_js_1.Pattern(set, g, 0, _this_1.platform);
                    });
                }
                Glob.prototype.walk = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _1;
                        return __generator(this, function (_2) {
                            switch (_2.label) {
                                case 0:
                                    _1 = [[]];
                                    return [4 /*yield*/, new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, __assign(__assign({}, this.opts), { maxDepth: this.maxDepth !== Infinity
                                                ? this.maxDepth + this.scurry.cwd.depth()
                                                : Infinity, platform: this.platform, nocase: this.nocase })).walk()];
                                case 1: 
                                // Walkers always return array of Path objects, so we just have to
                                // coerce them into the right shape.  It will have already called
                                // realpath() if the option was set to do so, so we know that's cached.
                                // start out knowing the cwd, at least
                                return [2 /*return*/, __spreadArray.apply(void 0, _1.concat([(_2.sent()), true]))];
                            }
                        });
                    });
                };
                Glob.prototype.walkSync = function () {
                    return __spreadArray([], new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, __assign(__assign({}, this.opts), { maxDepth: this.maxDepth !== Infinity
                            ? this.maxDepth + this.scurry.cwd.depth()
                            : Infinity, platform: this.platform, nocase: this.nocase })).walkSync(), true);
                };
                Glob.prototype.stream = function () {
                    return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, __assign(__assign({}, this.opts), { maxDepth: this.maxDepth !== Infinity
                            ? this.maxDepth + this.scurry.cwd.depth()
                            : Infinity, platform: this.platform, nocase: this.nocase })).stream();
                };
                Glob.prototype.streamSync = function () {
                    return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, __assign(__assign({}, this.opts), { maxDepth: this.maxDepth !== Infinity
                            ? this.maxDepth + this.scurry.cwd.depth()
                            : Infinity, platform: this.platform, nocase: this.nocase })).streamSync();
                };
                /**
                 * Default sync iteration function. Returns a Generator that
                 * iterates over the results.
                 */
                Glob.prototype.iterateSync = function () {
                    return this.streamSync()[Symbol.iterator]();
                };
                Glob.prototype[Symbol.iterator] = function () {
                    return this.iterateSync();
                };
                /**
                 * Default async iteration function. Returns an AsyncGenerator that
                 * iterates over the results.
                 */
                Glob.prototype.iterate = function () {
                    return this.stream()[Symbol.asyncIterator]();
                };
                Glob.prototype[Symbol.asyncIterator] = function () {
                    return this.iterate();
                };
                return Glob;
            }());
            exports.Glob = Glob;
            //# sourceMappingURL=glob.js.map
            /***/ 
        }),
        /***/ 3133: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.hasMagic = void 0;
            var minimatch_1 = __nccwpck_require__(1953);
            /**
             * Return true if the patterns provided contain any magic glob characters,
             * given the options provided.
             *
             * Brace expansion is not considered "magic" unless the `magicalBraces` option
             * is set, as brace expansion just turns one string into an array of strings.
             * So a pattern like `'x{a,b}y'` would return `false`, because `'xay'` and
             * `'xby'` both do not contain any magic glob characters, and it's treated the
             * same as if you had called it on `['xay', 'xby']`. When `magicalBraces:true`
             * is in the options, brace expansion _is_ treated as a pattern having magic.
             */
            var hasMagic = function (pattern, options) {
                if (options === void 0) { options = {}; }
                if (!Array.isArray(pattern)) {
                    pattern = [pattern];
                }
                for (var _1 = 0, pattern_2 = pattern; _1 < pattern_2.length; _1++) {
                    var p = pattern_2[_1];
                    if (new minimatch_1.Minimatch(p, options).hasMagic())
                        return true;
                }
                return false;
            };
            exports.hasMagic = hasMagic;
            //# sourceMappingURL=has-magic.js.map
            /***/ 
        }),
        /***/ 9703: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            // give it a pattern, and it'll be able to tell you if
            // a given path should be ignored.
            // Ignoring a path ignores its children if the pattern ends in /**
            // Ignores are always parsed in dot:true mode
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.Ignore = void 0;
            var minimatch_1 = __nccwpck_require__(1953);
            var pattern_js_1 = __nccwpck_require__(6866);
            var defaultPlatform = typeof process === 'object' &&
                process &&
                typeof process.platform === 'string'
                ? process.platform
                : 'linux';
            /**
             * Class used to process ignored patterns
             */
            var Ignore = /** @class */ (function () {
                function Ignore(ignored, _1) {
                    var nobrace = _1.nobrace, nocase = _1.nocase, noext = _1.noext, noglobstar = _1.noglobstar, _2 = _1.platform, platform = _2 === void 0 ? defaultPlatform : _2;
                    this.relative = [];
                    this.absolute = [];
                    this.relativeChildren = [];
                    this.absoluteChildren = [];
                    var mmopts = {
                        dot: true,
                        nobrace: nobrace,
                        nocase: nocase,
                        noext: noext,
                        noglobstar: noglobstar,
                        optimizationLevel: 2,
                        platform: platform,
                        nocomment: true,
                        nonegate: true
                    };
                    // this is a little weird, but it gives us a clean set of optimized
                    // minimatch matchers, without getting tripped up if one of them
                    // ends in /** inside a brace section, and it's only inefficient at
                    // the start of the walk, not along it.
                    // It'd be nice if the Pattern class just had a .test() method, but
                    // handling globstars is a bit of a pita, and that code already lives
                    // in minimatch anyway.
                    // Another way would be if maybe Minimatch could take its set/globParts
                    // as an option, and then we could at least just use Pattern to test
                    // for absolute-ness.
                    // Yet another way, Minimatch could take an array of glob strings, and
                    // a cwd option, and do the right thing.
                    for (var _3 = 0, ignored_1 = ignored; _3 < ignored_1.length; _3++) {
                        var ign = ignored_1[_3];
                        var mm = new minimatch_1.Minimatch(ign, mmopts);
                        for (var i = 0; i < mm.set.length; i++) {
                            var parsed = mm.set[i];
                            var globParts = mm.globParts[i];
                            /* c8 ignore start */
                            if (!parsed || !globParts) {
                                throw new Error('invalid pattern object');
                            }
                            /* c8 ignore stop */
                            var p = new pattern_js_1.Pattern(parsed, globParts, 0, platform);
                            var m = new minimatch_1.Minimatch(p.globString(), mmopts);
                            var children = globParts[globParts.length - 1] === '**';
                            var absolute = p.isAbsolute();
                            if (absolute)
                                this.absolute.push(m);
                            else
                                this.relative.push(m);
                            if (children) {
                                if (absolute)
                                    this.absoluteChildren.push(m);
                                else
                                    this.relativeChildren.push(m);
                            }
                        }
                    }
                }
                Ignore.prototype.ignored = function (p) {
                    var fullpath = p.fullpath();
                    var fullpaths = "".concat(fullpath, "/");
                    var relative = p.relative() || '.';
                    var relatives = "".concat(relative, "/");
                    for (var _1 = 0, _2 = this.relative; _1 < _2.length; _1++) {
                        var m = _2[_1];
                        if (m.match(relative) || m.match(relatives))
                            return true;
                    }
                    for (var _3 = 0, _4 = this.absolute; _3 < _4.length; _3++) {
                        var m = _4[_3];
                        if (m.match(fullpath) || m.match(fullpaths))
                            return true;
                    }
                    return false;
                };
                Ignore.prototype.childrenIgnored = function (p) {
                    var fullpath = p.fullpath() + '/';
                    var relative = (p.relative() || '.') + '/';
                    for (var _1 = 0, _2 = this.relativeChildren; _1 < _2.length; _1++) {
                        var m = _2[_1];
                        if (m.match(relative))
                            return true;
                    }
                    for (var _3 = 0, _4 = this.absoluteChildren; _3 < _4.length; _3++) {
                        var m = _4[_3];
                        if (m.match(fullpath))
                            return true;
                    }
                    return false;
                };
                return Ignore;
            }());
            exports.Ignore = Ignore;
            //# sourceMappingURL=ignore.js.map
            /***/ 
        }),
        /***/ 8211: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.glob = exports.hasMagic = exports.Glob = exports.unescape = exports.escape = exports.sync = exports.iterate = exports.iterateSync = exports.stream = exports.streamSync = exports.globIterate = exports.globIterateSync = exports.globSync = exports.globStream = exports.globStreamSync = void 0;
            var minimatch_1 = __nccwpck_require__(1953);
            var glob_js_1 = __nccwpck_require__(2487);
            var has_magic_js_1 = __nccwpck_require__(3133);
            function globStreamSync(pattern, options) {
                if (options === void 0) { options = {}; }
                return new glob_js_1.Glob(pattern, options).streamSync();
            }
            exports.globStreamSync = globStreamSync;
            function globStream(pattern, options) {
                if (options === void 0) { options = {}; }
                return new glob_js_1.Glob(pattern, options).stream();
            }
            exports.globStream = globStream;
            function globSync(pattern, options) {
                if (options === void 0) { options = {}; }
                return new glob_js_1.Glob(pattern, options).walkSync();
            }
            exports.globSync = globSync;
            function glob_(pattern, options) {
                if (options === void 0) { options = {}; }
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_1) {
                        return [2 /*return*/, new glob_js_1.Glob(pattern, options).walk()];
                    });
                });
            }
            function globIterateSync(pattern, options) {
                if (options === void 0) { options = {}; }
                return new glob_js_1.Glob(pattern, options).iterateSync();
            }
            exports.globIterateSync = globIterateSync;
            function globIterate(pattern, options) {
                if (options === void 0) { options = {}; }
                return new glob_js_1.Glob(pattern, options).iterate();
            }
            exports.globIterate = globIterate;
            // aliases: glob.sync.stream() glob.stream.sync() glob.sync() etc
            exports.streamSync = globStreamSync;
            exports.stream = Object.assign(globStream, { sync: globStreamSync });
            exports.iterateSync = globIterateSync;
            exports.iterate = Object.assign(globIterate, {
                sync: globIterateSync
            });
            exports.sync = Object.assign(globSync, {
                stream: globStreamSync,
                iterate: globIterateSync
            });
            /* c8 ignore start */
            var minimatch_2 = __nccwpck_require__(1953);
            Object.defineProperty(exports, "escape", ({ enumerable: true, get: function () { return minimatch_2.escape; } }));
            Object.defineProperty(exports, "unescape", ({ enumerable: true, get: function () { return minimatch_2.unescape; } }));
            var glob_js_2 = __nccwpck_require__(2487);
            Object.defineProperty(exports, "Glob", ({ enumerable: true, get: function () { return glob_js_2.Glob; } }));
            var has_magic_js_2 = __nccwpck_require__(3133);
            Object.defineProperty(exports, "hasMagic", ({ enumerable: true, get: function () { return has_magic_js_2.hasMagic; } }));
            /* c8 ignore stop */
            exports.glob = Object.assign(glob_, {
                glob: glob_,
                globSync: globSync,
                sync: exports.sync,
                globStream: globStream,
                stream: exports.stream,
                globStreamSync: globStreamSync,
                streamSync: exports.streamSync,
                globIterate: globIterate,
                iterate: exports.iterate,
                globIterateSync: globIterateSync,
                iterateSync: exports.iterateSync,
                Glob: glob_js_1.Glob,
                hasMagic: has_magic_js_1.hasMagic,
                escape: minimatch_1.escape,
                unescape: minimatch_1.unescape
            });
            exports.glob.glob = exports.glob;
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 6866: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var _Pattern_patternList, _Pattern_globList, _Pattern_index, _Pattern_platform, _Pattern_rest, _Pattern_globString, _Pattern_isDrive, _Pattern_isUNC, _Pattern_isAbsolute, _Pattern_followGlobstar;
            // this is just a very light wrapper around 2 arrays with an offset index
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.Pattern = void 0;
            var minimatch_1 = __nccwpck_require__(1953);
            var isPatternList = function (pl) { return pl.length >= 1; };
            var isGlobList = function (gl) { return gl.length >= 1; };
            /**
             * An immutable-ish view on an array of glob parts and their parsed
             * results
             */
            var Pattern = /** @class */ (function () {
                function Pattern(patternList, globList, index, platform) {
                    _Pattern_patternList.set(this, void 0);
                    _Pattern_globList.set(this, void 0);
                    _Pattern_index.set(this, void 0);
                    _Pattern_platform.set(this, void 0);
                    _Pattern_rest.set(this, void 0);
                    _Pattern_globString.set(this, void 0);
                    _Pattern_isDrive.set(this, void 0);
                    _Pattern_isUNC.set(this, void 0);
                    _Pattern_isAbsolute.set(this, void 0);
                    _Pattern_followGlobstar.set(this, true);
                    if (!isPatternList(patternList)) {
                        throw new TypeError('empty pattern list');
                    }
                    if (!isGlobList(globList)) {
                        throw new TypeError('empty glob list');
                    }
                    if (globList.length !== patternList.length) {
                        throw new TypeError('mismatched pattern list and glob list lengths');
                    }
                    this.length = patternList.length;
                    if (index < 0 || index >= this.length) {
                        throw new TypeError('index out of range');
                    }
                    __classPrivateFieldSet(this, _Pattern_patternList, patternList, "f");
                    __classPrivateFieldSet(this, _Pattern_globList, globList, "f");
                    __classPrivateFieldSet(this, _Pattern_index, index, "f");
                    __classPrivateFieldSet(this, _Pattern_platform, platform, "f");
                    // normalize root entries of absolute patterns on initial creation.
                    if (__classPrivateFieldGet(this, _Pattern_index, "f") === 0) {
                        // c: => ['c:/']
                        // C:/ => ['C:/']
                        // C:/x => ['C:/', 'x']
                        // //host/share => ['//host/share/']
                        // //host/share/ => ['//host/share/']
                        // //host/share/x => ['//host/share/', 'x']
                        // /etc => ['/', 'etc']
                        // / => ['/']
                        if (this.isUNC()) {
                            // '' / '' / 'host' / 'share'
                            var _1 = __classPrivateFieldGet(this, _Pattern_patternList, "f"), p0 = _1[0], p1 = _1[1], p2 = _1[2], p3 = _1[3], prest = _1.slice(4);
                            var _2 = __classPrivateFieldGet(this, _Pattern_globList, "f"), g0 = _2[0], g1 = _2[1], g2 = _2[2], g3 = _2[3], grest = _2.slice(4);
                            if (prest[0] === '') {
                                // ends in /
                                prest.shift();
                                grest.shift();
                            }
                            var p = [p0, p1, p2, p3, ''].join('/');
                            var g = [g0, g1, g2, g3, ''].join('/');
                            __classPrivateFieldSet(this, _Pattern_patternList, __spreadArray([p], prest, true), "f");
                            __classPrivateFieldSet(this, _Pattern_globList, __spreadArray([g], grest, true), "f");
                            this.length = __classPrivateFieldGet(this, _Pattern_patternList, "f").length;
                        }
                        else if (this.isDrive() || this.isAbsolute()) {
                            var _3 = __classPrivateFieldGet(this, _Pattern_patternList, "f"), p1 = _3[0], prest = _3.slice(1);
                            var _4 = __classPrivateFieldGet(this, _Pattern_globList, "f"), g1 = _4[0], grest = _4.slice(1);
                            if (prest[0] === '') {
                                // ends in /
                                prest.shift();
                                grest.shift();
                            }
                            var p = p1 + '/';
                            var g = g1 + '/';
                            __classPrivateFieldSet(this, _Pattern_patternList, __spreadArray([p], prest, true), "f");
                            __classPrivateFieldSet(this, _Pattern_globList, __spreadArray([g], grest, true), "f");
                            this.length = __classPrivateFieldGet(this, _Pattern_patternList, "f").length;
                        }
                    }
                }
                /**
                 * The first entry in the parsed list of patterns
                 */
                Pattern.prototype.pattern = function () {
                    return __classPrivateFieldGet(this, _Pattern_patternList, "f")[__classPrivateFieldGet(this, _Pattern_index, "f")];
                };
                /**
                 * true of if pattern() returns a string
                 */
                Pattern.prototype.isString = function () {
                    return typeof __classPrivateFieldGet(this, _Pattern_patternList, "f")[__classPrivateFieldGet(this, _Pattern_index, "f")] === 'string';
                };
                /**
                 * true of if pattern() returns GLOBSTAR
                 */
                Pattern.prototype.isGlobstar = function () {
                    return __classPrivateFieldGet(this, _Pattern_patternList, "f")[__classPrivateFieldGet(this, _Pattern_index, "f")] === minimatch_1.GLOBSTAR;
                };
                /**
                 * true if pattern() returns a regexp
                 */
                Pattern.prototype.isRegExp = function () {
                    return __classPrivateFieldGet(this, _Pattern_patternList, "f")[__classPrivateFieldGet(this, _Pattern_index, "f")] instanceof RegExp;
                };
                /**
                 * The /-joined set of glob parts that make up this pattern
                 */
                Pattern.prototype.globString = function () {
                    return (__classPrivateFieldSet(this, _Pattern_globString, __classPrivateFieldGet(this, _Pattern_globString, "f") ||
                        (__classPrivateFieldGet(this, _Pattern_index, "f") === 0
                            ? this.isAbsolute()
                                ? __classPrivateFieldGet(this, _Pattern_globList, "f")[0] + __classPrivateFieldGet(this, _Pattern_globList, "f").slice(1).join('/')
                                : __classPrivateFieldGet(this, _Pattern_globList, "f").join('/')
                            : __classPrivateFieldGet(this, _Pattern_globList, "f").slice(__classPrivateFieldGet(this, _Pattern_index, "f")).join('/')), "f"));
                };
                /**
                 * true if there are more pattern parts after this one
                 */
                Pattern.prototype.hasMore = function () {
                    return this.length > __classPrivateFieldGet(this, _Pattern_index, "f") + 1;
                };
                /**
                 * The rest of the pattern after this part, or null if this is the end
                 */
                Pattern.prototype.rest = function () {
                    if (__classPrivateFieldGet(this, _Pattern_rest, "f") !== undefined)
                        return __classPrivateFieldGet(this, _Pattern_rest, "f");
                    if (!this.hasMore())
                        return (__classPrivateFieldSet(this, _Pattern_rest, null, "f"));
                    __classPrivateFieldSet(this, _Pattern_rest, new Pattern(__classPrivateFieldGet(this, _Pattern_patternList, "f"), __classPrivateFieldGet(this, _Pattern_globList, "f"), __classPrivateFieldGet(this, _Pattern_index, "f") + 1, __classPrivateFieldGet(this, _Pattern_platform, "f")), "f");
                    __classPrivateFieldSet(__classPrivateFieldGet(this, _Pattern_rest, "f"), _Pattern_isAbsolute, __classPrivateFieldGet(this, _Pattern_isAbsolute, "f"), "f");
                    __classPrivateFieldSet(__classPrivateFieldGet(this, _Pattern_rest, "f"), _Pattern_isUNC, __classPrivateFieldGet(this, _Pattern_isUNC, "f"), "f");
                    __classPrivateFieldSet(__classPrivateFieldGet(this, _Pattern_rest, "f"), _Pattern_isDrive, __classPrivateFieldGet(this, _Pattern_isDrive, "f"), "f");
                    return __classPrivateFieldGet(this, _Pattern_rest, "f");
                };
                /**
                 * true if the pattern represents a //unc/path/ on windows
                 */
                Pattern.prototype.isUNC = function () {
                    var pl = __classPrivateFieldGet(this, _Pattern_patternList, "f");
                    return __classPrivateFieldGet(this, _Pattern_isUNC, "f") !== undefined
                        ? __classPrivateFieldGet(this, _Pattern_isUNC, "f")
                        : (__classPrivateFieldSet(this, _Pattern_isUNC, __classPrivateFieldGet(this, _Pattern_platform, "f") === 'win32' &&
                            __classPrivateFieldGet(this, _Pattern_index, "f") === 0 &&
                            pl[0] === '' &&
                            pl[1] === '' &&
                            typeof pl[2] === 'string' &&
                            !!pl[2] &&
                            typeof pl[3] === 'string' &&
                            !!pl[3], "f"));
                };
                // pattern like C:/...
                // split = ['C:', ...]
                // XXX: would be nice to handle patterns like `c:*` to test the cwd
                // in c: for *, but I don't know of a way to even figure out what that
                // cwd is without actually chdir'ing into it?
                /**
                 * True if the pattern starts with a drive letter on Windows
                 */
                Pattern.prototype.isDrive = function () {
                    var pl = __classPrivateFieldGet(this, _Pattern_patternList, "f");
                    return __classPrivateFieldGet(this, _Pattern_isDrive, "f") !== undefined
                        ? __classPrivateFieldGet(this, _Pattern_isDrive, "f")
                        : (__classPrivateFieldSet(this, _Pattern_isDrive, __classPrivateFieldGet(this, _Pattern_platform, "f") === 'win32' &&
                            __classPrivateFieldGet(this, _Pattern_index, "f") === 0 &&
                            this.length > 1 &&
                            typeof pl[0] === 'string' &&
                            /^[a-z]:$/i.test(pl[0]), "f"));
                };
                // pattern = '/' or '/...' or '/x/...'
                // split = ['', ''] or ['', ...] or ['', 'x', ...]
                // Drive and UNC both considered absolute on windows
                /**
                 * True if the pattern is rooted on an absolute path
                 */
                Pattern.prototype.isAbsolute = function () {
                    var pl = __classPrivateFieldGet(this, _Pattern_patternList, "f");
                    return __classPrivateFieldGet(this, _Pattern_isAbsolute, "f") !== undefined
                        ? __classPrivateFieldGet(this, _Pattern_isAbsolute, "f")
                        : (__classPrivateFieldSet(this, _Pattern_isAbsolute, (pl[0] === '' && pl.length > 1) ||
                            this.isDrive() ||
                            this.isUNC(), "f"));
                };
                /**
                 * consume the root of the pattern, and return it
                 */
                Pattern.prototype.root = function () {
                    var p = __classPrivateFieldGet(this, _Pattern_patternList, "f")[0];
                    return typeof p === 'string' && this.isAbsolute() && __classPrivateFieldGet(this, _Pattern_index, "f") === 0
                        ? p
                        : '';
                };
                /**
                 * Check to see if the current globstar pattern is allowed to follow
                 * a symbolic link.
                 */
                Pattern.prototype.checkFollowGlobstar = function () {
                    return !(__classPrivateFieldGet(this, _Pattern_index, "f") === 0 ||
                        !this.isGlobstar() ||
                        !__classPrivateFieldGet(this, _Pattern_followGlobstar, "f"));
                };
                /**
                 * Mark that the current globstar pattern is following a symbolic link
                 */
                Pattern.prototype.markFollowGlobstar = function () {
                    if (__classPrivateFieldGet(this, _Pattern_index, "f") === 0 || !this.isGlobstar() || !__classPrivateFieldGet(this, _Pattern_followGlobstar, "f"))
                        return false;
                    __classPrivateFieldSet(this, _Pattern_followGlobstar, false, "f");
                    return true;
                };
                return Pattern;
            }());
            _Pattern_patternList = new WeakMap(), _Pattern_globList = new WeakMap(), _Pattern_index = new WeakMap(), _Pattern_platform = new WeakMap(), _Pattern_rest = new WeakMap(), _Pattern_globString = new WeakMap(), _Pattern_isDrive = new WeakMap(), _Pattern_isUNC = new WeakMap(), _Pattern_isAbsolute = new WeakMap(), _Pattern_followGlobstar = new WeakMap();
            exports.Pattern = Pattern;
            //# sourceMappingURL=pattern.js.map
            /***/ 
        }),
        /***/ 4628: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            // synchronous utility for filtering entries and calculating subwalks
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.Processor = exports.SubWalks = exports.MatchRecord = exports.HasWalkedCache = void 0;
            var minimatch_1 = __nccwpck_require__(1953);
            /**
             * A cache of which patterns have been processed for a given Path
             */
            var HasWalkedCache = /** @class */ (function () {
                function HasWalkedCache(store) {
                    if (store === void 0) { store = new Map(); }
                    this.store = store;
                }
                HasWalkedCache.prototype.copy = function () {
                    return new HasWalkedCache(new Map(this.store));
                };
                HasWalkedCache.prototype.hasWalked = function (target, pattern) {
                    var _1;
                    return (_1 = this.store.get(target.fullpath())) === null || _1 === void 0 ? void 0 : _1.has(pattern.globString());
                };
                HasWalkedCache.prototype.storeWalked = function (target, pattern) {
                    var fullpath = target.fullpath();
                    var cached = this.store.get(fullpath);
                    if (cached)
                        cached.add(pattern.globString());
                    else
                        this.store.set(fullpath, new Set([pattern.globString()]));
                };
                return HasWalkedCache;
            }());
            exports.HasWalkedCache = HasWalkedCache;
            /**
             * A record of which paths have been matched in a given walk step,
             * and whether they only are considered a match if they are a directory,
             * and whether their absolute or relative path should be returned.
             */
            var MatchRecord = /** @class */ (function () {
                function MatchRecord() {
                    this.store = new Map();
                }
                MatchRecord.prototype.add = function (target, absolute, ifDir) {
                    var n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
                    var current = this.store.get(target);
                    this.store.set(target, current === undefined ? n : n & current);
                };
                // match, absolute, ifdir
                MatchRecord.prototype.entries = function () {
                    return __spreadArray([], this.store.entries(), true).map(function (_1) {
                        var path = _1[0], n = _1[1];
                        return [
                            path,
                            !!(n & 2),
                            !!(n & 1),
                        ];
                    });
                };
                return MatchRecord;
            }());
            exports.MatchRecord = MatchRecord;
            /**
             * A collection of patterns that must be processed in a subsequent step
             * for a given path.
             */
            var SubWalks = /** @class */ (function () {
                function SubWalks() {
                    this.store = new Map();
                }
                SubWalks.prototype.add = function (target, pattern) {
                    if (!target.canReaddir()) {
                        return;
                    }
                    var subs = this.store.get(target);
                    if (subs) {
                        if (!subs.find(function (p) { return p.globString() === pattern.globString(); })) {
                            subs.push(pattern);
                        }
                    }
                    else
                        this.store.set(target, [pattern]);
                };
                SubWalks.prototype.get = function (target) {
                    var subs = this.store.get(target);
                    /* c8 ignore start */
                    if (!subs) {
                        throw new Error('attempting to walk unknown path');
                    }
                    /* c8 ignore stop */
                    return subs;
                };
                SubWalks.prototype.entries = function () {
                    var _this_1 = this;
                    return this.keys().map(function (k) { return [k, _this_1.store.get(k)]; });
                };
                SubWalks.prototype.keys = function () {
                    return __spreadArray([], this.store.keys(), true).filter(function (t) { return t.canReaddir(); });
                };
                return SubWalks;
            }());
            exports.SubWalks = SubWalks;
            /**
             * The class that processes patterns for a given path.
             *
             * Handles child entry filtering, and determining whether a path's
             * directory contents must be read.
             */
            var Processor = /** @class */ (function () {
                function Processor(opts, hasWalkedCache) {
                    this.matches = new MatchRecord();
                    this.subwalks = new SubWalks();
                    this.opts = opts;
                    this.follow = !!opts.follow;
                    this.dot = !!opts.dot;
                    this.hasWalkedCache = hasWalkedCache
                        ? hasWalkedCache.copy()
                        : new HasWalkedCache();
                }
                Processor.prototype.processPatterns = function (target, patterns) {
                    this.patterns = patterns;
                    var processingSet = patterns.map(function (p) { return [target, p]; });
                    // map of paths to the magic-starting subwalks they need to walk
                    // first item in patterns is the filter
                    for (var _1 = 0, processingSet_1 = processingSet; _1 < processingSet_1.length; _1++) {
                        var _2 = processingSet_1[_1], t = _2[0], pattern = _2[1];
                        this.hasWalkedCache.storeWalked(t, pattern);
                        var root = pattern.root();
                        var absolute = pattern.isAbsolute() && this.opts.absolute !== false;
                        // start absolute patterns at root
                        if (root) {
                            t = t.resolve(root === '/' && this.opts.root !== undefined
                                ? this.opts.root
                                : root);
                            var rest_1 = pattern.rest();
                            if (!rest_1) {
                                this.matches.add(t, true, false);
                                continue;
                            }
                            else {
                                pattern = rest_1;
                            }
                        }
                        if (t.isENOENT())
                            continue;
                        var p = void 0;
                        var rest = void 0;
                        var changed = false;
                        while (typeof (p = pattern.pattern()) === 'string' &&
                            (rest = pattern.rest())) {
                            var c = t.resolve(p);
                            t = c;
                            pattern = rest;
                            changed = true;
                        }
                        p = pattern.pattern();
                        rest = pattern.rest();
                        if (changed) {
                            if (this.hasWalkedCache.hasWalked(t, pattern))
                                continue;
                            this.hasWalkedCache.storeWalked(t, pattern);
                        }
                        // now we have either a final string for a known entry,
                        // more strings for an unknown entry,
                        // or a pattern starting with magic, mounted on t.
                        if (typeof p === 'string') {
                            // must not be final entry, otherwise we would have
                            // concatenated it earlier.
                            var ifDir = p === '..' || p === '' || p === '.';
                            this.matches.add(t.resolve(p), absolute, ifDir);
                            continue;
                        }
                        else if (p === minimatch_1.GLOBSTAR) {
                            // if no rest, match and subwalk pattern
                            // if rest, process rest and subwalk pattern
                            // if it's a symlink, but we didn't get here by way of a
                            // globstar match (meaning it's the first time THIS globstar
                            // has traversed a symlink), then we follow it. Otherwise, stop.
                            if (!t.isSymbolicLink() ||
                                this.follow ||
                                pattern.checkFollowGlobstar()) {
                                this.subwalks.add(t, pattern);
                            }
                            var rp = rest === null || rest === void 0 ? void 0 : rest.pattern();
                            var rrest = rest === null || rest === void 0 ? void 0 : rest.rest();
                            if (!rest || ((rp === '' || rp === '.') && !rrest)) {
                                // only HAS to be a dir if it ends in **/ or **/.
                                // but ending in ** will match files as well.
                                this.matches.add(t, absolute, rp === '' || rp === '.');
                            }
                            else {
                                if (rp === '..') {
                                    // this would mean you're matching **/.. at the fs root,
                                    // and no thanks, I'm not gonna test that specific case.
                                    /* c8 ignore start */
                                    var tp = t.parent || t;
                                    /* c8 ignore stop */
                                    if (!rrest)
                                        this.matches.add(tp, absolute, true);
                                    else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
                                        this.subwalks.add(tp, rrest);
                                    }
                                }
                            }
                        }
                        else if (p instanceof RegExp) {
                            this.subwalks.add(t, pattern);
                        }
                    }
                    return this;
                };
                Processor.prototype.subwalkTargets = function () {
                    return this.subwalks.keys();
                };
                Processor.prototype.child = function () {
                    return new Processor(this.opts, this.hasWalkedCache);
                };
                // return a new Processor containing the subwalks for each
                // child entry, and a set of matches, and
                // a hasWalkedCache that's a copy of this one
                // then we're going to call
                Processor.prototype.filterEntries = function (parent, entries) {
                    var patterns = this.subwalks.get(parent);
                    // put matches and entry walks into the results processor
                    var results = this.child();
                    for (var _1 = 0, entries_1 = entries; _1 < entries_1.length; _1++) {
                        var e = entries_1[_1];
                        for (var _2 = 0, patterns_2 = patterns; _2 < patterns_2.length; _2++) {
                            var pattern = patterns_2[_2];
                            var absolute = pattern.isAbsolute();
                            var p = pattern.pattern();
                            var rest = pattern.rest();
                            if (p === minimatch_1.GLOBSTAR) {
                                results.testGlobstar(e, pattern, rest, absolute);
                            }
                            else if (p instanceof RegExp) {
                                results.testRegExp(e, p, rest, absolute);
                            }
                            else {
                                results.testString(e, p, rest, absolute);
                            }
                        }
                    }
                    return results;
                };
                Processor.prototype.testGlobstar = function (e, pattern, rest, absolute) {
                    if (this.dot || !e.name.startsWith('.')) {
                        if (!pattern.hasMore()) {
                            this.matches.add(e, absolute, false);
                        }
                        if (e.canReaddir()) {
                            // if we're in follow mode or it's not a symlink, just keep
                            // testing the same pattern. If there's more after the globstar,
                            // then this symlink consumes the globstar. If not, then we can
                            // follow at most ONE symlink along the way, so we mark it, which
                            // also checks to ensure that it wasn't already marked.
                            if (this.follow || !e.isSymbolicLink()) {
                                this.subwalks.add(e, pattern);
                            }
                            else if (e.isSymbolicLink()) {
                                if (rest && pattern.checkFollowGlobstar()) {
                                    this.subwalks.add(e, rest);
                                }
                                else if (pattern.markFollowGlobstar()) {
                                    this.subwalks.add(e, pattern);
                                }
                            }
                        }
                    }
                    // if the NEXT thing matches this entry, then also add
                    // the rest.
                    if (rest) {
                        var rp = rest.pattern();
                        if (typeof rp === 'string' &&
                            // dots and empty were handled already
                            rp !== '..' &&
                            rp !== '' &&
                            rp !== '.') {
                            this.testString(e, rp, rest.rest(), absolute);
                        }
                        else if (rp === '..') {
                            /* c8 ignore start */
                            var ep = e.parent || e;
                            /* c8 ignore stop */
                            this.subwalks.add(ep, rest);
                        }
                        else if (rp instanceof RegExp) {
                            this.testRegExp(e, rp, rest.rest(), absolute);
                        }
                    }
                };
                Processor.prototype.testRegExp = function (e, p, rest, absolute) {
                    if (!p.test(e.name))
                        return;
                    if (!rest) {
                        this.matches.add(e, absolute, false);
                    }
                    else {
                        this.subwalks.add(e, rest);
                    }
                };
                Processor.prototype.testString = function (e, p, rest, absolute) {
                    // should never happen?
                    if (!e.isNamed(p))
                        return;
                    if (!rest) {
                        this.matches.add(e, absolute, false);
                    }
                    else {
                        this.subwalks.add(e, rest);
                    }
                };
                return Processor;
            }());
            exports.Processor = Processor;
            //# sourceMappingURL=processor.js.map
            /***/ 
        }),
        /***/ 153: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var _GlobUtil_instances, _GlobUtil_onResume, _GlobUtil_ignore, _GlobUtil_sep, _GlobUtil_ignored, _GlobUtil_childrenIgnored;
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.GlobStream = exports.GlobWalker = exports.GlobUtil = void 0;
            /**
             * Single-use utility classes to provide functionality to the {@link Glob}
             * methods.
             *
             * @module
             */
            var minipass_1 = __nccwpck_require__(8865);
            var ignore_js_1 = __nccwpck_require__(9703);
            var processor_js_1 = __nccwpck_require__(4628);
            var makeIgnore = function (ignore, opts) { return typeof ignore === 'string'
                ? new ignore_js_1.Ignore([ignore], opts)
                : Array.isArray(ignore)
                    ? new ignore_js_1.Ignore(ignore, opts)
                    : ignore; };
            /**
             * basic walking utilities that all the glob walker types use
             */
            var GlobUtil = /** @class */ (function () {
                function GlobUtil(patterns, path, opts) {
                    var _this_1 = this;
                    _GlobUtil_instances.add(this);
                    this.seen = new Set();
                    this.paused = false;
                    this.aborted = false;
                    _GlobUtil_onResume.set(this, []);
                    _GlobUtil_ignore.set(this, void 0);
                    _GlobUtil_sep.set(this, void 0);
                    this.patterns = patterns;
                    this.path = path;
                    this.opts = opts;
                    __classPrivateFieldSet(this, _GlobUtil_sep, !opts.posix && opts.platform === 'win32' ? '\\' : '/', "f");
                    if (opts.ignore) {
                        __classPrivateFieldSet(this, _GlobUtil_ignore, makeIgnore(opts.ignore, opts), "f");
                    }
                    // ignore, always set with maxDepth, but it's optional on the
                    // GlobOptions type
                    /* c8 ignore start */
                    this.maxDepth = opts.maxDepth || Infinity;
                    /* c8 ignore stop */
                    if (opts.signal) {
                        this.signal = opts.signal;
                        this.signal.addEventListener('abort', function () {
                            __classPrivateFieldGet(_this_1, _GlobUtil_onResume, "f").length = 0;
                        });
                    }
                }
                // backpressure mechanism
                GlobUtil.prototype.pause = function () {
                    this.paused = true;
                };
                GlobUtil.prototype.resume = function () {
                    var _1;
                    /* c8 ignore start */
                    if ((_1 = this.signal) === null || _1 === void 0 ? void 0 : _1.aborted)
                        return;
                    /* c8 ignore stop */
                    this.paused = false;
                    var fn = undefined;
                    while (!this.paused && (fn = __classPrivateFieldGet(this, _GlobUtil_onResume, "f").shift())) {
                        fn();
                    }
                };
                GlobUtil.prototype.onResume = function (fn) {
                    var _1;
                    if ((_1 = this.signal) === null || _1 === void 0 ? void 0 : _1.aborted)
                        return;
                    /* c8 ignore start */
                    if (!this.paused) {
                        fn();
                    }
                    else {
                        /* c8 ignore stop */
                        __classPrivateFieldGet(this, _GlobUtil_onResume, "f").push(fn);
                    }
                };
                // do the requisite realpath/stat checking, and return the path
                // to add or undefined to filter it out.
                GlobUtil.prototype.matchCheck = function (e, ifDir) {
                    return __awaiter(this, void 0, void 0, function () {
                        var rpc, _1, needStat, _2, _3;
                        return __generator(this, function (_4) {
                            switch (_4.label) {
                                case 0:
                                    if (ifDir && this.opts.nodir)
                                        return [2 /*return*/, undefined];
                                    if (!this.opts.realpath) return [3 /*break*/, 3];
                                    _1 = e.realpathCached();
                                    if (_1) return [3 /*break*/, 2];
                                    return [4 /*yield*/, e.realpath()];
                                case 1:
                                    _1 = (_4.sent());
                                    _4.label = 2;
                                case 2:
                                    rpc = _1;
                                    if (!rpc)
                                        return [2 /*return*/, undefined];
                                    e = rpc;
                                    _4.label = 3;
                                case 3:
                                    needStat = e.isUnknown() || this.opts.stat;
                                    _2 = this.matchCheckTest;
                                    if (!needStat) return [3 /*break*/, 5];
                                    return [4 /*yield*/, e.lstat()];
                                case 4:
                                    _3 = _4.sent();
                                    return [3 /*break*/, 6];
                                case 5:
                                    _3 = e;
                                    _4.label = 6;
                                case 6: return [2 /*return*/, _2.apply(this, [_3, ifDir])];
                            }
                        });
                    });
                };
                GlobUtil.prototype.matchCheckTest = function (e, ifDir) {
                    return e &&
                        (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&
                        (!ifDir || e.canReaddir()) &&
                        (!this.opts.nodir || !e.isDirectory()) &&
                        !__classPrivateFieldGet(this, _GlobUtil_instances, "m", _GlobUtil_ignored).call(this, e)
                        ? e
                        : undefined;
                };
                GlobUtil.prototype.matchCheckSync = function (e, ifDir) {
                    if (ifDir && this.opts.nodir)
                        return undefined;
                    var rpc;
                    if (this.opts.realpath) {
                        rpc = e.realpathCached() || e.realpathSync();
                        if (!rpc)
                            return undefined;
                        e = rpc;
                    }
                    var needStat = e.isUnknown() || this.opts.stat;
                    return this.matchCheckTest(needStat ? e.lstatSync() : e, ifDir);
                };
                GlobUtil.prototype.matchFinish = function (e, absolute) {
                    if (__classPrivateFieldGet(this, _GlobUtil_instances, "m", _GlobUtil_ignored).call(this, e))
                        return;
                    var abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;
                    this.seen.add(e);
                    var mark = this.opts.mark && e.isDirectory() ? __classPrivateFieldGet(this, _GlobUtil_sep, "f") : '';
                    // ok, we have what we need!
                    if (this.opts.withFileTypes) {
                        this.matchEmit(e);
                    }
                    else if (abs) {
                        var abs_1 = this.opts.posix ? e.fullpathPosix() : e.fullpath();
                        this.matchEmit(abs_1 + mark);
                    }
                    else {
                        var rel = this.opts.posix ? e.relativePosix() : e.relative();
                        var pre = this.opts.dotRelative && !rel.startsWith('..' + __classPrivateFieldGet(this, _GlobUtil_sep, "f"))
                            ? '.' + __classPrivateFieldGet(this, _GlobUtil_sep, "f")
                            : '';
                        this.matchEmit(!rel ? '.' + mark : pre + rel + mark);
                    }
                };
                GlobUtil.prototype.match = function (e, absolute, ifDir) {
                    return __awaiter(this, void 0, void 0, function () {
                        var p;
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0: return [4 /*yield*/, this.matchCheck(e, ifDir)];
                                case 1:
                                    p = _1.sent();
                                    if (p)
                                        this.matchFinish(p, absolute);
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                GlobUtil.prototype.matchSync = function (e, absolute, ifDir) {
                    var p = this.matchCheckSync(e, ifDir);
                    if (p)
                        this.matchFinish(p, absolute);
                };
                GlobUtil.prototype.walkCB = function (target, patterns, cb) {
                    var _1;
                    /* c8 ignore start */
                    if ((_1 = this.signal) === null || _1 === void 0 ? void 0 : _1.aborted)
                        cb();
                    /* c8 ignore stop */
                    this.walkCB2(target, patterns, new processor_js_1.Processor(this.opts), cb);
                };
                GlobUtil.prototype.walkCB2 = function (target, patterns, processor, cb) {
                    var _this_1 = this;
                    var _1;
                    if (__classPrivateFieldGet(this, _GlobUtil_instances, "m", _GlobUtil_childrenIgnored).call(this, target))
                        return cb();
                    if ((_1 = this.signal) === null || _1 === void 0 ? void 0 : _1.aborted)
                        cb();
                    if (this.paused) {
                        this.onResume(function () { return _this_1.walkCB2(target, patterns, processor, cb); });
                        return;
                    }
                    processor.processPatterns(target, patterns);
                    // done processing.  all of the above is sync, can be abstracted out.
                    // subwalks is a map of paths to the entry filters they need
                    // matches is a map of paths to [absolute, ifDir] tuples.
                    var tasks = 1;
                    var next = function () {
                        if (--tasks === 0)
                            cb();
                    };
                    for (var _2 = 0, _3 = processor.matches.entries(); _2 < _3.length; _2++) {
                        var _4 = _3[_2], m = _4[0], absolute = _4[1], ifDir = _4[2];
                        if (__classPrivateFieldGet(this, _GlobUtil_instances, "m", _GlobUtil_ignored).call(this, m))
                            continue;
                        tasks++;
                        this.match(m, absolute, ifDir).then(function () { return next(); });
                    }
                    var _loop_16 = function (t) {
                        if (this_1.maxDepth !== Infinity && t.depth() >= this_1.maxDepth) {
                            return "continue";
                        }
                        tasks++;
                        var childrenCached = t.readdirCached();
                        if (t.calledReaddir())
                            this_1.walkCB3(t, childrenCached, processor, next);
                        else {
                            t.readdirCB(function (_, entries) { return _this_1.walkCB3(t, entries, processor, next); }, true);
                        }
                    };
                    var this_1 = this;
                    for (var _5 = 0, _6 = processor.subwalkTargets(); _5 < _6.length; _5++) {
                        var t = _6[_5];
                        _loop_16(t);
                    }
                    next();
                };
                GlobUtil.prototype.walkCB3 = function (target, entries, processor, cb) {
                    processor = processor.filterEntries(target, entries);
                    var tasks = 1;
                    var next = function () {
                        if (--tasks === 0)
                            cb();
                    };
                    for (var _1 = 0, _2 = processor.matches.entries(); _1 < _2.length; _1++) {
                        var _3 = _2[_1], m = _3[0], absolute = _3[1], ifDir = _3[2];
                        if (__classPrivateFieldGet(this, _GlobUtil_instances, "m", _GlobUtil_ignored).call(this, m))
                            continue;
                        tasks++;
                        this.match(m, absolute, ifDir).then(function () { return next(); });
                    }
                    for (var _4 = 0, _5 = processor.subwalks.entries(); _4 < _5.length; _4++) {
                        var _6 = _5[_4], target_1 = _6[0], patterns = _6[1];
                        tasks++;
                        this.walkCB2(target_1, patterns, processor.child(), next);
                    }
                    next();
                };
                GlobUtil.prototype.walkCBSync = function (target, patterns, cb) {
                    var _1;
                    /* c8 ignore start */
                    if ((_1 = this.signal) === null || _1 === void 0 ? void 0 : _1.aborted)
                        cb();
                    /* c8 ignore stop */
                    this.walkCB2Sync(target, patterns, new processor_js_1.Processor(this.opts), cb);
                };
                GlobUtil.prototype.walkCB2Sync = function (target, patterns, processor, cb) {
                    var _this_1 = this;
                    var _1;
                    if (__classPrivateFieldGet(this, _GlobUtil_instances, "m", _GlobUtil_childrenIgnored).call(this, target))
                        return cb();
                    if ((_1 = this.signal) === null || _1 === void 0 ? void 0 : _1.aborted)
                        cb();
                    if (this.paused) {
                        this.onResume(function () { return _this_1.walkCB2Sync(target, patterns, processor, cb); });
                        return;
                    }
                    processor.processPatterns(target, patterns);
                    // done processing.  all of the above is sync, can be abstracted out.
                    // subwalks is a map of paths to the entry filters they need
                    // matches is a map of paths to [absolute, ifDir] tuples.
                    var tasks = 1;
                    var next = function () {
                        if (--tasks === 0)
                            cb();
                    };
                    for (var _2 = 0, _3 = processor.matches.entries(); _2 < _3.length; _2++) {
                        var _4 = _3[_2], m = _4[0], absolute = _4[1], ifDir = _4[2];
                        if (__classPrivateFieldGet(this, _GlobUtil_instances, "m", _GlobUtil_ignored).call(this, m))
                            continue;
                        this.matchSync(m, absolute, ifDir);
                    }
                    for (var _5 = 0, _6 = processor.subwalkTargets(); _5 < _6.length; _5++) {
                        var t = _6[_5];
                        if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
                            continue;
                        }
                        tasks++;
                        var children = t.readdirSync();
                        this.walkCB3Sync(t, children, processor, next);
                    }
                    next();
                };
                GlobUtil.prototype.walkCB3Sync = function (target, entries, processor, cb) {
                    processor = processor.filterEntries(target, entries);
                    var tasks = 1;
                    var next = function () {
                        if (--tasks === 0)
                            cb();
                    };
                    for (var _1 = 0, _2 = processor.matches.entries(); _1 < _2.length; _1++) {
                        var _3 = _2[_1], m = _3[0], absolute = _3[1], ifDir = _3[2];
                        if (__classPrivateFieldGet(this, _GlobUtil_instances, "m", _GlobUtil_ignored).call(this, m))
                            continue;
                        this.matchSync(m, absolute, ifDir);
                    }
                    for (var _4 = 0, _5 = processor.subwalks.entries(); _4 < _5.length; _4++) {
                        var _6 = _5[_4], target_2 = _6[0], patterns = _6[1];
                        tasks++;
                        this.walkCB2Sync(target_2, patterns, processor.child(), next);
                    }
                    next();
                };
                return GlobUtil;
            }());
            _GlobUtil_onResume = new WeakMap(), _GlobUtil_ignore = new WeakMap(), _GlobUtil_sep = new WeakMap(), _GlobUtil_instances = new WeakSet(), _GlobUtil_ignored = function _GlobUtil_ignored(path) {
                var _1, _2;
                return this.seen.has(path) || !!((_2 = (_1 = __classPrivateFieldGet(this, _GlobUtil_ignore, "f")) === null || _1 === void 0 ? void 0 : _1.ignored) === null || _2 === void 0 ? void 0 : _2.call(_1, path));
            }, _GlobUtil_childrenIgnored = function _GlobUtil_childrenIgnored(path) {
                var _1, _2;
                return !!((_2 = (_1 = __classPrivateFieldGet(this, _GlobUtil_ignore, "f")) === null || _1 === void 0 ? void 0 : _1.childrenIgnored) === null || _2 === void 0 ? void 0 : _2.call(_1, path));
            };
            exports.GlobUtil = GlobUtil;
            var GlobWalker = /** @class */ (function (_super) {
                __extends(GlobWalker, _super);
                function GlobWalker(patterns, path, opts) {
                    var _this_1 = _super.call(this, patterns, path, opts) || this;
                    _this_1.matches = new Set();
                    return _this_1;
                }
                GlobWalker.prototype.matchEmit = function (e) {
                    this.matches.add(e);
                };
                GlobWalker.prototype.walk = function () {
                    var _1;
                    return __awaiter(this, void 0, void 0, function () {
                        var _this_1 = this;
                        return __generator(this, function (_2) {
                            switch (_2.label) {
                                case 0:
                                    if ((_1 = this.signal) === null || _1 === void 0 ? void 0 : _1.aborted)
                                        throw this.signal.reason;
                                    if (!this.path.isUnknown()) return [3 /*break*/, 2];
                                    return [4 /*yield*/, this.path.lstat()];
                                case 1:
                                    _2.sent();
                                    _2.label = 2;
                                case 2: return [4 /*yield*/, new Promise(function (res, rej) {
                                        _this_1.walkCB(_this_1.path, _this_1.patterns, function () {
                                            var _1;
                                            if ((_1 = _this_1.signal) === null || _1 === void 0 ? void 0 : _1.aborted) {
                                                rej(_this_1.signal.reason);
                                            }
                                            else {
                                                res(_this_1.matches);
                                            }
                                        });
                                    })];
                                case 3:
                                    _2.sent();
                                    return [2 /*return*/, this.matches];
                            }
                        });
                    });
                };
                GlobWalker.prototype.walkSync = function () {
                    var _this_1 = this;
                    var _1;
                    if ((_1 = this.signal) === null || _1 === void 0 ? void 0 : _1.aborted)
                        throw this.signal.reason;
                    if (this.path.isUnknown()) {
                        this.path.lstatSync();
                    }
                    // nothing for the callback to do, because this never pauses
                    this.walkCBSync(this.path, this.patterns, function () {
                        var _1;
                        if ((_1 = _this_1.signal) === null || _1 === void 0 ? void 0 : _1.aborted)
                            throw _this_1.signal.reason;
                    });
                    return this.matches;
                };
                return GlobWalker;
            }(GlobUtil));
            exports.GlobWalker = GlobWalker;
            var GlobStream = /** @class */ (function (_super) {
                __extends(GlobStream, _super);
                function GlobStream(patterns, path, opts) {
                    var _this_1 = _super.call(this, patterns, path, opts) || this;
                    _this_1.results = new minipass_1.Minipass({
                        signal: _this_1.signal,
                        objectMode: true
                    });
                    _this_1.results.on('drain', function () { return _this_1.resume(); });
                    _this_1.results.on('resume', function () { return _this_1.resume(); });
                    return _this_1;
                }
                GlobStream.prototype.matchEmit = function (e) {
                    this.results.write(e);
                    if (!this.results.flowing)
                        this.pause();
                };
                GlobStream.prototype.stream = function () {
                    var _this_1 = this;
                    var target = this.path;
                    if (target.isUnknown()) {
                        target.lstat().then(function () {
                            _this_1.walkCB(target, _this_1.patterns, function () { return _this_1.results.end(); });
                        });
                    }
                    else {
                        this.walkCB(target, this.patterns, function () { return _this_1.results.end(); });
                    }
                    return this.results;
                };
                GlobStream.prototype.streamSync = function () {
                    var _this_1 = this;
                    if (this.path.isUnknown()) {
                        this.path.lstatSync();
                    }
                    this.walkCBSync(this.path, this.patterns, function () { return _this_1.results.end(); });
                    return this.results;
                };
                return GlobStream;
            }(GlobUtil));
            exports.GlobStream = GlobStream;
            //# sourceMappingURL=walker.js.map
            /***/ 
        }),
        /***/ 937: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var _1;
            var coreNodejs = __nccwpck_require__(2687);
            var core = __nccwpck_require__(2110);
            var path = __nccwpck_require__(9411);
            var fs = __nccwpck_require__(7147);
            var glob = __nccwpck_require__(8211);
            var ignore = __nccwpck_require__(1230);
            var deepmerge = __nccwpck_require__(6323);
            var prompts = __nccwpck_require__(9646);
            __nccwpck_require__(9800);
            var kleur = __nccwpck_require__(5215);
            function _interopDefault(e) { return e && e.__esModule ? e : { "default": e }; }
            var path__default = /*#__PURE__*/ _interopDefault(path);
            var fs__default = /*#__PURE__*/ _interopDefault(fs);
            var ignore__default = /*#__PURE__*/ _interopDefault(ignore);
            var deepmerge__default = /*#__PURE__*/ _interopDefault(deepmerge);
            var prompts__default = /*#__PURE__*/ _interopDefault(prompts);
            var kleur__default = /*#__PURE__*/ _interopDefault(kleur);
            var DEFAULT_EXTENSIONS = ["html"];
            function isDirectory(filename) {
                var st = fs__default["default"].statSync(filename);
                return st.isDirectory();
            }
            function join(stem, filename) {
                if (path__default["default"].isAbsolute(filename)) {
                    return path__default["default"].normalize(filename);
                }
                else {
                    return path__default["default"].normalize(path__default["default"].join(stem, filename));
                }
            }
            function directoryPattern(extensions) {
                switch (extensions.length) {
                    case 0:
                        return "**/*";
                    case 1:
                        return "**/*.".concat(extensions[0]);
                    default:
                        return "**/*.{".concat(extensions.join(","), "}");
                }
            }
            /**
             * Takes a number of file patterns (globs) and returns array of expanded
             * filenames.
             */
            function expandFiles(patterns, options) {
                var _a, _b;
                var cwd = (_a = options.cwd) !== null && _a !== void 0 ? _a : process.cwd();
                var extensions = (_b = options.extensions) !== null && _b !== void 0 ? _b : DEFAULT_EXTENSIONS;
                var files = patterns.reduce(function (result, pattern) {
                    /* process - as standard input */
                    if (pattern === "-") {
                        result.push("/dev/stdin");
                        return result;
                    }
                    var _loop_17 = function (filename) {
                        /* if file is a directory recursively expand files from it */
                        var fullpath = join(cwd, filename);
                        if (isDirectory(fullpath)) {
                            var dir = expandFiles([directoryPattern(extensions)], __assign(__assign({}, options), { cwd: fullpath }));
                            result = result.concat(dir.map(function (cur) { return join(filename, cur); }));
                            return "continue";
                        }
                        result.push(fullpath);
                    };
                    for (var _1 = 0, _2 = glob.globSync(pattern, { cwd: cwd }); _1 < _2.length; _1++) {
                        var filename = _2[_1];
                        _loop_17(filename);
                    }
                    return result.sort(function (a, b) {
                        var pa = a.split("/").length;
                        var pb = b.split("/").length;
                        if (pa !== pb) {
                            return pa - pb;
                        }
                        else {
                            return a > b ? 1 : -1;
                        }
                    });
                }, []);
                /* only return unique matches */
                return Array.from(new Set(files));
            }
            function wrap(formatter, dst) {
                return function (results) {
                    var output = formatter(results);
                    if (dst) {
                        var dir = path__default["default"].dirname(dst);
                        if (!fs__default["default"].existsSync(dir)) {
                            fs__default["default"].mkdirSync(dir, { recursive: true });
                        }
                        fs__default["default"].writeFileSync(dst, output, "utf-8");
                        return "";
                    }
                    else {
                        return output;
                    }
                };
            }
            function loadFormatter(name) {
                var fn = core.getFormatter(name);
                if (fn) {
                    return fn;
                }
                try {
                    return coreNodejs.legacyRequire(name);
                }
                catch (error) {
                    throw new core.UserError("No formatter named \"".concat(name, "\""), core.ensureError(error));
                }
            }
            function getFormatter(formatters) {
                var fn = formatters.split(",").map(function (cur) {
                    var _1 = cur.split("=", 2), name = _1[0], dst = _1[1];
                    var fn = loadFormatter(name);
                    return wrap(fn, dst);
                });
                return function (report) {
                    return fn
                        .map(function (formatter) { return formatter(report.results); })
                        .filter(Boolean)
                        .join("\n");
                };
            }
            var IsIgnored = /** @class */ (function () {
                function IsIgnored() {
                    this.cacheIgnore = new Map();
                }
                /**
                 * Searches ".htmlvalidateignore" files from filesystem and returns `true` if
                 * one of them contains a pattern matching given filename.
                 */
                IsIgnored.prototype.isIgnored = function (filename) {
                    return this.match(filename);
                };
                /**
                 * Clear cache
                 */
                IsIgnored.prototype.clearCache = function () {
                    this.cacheIgnore.clear();
                };
                IsIgnored.prototype.match = function (target) {
                    var current = path__default["default"].dirname(target);
                    // eslint-disable-next-line no-constant-condition -- breaks out when filesystem is traversed
                    while (true) {
                        var relative = path__default["default"].relative(current, target);
                        var filename = path__default["default"].join(current, ".htmlvalidateignore");
                        /* test filename (relative to the ignore file) against the patterns */
                        var ig = this.parseFile(filename);
                        if (ig && ig.ignores(relative)) {
                            return true;
                        }
                        /* get the parent directory */
                        var child = current;
                        current = path__default["default"].dirname(current);
                        /* stop if this is the root directory */
                        if (current === child) {
                            break;
                        }
                    }
                    return false;
                };
                IsIgnored.prototype.parseFile = function (filename) {
                    if (this.cacheIgnore.has(filename)) {
                        return this.cacheIgnore.get(filename);
                    }
                    if (!fs__default["default"].existsSync(filename)) {
                        this.cacheIgnore.set(filename, undefined);
                        return undefined;
                    }
                    var content = fs__default["default"].readFileSync(filename, "utf-8");
                    var ig = ignore__default["default"]().add(content);
                    this.cacheIgnore.set(filename, ig);
                    return ig;
                };
                return IsIgnored;
            }());
            var Frameworks;
            (function (Frameworks) {
                Frameworks["angularjs"] = "AngularJS";
                Frameworks["vuejs"] = "Vue.js";
                Frameworks["markdown"] = "Markdown";
            })(Frameworks || (Frameworks = {}));
            var frameworkConfig = (_1 = {},
                _1[Frameworks.angularjs] = {
                    transform: {
                        "^.*\\.js$": "html-validate-angular/js",
                        "^.*\\.html$": "html-validate-angular/html"
                    }
                },
                _1[Frameworks.vuejs] = {
                    plugins: ["html-validate-vue"],
                    "extends": ["html-validate-vue:recommended"],
                    transform: {
                        "^.*\\.vue$": "html-validate-vue"
                    }
                },
                _1[Frameworks.markdown] = {
                    transform: {
                        "^.*\\.md$": "html-validate-markdown"
                    }
                },
                _1);
            function addFrameworks(src, frameworks) {
                var config = src;
                for (var _1 = 0, frameworks_1 = frameworks; _1 < frameworks_1.length; _1++) {
                    var framework = frameworks_1[_1];
                    config = deepmerge__default["default"](config, frameworkConfig[framework]);
                }
                return config;
            }
            function writeConfig(dst, config) {
                return new Promise(function (resolve, reject) {
                    fs__default["default"].writeFile(dst, JSON.stringify(config, null, 2), function (err) {
                        if (err)
                            reject(err);
                        resolve();
                    });
                });
            }
            function init$1(cwd) {
                return __awaiter(this, void 0, void 0, function () {
                    var filename, exists, initialConfig, result, questions, answers, config;
                    return __generator(this, function (_1) {
                        switch (_1.label) {
                            case 0:
                                filename = "".concat(cwd, "/.htmlvalidate.json");
                                exists = fs__default["default"].existsSync(filename);
                                initialConfig = {
                                    elements: ["html5"],
                                    "extends": ["html-validate:recommended"]
                                };
                                if (!exists) return [3 /*break*/, 2];
                                return [4 /*yield*/, prompts__default["default"]({
                                        name: "overwrite",
                                        type: "confirm",
                                        message: "A .htmlvalidate.json file already exists, do you want to overwrite it?"
                                    })];
                            case 1:
                                result = _1.sent();
                                if (!result.overwrite) {
                                    return [2 /*return*/, Promise.reject()];
                                }
                                _1.label = 2;
                            case 2:
                                questions = [
                                    {
                                        name: "frameworks",
                                        type: "multiselect",
                                        choices: [
                                            { title: Frameworks.angularjs, value: Frameworks.angularjs },
                                            { title: Frameworks.vuejs, value: Frameworks.vuejs },
                                            { title: Frameworks.markdown, value: Frameworks.markdown },
                                        ],
                                        message: "Support additional frameworks?"
                                    },
                                ];
                                return [4 /*yield*/, prompts__default["default"](questions)];
                            case 3:
                                answers = _1.sent();
                                config = initialConfig;
                                config = addFrameworks(config, answers.frameworks);
                                return [4 /*yield*/, writeConfig(filename, config)];
                            case 4:
                                _1.sent();
                                return [2 /*return*/, {
                                        filename: filename
                                    }];
                        }
                    });
                });
            }
            var defaultConfig = {
                "extends": ["html-validate:recommended"]
            };
            function getBaseConfig(filename) {
                if (filename) {
                    var resolver = coreNodejs.nodejsResolver();
                    var configData = resolver.resolveConfig(path__default["default"].resolve(filename), { cache: false });
                    if (!configData) {
                        throw new core.UserError("Failed to read configuration from \"".concat(filename, "\""));
                    }
                    return configData;
                }
                else {
                    return defaultConfig;
                }
            }
            /**
             * @public
             */
            var CLI = /** @class */ (function () {
                /**
                 * Create new CLI helper.
                 *
                 * Can be used to create tooling with similar properties to bundled CLI
                 * script.
                 */
                function CLI(options) {
                    this.options = options !== null && options !== void 0 ? options : {};
                    this.config = this.resolveConfig();
                    this.loader = new coreNodejs.FileSystemConfigLoader(this.config);
                    this.ignored = new IsIgnored();
                }
                /**
                 * Returns list of files matching patterns and are not ignored. Filenames will
                 * have absolute paths.
                 *
                 * @public
                 */
                CLI.prototype.expandFiles = function (patterns, options) {
                    var _this_1 = this;
                    if (options === void 0) { options = {}; }
                    return expandFiles(patterns, options).filter(function (filename) { return !_this_1.isIgnored(filename); });
                };
                CLI.prototype.getFormatter = function (formatters) {
                    return getFormatter(formatters);
                };
                /**
                 * Initialize project with a new configuration.
                 *
                 * A new `.htmlvalidate.json` file will be placed in the path provided by
                 * `cwd`.
                 */
                CLI.prototype.init = function (cwd) {
                    return init$1(cwd);
                };
                /**
                 * Searches ".htmlvalidateignore" files from filesystem and returns `true` if
                 * one of them contains a pattern matching given filename.
                 */
                CLI.prototype.isIgnored = function (filename) {
                    return this.ignored.isIgnored(filename);
                };
                /**
                 * Clear cache.
                 *
                 * Previously fetched [[HtmlValidate]] instances must either be fetched again
                 * or call [[HtmlValidate.flushConfigCache]].
                 */
                /* istanbul ignore next: each method is tested separately */
                CLI.prototype.clearCache = function () {
                    this.loader.flushCache();
                    this.ignored.clearCache();
                };
                /**
                 * Get HtmlValidate instance with configuration based on options passed to the
                 * constructor.
                 *
                 * @internal
                 */
                CLI.prototype.getLoader = function () {
                    return this.loader;
                };
                /**
                 * Get HtmlValidate instance with configuration based on options passed to the
                 * constructor.
                 *
                 * @public
                 */
                CLI.prototype.getValidator = function () {
                    var loader = this.getLoader();
                    return new core.HtmlValidate(loader);
                };
                /**
                 * @internal
                 */
                CLI.prototype.getConfig = function () {
                    return this.config;
                };
                CLI.prototype.resolveConfig = function () {
                    var options = this.options;
                    var config = getBaseConfig(options.configFile);
                    var rules = options.rules;
                    if (rules) {
                        if (Array.isArray(rules)) {
                            rules = rules.join(",");
                        }
                        var raw = rules
                            .split(",")
                            .map(function (it) { return it.trim().replace(/([^:]*):/, '"$1":'); })
                            .join(",");
                        try {
                            var rules_2 = JSON.parse("{".concat(raw, "}"));
                            config["extends"] = [];
                            config.rules = rules_2;
                        }
                        catch (err) /* istanbul ignore next */ {
                            var message = err instanceof Error ? err.message : String(err);
                            throw new core.UserError("Error while parsing --rule option \"{".concat(raw, "}\": ").concat(message, ".\n"));
                        }
                    }
                    return config;
                };
                return CLI;
            }());
            /**
             * @internal
             */
            exports.Mode = void 0;
            (function (Mode) {
                Mode[Mode["LINT"] = 0] = "LINT";
                Mode[Mode["INIT"] = 1] = "INIT";
                Mode[Mode["DUMP_EVENTS"] = 2] = "DUMP_EVENTS";
                Mode[Mode["DUMP_TOKENS"] = 3] = "DUMP_TOKENS";
                Mode[Mode["DUMP_TREE"] = 4] = "DUMP_TREE";
                Mode[Mode["DUMP_SOURCE"] = 5] = "DUMP_SOURCE";
                Mode[Mode["PRINT_CONFIG"] = 6] = "PRINT_CONFIG";
            })(exports.Mode || (exports.Mode = {}));
            function modeToFlag(mode) {
                switch (mode) {
                    case exports.Mode.LINT:
                        return null;
                    case exports.Mode.INIT:
                        return "--init";
                    case exports.Mode.DUMP_EVENTS:
                        return "--dump-events";
                    case exports.Mode.DUMP_TOKENS:
                        return "--dump-tokens";
                    case exports.Mode.DUMP_TREE:
                        return "--dump-tree";
                    case exports.Mode.DUMP_SOURCE:
                        return "--dump-source";
                    case exports.Mode.PRINT_CONFIG:
                        return "--print-config";
                }
            }
            function renameStdin(report, filename) {
                var stdin = report.results.find(function (cur) { return cur.filePath === "/dev/stdin"; });
                if (stdin) {
                    stdin.filePath = filename;
                }
            }
            function lint(htmlvalidate, output, files, options) {
                var reports = files.map(function (filename) {
                    try {
                        return htmlvalidate.validateFileSync(filename);
                    }
                    catch (err) {
                        var message = kleur__default["default"].red("Validator crashed when parsing \"".concat(filename, "\""));
                        output.write("".concat(message, "\n"));
                        throw err;
                    }
                });
                var merged = core.Reporter.merge(reports);
                /* rename stdin if an explicit filename was passed */
                if (options.stdinFilename) {
                    renameStdin(merged, options.stdinFilename);
                }
                output.write(options.formatter(merged));
                if (options.maxWarnings >= 0 && merged.warningCount > options.maxWarnings) {
                    output.write("\nhtml-validate found too many warnings (maximum: ".concat(options.maxWarnings, ").\n"));
                    return Promise.resolve(false);
                }
                return Promise.resolve(merged.valid);
            }
            function init(cli, output, options) {
                return __awaiter(this, void 0, void 0, function () {
                    var result;
                    return __generator(this, function (_1) {
                        switch (_1.label) {
                            case 0: return [4 /*yield*/, cli.init(options.cwd)];
                            case 1:
                                result = _1.sent();
                                output.write("Configuration written to \"".concat(result.filename, "\"\n"));
                                return [2 /*return*/, true];
                        }
                    });
                });
            }
            function printConfig(htmlvalidate, output, files) {
                return __awaiter(this, void 0, void 0, function () {
                    var _1, files_2, filename, config, json;
                    return __generator(this, function (_2) {
                        switch (_2.label) {
                            case 0:
                                if (files.length > 1) {
                                    output.write("`--print-config` expected a single filename but got multiple:\n\n");
                                    for (_1 = 0, files_2 = files; _1 < files_2.length; _1++) {
                                        filename = files_2[_1];
                                        output.write("  - ".concat(filename, "\n"));
                                    }
                                    output.write("\n");
                                    return [2 /*return*/, false];
                                }
                                return [4 /*yield*/, htmlvalidate.getConfigFor(files[0])];
                            case 1:
                                config = _2.sent();
                                json = JSON.stringify(config.getConfigData(), null, 2);
                                output.write("".concat(json, "\n"));
                                return [2 /*return*/, true];
                        }
                    });
                });
            }
            var jsonIgnored = [
                "annotation",
                "blockedRules",
                "cache",
                "closed",
                "depth",
                "disabledRules",
                "nodeType",
                "unique",
                "voidElement",
            ];
            var jsonFiltered = [
                "childNodes",
                "children",
                "data",
                "meta",
                "metaElement",
                "originalData",
                "parent",
            ];
            function isLocation(key, value) {
                return Boolean(value && (key === "location" || key.endsWith("Location")));
            }
            function isIgnored(key) {
                return Boolean(key.startsWith("_") || jsonIgnored.includes(key));
            }
            function isFiltered(key, value) {
                return Boolean(value && jsonFiltered.includes(key));
            }
            function eventReplacer(key, value) {
                if (isLocation(key, value)) {
                    return "".concat(value.filename, ":").concat(value.line, ":").concat(value.column);
                }
                if (isIgnored(key)) {
                    return undefined;
                }
                if (isFiltered(key, value)) {
                    return "[truncated]";
                }
                return value;
            }
            function eventFormatter(entry) {
                var strdata = JSON.stringify(entry.data, eventReplacer, 2);
                return "".concat(entry.event, ": ").concat(strdata);
            }
            function dump(htmlvalidate, output, files, mode) {
                var lines = [];
                switch (mode) {
                    case exports.Mode.DUMP_EVENTS:
                        lines = files.map(function (filename) { return htmlvalidate.dumpEvents(filename).map(eventFormatter); });
                        break;
                    case exports.Mode.DUMP_TOKENS:
                        lines = files.map(function (filename) { return htmlvalidate.dumpTokens(filename).map(function (entry) {
                            var data = JSON.stringify(entry.data);
                            return "TOKEN: ".concat(entry.token, "\n  Data: ").concat(data, "\n  Location: ").concat(entry.location);
                        }); });
                        break;
                    case exports.Mode.DUMP_TREE:
                        lines = files.map(function (filename) { return htmlvalidate.dumpTree(filename); });
                        break;
                    case exports.Mode.DUMP_SOURCE:
                        lines = files.map(function (filename) { return htmlvalidate.dumpSource(filename); });
                        break;
                    default:
                        throw new Error("Unknown mode \"".concat(mode, "\""));
                }
                var flat = lines.reduce(function (s, c) { return s.concat(c); }, []);
                output.write(flat.join("\n"));
                output.write("\n");
                return Promise.resolve(true);
            }
            exports.CLI = CLI;
            exports.dump = dump;
            exports.init = init;
            exports.lint = lint;
            exports.modeToFlag = modeToFlag;
            exports.printConfig = printConfig;
            //# sourceMappingURL=cli.js.map
            /***/ 
        }),
        /***/ 2687: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var fs = __nccwpck_require__(7561);
            var path = __nccwpck_require__(9411);
            var core = __nccwpck_require__(2110);
            var kleur = __nccwpck_require__(5215);
            function _interopDefault(e) { return e && e.__esModule ? e : { "default": e }; }
            var fs__default = /*#__PURE__*/ _interopDefault(fs);
            var path__default = /*#__PURE__*/ _interopDefault(path);
            var kleur__default = /*#__PURE__*/ _interopDefault(kleur);
            /**
             * Similar to `require(..)` but removes the cached copy first.
             */
            function requireUncached(require, moduleId) {
                var filename = require.resolve(moduleId);
                /* remove references from the parent module to prevent memory leak */
                var m = require.cache[filename];
                if (m === null || m === void 0 ? void 0 : m.parent) {
                    var parent_1 = m.parent;
                    for (var i = parent_1.children.length - 1; i >= 0; i--) {
                        if (parent_1.children[i].id === filename) {
                            parent_1.children.splice(i, 1);
                        }
                    }
                }
                /* remove old module from cache */
                /* eslint-disable-next-line @typescript-eslint/no-dynamic-delete -- needed to perform its function */
                delete require.cache[filename];
                /* eslint-disable-next-line import/no-dynamic-require, security/detect-non-literal-require -- as expected but should be moved to upcoming resolver class */
                return require(filename);
            }
            var legacyRequire = require;
            var cachedRootDir = null;
            /**
             * @internal
             */
            function determineRootDirImpl(intial, fs) {
                /* try to locate package.json */
                var current = intial;
                // eslint-disable-next-line no-constant-condition -- break outs when filesystem is traversed
                while (true) {
                    var search = path__default["default"].join(current, "package.json");
                    if (fs.existsSync(search)) {
                        return current;
                    }
                    /* get the parent directory */
                    var child = current;
                    current = path__default["default"].dirname(current);
                    /* stop if this is the root directory */
                    if (current === child) {
                        break;
                    }
                }
                /* default to working directory if no package.json is found */
                return intial;
            }
            /**
             * Try to determine root directory based on the location of the closest
             * `package.json`. Fallbacks on `process.cwd()` if no package.json was found.
             *
             * @internal
             */
            /* istanbul ignore next: cached version of determineRootDirImpl, no need to test */
            function determineRootDir() {
                if (cachedRootDir === null) {
                    cachedRootDir = determineRootDirImpl(process.cwd(), fs__default["default"]);
                }
                return cachedRootDir;
            }
            /**
             * @internal
             */
            function expandRelativePath(value, _1) {
                var cwd = _1.cwd;
                if (typeof value === "string" && value.startsWith(".")) {
                    return path__default["default"].normalize(path__default["default"].join(cwd, value));
                }
                else {
                    return value;
                }
            }
            function isRequireError(error) {
                return Boolean(error && typeof error === "object" && "code" in error);
            }
            function isTransformer(value) {
                return typeof value === "function";
            }
            /**
             * Create a new resolver for NodeJS packages using `require(..)`.
             *
             * If the module name contains `<rootDir>` (e.g. `<rootDir/foo`) it will be
             * expanded relative to the root directory either explicitly set by the
             * `rootDir` parameter or determined automatically by the closest `package.json`
             * file (starting at the current working directory).
             *
             * @public
             * @since 8.0.0
             */
            function nodejsResolver(options) {
                if (options === void 0) { options = {}; }
                var _a;
                var rootDir = (_a = options.rootDir) !== null && _a !== void 0 ? _a : determineRootDir();
                function internalRequire(id, _1) {
                    var cache = _1.cache;
                    var moduleName = id.replace("<rootDir>", rootDir);
                    try {
                        /* istanbul ignore else: the tests only runs the cached versions to get
                         * unmodified access to `require`, the implementation of `requireUncached`
                         * is assumed to be tested elsewhere */
                        if (cache) {
                            return legacyRequire(moduleName);
                        }
                        else {
                            return requireUncached(legacyRequire, moduleName);
                        }
                    }
                    catch (err) {
                        if (isRequireError(err) && err.code === "MODULE_NOT_FOUND") {
                            return null;
                        }
                        throw err;
                    }
                }
                return {
                    name: "nodejs-resolver",
                    resolveElements: function (id, options) {
                        return internalRequire(id, options);
                    },
                    resolveConfig: function (id, options) {
                        var configData = internalRequire(id, options);
                        if (!configData) {
                            return null;
                        }
                        /* expand any relative paths */
                        var cwd = path__default["default"].dirname(id);
                        var expand = function (value) { return expandRelativePath(value, { cwd: cwd }); };
                        if (configData.elements) {
                            configData.elements = configData.elements.map(expand);
                        }
                        if (configData["extends"]) {
                            configData["extends"] = configData["extends"].map(expand);
                        }
                        if (configData.plugins) {
                            configData.plugins = configData.plugins.map(expand);
                        }
                        return configData;
                    },
                    resolvePlugin: function (id, options) {
                        return internalRequire(id, options);
                    },
                    resolveTransformer: function (id, options) {
                        var mod = internalRequire(id, options);
                        if (!mod) {
                            return null;
                        }
                        if (isTransformer(mod)) {
                            return mod;
                        }
                        /* this is not a proper transformer, is it a plugin exposing a transformer? */
                        if (mod.transformer) {
                            throw new core.ConfigError("Module \"".concat(id, "\" is not a valid transformer. This looks like a plugin, did you forget to load the plugin first?"));
                        }
                        throw new core.ConfigError("Module \"".concat(id, "\" is not a valid transformer."));
                    }
                };
            }
            /**
             * @internal
             */
            function findConfigurationFiles(fs, directory) {
                return ["json", "cjs", "js"]
                    .map(function (extension) { return path__default["default"].join(directory, ".htmlvalidate.".concat(extension)); })
                    .filter(function (filePath) { return fs.existsSync(filePath); });
            }
            var defaultResolvers = [nodejsResolver()];
            function hasResolver(value) {
                return Array.isArray(value[0]);
            }
            /**
             * Loads configuration by traversing filesystem.
             *
             * Configuration is read from three sources and in the following order:
             *
             * 1. Global configuration passed to constructor.
             * 2. Configuration files found when traversing the directory structure.
             * 3. Override passed to this function.
             *
             * The following configuration filenames are searched:
             *
             * - `.htmlvalidate.json`
             * - `.htmlvalidate.js`
             * - `.htmlvalidate.cjs`
             *
             * Global configuration is used when no configuration file is found. The
             * result is always merged with override if present.
             *
             * The `root` property set to `true` affects the configuration as following:
             *
             * 1. If set in override the override is returned as-is.
             * 2. If set in the global config the override is merged into global and
             * returned. No configuration files are searched.
             * 3. Setting `root` in configuration file only stops directory traversal.
             *
             * @public
             */
            var FileSystemConfigLoader = /** @class */ (function (_super) {
                __extends(FileSystemConfigLoader, _super);
                function FileSystemConfigLoader() {
                    var args = [];
                    for (var _1 = 0; _1 < arguments.length; _1++) {
                        args[_1] = arguments[_1];
                    }
                    var _this_1 = this;
                    var _a, _b;
                    if (hasResolver(args)) {
                        /* istanbul ignore next */
                        var resolvers = args[0], config = args[1], _2 = args[2], options = _2 === void 0 ? {} : _2;
                        _this_1 = _super.call(this, resolvers, config) || this;
                        _this_1.fs = /* istanbul ignore next */ (_a = options.fs) !== null && _a !== void 0 ? _a : fs__default["default"];
                    }
                    else {
                        /* istanbul ignore next */
                        var config = args[0], _3 = args[1], options = _3 === void 0 ? {} : _3;
                        _this_1 = _super.call(this, defaultResolvers, config) || this;
                        _this_1.fs = /* istanbul ignore next */ (_b = options.fs) !== null && _b !== void 0 ? _b : fs__default["default"];
                    }
                    _this_1.cache = new Map();
                    return _this_1;
                }
                /**
                 * Get configuration for given filename.
                 *
                 * @param filename - Filename to get configuration for.
                 * @param configOverride - Configuration to merge final result with.
                 */
                FileSystemConfigLoader.prototype.getConfigFor = function (filename, configOverride) {
                    /* special case when the overridden configuration is marked as root, should
                     * not try to load any more configuration files */
                    var override = this.loadFromObject(configOverride !== null && configOverride !== void 0 ? configOverride : {});
                    if (override.isRootFound()) {
                        override.init();
                        return override.resolve();
                    }
                    /* special case when the global configuration is marked as root, should not
                     * try to load and more configuration files */
                    if (this.globalConfig.isRootFound()) {
                        var merged_1 = this.globalConfig.merge(this.resolvers, override);
                        merged_1.init();
                        return merged_1.resolve();
                    }
                    var config = this.fromFilename(filename);
                    var merged = config
                        ? config.merge(this.resolvers, override)
                        : this.globalConfig.merge(this.resolvers, override);
                    merged.init();
                    return merged.resolve();
                };
                /**
                 * Flush configuration cache.
                 *
                 * @param filename - If given only the cache for that file is flushed.
                 */
                FileSystemConfigLoader.prototype.flushCache = function (filename) {
                    if (filename) {
                        this.cache["delete"](filename);
                    }
                    else {
                        this.cache.clear();
                    }
                };
                /**
                 * Load raw configuration from directory traversal.
                 *
                 * This configuration is not merged with global configuration and may return
                 * `null` if no configuration files are found.
                 */
                FileSystemConfigLoader.prototype.fromFilename = function (filename) {
                    if (filename === "inline") {
                        return null;
                    }
                    var cache = this.cache.get(filename);
                    if (cache) {
                        return cache;
                    }
                    var found = false;
                    var current = path__default["default"].resolve(path__default["default"].dirname(filename));
                    var config = this.empty();
                    // eslint-disable-next-line no-constant-condition -- it will break out when filesystem is traversed
                    while (true) {
                        /* search configuration files in current directory */
                        for (var _1 = 0, _2 = findConfigurationFiles(this.fs, current); _1 < _2.length; _1++) {
                            var configFile = _2[_1];
                            var local = this.loadFromFile(configFile);
                            found = true;
                            config = local.merge(this.resolvers, config);
                        }
                        /* stop if a configuration with "root" is set to true */
                        if (config.isRootFound()) {
                            break;
                        }
                        /* get the parent directory */
                        var child = current;
                        current = path__default["default"].dirname(current);
                        /* stop if this is the root directory */
                        if (current === child) {
                            break;
                        }
                    }
                    /* no config was found by loader, return null and let caller decide what to do */
                    if (!found) {
                        this.cache.set(filename, null);
                        return null;
                    }
                    this.cache.set(filename, config);
                    return config;
                };
                /**
                 * @internal For testing only
                 */
                FileSystemConfigLoader.prototype._getInternalCache = function () {
                    return this.cache;
                };
                FileSystemConfigLoader.prototype.defaultConfig = function () {
                    return core.Config.defaultConfig();
                };
                return FileSystemConfigLoader;
            }(core.ConfigLoader));
            var defaults = {
                silent: false,
                version: core.version,
                logger: function (text) {
                    /* eslint-disable-next-line no-console -- expected to log */
                    console.error(kleur__default["default"].red(text));
                }
            };
            /**
             * Tests if plugin is compatible with html-validate library. Unless the `silent`
             * option is used a warning is displayed on the console.
             *
             * @public
             * @since v5.0.0
             * @param name - Name of plugin
             * @param declared - What library versions the plugin support (e.g. declared peerDependencies)
             * @returns - `true` if version is compatible
             */
            function compatibilityCheck(name, declared, options) {
                return core.compatibilityCheckImpl(name, declared, __assign(__assign({}, defaults), options));
            }
            exports.FileSystemConfigLoader = FileSystemConfigLoader;
            exports.compatibilityCheck = compatibilityCheck;
            exports.legacyRequire = legacyRequire;
            exports.nodejsResolver = nodejsResolver;
            //# sourceMappingURL=core-nodejs.js.map
            /***/ 
        }),
        /***/ 2110: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var _1;
            var Ajv = __nccwpck_require__(2426);
            var deepmerge = __nccwpck_require__(6323);
            var elements = __nccwpck_require__(6420);
            var fs = __nccwpck_require__(7147);
            var betterAjvErrors = __nccwpck_require__(7963);
            var utils_naturalJoin = __nccwpck_require__(8902);
            var codeFrame = __nccwpck_require__(1322);
            var kleur = __nccwpck_require__(5215);
            var stylish$2 = __nccwpck_require__(6962);
            var semver = __nccwpck_require__(1383);
            function _interopDefault(e) { return e && e.__esModule ? e : { "default": e }; }
            var Ajv__default = /*#__PURE__*/ _interopDefault(Ajv);
            var deepmerge__default = /*#__PURE__*/ _interopDefault(deepmerge);
            var fs__default = /*#__PURE__*/ _interopDefault(fs);
            var betterAjvErrors__default = /*#__PURE__*/ _interopDefault(betterAjvErrors);
            var kleur__default = /*#__PURE__*/ _interopDefault(kleur);
            var semver__default = /*#__PURE__*/ _interopDefault(semver);
            var $schema$2 = "http://json-schema.org/draft-06/schema#";
            var $id$2 = "http://json-schema.org/draft-06/schema#";
            var title = "Core schema meta-schema";
            var definitions$1 = {
                schemaArray: {
                    type: "array",
                    minItems: 1,
                    items: {
                        $ref: "#"
                    }
                },
                nonNegativeInteger: {
                    type: "integer",
                    minimum: 0
                },
                nonNegativeIntegerDefault0: {
                    allOf: [
                        {
                            $ref: "#/definitions/nonNegativeInteger"
                        },
                        {
                            "default": 0
                        }
                    ]
                },
                simpleTypes: {
                    "enum": [
                        "array",
                        "boolean",
                        "integer",
                        "null",
                        "number",
                        "object",
                        "string"
                    ]
                },
                stringArray: {
                    type: "array",
                    items: {
                        type: "string"
                    },
                    uniqueItems: true,
                    "default": []
                }
            };
            var type$2 = [
                "object",
                "boolean"
            ];
            var properties$2 = {
                $id: {
                    type: "string",
                    format: "uri-reference"
                },
                $schema: {
                    type: "string",
                    format: "uri"
                },
                $ref: {
                    type: "string",
                    format: "uri-reference"
                },
                title: {
                    type: "string"
                },
                description: {
                    type: "string"
                },
                "default": {},
                examples: {
                    type: "array",
                    items: {}
                },
                multipleOf: {
                    type: "number",
                    exclusiveMinimum: 0
                },
                maximum: {
                    type: "number"
                },
                exclusiveMaximum: {
                    type: "number"
                },
                minimum: {
                    type: "number"
                },
                exclusiveMinimum: {
                    type: "number"
                },
                maxLength: {
                    $ref: "#/definitions/nonNegativeInteger"
                },
                minLength: {
                    $ref: "#/definitions/nonNegativeIntegerDefault0"
                },
                pattern: {
                    type: "string",
                    format: "regex"
                },
                additionalItems: {
                    $ref: "#"
                },
                items: {
                    anyOf: [
                        {
                            $ref: "#"
                        },
                        {
                            $ref: "#/definitions/schemaArray"
                        }
                    ],
                    "default": {}
                },
                maxItems: {
                    $ref: "#/definitions/nonNegativeInteger"
                },
                minItems: {
                    $ref: "#/definitions/nonNegativeIntegerDefault0"
                },
                uniqueItems: {
                    type: "boolean",
                    "default": false
                },
                contains: {
                    $ref: "#"
                },
                maxProperties: {
                    $ref: "#/definitions/nonNegativeInteger"
                },
                minProperties: {
                    $ref: "#/definitions/nonNegativeIntegerDefault0"
                },
                required: {
                    $ref: "#/definitions/stringArray"
                },
                additionalProperties: {
                    $ref: "#"
                },
                definitions: {
                    type: "object",
                    additionalProperties: {
                        $ref: "#"
                    },
                    "default": {}
                },
                properties: {
                    type: "object",
                    additionalProperties: {
                        $ref: "#"
                    },
                    "default": {}
                },
                patternProperties: {
                    type: "object",
                    additionalProperties: {
                        $ref: "#"
                    },
                    "default": {}
                },
                dependencies: {
                    type: "object",
                    additionalProperties: {
                        anyOf: [
                            {
                                $ref: "#"
                            },
                            {
                                $ref: "#/definitions/stringArray"
                            }
                        ]
                    }
                },
                propertyNames: {
                    $ref: "#"
                },
                "const": {},
                "enum": {
                    type: "array",
                    minItems: 1,
                    uniqueItems: true
                },
                type: {
                    anyOf: [
                        {
                            $ref: "#/definitions/simpleTypes"
                        },
                        {
                            type: "array",
                            items: {
                                $ref: "#/definitions/simpleTypes"
                            },
                            minItems: 1,
                            uniqueItems: true
                        }
                    ]
                },
                format: {
                    type: "string"
                },
                allOf: {
                    $ref: "#/definitions/schemaArray"
                },
                anyOf: {
                    $ref: "#/definitions/schemaArray"
                },
                oneOf: {
                    $ref: "#/definitions/schemaArray"
                },
                not: {
                    $ref: "#"
                }
            };
            var ajvSchemaDraft = {
                $schema: $schema$2,
                $id: $id$2,
                title: title,
                definitions: definitions$1,
                type: type$2,
                properties: properties$2,
                "default": {}
            };
            function stringify(value) {
                if (typeof value === "string") {
                    return String(value);
                }
                else {
                    return JSON.stringify(value);
                }
            }
            /**
             * Represents an `Error` created from arbitrary values.
             *
             * @public
             */
            var WrappedError = /** @class */ (function (_super) {
                __extends(WrappedError, _super);
                function WrappedError(message) {
                    return _super.call(this, stringify(message)) || this;
                }
                return WrappedError;
            }(Error));
            /**
             * Ensures the value is an Error.
             *
             * If the passed value is not an `Error` instance a [[WrappedError]] is
             * constructed with the stringified value.
             *
             * @internal
             */
            function ensureError(value) {
                if (value instanceof Error) {
                    return value;
                }
                else {
                    return new WrappedError(value);
                }
            }
            /**
             * @public
             */
            var NestedError = /** @class */ (function (_super) {
                __extends(NestedError, _super);
                function NestedError(message, nested) {
                    var _this_1 = _super.call(this, message) || this;
                    Error.captureStackTrace(_this_1, NestedError);
                    _this_1.name = NestedError.name;
                    if (nested === null || nested === void 0 ? void 0 : nested.stack) {
                        _this_1.stack += "\nCaused by: ".concat(nested.stack);
                    }
                    return _this_1;
                }
                return NestedError;
            }(Error));
            /**
             * @public
             */
            var UserError = /** @class */ (function (_super) {
                __extends(UserError, _super);
                function UserError(message, nested) {
                    var _this_1 = _super.call(this, message, nested) || this;
                    Error.captureStackTrace(_this_1, UserError);
                    _this_1.name = UserError.name;
                    return _this_1;
                }
                /**
                 * @public
                 */
                /* istanbul ignore next: default implementation */
                UserError.prototype.prettyFormat = function () {
                    return undefined;
                };
                return UserError;
            }(NestedError));
            /**
             * @internal
             */
            var InheritError = /** @class */ (function (_super) {
                __extends(InheritError, _super);
                function InheritError(_1) {
                    var tagName = _1.tagName, inherit = _1.inherit;
                    var _this_1 = this;
                    var message = "Element <".concat(tagName, "> cannot inherit from <").concat(inherit, ">: no such element");
                    _this_1 = _super.call(this, message) || this;
                    Error.captureStackTrace(_this_1, InheritError);
                    _this_1.name = InheritError.name;
                    _this_1.tagName = tagName;
                    _this_1.inherit = inherit;
                    _this_1.filename = null;
                    return _this_1;
                }
                InheritError.prototype.prettyFormat = function () {
                    var _1 = this, message = _1.message, tagName = _1.tagName, inherit = _1.inherit;
                    var source = this.filename
                        ? ["", "This error occurred when loading element metadata from:", "\"".concat(this.filename, "\""), ""]
                        : [""];
                    return __spreadArray(__spreadArray([
                        message
                    ], source, true), [
                        "This usually occurs when the elements are defined in the wrong order, try one of the following:",
                        "",
                        "  - Ensure the spelling of \"".concat(inherit, "\" is correct."),
                        "  - Ensure the file containing \"".concat(inherit, "\" is loaded before the file containing \"").concat(tagName, "\"."),
                        "  - Move the definition of \"".concat(inherit, "\" above the definition for \"").concat(tagName, "\"."),
                    ], false).join("\n");
                };
                return InheritError;
            }(UserError));
            function getSummary(schema, obj, errors) {
                var output = betterAjvErrors__default["default"](schema, obj, errors, {
                    format: "js"
                });
                // istanbul ignore next: for safety only
                return output.length > 0 ? output[0].error : "unknown validation error";
            }
            /**
             * @public
             */
            var SchemaValidationError = /** @class */ (function (_super) {
                __extends(SchemaValidationError, _super);
                function SchemaValidationError(filename, message, obj, schema, errors) {
                    var _this_1 = this;
                    var summary = getSummary(schema, obj, errors);
                    _this_1 = _super.call(this, "".concat(message, ": ").concat(summary)) || this;
                    _this_1.filename = filename;
                    _this_1.obj = obj;
                    _this_1.schema = schema;
                    _this_1.errors = errors;
                    return _this_1;
                }
                SchemaValidationError.prototype.prettyError = function () {
                    var json = this.getRawJSON();
                    return betterAjvErrors__default["default"](this.schema, this.obj, this.errors, {
                        format: "cli",
                        indent: 2,
                        json: json
                    });
                };
                SchemaValidationError.prototype.getRawJSON = function () {
                    if (this.filename && fs__default["default"].existsSync(this.filename)) {
                        return fs__default["default"].readFileSync(this.filename, "utf-8");
                    }
                    else {
                        return null;
                    }
                };
                return SchemaValidationError;
            }(UserError));
            /**
             * Computes hash for given string.
             *
             * @internal
             */
            function cyrb53(str) {
                var a = 2654435761;
                var b = 1597334677;
                var c = 2246822507;
                var d = 3266489909;
                var e = 4294967296;
                var f = 2097151;
                var seed = 0;
                var h1 = 0xdeadbeef ^ seed;
                var h2 = 0x41c6ce57 ^ seed;
                for (var i = 0, ch = void 0; i < str.length; i++) {
                    ch = str.charCodeAt(i);
                    h1 = Math.imul(h1 ^ ch, a);
                    h2 = Math.imul(h2 ^ ch, b);
                }
                h1 = Math.imul(h1 ^ (h1 >>> 16), c) ^ Math.imul(h2 ^ (h2 >>> 13), d);
                h2 = Math.imul(h2 ^ (h2 >>> 16), c) ^ Math.imul(h1 ^ (h1 >>> 13), d);
                return e * (f & h2) + (h1 >>> 0);
            }
            var computeHash = cyrb53;
            var $schema$1 = "http://json-schema.org/draft-06/schema#";
            var $id$1 = "https://html-validate.org/schemas/elements.json";
            var type$1 = "object";
            var properties$1 = {
                $schema: {
                    type: "string"
                }
            };
            var patternProperties = {
                "^[^$].*$": {
                    type: "object",
                    properties: {
                        inherit: {
                            title: "Inherit from another element",
                            description: "Most properties from the parent element will be copied onto this one",
                            type: "string"
                        },
                        embedded: {
                            title: "Mark this element as belonging in the embedded content category",
                            $ref: "#/definitions/contentCategory"
                        },
                        flow: {
                            title: "Mark this element as belonging in the flow content category",
                            $ref: "#/definitions/contentCategory"
                        },
                        heading: {
                            title: "Mark this element as belonging in the heading content category",
                            $ref: "#/definitions/contentCategory"
                        },
                        interactive: {
                            title: "Mark this element as belonging in the interactive content category",
                            $ref: "#/definitions/contentCategory"
                        },
                        metadata: {
                            title: "Mark this element as belonging in the metadata content category",
                            $ref: "#/definitions/contentCategory"
                        },
                        phrasing: {
                            title: "Mark this element as belonging in the phrasing content category",
                            $ref: "#/definitions/contentCategory"
                        },
                        sectioning: {
                            title: "Mark this element as belonging in the sectioning content category",
                            $ref: "#/definitions/contentCategory"
                        },
                        deprecated: {
                            title: "Mark element as deprecated",
                            description: "Deprecated elements should not be used. If a message is provided it will be included in the error",
                            anyOf: [
                                {
                                    type: "boolean"
                                },
                                {
                                    type: "string"
                                },
                                {
                                    $ref: "#/definitions/deprecatedElement"
                                }
                            ]
                        },
                        foreign: {
                            title: "Mark element as foreign",
                            description: "Foreign elements are elements which have a start and end tag but is otherwize not parsed",
                            type: "boolean"
                        },
                        "void": {
                            title: "Mark element as void",
                            description: "Void elements are elements which cannot have content and thus must not use an end tag",
                            type: "boolean"
                        },
                        transparent: {
                            title: "Mark element as transparent",
                            description: "Transparent elements follows the same content model as its parent, i.e. the content must be allowed in the parent.",
                            anyOf: [
                                {
                                    type: "boolean"
                                },
                                {
                                    type: "array",
                                    items: {
                                        type: "string"
                                    }
                                }
                            ]
                        },
                        implicitClosed: {
                            title: "List of elements which implicitly closes this element",
                            description: "Some elements are automatically closed when another start tag occurs",
                            type: "array",
                            items: {
                                type: "string"
                            }
                        },
                        implicitRole: {
                            title: "Implicit ARIA role for this element",
                            description: "Some elements have implicit ARIA roles.",
                            "function": true
                        },
                        scriptSupporting: {
                            title: "Mark element as script-supporting",
                            description: "Script-supporting elements are elements which can be inserted where othersise not permitted to assist in templating",
                            type: "boolean"
                        },
                        form: {
                            title: "Mark element as a submittable form element",
                            type: "boolean"
                        },
                        formAssociated: {
                            title: "Mark element as a form-associated element",
                            $ref: "#/definitions/FormAssociated"
                        },
                        labelable: {
                            title: "Mark this element as labelable",
                            description: "This element may contain an associated label element.",
                            anyOf: [
                                {
                                    type: "boolean"
                                },
                                {
                                    $ref: "#/definitions/expression"
                                }
                            ]
                        },
                        deprecatedAttributes: {
                            title: "List of deprecated attributes",
                            type: "array",
                            items: {
                                type: "string"
                            }
                        },
                        requiredAttributes: {
                            title: "List of required attributes",
                            type: "array",
                            items: {
                                type: "string"
                            }
                        },
                        attributes: {
                            title: "List of known attributes and allowed values",
                            $ref: "#/definitions/PermittedAttribute"
                        },
                        permittedContent: {
                            title: "List of elements or categories allowed as content in this element",
                            $ref: "#/definitions/Permitted"
                        },
                        permittedDescendants: {
                            title: "List of elements or categories allowed as descendants in this element",
                            $ref: "#/definitions/Permitted"
                        },
                        permittedOrder: {
                            title: "Required order of child elements",
                            $ref: "#/definitions/PermittedOrder"
                        },
                        permittedParent: {
                            title: "List of elements or categories allowed as parent to this element",
                            $ref: "#/definitions/Permitted"
                        },
                        requiredAncestors: {
                            title: "List of required ancestor elements",
                            $ref: "#/definitions/RequiredAncestors"
                        },
                        requiredContent: {
                            title: "List of required content elements",
                            $ref: "#/definitions/RequiredContent"
                        },
                        textContent: {
                            title: "Allow, disallow or require textual content",
                            description: "This property controls whenever an element allows, disallows or requires text. Text from any descendant counts, not only direct children",
                            "default": "default",
                            type: "string",
                            "enum": [
                                "none",
                                "default",
                                "required",
                                "accessible"
                            ]
                        }
                    },
                    additionalProperties: false
                }
            };
            var definitions = {
                contentCategory: {
                    anyOf: [
                        {
                            type: "boolean"
                        },
                        {
                            $ref: "#/definitions/expression"
                        }
                    ]
                },
                expression: {
                    type: "array",
                    minItems: 2,
                    maxItems: 2,
                    items: [
                        {
                            type: "string",
                            "enum": [
                                "isDescendant",
                                "hasAttribute",
                                "matchAttribute"
                            ]
                        },
                        {
                            anyOf: [
                                {
                                    type: "string"
                                },
                                {
                                    $ref: "#/definitions/operation"
                                }
                            ]
                        }
                    ]
                },
                operation: {
                    type: "array",
                    minItems: 3,
                    maxItems: 3,
                    items: [
                        {
                            type: "string"
                        },
                        {
                            type: "string",
                            "enum": [
                                "!=",
                                "="
                            ]
                        },
                        {
                            type: "string"
                        }
                    ]
                },
                deprecatedElement: {
                    type: "object",
                    additionalProperties: false,
                    properties: {
                        message: {
                            type: "string",
                            title: "A short text message shown next to the regular error message."
                        },
                        documentation: {
                            type: "string",
                            title: "An extended markdown formatted message shown with the contextual rule documentation."
                        },
                        source: {
                            type: "string",
                            title: "Element source, e.g. what standard or library deprecated this element.",
                            "default": "html5"
                        }
                    }
                },
                FormAssociated: {
                    type: "object",
                    additionalProperties: false,
                    properties: {
                        listed: {
                            type: "boolean",
                            title: "Listed elements have a name attribute and is listed in the form and fieldset elements property."
                        }
                    }
                },
                Permitted: {
                    type: "array",
                    items: {
                        anyOf: [
                            {
                                type: "string"
                            },
                            {
                                type: "array",
                                items: {
                                    anyOf: [
                                        {
                                            type: "string"
                                        },
                                        {
                                            $ref: "#/definitions/PermittedGroup"
                                        }
                                    ]
                                }
                            },
                            {
                                $ref: "#/definitions/PermittedGroup"
                            }
                        ]
                    }
                },
                PermittedAttribute: {
                    type: "object",
                    patternProperties: {
                        "^.*$": {
                            anyOf: [
                                {
                                    type: "object",
                                    additionalProperties: false,
                                    properties: {
                                        allowed: {
                                            "function": true,
                                            title: "Set to a function to evaluate if this attribute is allowed in this context"
                                        },
                                        boolean: {
                                            type: "boolean",
                                            title: "Set to true if this is a boolean attribute"
                                        },
                                        deprecated: {
                                            title: "Set to true or string if this attribute is deprecated",
                                            oneOf: [
                                                {
                                                    type: "boolean"
                                                },
                                                {
                                                    type: "string"
                                                }
                                            ]
                                        },
                                        list: {
                                            type: "boolean",
                                            title: "Set to true if this attribute is a list of space-separated tokens, each which must be valid by itself"
                                        },
                                        "enum": {
                                            type: "array",
                                            title: "Exhaustive list of values (string or regex) this attribute accepts",
                                            uniqueItems: true,
                                            items: {
                                                anyOf: [
                                                    {
                                                        type: "string"
                                                    },
                                                    {
                                                        regexp: true
                                                    }
                                                ]
                                            }
                                        },
                                        omit: {
                                            type: "boolean",
                                            title: "Set to true if this attribute can optionally omit its value"
                                        },
                                        required: {
                                            type: "boolean",
                                            title: "Set to true if this attribute is required"
                                        }
                                    }
                                },
                                {
                                    type: "array",
                                    uniqueItems: true,
                                    items: {
                                        type: "string"
                                    }
                                },
                                {
                                    type: "null"
                                }
                            ]
                        }
                    }
                },
                PermittedGroup: {
                    type: "object",
                    additionalProperties: false,
                    properties: {
                        exclude: {
                            anyOf: [
                                {
                                    items: {
                                        type: "string"
                                    },
                                    type: "array"
                                },
                                {
                                    type: "string"
                                }
                            ]
                        }
                    }
                },
                PermittedOrder: {
                    type: "array",
                    items: {
                        type: "string"
                    }
                },
                RequiredAncestors: {
                    type: "array",
                    items: {
                        type: "string"
                    }
                },
                RequiredContent: {
                    type: "array",
                    items: {
                        type: "string"
                    }
                }
            };
            var schema = {
                $schema: $schema$1,
                $id: $id$1,
                type: type$1,
                properties: properties$1,
                patternProperties: patternProperties,
                definitions: definitions
            };
            /**
             * AJV keyword "regexp" to validate the type to be a regular expression.
             * Injects errors with the "type" keyword to give the same output.
             */
            /* istanbul ignore next: manual testing */
            var ajvRegexpValidate = function (data, dataCxt) {
                var valid = data instanceof RegExp;
                if (!valid) {
                    ajvRegexpValidate.errors = [
                        {
                            instancePath: dataCxt === null || dataCxt === void 0 ? void 0 : dataCxt.instancePath,
                            schemaPath: undefined,
                            keyword: "type",
                            message: "should be a regular expression",
                            params: {
                                keyword: "type"
                            }
                        },
                    ];
                }
                return valid;
            };
            var ajvRegexpKeyword = {
                keyword: "regexp",
                schema: false,
                errors: true,
                validate: ajvRegexpValidate
            };
            /**
             * AJV keyword "function" to validate the type to be a function. Injects errors
             * with the "type" keyword to give the same output.
             */
            var ajvFunctionValidate = function (data, dataCxt) {
                var valid = typeof data === "function";
                if (!valid) {
                    ajvFunctionValidate.errors = [
                        {
                            instancePath: /* istanbul ignore next */ dataCxt === null || dataCxt === void 0 ? void 0 : dataCxt.instancePath,
                            schemaPath: undefined,
                            keyword: "type",
                            message: "should be a function",
                            params: {
                                keyword: "type"
                            }
                        },
                    ];
                }
                return valid;
            };
            var ajvFunctionKeyword = {
                keyword: "function",
                schema: false,
                errors: true,
                validate: ajvFunctionValidate
            };
            /**
             * @public
             */
            exports.TextContent = void 0;
            (function (TextContent) {
                /* forbid node to have text content, inter-element whitespace is ignored */
                TextContent["NONE"] = "none";
                /* node can have text but not required too */
                TextContent["DEFAULT"] = "default";
                /* node requires text-nodes to be present (direct or by descendant) */
                TextContent["REQUIRED"] = "required";
                /* node requires accessible text (hidden text is ignored, tries to get text from accessibility tree) */
                TextContent["ACCESSIBLE"] = "accessible";
            })(exports.TextContent || (exports.TextContent = {}));
            /**
             * Properties listed here can be copied (loaded) onto another element using
             * [[HtmlElement.loadMeta]].
             *
             * @public
             */
            var MetaCopyableProperty = [
                "metadata",
                "flow",
                "sectioning",
                "heading",
                "phrasing",
                "embedded",
                "interactive",
                "transparent",
                "form",
                "formAssociated",
                "labelable",
                "attributes",
                "permittedContent",
                "permittedDescendants",
                "permittedOrder",
                "permittedParent",
                "requiredAncestors",
                "requiredContent",
            ];
            /**
             * @internal
             */
            function setMetaProperty(dst, key, value) {
                dst[key] = value;
            }
            function isSet(value) {
                return typeof value !== "undefined";
            }
            function flag(value) {
                return value ? true : undefined;
            }
            function stripUndefined(src) {
                var entries = Object.entries(src).filter(function (_1) {
                    var value = _1[1];
                    return isSet(value);
                });
                return Object.fromEntries(entries);
            }
            function migrateSingleAttribute(src, key) {
                var _a, _b;
                var result = {};
                result.deprecated = flag((_a = src.deprecatedAttributes) === null || _a === void 0 ? void 0 : _a.includes(key));
                result.required = flag((_b = src.requiredAttributes) === null || _b === void 0 ? void 0 : _b.includes(key));
                result.omit = undefined;
                var attr = src.attributes ? src.attributes[key] : undefined;
                if (typeof attr === "undefined") {
                    return stripUndefined(result);
                }
                /* when the attribute is set to null we use a special property "delete" to
                 * flag it, if it is still set during merge (inheritance, overwriting, etc) the attribute will be removed */
                if (attr === null) {
                    result["delete"] = true;
                    return stripUndefined(result);
                }
                if (Array.isArray(attr)) {
                    if (attr.length === 0) {
                        result.boolean = true;
                    }
                    else {
                        result["enum"] = attr.filter(function (it) { return it !== ""; });
                        if (attr.includes("")) {
                            result.omit = true;
                        }
                    }
                    return stripUndefined(result);
                }
                else {
                    return stripUndefined(__assign(__assign({}, result), attr));
                }
            }
            function migrateAttributes(src) {
                var _a, _b, _c;
                var keys = __spreadArray(__spreadArray(__spreadArray([], Object.keys((_a = src.attributes) !== null && _a !== void 0 ? _a : {}), true), ((_b = src.requiredAttributes) !== null && _b !== void 0 ? _b : []), true), ((_c = src.deprecatedAttributes) !== null && _c !== void 0 ? _c : []), true).sort();
                var entries = keys.map(function (key) {
                    return [key, migrateSingleAttribute(src, key)];
                });
                return Object.fromEntries(entries);
            }
            function migrateElement(src) {
                var _a;
                var result = __assign(__assign(__assign({}, src), {
                    formAssociated: undefined
                }), { attributes: migrateAttributes(src), textContent: src.textContent, implicitRole: (_a = src.implicitRole) !== null && _a !== void 0 ? _a : (function () { return null; }) });
                /* removed properties */
                delete result.deprecatedAttributes;
                delete result.requiredAttributes;
                /* strip out undefined */
                if (!result.textContent) {
                    delete result.textContent;
                }
                if (src.formAssociated) {
                    result.formAssociated = {
                        listed: Boolean(src.formAssociated.listed)
                    };
                }
                else {
                    delete result.formAssociated;
                }
                return result;
            }
            /**
             * Returns true if given element is a descendant of given tagname.
             *
             * @internal
             */
            function isDescendant(node, tagName) {
                var cur = node.parent;
                while (cur && !cur.isRootElement()) {
                    if (cur.is(tagName)) {
                        return true;
                    }
                    cur = cur.parent;
                }
                return false;
            }
            /**
             * Returns true if given element has given attribute (no matter the value, null,
             * dynamic, etc).
             */
            function hasAttribute(node, attr) {
                return node.hasAttribute(attr);
            }
            /**
             * Matches attribute against value.
             */
            function matchAttribute(node, key, op, value) {
                var _a;
                var nodeValue = ((_a = node.getAttributeValue(key)) !== null && _a !== void 0 ? _a : "").toLowerCase();
                switch (op) {
                    case "!=":
                        return nodeValue !== value;
                    case "=":
                        return nodeValue === value;
                }
            }
            var dynamicKeys = [
                "metadata",
                "flow",
                "sectioning",
                "heading",
                "phrasing",
                "embedded",
                "interactive",
                "labelable",
            ];
            var functionTable = {
                isDescendant: isDescendantFacade,
                hasAttribute: hasAttributeFacade,
                matchAttribute: matchAttributeFacade
            };
            var schemaCache = new Map();
            function clone(src) {
                return JSON.parse(JSON.stringify(src));
            }
            function overwriteMerge$1(a, b) {
                return b;
            }
            /**
             * @public
             */
            var MetaTable = /** @class */ (function () {
                /**
                 * @internal
                 */
                function MetaTable() {
                    this.elements = {};
                    this.schema = clone(schema);
                }
                /**
                 * @internal
                 */
                MetaTable.prototype.init = function () {
                    this.resolveGlobal();
                };
                /**
                 * Extend validation schema.
                 *
                 * @public
                 */
                MetaTable.prototype.extendValidationSchema = function (patch) {
                    if (patch.properties) {
                        this.schema = deepmerge__default["default"](this.schema, {
                            patternProperties: {
                                "^[^$].*$": {
                                    properties: patch.properties
                                }
                            }
                        });
                    }
                    if (patch.definitions) {
                        this.schema = deepmerge__default["default"](this.schema, {
                            definitions: patch.definitions
                        });
                    }
                };
                /**
                 * Load metadata table from object.
                 *
                 * @public
                 * @param obj - Object with metadata to load
                 * @param filename - Optional filename used when presenting validation error
                 */
                MetaTable.prototype.loadFromObject = function (obj, filename) {
                    if (filename === void 0) { filename = null; }
                    var _a;
                    try {
                        var validate = this.getSchemaValidator();
                        if (!validate(obj)) {
                            throw new SchemaValidationError(filename, "Element metadata is not valid", obj, this.schema, 
                            /* istanbul ignore next: AJV sets .errors when validate returns false */
                            (_a = validate.errors) !== null && _a !== void 0 ? _a : []);
                        }
                        for (var _1 = 0, _2 = Object.entries(obj); _1 < _2.length; _1++) {
                            var _3 = _2[_1], key = _3[0], value = _3[1];
                            if (key === "$schema")
                                continue;
                            this.addEntry(key, migrateElement(value));
                        }
                    }
                    catch (err) {
                        if (err instanceof InheritError) {
                            err.filename = filename;
                            throw err;
                        }
                        if (err instanceof SchemaValidationError) {
                            throw err;
                        }
                        if (!filename) {
                            throw err;
                        }
                        throw new UserError("Failed to load element metadata from \"".concat(filename, "\""), ensureError(err));
                    }
                };
                /**
                 * Get [[MetaElement]] for the given tag. If no specific metadata is present
                 * the global metadata is returned or null if no global is present.
                 *
                 * @public
                 * @returns A shallow copy of metadata.
                 */
                MetaTable.prototype.getMetaFor = function (tagName) {
                    /* try to locate by tagname */
                    tagName = tagName.toLowerCase();
                    if (this.elements[tagName]) {
                        return __assign({}, this.elements[tagName]);
                    }
                    /* try to locate global element */
                    if (this.elements["*"]) {
                        return __assign({}, this.elements["*"]);
                    }
                    return null;
                };
                /**
                 * Find all tags which has enabled given property.
                 *
                 * @public
                 */
                MetaTable.prototype.getTagsWithProperty = function (propName) {
                    return Object.entries(this.elements)
                        .filter(function (_1) {
                        var entry = _1[1];
                        return entry[propName];
                    })
                        .map(function (_1) {
                        var tagName = _1[0];
                        return tagName;
                    });
                };
                /**
                 * Find tag matching tagName or inheriting from it.
                 *
                 * @public
                 */
                MetaTable.prototype.getTagsDerivedFrom = function (tagName) {
                    return Object.entries(this.elements)
                        .filter(function (_1) {
                        var key = _1[0], entry = _1[1];
                        return key === tagName || entry.inherit === tagName;
                    })
                        .map(function (_1) {
                        var tagName = _1[0];
                        return tagName;
                    });
                };
                MetaTable.prototype.addEntry = function (tagName, entry) {
                    var parent = this.elements[tagName] || {};
                    /* handle inheritance */
                    if (entry.inherit) {
                        var name_11 = entry.inherit;
                        parent = this.elements[name_11];
                        if (!parent) {
                            throw new InheritError({
                                tagName: tagName,
                                inherit: name_11
                            });
                        }
                    }
                    /* merge all sources together */
                    var expanded = this.mergeElement(parent, __assign(__assign({}, entry), { tagName: tagName }));
                    expandRegex(expanded);
                    this.elements[tagName] = expanded;
                };
                /**
                 * Construct a new AJV schema validator.
                 */
                MetaTable.prototype.getSchemaValidator = function () {
                    var hash = computeHash(JSON.stringify(this.schema));
                    var cached = schemaCache.get(hash);
                    if (cached) {
                        return cached;
                    }
                    else {
                        var ajv_1 = new Ajv__default["default"]({ strict: true, strictTuples: true, strictTypes: true });
                        ajv_1.addMetaSchema(ajvSchemaDraft);
                        ajv_1.addKeyword(ajvFunctionKeyword);
                        ajv_1.addKeyword(ajvRegexpKeyword);
                        ajv_1.addKeyword({ keyword: "copyable" });
                        var validate = ajv_1.compile(this.schema);
                        schemaCache.set(hash, validate);
                        return validate;
                    }
                };
                /**
                 * @public
                 */
                MetaTable.prototype.getJSONSchema = function () {
                    return this.schema;
                };
                /**
                 * Finds the global element definition and merges each known element with the
                 * global, e.g. to assign global attributes.
                 */
                MetaTable.prototype.resolveGlobal = function () {
                    /* skip if there is no global elements */
                    if (!this.elements["*"])
                        return;
                    /* fetch and remove the global element, it should not be resolvable by
                     * itself */
                    var global = this.elements["*"];
                    delete this.elements["*"];
                    /* hack: unset default properties which global should not override */
                    delete global.tagName;
                    delete global["void"];
                    /* merge elements */
                    for (var _1 = 0, _2 = Object.entries(this.elements); _1 < _2.length; _1++) {
                        var _3 = _2[_1], tagName = _3[0], entry = _3[1];
                        this.elements[tagName] = this.mergeElement(global, entry);
                    }
                };
                MetaTable.prototype.mergeElement = function (a, b) {
                    var merged = deepmerge__default["default"](a, b, { arrayMerge: overwriteMerge$1 });
                    /* special handling when removing attributes by setting them to null
                     * resulting in the deletion flag being set */
                    var filteredAttrs = Object.entries(merged.attributes).filter(function (_1) {
                        var attr = _1[1];
                        var val = !attr["delete"];
                        delete attr["delete"];
                        return val;
                    });
                    merged.attributes = Object.fromEntries(filteredAttrs);
                    return merged;
                };
                /**
                 * @internal
                 */
                MetaTable.prototype.resolve = function (node) {
                    if (node.meta) {
                        expandProperties(node, node.meta);
                    }
                };
                return MetaTable;
            }());
            function expandProperties(node, entry) {
                for (var _1 = 0, dynamicKeys_1 = dynamicKeys; _1 < dynamicKeys_1.length; _1++) {
                    var key = dynamicKeys_1[_1];
                    var property = entry[key];
                    if (property && typeof property !== "boolean") {
                        setMetaProperty(entry, key, evaluateProperty(node, property));
                    }
                }
            }
            /**
             * Given a string it returns either the string as-is or if the string is wrapped
             * in /../ it creates and returns a regex instead.
             */
            function expandRegexValue(value) {
                if (value instanceof RegExp) {
                    return value;
                }
                var match = value.match(/^\/\^?([^/$]*)\$?\/([i]*)$/);
                if (match) {
                    var expr = match[1], flags = match[2];
                    // eslint-disable-next-line security/detect-non-literal-regexp -- expected to be regexp
                    return new RegExp("^".concat(expr, "$"), flags);
                }
                else {
                    return value;
                }
            }
            /**
             * Expand all regular expressions in strings ("/../"). This mutates the object.
             */
            function expandRegex(entry) {
                for (var _1 = 0, _2 = Object.entries(entry.attributes); _1 < _2.length; _1++) {
                    var _3 = _2[_1], name_12 = _3[0], values = _3[1];
                    if (values["enum"]) {
                        entry.attributes[name_12]["enum"] = values["enum"].map(expandRegexValue);
                    }
                }
            }
            function evaluateProperty(node, expr) {
                var _1 = parseExpression(expr), func = _1[0], options = _1[1];
                return func(node, options);
            }
            function parseExpression(expr) {
                if (typeof expr === "string") {
                    return parseExpression([expr, {}]);
                }
                else {
                    /* eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- old style expressions should be replaced with typesafe functions */
                    var funcName = expr[0], options = expr[1];
                    var func = functionTable[funcName];
                    if (!func) {
                        throw new Error("Failed to find function \"".concat(funcName, "\" when evaluating property expression"));
                    }
                    return [func, options];
                }
            }
            function isDescendantFacade(node, tagName) {
                if (typeof tagName !== "string") {
                    throw new Error("Property expression \"isDescendant\" must take string argument when evaluating metadata for <".concat(node.tagName, ">"));
                }
                return isDescendant(node, tagName);
            }
            function hasAttributeFacade(node, attr) {
                if (typeof attr !== "string") {
                    throw new Error("Property expression \"hasAttribute\" must take string argument when evaluating metadata for <".concat(node.tagName, ">"));
                }
                return hasAttribute(node, attr);
            }
            function matchAttributeFacade(node, match) {
                if (!Array.isArray(match) || match.length !== 3) {
                    throw new Error("Property expression \"matchAttribute\" must take [key, op, value] array as argument when evaluating metadata for <".concat(node.tagName, ">"));
                }
                var _1 = match.map(function (x) { return x.toLowerCase(); }), key = _1[0], op = _1[1], value = _1[2];
                switch (op) {
                    case "!=":
                    case "=":
                        return matchAttribute(node, key, op, value);
                    default:
                        throw new Error("Property expression \"matchAttribute\" has invalid operator \"".concat(op, "\" when evaluating metadata for <").concat(node.tagName, ">"));
                }
            }
            /**
             * @public
             */
            var DynamicValue = /** @class */ (function () {
                function DynamicValue(expr) {
                    this.expr = expr;
                }
                DynamicValue.prototype.toString = function () {
                    return this.expr;
                };
                return DynamicValue;
            }());
            /**
             * DOM Attribute.
             *
             * Represents a HTML attribute. Can contain either a fixed static value or a
             * placeholder for dynamic values (e.g. interpolated).
             *
             * @public
             */
            var Attribute = /** @class */ (function () {
                /**
                 * @param key - Attribute name.
                 * @param value - Attribute value. Set to `null` for boolean attributes.
                 * @param keyLocation - Source location of attribute name.
                 * @param valueLocation - Source location of attribute value.
                 * @param originalAttribute - If this attribute was dynamically added via a
                 * transformation (e.g. vuejs `:id` generating the `id` attribute) this
                 * parameter should be set to the attribute name of the source attribute (`:id`).
                 */
                function Attribute(key, value, keyLocation, valueLocation, originalAttribute) {
                    this.key = key;
                    this.value = value;
                    this.keyLocation = keyLocation;
                    this.valueLocation = valueLocation;
                    this.originalAttribute = originalAttribute;
                    /* force undefined to null */
                    if (typeof this.value === "undefined") {
                        this.value = null;
                    }
                }
                Object.defineProperty(Attribute.prototype, "isStatic", {
                    /**
                     * Flag set to true if the attribute value is static.
                     */
                    get: function () {
                        return !this.isDynamic;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(Attribute.prototype, "isDynamic", {
                    /**
                     * Flag set to true if the attribute value is dynamic.
                     */
                    get: function () {
                        return this.value instanceof DynamicValue;
                    },
                    enumerable: false,
                    configurable: true
                });
                /**
                 * Test attribute value.
                 *
                 * @param pattern - Pattern to match value against. Can be a RegExp, literal
                 * string or an array of strings (returns true if any value matches the
                 * array).
                 * @param dynamicMatches - If true `DynamicValue` will always match, if false
                 * it never matches.
                 * @returns `true` if attribute value matches pattern.
                 */
                Attribute.prototype.valueMatches = function (pattern, dynamicMatches) {
                    if (dynamicMatches === void 0) { dynamicMatches = true; }
                    if (this.value === null) {
                        return false;
                    }
                    /* dynamic values matches everything */
                    if (this.value instanceof DynamicValue) {
                        return dynamicMatches;
                    }
                    /* test against an array of keywords */
                    if (Array.isArray(pattern)) {
                        return pattern.includes(this.value);
                    }
                    /* test value against pattern */
                    if (pattern instanceof RegExp) {
                        return this.value.match(pattern) !== null;
                    }
                    else {
                        return this.value === pattern;
                    }
                };
                return Attribute;
            }());
            function getCSSDeclarations(value) {
                return value
                    .trim()
                    .split(";")
                    .filter(Boolean)
                    .map(function (it) {
                    var _1 = it.split(":", 2), property = _1[0], value = _1[1];
                    return [property.trim(), value ? value.trim() : ""];
                });
            }
            /**
             * @internal
             */
            function parseCssDeclaration(value) {
                if (!value || value instanceof DynamicValue) {
                    return {};
                }
                var pairs = getCSSDeclarations(value);
                return Object.fromEntries(pairs);
            }
            function sliceSize(size, begin, end) {
                if (typeof size !== "number") {
                    return size;
                }
                if (typeof end !== "number") {
                    return size - begin;
                }
                if (end < 0) {
                    end = size + end;
                }
                return Math.min(size, end - begin);
            }
            function sliceLocation(location, begin, end, wrap) {
                if (!location)
                    return null;
                var size = sliceSize(location.size, begin, end);
                var sliced = {
                    filename: location.filename,
                    offset: location.offset + begin,
                    line: location.line,
                    column: location.column + begin,
                    size: size
                };
                /* if text content is provided try to find all newlines and modify line/column accordingly */
                if (wrap) {
                    var index = -1;
                    var col = sliced.column;
                    do {
                        index = wrap.indexOf("\n", index + 1);
                        if (index >= 0 && index < begin) {
                            sliced.column = col - (index + 1);
                            sliced.line++;
                        }
                        else {
                            break;
                        }
                    } while (true); // eslint-disable-line no-constant-condition -- it will break out
                }
                return sliced;
            }
            var State;
            (function (State) {
                State[State["INITIAL"] = 1] = "INITIAL";
                State[State["DOCTYPE"] = 2] = "DOCTYPE";
                State[State["TEXT"] = 3] = "TEXT";
                State[State["TAG"] = 4] = "TAG";
                State[State["ATTR"] = 5] = "ATTR";
                State[State["CDATA"] = 6] = "CDATA";
                State[State["SCRIPT"] = 7] = "SCRIPT";
                State[State["STYLE"] = 8] = "STYLE";
            })(State || (State = {}));
            var ContentModel;
            (function (ContentModel) {
                ContentModel[ContentModel["TEXT"] = 1] = "TEXT";
                ContentModel[ContentModel["SCRIPT"] = 2] = "SCRIPT";
                ContentModel[ContentModel["STYLE"] = 3] = "STYLE";
            })(ContentModel || (ContentModel = {}));
            var Context = /** @class */ (function () {
                function Context(source) {
                    var _a, _b, _c, _d;
                    this.state = State.INITIAL;
                    this.string = source.data;
                    this.filename = (_a = source.filename) !== null && _a !== void 0 ? _a : "";
                    this.offset = (_b = source.offset) !== null && _b !== void 0 ? _b : 0;
                    this.line = (_c = source.line) !== null && _c !== void 0 ? _c : 1;
                    this.column = (_d = source.column) !== null && _d !== void 0 ? _d : 1;
                    this.contentModel = ContentModel.TEXT;
                }
                Context.prototype.getTruncatedLine = function (n) {
                    if (n === void 0) { n = 13; }
                    return JSON.stringify(this.string.length > n ? "".concat(this.string.slice(0, 10), "...") : this.string);
                };
                Context.prototype.consume = function (n, state) {
                    /* if "n" is an regex match the first value is the full matched
                     * string so consume that many characters. */
                    if (typeof n !== "number") {
                        n = n[0].length; /* regex match */
                    }
                    /* poor mans line counter :( */
                    var consumed = this.string.slice(0, n);
                    var offset;
                    while ((offset = consumed.indexOf("\n")) >= 0) {
                        this.line++;
                        this.column = 1;
                        consumed = consumed.substr(offset + 1);
                    }
                    this.column += consumed.length;
                    this.offset += n;
                    /* remove N chars */
                    this.string = this.string.substr(n);
                    /* change state */
                    this.state = state;
                };
                Context.prototype.getLocation = function (size) {
                    return {
                        filename: this.filename,
                        offset: this.offset,
                        line: this.line,
                        column: this.column,
                        size: size
                    };
                };
                return Context;
            }());
            /**
             * @public
             */
            exports.NodeType = void 0;
            (function (NodeType) {
                NodeType[NodeType["ELEMENT_NODE"] = 1] = "ELEMENT_NODE";
                NodeType[NodeType["TEXT_NODE"] = 3] = "TEXT_NODE";
                NodeType[NodeType["DOCUMENT_NODE"] = 9] = "DOCUMENT_NODE";
            })(exports.NodeType || (exports.NodeType = {}));
            var DOCUMENT_NODE_NAME = "#document";
            var TEXT_CONTENT = Symbol("textContent");
            var counter = 0;
            /**
             * @public
             */
            var DOMNode = /** @class */ (function () {
                /**
                 * Create a new DOMNode.
                 *
                 * @param nodeType - What node type to create.
                 * @param nodeName - What node name to use. For `HtmlElement` this corresponds
                 * to the tagName but other node types have specific predefined values.
                 * @param location - Source code location of this node.
                 */
                function DOMNode(nodeType, nodeName, location) {
                    this.nodeType = nodeType;
                    this.nodeName = nodeName !== null && nodeName !== void 0 ? nodeName : DOCUMENT_NODE_NAME;
                    this.location = location;
                    this.disabledRules = new Set();
                    this.blockedRules = new Map();
                    this.childNodes = [];
                    this.unique = counter++;
                    this.cache = null;
                }
                /**
                 * Enable cache for this node.
                 *
                 * Should not be called before the node and all children are fully constructed.
                 *
                 * @internal
                 */
                DOMNode.prototype.cacheEnable = function () {
                    this.cache = new Map();
                };
                DOMNode.prototype.cacheGet = function (key) {
                    if (this.cache) {
                        return this.cache.get(key);
                    }
                    else {
                        return undefined;
                    }
                };
                DOMNode.prototype.cacheSet = function (key, value) {
                    if (this.cache) {
                        this.cache.set(key, value);
                    }
                    return value;
                };
                DOMNode.prototype.cacheRemove = function (key) {
                    if (this.cache) {
                        return this.cache["delete"](key);
                    }
                    else {
                        return false;
                    }
                };
                DOMNode.prototype.cacheExists = function (key) {
                    return Boolean(this.cache && this.cache.has(key));
                };
                Object.defineProperty(DOMNode.prototype, "textContent", {
                    /**
                     * Get the text (recursive) from all child nodes.
                     */
                    get: function () {
                        var cached = this.cacheGet(TEXT_CONTENT);
                        if (cached) {
                            return cached;
                        }
                        var text = this.childNodes.map(function (node) { return node.textContent; }).join("");
                        this.cacheSet(TEXT_CONTENT, text);
                        return text;
                    },
                    enumerable: false,
                    configurable: true
                });
                DOMNode.prototype.append = function (node) {
                    this.childNodes.push(node);
                };
                DOMNode.prototype.isRootElement = function () {
                    return this.nodeType === exports.NodeType.DOCUMENT_NODE;
                };
                /**
                 * Tests if two nodes are the same (references the same object).
                 *
                 * @since v4.11.0
                 */
                DOMNode.prototype.isSameNode = function (otherNode) {
                    return this.unique === otherNode.unique;
                };
                Object.defineProperty(DOMNode.prototype, "firstChild", {
                    /**
                     * Returns a DOMNode representing the first direct child node or `null` if the
                     * node has no children.
                     */
                    get: function () {
                        return this.childNodes[0] || null;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(DOMNode.prototype, "lastChild", {
                    /**
                     * Returns a DOMNode representing the last direct child node or `null` if the
                     * node has no children.
                     */
                    get: function () {
                        return this.childNodes[this.childNodes.length - 1] || null;
                    },
                    enumerable: false,
                    configurable: true
                });
                /**
                 * Block a rule for this node.
                 *
                 * @internal
                 */
                DOMNode.prototype.blockRule = function (ruleId, blocker) {
                    var current = this.blockedRules.get(ruleId);
                    if (current) {
                        current.push(blocker);
                    }
                    else {
                        this.blockedRules.set(ruleId, [blocker]);
                    }
                };
                /**
                 * Blocks multiple rules.
                 *
                 * @internal
                 */
                DOMNode.prototype.blockRules = function (rules, blocker) {
                    for (var _1 = 0, rules_3 = rules; _1 < rules_3.length; _1++) {
                        var rule = rules_3[_1];
                        this.blockRule(rule, blocker);
                    }
                };
                /**
                 * Disable a rule for this node.
                 *
                 * @internal
                 */
                DOMNode.prototype.disableRule = function (ruleId) {
                    this.disabledRules.add(ruleId);
                };
                /**
                 * Disables multiple rules.
                 *
                 * @internal
                 */
                DOMNode.prototype.disableRules = function (rules) {
                    for (var _1 = 0, rules_4 = rules; _1 < rules_4.length; _1++) {
                        var rule = rules_4[_1];
                        this.disableRule(rule);
                    }
                };
                /**
                 * Enable a previously disabled rule for this node.
                 */
                DOMNode.prototype.enableRule = function (ruleId) {
                    this.disabledRules["delete"](ruleId);
                };
                /**
                 * Enables multiple rules.
                 */
                DOMNode.prototype.enableRules = function (rules) {
                    for (var _1 = 0, rules_5 = rules; _1 < rules_5.length; _1++) {
                        var rule = rules_5[_1];
                        this.enableRule(rule);
                    }
                };
                /**
                 * Test if a rule is enabled for this node.
                 *
                 * @internal
                 */
                DOMNode.prototype.ruleEnabled = function (ruleId) {
                    return !this.disabledRules.has(ruleId);
                };
                /**
                 * Test if a rule is blocked for this node.
                 *
                 * @internal
                 */
                DOMNode.prototype.ruleBlockers = function (ruleId) {
                    var _a;
                    return (_a = this.blockedRules.get(ruleId)) !== null && _a !== void 0 ? _a : [];
                };
                DOMNode.prototype.generateSelector = function () {
                    return null;
                };
                return DOMNode;
            }());
            function parse(text, baseLocation) {
                var tokens = [];
                var locations = baseLocation ? [] : null;
                for (var begin = 0; begin < text.length;) {
                    var end = text.indexOf(" ", begin);
                    /* if the last space was found move the position to the last character
                     * in the string */
                    if (end === -1) {
                        end = text.length;
                    }
                    /* handle multiple spaces */
                    var size = end - begin;
                    if (size === 0) {
                        begin++;
                        continue;
                    }
                    /* extract token */
                    var token = text.substring(begin, end);
                    tokens.push(token);
                    /* extract location */
                    if (locations && baseLocation) {
                        var location_2 = sliceLocation(baseLocation, begin, end);
                        locations.push(location_2);
                    }
                    /* advance position to the character after the current end position */
                    begin += size + 1;
                }
                return { tokens: tokens, locations: locations };
            }
            /**
             * @public
             */
            var DOMTokenList = /** @class */ (function (_super) {
                __extends(DOMTokenList, _super);
                function DOMTokenList(value, location) {
                    var _this_1 = this;
                    if (value && typeof value === "string") {
                        /* replace all whitespace with a single space for easier parsing */
                        var normalized = value.replace(/[\t\r\n]/g, " ");
                        var _1 = parse(normalized, location), tokens = _1.tokens, locations = _1.locations;
                        _this_1 = _super.apply(this, tokens) || this;
                        _this_1.locations = locations;
                    }
                    else {
                        _this_1 = _super.call(this, 0) || this;
                        _this_1.locations = null;
                    }
                    if (value instanceof DynamicValue) {
                        _this_1.value = value.expr;
                    }
                    else {
                        _this_1.value = value !== null && value !== void 0 ? value : "";
                    }
                    return _this_1;
                }
                DOMTokenList.prototype.item = function (n) {
                    return this[n];
                };
                DOMTokenList.prototype.location = function (n) {
                    if (this.locations) {
                        return this.locations[n];
                    }
                    else {
                        throw new Error("Trying to access DOMTokenList location when base location isn't set");
                    }
                };
                DOMTokenList.prototype.contains = function (token) {
                    return this.includes(token);
                };
                DOMTokenList.prototype.iterator = function () {
                    var index, item, location_3;
                    return __generator(this, function (_1) {
                        switch (_1.label) {
                            case 0:
                                index = 0;
                                _1.label = 1;
                            case 1:
                                if (!(index < this.length)) return [3 /*break*/, 4];
                                item = this.item(index);
                                location_3 = this.location(index);
                                /* eslint-enable @typescript-eslint/no-non-null-assertion */
                                return [4 /*yield*/, { index: index, item: item, location: location_3 }];
                            case 2:
                                /* eslint-enable @typescript-eslint/no-non-null-assertion */
                                _1.sent();
                                _1.label = 3;
                            case 3:
                                index++;
                                return [3 /*break*/, 1];
                            case 4: return [2 /*return*/];
                        }
                    });
                };
                return DOMTokenList;
            }(Array));
            var Combinator;
            (function (Combinator) {
                Combinator[Combinator["DESCENDANT"] = 1] = "DESCENDANT";
                Combinator[Combinator["CHILD"] = 2] = "CHILD";
                Combinator[Combinator["ADJACENT_SIBLING"] = 3] = "ADJACENT_SIBLING";
                Combinator[Combinator["GENERAL_SIBLING"] = 4] = "GENERAL_SIBLING";
                /* special cases */
                Combinator[Combinator["SCOPE"] = 5] = "SCOPE";
            })(Combinator || (Combinator = {}));
            function parseCombinator(combinator, pattern) {
                /* special case, when pattern is :scope [[Selector]] will handle this
                 * "combinator" to match itself instead of descendants */
                if (pattern === ":scope") {
                    return Combinator.SCOPE;
                }
                switch (combinator) {
                    case undefined:
                    case null:
                    case "":
                        return Combinator.DESCENDANT;
                    case ">":
                        return Combinator.CHILD;
                    case "+":
                        return Combinator.ADJACENT_SIBLING;
                    case "~":
                        return Combinator.GENERAL_SIBLING;
                    default:
                        throw new Error("Unknown combinator \"".concat(combinator, "\""));
                }
            }
            function firstChild(node) {
                return node.previousSibling === null;
            }
            function lastChild(node) {
                return node.nextSibling === null;
            }
            var cache = {};
            function getNthChild(node) {
                if (!node.parent) {
                    return -1;
                }
                if (!cache[node.unique]) {
                    var parent_2 = node.parent;
                    var index = parent_2.childElements.findIndex(function (cur) {
                        return cur.unique === node.unique;
                    });
                    cache[node.unique] = index + 1; /* nthChild starts at 1 */
                }
                return cache[node.unique];
            }
            function nthChild(node, args) {
                if (!args) {
                    throw new Error("Missing argument to nth-child");
                }
                var n = parseInt(args.trim(), 10);
                var cur = getNthChild(node);
                return cur === n;
            }
            function scope(node) {
                return node.isSameNode(this.scope);
            }
            var table = {
                "first-child": firstChild,
                "last-child": lastChild,
                "nth-child": nthChild,
                scope: scope
            };
            function factory(name, context) {
                var fn = table[name];
                if (fn) {
                    return fn.bind(context);
                }
                else {
                    throw new Error("Pseudo-class \"".concat(name, "\" is not implemented"));
                }
            }
            /**
             * Homage to PHP: unescapes slashes.
             *
             * E.g. "foo\:bar" becomes "foo:bar"
             */
            function stripslashes(value) {
                return value.replace(/\\(.)/g, "$1");
            }
            /**
             * @internal
             */
            function escapeSelectorComponent(text) {
                return text.toString().replace(/([^a-z0-9_-])/gi, "\\$1");
            }
            /**
             * @internal
             */
            function generateIdSelector(id) {
                var escaped = escapeSelectorComponent(id);
                return escaped.match(/^\d/) ? "[id=\"".concat(escaped, "\"]") : "#".concat(escaped);
            }
            /**
             * Returns true if the character is a delimiter for different kinds of selectors:
             *
             * - `.` - begins a class selector
             * - `#` - begins an id selector
             * - `[` - begins an attribute selector
             * - `:` - begins a pseudo class or element selector
             */
            function isDelimiter(ch) {
                return /[.#[:]/.test(ch);
            }
            /**
             * Returns true if the character is a quotation mark.
             */
            function isQuotationMark(ch) {
                return /['"]/.test(ch);
            }
            function isPseudoElement(ch, buffer) {
                return ch === ":" && buffer === ":";
            }
            /**
             * @internal
             */
            function splitPattern(pattern) {
                var end, begin, cur, quoted, ch, buffer, tail;
                return __generator(this, function (_1) {
                    switch (_1.label) {
                        case 0:
                            if (pattern === "") {
                                return [2 /*return*/];
                            }
                            end = pattern.length;
                            begin = 0;
                            cur = 1;
                            quoted = false;
                            _1.label = 1;
                        case 1:
                            if (!(cur < end)) return [3 /*break*/, 4];
                            ch = pattern[cur];
                            buffer = pattern.slice(begin, cur);
                            /* escaped character, ignore whatever is next */
                            if (ch === "\\") {
                                cur += 2;
                                return [3 /*break*/, 1];
                            }
                            /* if inside quoted string we only look for the end quotation mark */
                            if (quoted) {
                                if (ch === quoted) {
                                    quoted = false;
                                }
                                cur += 1;
                                return [3 /*break*/, 1];
                            }
                            /* if the character is a quotation mark we store the character and the above
                             * condition will look for a similar end quotation mark */
                            if (isQuotationMark(ch)) {
                                quoted = ch;
                                cur += 1;
                                return [3 /*break*/, 1];
                            }
                            /* special case when using :: pseudo element selector */
                            if (isPseudoElement(ch, buffer)) {
                                cur += 1;
                                return [3 /*break*/, 1];
                            }
                            if (!isDelimiter(ch)) return [3 /*break*/, 3];
                            begin = cur;
                            return [4 /*yield*/, buffer];
                        case 2:
                            _1.sent();
                            _1.label = 3;
                        case 3:
                            cur += 1;
                            return [3 /*break*/, 1];
                        case 4:
                            tail = pattern.slice(begin, cur);
                            return [4 /*yield*/, tail];
                        case 5:
                            _1.sent();
                            return [2 /*return*/];
                    }
                });
            }
            var Matcher = /** @class */ (function () {
                function Matcher() {
                }
                return Matcher;
            }());
            var ClassMatcher = /** @class */ (function (_super) {
                __extends(ClassMatcher, _super);
                function ClassMatcher(classname) {
                    var _this_1 = _super.call(this) || this;
                    _this_1.classname = classname;
                    return _this_1;
                }
                ClassMatcher.prototype.match = function (node) {
                    return node.classList.contains(this.classname);
                };
                return ClassMatcher;
            }(Matcher));
            var IdMatcher = /** @class */ (function (_super) {
                __extends(IdMatcher, _super);
                function IdMatcher(id) {
                    var _this_1 = _super.call(this) || this;
                    _this_1.id = stripslashes(id);
                    return _this_1;
                }
                IdMatcher.prototype.match = function (node) {
                    return node.id === this.id;
                };
                return IdMatcher;
            }(Matcher));
            var AttrMatcher = /** @class */ (function (_super) {
                __extends(AttrMatcher, _super);
                function AttrMatcher(attr) {
                    var _this_1 = _super.call(this) || this;
                    var _1 = attr.match(/^(.+?)(?:([~^$*|]?=)"([^"]+?)")?$/), key = _1[1], op = _1[2], value = _1[3]; // eslint-disable-line @typescript-eslint/no-non-null-assertion -- will always match
                    _this_1.key = key;
                    _this_1.op = op;
                    _this_1.value = value;
                    return _this_1;
                }
                AttrMatcher.prototype.match = function (node) {
                    var _this_1 = this;
                    var attr = node.getAttribute(this.key, true) || [];
                    return attr.some(function (cur) {
                        switch (_this_1.op) {
                            case undefined:
                                return true; /* attribute exists */
                            case "=":
                                return cur.value === _this_1.value;
                            default:
                                throw new Error("Attribute selector operator ".concat(_this_1.op, " is not implemented yet"));
                        }
                    });
                };
                return AttrMatcher;
            }(Matcher));
            var PseudoClassMatcher = /** @class */ (function (_super) {
                __extends(PseudoClassMatcher, _super);
                function PseudoClassMatcher(pseudoclass, context) {
                    var _this_1 = _super.call(this) || this;
                    var match = pseudoclass.match(/^([^(]+)(?:\((.*)\))?$/);
                    if (!match) {
                        throw new Error("Missing pseudo-class after colon in selector pattern \"".concat(context, "\""));
                    }
                    var name = match[1], args = match[2];
                    _this_1.name = name;
                    _this_1.args = args;
                    return _this_1;
                }
                PseudoClassMatcher.prototype.match = function (node, context) {
                    var fn = factory(this.name, context);
                    return fn(node, this.args);
                };
                return PseudoClassMatcher;
            }(Matcher));
            var Pattern = /** @class */ (function () {
                function Pattern(pattern) {
                    var _this_1 = this;
                    var match = pattern.match(/^([~+\->]?)((?:[*]|[^.#[:]+)?)(.*)$/); // eslint-disable-line @typescript-eslint/no-non-null-assertion -- will always match
                    match.shift(); /* remove full matched string */
                    this.selector = pattern;
                    this.combinator = parseCombinator(match.shift(), pattern);
                    this.tagName = match.shift() || "*"; // eslint-disable-line @typescript-eslint/prefer-nullish-coalescing -- empty string */
                    this.pattern = Array.from(splitPattern(match[0]), function (it) { return _this_1.createMatcher(it); });
                }
                Pattern.prototype.match = function (node, context) {
                    return node.is(this.tagName) && this.pattern.every(function (cur) { return cur.match(node, context); });
                };
                Pattern.prototype.createMatcher = function (pattern) {
                    switch (pattern[0]) {
                        case ".":
                            return new ClassMatcher(pattern.slice(1));
                        case "#":
                            return new IdMatcher(pattern.slice(1));
                        case "[":
                            return new AttrMatcher(pattern.slice(1, -1));
                        case ":":
                            return new PseudoClassMatcher(pattern.slice(1), this.selector);
                        default:
                            /* istanbul ignore next: fallback solution, the switch cases should cover
                             * everything and there is no known way to trigger this fallback */
                            throw new Error("Failed to create matcher for \"".concat(pattern, "\""));
                    }
                };
                return Pattern;
            }());
            /**
             * DOM Selector.
             */
            var Selector = /** @class */ (function () {
                function Selector(selector) {
                    this.pattern = Selector.parse(selector);
                }
                /**
                 * Match this selector against a HtmlElement.
                 *
                 * @param root - Element to match against.
                 * @returns Iterator with matched elements.
                 */
                Selector.prototype.match = function (root) {
                    var context;
                    return __generator(this, function (_1) {
                        switch (_1.label) {
                            case 0:
                                context = { scope: root };
                                return [5 /*yield**/, __values(this.matchInternal(root, 0, context))];
                            case 1:
                                _1.sent();
                                return [2 /*return*/];
                        }
                    });
                };
                Selector.prototype.matchInternal = function (root, level, context) {
                    var pattern, matches, _1, matches_1, node;
                    return __generator(this, function (_2) {
                        switch (_2.label) {
                            case 0:
                                if (!(level >= this.pattern.length)) return [3 /*break*/, 2];
                                return [4 /*yield*/, root];
                            case 1:
                                _2.sent();
                                return [2 /*return*/];
                            case 2:
                                pattern = this.pattern[level];
                                matches = Selector.findCandidates(root, pattern);
                                _1 = 0, matches_1 = matches;
                                _2.label = 3;
                            case 3:
                                if (!(_1 < matches_1.length)) return [3 /*break*/, 6];
                                node = matches_1[_1];
                                if (!pattern.match(node, context)) {
                                    return [3 /*break*/, 5];
                                }
                                return [5 /*yield**/, __values(this.matchInternal(node, level + 1, context))];
                            case 4:
                                _2.sent();
                                _2.label = 5;
                            case 5:
                                _1++;
                                return [3 /*break*/, 3];
                            case 6: return [2 /*return*/];
                        }
                    });
                };
                Selector.parse = function (selector) {
                    /* strip whitespace before combinators, "ul > li" becomes "ul >li", for
                     * easier parsing */
                    selector = selector.replace(/([+~>]) /g, "$1");
                    var pattern = selector.split(/(?:(?<!\\) )+/);
                    return pattern.map(function (part) { return new Pattern(part); });
                };
                Selector.findCandidates = function (root, pattern) {
                    switch (pattern.combinator) {
                        case Combinator.DESCENDANT:
                            return root.getElementsByTagName(pattern.tagName);
                        case Combinator.CHILD:
                            return root.childElements.filter(function (node) { return node.is(pattern.tagName); });
                        case Combinator.ADJACENT_SIBLING:
                            return Selector.findAdjacentSibling(root);
                        case Combinator.GENERAL_SIBLING:
                            return Selector.findGeneralSibling(root);
                        case Combinator.SCOPE:
                            return [root];
                    }
                    /* istanbul ignore next: fallback solution, the switch cases should cover
                     * everything and there is no known way to trigger this fallback */
                    return [];
                };
                Selector.findAdjacentSibling = function (node) {
                    var adjacent = false;
                    return node.siblings.filter(function (cur) {
                        if (adjacent) {
                            adjacent = false;
                            return true;
                        }
                        if (cur === node) {
                            adjacent = true;
                        }
                        return false;
                    });
                };
                Selector.findGeneralSibling = function (node) {
                    var after = false;
                    return node.siblings.filter(function (cur) {
                        if (after) {
                            return true;
                        }
                        if (cur === node) {
                            after = true;
                        }
                        return false;
                    });
                };
                return Selector;
            }());
            var TEXT_NODE_NAME = "#text";
            /**
             * Returns true if the node is a text node.
             *
             * @public
             */
            function isTextNode(node) {
                return Boolean(node && node.nodeType === exports.NodeType.TEXT_NODE);
            }
            /**
             * Represents a text in the HTML document.
             *
             * Text nodes are appended as children of `HtmlElement` and cannot have childen
             * of its own.
             *
             * @public
             */
            var TextNode = /** @class */ (function (_super) {
                __extends(TextNode, _super);
                /**
                 * @param text - Text to add. When a `DynamicValue` is used the expression is
                 * used as "text".
                 * @param location - Source code location of this node.
                 */
                function TextNode(text, location) {
                    var _this_1 = _super.call(this, exports.NodeType.TEXT_NODE, TEXT_NODE_NAME, location) || this;
                    _this_1.text = text;
                    return _this_1;
                }
                Object.defineProperty(TextNode.prototype, "textContent", {
                    /**
                     * Get the text from node.
                     */
                    get: function () {
                        return this.text.toString();
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(TextNode.prototype, "isStatic", {
                    /**
                     * Flag set to true if the attribute value is static.
                     */
                    get: function () {
                        return !this.isDynamic;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(TextNode.prototype, "isDynamic", {
                    /**
                     * Flag set to true if the attribute value is dynamic.
                     */
                    get: function () {
                        return this.text instanceof DynamicValue;
                    },
                    enumerable: false,
                    configurable: true
                });
                return TextNode;
            }(DOMNode));
            /**
             * @public
             */
            exports.NodeClosed = void 0;
            (function (NodeClosed) {
                NodeClosed[NodeClosed["Open"] = 0] = "Open";
                NodeClosed[NodeClosed["EndTag"] = 1] = "EndTag";
                NodeClosed[NodeClosed["VoidOmitted"] = 2] = "VoidOmitted";
                NodeClosed[NodeClosed["VoidSelfClosed"] = 3] = "VoidSelfClosed";
                NodeClosed[NodeClosed["ImplicitClosed"] = 4] = "ImplicitClosed";
            })(exports.NodeClosed || (exports.NodeClosed = {}));
            /**
             * Returns true if the node is an element node.
             *
             * @public
             */
            function isElementNode(node) {
                return Boolean(node && node.nodeType === exports.NodeType.ELEMENT_NODE);
            }
            function isValidTagName(tagName) {
                return Boolean(tagName !== "" && tagName !== "*");
            }
            function createAdapter(node) {
                return {
                    closest: function (selectors) {
                        var _a;
                        return (_a = node.closest(selectors)) === null || _a === void 0 ? void 0 : _a._adapter;
                    },
                    getAttribute: function (name) {
                        var _a;
                        return (_a = node.getAttribute(name)) === null || _a === void 0 ? void 0 : _a.value;
                    },
                    hasAttribute: function (name) {
                        return node.hasAttribute(name);
                    }
                };
            }
            /**
             * @public
             */
            var HtmlElement = /** @class */ (function (_super) {
                __extends(HtmlElement, _super);
                function HtmlElement(tagName, parent, closed, meta, location) {
                    var _this_1 = this;
                    var nodeType = tagName ? exports.NodeType.ELEMENT_NODE : exports.NodeType.DOCUMENT_NODE;
                    _this_1 = _super.call(this, nodeType, tagName, location) || this;
                    if (!isValidTagName(tagName)) {
                        throw new Error("The tag name provided ('".concat(tagName, "') is not a valid name"));
                    }
                    _this_1.tagName = tagName !== null && tagName !== void 0 ? tagName : "#document";
                    _this_1.parent = parent !== null && parent !== void 0 ? parent : null;
                    _this_1.attr = {};
                    _this_1.metaElement = meta !== null && meta !== void 0 ? meta : null;
                    _this_1.closed = closed;
                    _this_1.voidElement = meta ? Boolean(meta["void"]) : false;
                    _this_1.depth = 0;
                    _this_1.annotation = null;
                    _this_1._adapter = createAdapter(_this_1);
                    if (parent) {
                        parent.childNodes.push(_this_1);
                        /* calculate depth in domtree */
                        var cur = parent;
                        while (cur.parent) {
                            _this_1.depth++;
                            cur = cur.parent;
                        }
                    }
                    return _this_1;
                }
                /**
                 * @internal
                 */
                HtmlElement.rootNode = function (location) {
                    var root = new HtmlElement(undefined, null, exports.NodeClosed.EndTag, null, location);
                    root.setAnnotation("#document");
                    return root;
                };
                /**
                 * @internal
                 *
                 * @param namespace - If given it is appended to the tagName.
                 */
                HtmlElement.fromTokens = function (startToken, endToken, parent, metaTable, namespace) {
                    if (namespace === void 0) { namespace = ""; }
                    var name = startToken.data[2];
                    var tagName = namespace ? "".concat(namespace, ":").concat(name) : name;
                    if (!name) {
                        throw new Error("tagName cannot be empty");
                    }
                    var meta = metaTable ? metaTable.getMetaFor(tagName) : null;
                    var open = startToken.data[1] !== "/";
                    var closed = isClosed(endToken, meta);
                    /* location contains position of '<' so strip it out */
                    var location = sliceLocation(startToken.location, 1);
                    return new HtmlElement(tagName, open ? parent : null, closed, meta, location);
                };
                Object.defineProperty(HtmlElement.prototype, "annotatedName", {
                    /**
                     * Returns annotated name if set or defaults to `<tagName>`.
                     *
                     * E.g. `my-annotation` or `<div>`.
                     */
                    get: function () {
                        if (this.annotation) {
                            return this.annotation;
                        }
                        else {
                            return "<".concat(this.tagName, ">");
                        }
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(HtmlElement.prototype, "ariaLabelledby", {
                    /**
                     * Get list of IDs referenced by `aria-labelledby`.
                     *
                     * If the attribute is unset or empty this getter returns null.
                     * If the attribute is dynamic the original {@link DynamicValue} is returned.
                     *
                     * @public
                     */
                    get: function () {
                        var attr = this.getAttribute("aria-labelledby");
                        if (!(attr === null || attr === void 0 ? void 0 : attr.value)) {
                            return null;
                        }
                        if (attr.value instanceof DynamicValue) {
                            return attr.value;
                        }
                        var list = new DOMTokenList(attr.value, attr.valueLocation);
                        return list.length ? Array.from(list) : null;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(HtmlElement.prototype, "childElements", {
                    /**
                     * Similar to childNodes but only elements.
                     */
                    get: function () {
                        return this.childNodes.filter(isElementNode);
                    },
                    enumerable: false,
                    configurable: true
                });
                /**
                 * Find the first ancestor matching a selector.
                 *
                 * Implementation of DOM specification of Element.closest(selectors).
                 */
                HtmlElement.prototype.closest = function (selectors) {
                    /* eslint-disable-next-line @typescript-eslint/no-this-alias -- false positive*/
                    var node = this;
                    while (node) {
                        if (node.matches(selectors)) {
                            return node;
                        }
                        node = node.parent;
                    }
                    return null;
                };
                /**
                 * Generate a DOM selector for this element. The returned selector will be
                 * unique inside the current document.
                 */
                HtmlElement.prototype.generateSelector = function () {
                    /* root element cannot have a selector as it isn't a proper element */
                    if (this.isRootElement()) {
                        return null;
                    }
                    var parts = [];
                    var root;
                    /* eslint-disable-next-line @typescript-eslint/no-this-alias -- false positive */
                    for (root = this; root.parent; root = root.parent) {
                        /* .. */
                    }
                    var _loop_18 = function (cur) {
                        /* if a unique id is present, use it and short-circuit */
                        if (cur.id) {
                            var selector_1 = generateIdSelector(cur.id);
                            var matches = root.querySelectorAll(selector_1);
                            if (matches.length === 1) {
                                parts.push(selector_1);
                                return "break";
                            }
                        }
                        var parent_3 = cur.parent;
                        var child = parent_3.childElements;
                        var index = child.findIndex(function (it) { return it.unique === cur.unique; });
                        var numOfType = child.filter(function (it) { return it.is(cur.tagName); }).length;
                        var solo = numOfType === 1;
                        /* if this is the only tagName in this level of siblings nth-child isn't needed */
                        if (solo) {
                            parts.push(cur.tagName.toLowerCase());
                            return "continue";
                        }
                        /* this will generate the worst kind of selector but at least it will be accurate (optimizations welcome) */
                        parts.push("".concat(cur.tagName.toLowerCase(), ":nth-child(").concat(index + 1, ")"));
                    };
                    // eslint-disable-next-line @typescript-eslint/no-this-alias -- false positive
                    for (var cur = this; cur.parent; cur = cur.parent) {
                        var state_3 = _loop_18(cur);
                        if (state_3 === "break")
                            break;
                    }
                    return parts.reverse().join(" > ");
                };
                /**
                 * Tests if this element has given tagname.
                 *
                 * If passing "*" this test will pass if any tagname is set.
                 */
                HtmlElement.prototype.is = function (tagName) {
                    return tagName === "*" || this.tagName.toLowerCase() === tagName.toLowerCase();
                };
                /**
                 * Load new element metadata onto this element.
                 *
                 * Do note that semantics such as `void` cannot be changed (as the element has
                 * already been created). In addition the element will still "be" the same
                 * element, i.e. even if loading meta for a `<p>` tag upon a `<div>` tag it
                 * will still be a `<div>` as far as the rest of the validator is concerned.
                 *
                 * In fact only certain properties will be copied onto the element:
                 *
                 * - content categories (flow, phrasing, etc)
                 * - required attributes
                 * - attribute allowed values
                 * - permitted/required elements
                 *
                 * Properties *not* loaded:
                 *
                 * - inherit
                 * - deprecated
                 * - foreign
                 * - void
                 * - implicitClosed
                 * - scriptSupporting
                 * - deprecatedAttributes
                 *
                 * Changes to element metadata will only be visible after `element:ready` (and
                 * the subsequent `dom:ready` event).
                 */
                HtmlElement.prototype.loadMeta = function (meta) {
                    if (!this.metaElement) {
                        this.metaElement = {};
                    }
                    for (var _1 = 0, MetaCopyableProperty_1 = MetaCopyableProperty; _1 < MetaCopyableProperty_1.length; _1++) {
                        var key = MetaCopyableProperty_1[_1];
                        var value = meta[key];
                        if (typeof value !== "undefined") {
                            setMetaProperty(this.metaElement, key, value);
                        }
                        else {
                            /* eslint-disable-next-line @typescript-eslint/no-dynamic-delete -- technical debt */
                            delete this.metaElement[key];
                        }
                    }
                };
                /**
                 * Match this element against given selectors. Returns true if any selector
                 * matches.
                 *
                 * Implementation of DOM specification of Element.matches(selectors).
                 */
                HtmlElement.prototype.matches = function (selector) {
                    /* find root element */
                    /* eslint-disable-next-line @typescript-eslint/no-this-alias -- false positive */
                    var root = this;
                    while (root.parent) {
                        root = root.parent;
                    }
                    /* a bit slow implementation as it finds all candidates for the selector and
                     * then tests if any of them are the current element. A better
                     * implementation would be to walk the selector right-to-left and test
                     * ancestors. */
                    for (var _1 = 0, _2 = root.querySelectorAll(selector); _1 < _2.length; _1++) {
                        var match = _2[_1];
                        if (match.unique === this.unique) {
                            return true;
                        }
                    }
                    return false;
                };
                Object.defineProperty(HtmlElement.prototype, "meta", {
                    get: function () {
                        return this.metaElement;
                    },
                    enumerable: false,
                    configurable: true
                });
                /**
                 * Set annotation for this element.
                 */
                HtmlElement.prototype.setAnnotation = function (text) {
                    this.annotation = text;
                };
                /**
                 * Set attribute. Stores all attributes set even with the same name.
                 *
                 * @param key - Attribute name
                 * @param value - Attribute value. Use `null` if no value is present.
                 * @param keyLocation - Location of the attribute name.
                 * @param valueLocation - Location of the attribute value (excluding quotation)
                 * @param originalAttribute - If attribute is an alias for another attribute
                 * (dynamic attributes) set this to the original attribute name.
                 */
                HtmlElement.prototype.setAttribute = function (key, value, keyLocation, valueLocation, originalAttribute) {
                    key = key.toLowerCase();
                    if (!this.attr[key]) {
                        this.attr[key] = [];
                    }
                    this.attr[key].push(new Attribute(key, value, keyLocation, valueLocation, originalAttribute));
                };
                Object.defineProperty(HtmlElement.prototype, "attributes", {
                    /**
                     * Get a list of all attributes on this node.
                     */
                    get: function () {
                        return Object.values(this.attr).reduce(function (result, cur) {
                            return result.concat(cur);
                        }, []);
                    },
                    enumerable: false,
                    configurable: true
                });
                HtmlElement.prototype.hasAttribute = function (key) {
                    key = key.toLowerCase();
                    return key in this.attr;
                };
                HtmlElement.prototype.getAttribute = function (key, all) {
                    if (all === void 0) { all = false; }
                    key = key.toLowerCase();
                    if (key in this.attr) {
                        var matches = this.attr[key];
                        return all ? matches : matches[0];
                    }
                    else {
                        return null;
                    }
                };
                /**
                 * Get attribute value.
                 *
                 * Returns the attribute value if present.
                 *
                 * - Missing attributes return `null`.
                 * - Boolean attributes return `null`.
                 * - `DynamicValue` returns attribute expression.
                 *
                 * @param key - Attribute name
                 * @returns Attribute value or null.
                 */
                HtmlElement.prototype.getAttributeValue = function (key) {
                    var attr = this.getAttribute(key);
                    if (attr) {
                        return attr.value !== null ? attr.value.toString() : null;
                    }
                    else {
                        return null;
                    }
                };
                /**
                 * Add text as a child node to this element.
                 *
                 * @param text - Text to add.
                 * @param location - Source code location of this text.
                 */
                HtmlElement.prototype.appendText = function (text, location) {
                    this.childNodes.push(new TextNode(text, location));
                };
                Object.defineProperty(HtmlElement.prototype, "classList", {
                    /**
                     * Return a list of all known classes on the element. Dynamic values are
                     * ignored.
                     */
                    get: function () {
                        if (!this.hasAttribute("class")) {
                            return new DOMTokenList(null, null);
                        }
                        var classes = this.getAttribute("class", true)
                            .filter(function (attr) { return attr.isStatic; })
                            .map(function (attr) { return attr.value; })
                            .join(" ");
                        return new DOMTokenList(classes, null);
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(HtmlElement.prototype, "id", {
                    /**
                     * Get element ID if present.
                     */
                    get: function () {
                        return this.getAttributeValue("id");
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(HtmlElement.prototype, "style", {
                    get: function () {
                        var attr = this.getAttribute("style");
                        return parseCssDeclaration(attr === null || attr === void 0 ? void 0 : attr.value);
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(HtmlElement.prototype, "firstElementChild", {
                    /**
                     * Returns the first child element or null if there are no child elements.
                     */
                    get: function () {
                        var children = this.childElements;
                        return children.length > 0 ? children[0] : null;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(HtmlElement.prototype, "lastElementChild", {
                    /**
                     * Returns the last child element or null if there are no child elements.
                     */
                    get: function () {
                        var children = this.childElements;
                        return children.length > 0 ? children[children.length - 1] : null;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(HtmlElement.prototype, "siblings", {
                    get: function () {
                        return this.parent ? this.parent.childElements : [this];
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(HtmlElement.prototype, "previousSibling", {
                    get: function () {
                        var _this_1 = this;
                        var i = this.siblings.findIndex(function (node) { return node.unique === _this_1.unique; });
                        return i >= 1 ? this.siblings[i - 1] : null;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(HtmlElement.prototype, "nextSibling", {
                    get: function () {
                        var _this_1 = this;
                        var i = this.siblings.findIndex(function (node) { return node.unique === _this_1.unique; });
                        return i <= this.siblings.length - 2 ? this.siblings[i + 1] : null;
                    },
                    enumerable: false,
                    configurable: true
                });
                HtmlElement.prototype.getElementsByTagName = function (tagName) {
                    return this.childElements.reduce(function (matches, node) {
                        return matches.concat(node.is(tagName) ? [node] : [], node.getElementsByTagName(tagName));
                    }, []);
                };
                HtmlElement.prototype.querySelector = function (selector) {
                    var it = this.querySelectorImpl(selector);
                    var next = it.next();
                    if (next.done) {
                        return null;
                    }
                    else {
                        return next.value;
                    }
                };
                HtmlElement.prototype.querySelectorAll = function (selector) {
                    var it = this.querySelectorImpl(selector);
                    var unique = new Set(it);
                    return Array.from(unique.values());
                };
                HtmlElement.prototype.querySelectorImpl = function (selectorList) {
                    var _1, _2, selector_2, pattern;
                    return __generator(this, function (_3) {
                        switch (_3.label) {
                            case 0:
                                if (!selectorList) {
                                    return [2 /*return*/];
                                }
                                _1 = 0, _2 = selectorList.split(/,\s*/);
                                _3.label = 1;
                            case 1:
                                if (!(_1 < _2.length)) return [3 /*break*/, 4];
                                selector_2 = _2[_1];
                                pattern = new Selector(selector_2);
                                return [5 /*yield**/, __values(pattern.match(this))];
                            case 2:
                                _3.sent();
                                _3.label = 3;
                            case 3:
                                _1++;
                                return [3 /*break*/, 1];
                            case 4: return [2 /*return*/];
                        }
                    });
                };
                /**
                 * Visit all nodes from this node and down. Depth first.
                 *
                 * @internal
                 */
                HtmlElement.prototype.visitDepthFirst = function (callback) {
                    function visit(node) {
                        node.childElements.forEach(visit);
                        if (!node.isRootElement()) {
                            callback(node);
                        }
                    }
                    visit(this);
                };
                /**
                 * Evaluates callbackk on all descendants, returning true if any are true.
                 *
                 * @internal
                 */
                HtmlElement.prototype.someChildren = function (callback) {
                    return this.childElements.some(visit);
                    function visit(node) {
                        if (callback(node)) {
                            return true;
                        }
                        else {
                            return node.childElements.some(visit);
                        }
                    }
                };
                /**
                 * Evaluates callbackk on all descendants, returning true if all are true.
                 *
                 * @internal
                 */
                HtmlElement.prototype.everyChildren = function (callback) {
                    return this.childElements.every(visit);
                    function visit(node) {
                        if (!callback(node)) {
                            return false;
                        }
                        return node.childElements.every(visit);
                    }
                };
                /**
                 * Visit all nodes from this node and down. Breadth first.
                 *
                 * The first node for which the callback evaluates to true is returned.
                 *
                 * @internal
                 */
                HtmlElement.prototype.find = function (callback) {
                    function visit(node) {
                        if (callback(node)) {
                            return node;
                        }
                        for (var _1 = 0, _2 = node.childElements; _1 < _2.length; _1++) {
                            var child = _2[_1];
                            var match = child.find(callback);
                            if (match) {
                                return match;
                            }
                        }
                        return null;
                    }
                    return visit(this);
                };
                return HtmlElement;
            }(DOMNode));
            function isClosed(endToken, meta) {
                var closed = exports.NodeClosed.Open;
                if (meta && meta["void"]) {
                    closed = exports.NodeClosed.VoidOmitted;
                }
                if (endToken.data[0] === "/>") {
                    closed = exports.NodeClosed.VoidSelfClosed;
                }
                return closed;
            }
            /**
             * @public
             */
            var DOMTree = /** @class */ (function () {
                function DOMTree(location) {
                    this.root = HtmlElement.rootNode(location);
                    this.active = this.root;
                    this.doctype = null;
                }
                DOMTree.prototype.pushActive = function (node) {
                    this.active = node;
                };
                DOMTree.prototype.popActive = function () {
                    var _a;
                    if (this.active.isRootElement()) {
                        /* root element should never be popped, continue as if nothing happened */
                        return;
                    }
                    this.active = (_a = this.active.parent) !== null && _a !== void 0 ? _a : this.root;
                };
                DOMTree.prototype.getActive = function () {
                    return this.active;
                };
                /**
                 * Resolve dynamic meta expressions.
                 */
                DOMTree.prototype.resolveMeta = function (table) {
                    this.visitDepthFirst(function (node) {
                        table.resolve(node);
                    });
                };
                DOMTree.prototype.getElementsByTagName = function (tagName) {
                    return this.root.getElementsByTagName(tagName);
                };
                DOMTree.prototype.visitDepthFirst = function (callback) {
                    this.root.visitDepthFirst(callback);
                };
                DOMTree.prototype.find = function (callback) {
                    return this.root.find(callback);
                };
                DOMTree.prototype.querySelector = function (selector) {
                    return this.root.querySelector(selector);
                };
                DOMTree.prototype.querySelectorAll = function (selector) {
                    return this.root.querySelectorAll(selector);
                };
                return DOMTree;
            }());
            var allowedKeys = ["exclude"];
            /**
             * Helper class to validate elements against metadata rules.
             *
             * @public
             */
            /* eslint-disable-next-line @typescript-eslint/no-extraneous-class -- technical debt, should probably be plain functions maybe in an object */
            var Validator = /** @class */ (function () {
                function Validator() {
                }
                /**
                 * Test if element is used in a proper context.
                 *
                 * @param node - Element to test.
                 * @param rules - List of rules.
                 * @returns `true` if element passes all tests.
                 */
                Validator.validatePermitted = function (node, rules) {
                    if (!rules) {
                        return true;
                    }
                    return rules.some(function (rule) {
                        return Validator.validatePermittedRule(node, rule);
                    });
                };
                /**
                 * Test if an element is used the correct amount of times.
                 *
                 * For instance, a `<table>` element can only contain a single `<tbody>`
                 * child. If multiple `<tbody>` exists this test will fail both nodes.
                 * Note that this is called on the parent but will fail the children violating
                 * the rule.
                 *
                 * @param children - Array of children to validate.
                 * @param rules - List of rules of the parent element.
                 * @returns `true` if the parent element of the children passes the test.
                 */
                Validator.validateOccurrences = function (children, rules, cb) {
                    if (!rules) {
                        return true;
                    }
                    var valid = true;
                    var _loop_19 = function (rule) {
                        /** @todo handle complex rules and not just plain arrays (but as of now
                         * there is no use-case for it) */
                        // istanbul ignore next
                        if (typeof rule !== "string") {
                            return { value: false };
                        }
                        // Check if the rule has a quantifier
                        var _2 = rule.match(/^(@?.*?)([?*]?)$/), category = _2[1], quantifier = _2[2]; // eslint-disable-line @typescript-eslint/no-non-null-assertion -- will always match
                        var limit = category && quantifier && parseQuantifier(quantifier);
                        if (limit) {
                            var siblings = children.filter(function (cur) { return Validator.validatePermittedCategory(cur, rule, true); });
                            if (siblings.length > limit) {
                                // fail only the children above the limit (currently limit can only be 1)
                                for (var _3 = 0, _4 = siblings.slice(limit); _3 < _4.length; _3++) {
                                    var child = _4[_3];
                                    cb(child, category);
                                }
                                valid = false;
                            }
                        }
                    };
                    for (var _1 = 0, rules_6 = rules; _1 < rules_6.length; _1++) {
                        var rule = rules_6[_1];
                        var state_4 = _loop_19(rule);
                        if (typeof state_4 === "object")
                            return state_4.value;
                    }
                    return valid;
                };
                /**
                 * Validate elements order.
                 *
                 * Given a parent element with children and metadata containing permitted
                 * order it will validate each children and ensure each one exists in the
                 * specified order.
                 *
                 * For instance, for a `<table>` element the `<caption>` element must come
                 * before a `<thead>` which must come before `<tbody>`.
                 *
                 * @param children - Array of children to validate.
                 */
                Validator.validateOrder = function (children, rules, cb) {
                    if (!rules) {
                        return true;
                    }
                    var i = 0;
                    var prev = null;
                    var _loop_20 = function (node) {
                        var old = i;
                        while (rules[i] && !Validator.validatePermittedCategory(node, rules[i], true)) {
                            i++;
                        }
                        if (i >= rules.length) {
                            /* Second check is if the order is specified for this element at all. It
                             * will be unspecified in two cases:
                             * - disallowed elements
                             * - elements where the order doesn't matter
                             * In both of these cases no error should be reported. */
                            var orderSpecified = rules.find(function (cur) { return Validator.validatePermittedCategory(node, cur, true); });
                            if (orderSpecified) {
                                /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- technical debt, should never happen */
                                cb(node, prev);
                                return { value: false };
                            }
                            /* if this element has unspecified order the index is restored so new
                             * elements of the same type can be specified again */
                            i = old;
                        }
                        prev = node;
                    };
                    for (var _1 = 0, children_1 = children; _1 < children_1.length; _1++) {
                        var node = children_1[_1];
                        var state_5 = _loop_20(node);
                        if (typeof state_5 === "object")
                            return state_5.value;
                    }
                    return true;
                };
                /**
                 * Validate element ancestors.
                 *
                 * Check if an element has the required set of elements. At least one of the
                 * selectors must match.
                 */
                Validator.validateAncestors = function (node, rules) {
                    if (!rules || rules.length === 0) {
                        return true;
                    }
                    return rules.some(function (rule) { return node.closest(rule); });
                };
                /**
                 * Validate element required content.
                 *
                 * Check if an element has the required set of elements. At least one of the
                 * selectors must match.
                 *
                 * Returns `[]` when valid or a list of required but missing tagnames or
                 * categories.
                 */
                Validator.validateRequiredContent = function (node, rules) {
                    if (!rules || rules.length === 0) {
                        return [];
                    }
                    return rules.filter(function (tagName) {
                        var haveMatchingChild = node.childElements.some(function (child) { return Validator.validatePermittedCategory(child, tagName, false); });
                        return !haveMatchingChild;
                    });
                };
                /**
                 * Test if an attribute has an allowed value and/or format.
                 *
                 * @param attr - Attribute to test.
                 * @param rules - Element attribute metadta.
                 * @returns `true` if attribute passes all tests.
                 */
                Validator.validateAttribute = function (attr, rules) {
                    var _this_1 = this;
                    var rule = rules[attr.key];
                    if (!rule) {
                        return true;
                    }
                    /* consider dynamic values as valid as there is no way to properly test them
                     * while using transformed sources, i.e. it must be tested when running in a
                     * browser instead */
                    var value = attr.value;
                    if (value instanceof DynamicValue) {
                        return true;
                    }
                    var empty = value === null || value === "";
                    /* if boolean is set the value can be either null, empty string or the
                     * attribute key (attribute-boolean-style regulates style) */
                    if (rule.boolean) {
                        return empty || value === attr.key;
                    }
                    /* if omit is set the value can be either null or empty string
                     * (attribute-empty style regulates style) */
                    if (rule.omit && empty) {
                        return true;
                    }
                    /* validate each token when using list, all tokens must be valid */
                    if (rule.list) {
                        var tokens = new DOMTokenList(value, attr.valueLocation);
                        return tokens.every(function (token) {
                            return _this_1.validateAttributeValue(token, rule);
                        });
                    }
                    return this.validateAttributeValue(value, rule);
                };
                Validator.validateAttributeValue = function (value, rule) {
                    /* skip attribute if it not have enumerated list */
                    if (!rule["enum"]) {
                        return true;
                    }
                    if (value === null || value === undefined) {
                        return false;
                    }
                    var caseInsensitiveValue = value.toLowerCase();
                    return rule["enum"].some(function (entry) {
                        if (entry instanceof RegExp) {
                            /* regular expressions are matched case-sensitive */
                            return !!value.match(entry);
                        }
                        else {
                            /* strings matched case-insensitive */
                            return caseInsensitiveValue === entry;
                        }
                    });
                };
                Validator.validatePermittedRule = function (node, rule, isExclude) {
                    if (isExclude === void 0) { isExclude = false; }
                    if (typeof rule === "string") {
                        return Validator.validatePermittedCategory(node, rule, !isExclude);
                    }
                    else if (Array.isArray(rule)) {
                        return rule.every(function (inner) {
                            return Validator.validatePermittedRule(node, inner, isExclude);
                        });
                    }
                    else {
                        validateKeys(rule);
                        if (rule.exclude) {
                            if (Array.isArray(rule.exclude)) {
                                return !rule.exclude.some(function (inner) {
                                    return Validator.validatePermittedRule(node, inner, true);
                                });
                            }
                            else {
                                return !Validator.validatePermittedRule(node, rule.exclude, true);
                            }
                        }
                        else {
                            return true;
                        }
                    }
                };
                /**
                 * Validate node against a content category.
                 *
                 * When matching parent nodes against permitted parents use the superset
                 * parameter to also match for `@flow`. E.g. if a node expects a `@phrasing`
                 * parent it should also allow `@flow` parent since `@phrasing` is a subset of
                 * `@flow`.
                 *
                 * @param node - The node to test against
                 * @param category - Name of category with `@` prefix or tag name.
                 * @param defaultMatch - The default return value when node categories is not known.
                 */
                /* eslint-disable-next-line complexity -- rule does not like switch */
                Validator.validatePermittedCategory = function (node, category, defaultMatch) {
                    var _1 = category.match(/^(@?.*?)([?*]?)$/), rawCategory = _1[1]; // eslint-disable-line @typescript-eslint/no-non-null-assertion -- will always match
                    /* match tagName when an explicit name is given */
                    if (!rawCategory.startsWith("@")) {
                        return node.tagName === rawCategory;
                    }
                    /* if the meta entry is missing assume any content model would match */
                    if (!node.meta) {
                        return defaultMatch;
                    }
                    switch (rawCategory) {
                        case "@meta":
                            return node.meta.metadata;
                        case "@flow":
                            return node.meta.flow;
                        case "@sectioning":
                            return node.meta.sectioning;
                        case "@heading":
                            return node.meta.heading;
                        case "@phrasing":
                            return node.meta.phrasing;
                        case "@embedded":
                            return node.meta.embedded;
                        case "@interactive":
                            return node.meta.interactive;
                        case "@script":
                            return Boolean(node.meta.scriptSupporting);
                        case "@form":
                            return Boolean(node.meta.form);
                        default:
                            throw new Error("Invalid content category \"".concat(category, "\""));
                    }
                };
                return Validator;
            }());
            function validateKeys(rule) {
                for (var _1 = 0, _2 = Object.keys(rule); _1 < _2.length; _1++) {
                    var key = _2[_1];
                    if (!allowedKeys.includes(key)) {
                        var str = JSON.stringify(rule);
                        throw new Error("Permitted rule \"".concat(str, "\" contains unknown property \"").concat(key, "\""));
                    }
                }
            }
            function parseQuantifier(quantifier) {
                switch (quantifier) {
                    case "?":
                        return 1;
                    case "*":
                        return null;
                    // istanbul ignore next
                    default:
                        throw new Error("Invalid quantifier \"".concat(quantifier, "\" used"));
                }
            }
            var $schema = "http://json-schema.org/draft-06/schema#";
            var $id = "https://html-validate.org/schemas/config.json";
            var type = "object";
            var additionalProperties = false;
            var properties = {
                $schema: {
                    type: "string"
                },
                root: {
                    type: "boolean",
                    title: "Mark as root configuration",
                    description: "If this is set to true no further configurations will be searched.",
                    "default": false
                },
                "extends": {
                    type: "array",
                    items: {
                        type: "string"
                    },
                    title: "Configurations to extend",
                    description: "Array of shareable or builtin configurations to extend."
                },
                elements: {
                    type: "array",
                    items: {
                        anyOf: [
                            {
                                type: "string"
                            },
                            {
                                type: "object"
                            }
                        ]
                    },
                    title: "Element metadata to load",
                    description: "Array of modules, plugins or files to load element metadata from. Use <rootDir> to refer to the folder with the package.json file.",
                    examples: [
                        [
                            "html-validate:recommended",
                            "plugin:recommended",
                            "module",
                            "./local-file.json"
                        ]
                    ]
                },
                plugins: {
                    type: "array",
                    items: {
                        anyOf: [
                            {
                                type: "string"
                            },
                            {
                                type: "object"
                            }
                        ]
                    },
                    title: "Plugins to load",
                    description: "Array of plugins load. Use <rootDir> to refer to the folder with the package.json file.",
                    examples: [
                        [
                            "my-plugin",
                            "./local-plugin"
                        ]
                    ]
                },
                transform: {
                    type: "object",
                    additionalProperties: {
                        type: "string"
                    },
                    title: "File transformations to use.",
                    description: "Object where key is regular expression to match filename and value is name of transformer.",
                    examples: [
                        {
                            "^.*\\.foo$": "my-transformer",
                            "^.*\\.bar$": "my-plugin",
                            "^.*\\.baz$": "my-plugin:named"
                        }
                    ]
                },
                rules: {
                    type: "object",
                    patternProperties: {
                        ".*": {
                            anyOf: [
                                {
                                    "enum": [
                                        0,
                                        1,
                                        2,
                                        "off",
                                        "warn",
                                        "error"
                                    ]
                                },
                                {
                                    type: "array",
                                    minItems: 1,
                                    maxItems: 1,
                                    items: [
                                        {
                                            "enum": [
                                                0,
                                                1,
                                                2,
                                                "off",
                                                "warn",
                                                "error"
                                            ]
                                        }
                                    ]
                                },
                                {
                                    type: "array",
                                    minItems: 2,
                                    maxItems: 2,
                                    items: [
                                        {
                                            "enum": [
                                                0,
                                                1,
                                                2,
                                                "off",
                                                "warn",
                                                "error"
                                            ]
                                        },
                                        {}
                                    ]
                                }
                            ]
                        }
                    },
                    title: "Rule configuration.",
                    description: "Enable/disable rules, set severity. Some rules have additional configuration like style or patterns to use.",
                    examples: [
                        {
                            foo: "error",
                            bar: "off",
                            baz: [
                                "error",
                                {
                                    style: "camelcase"
                                }
                            ]
                        }
                    ]
                }
            };
            var configurationSchema = {
                $schema: $schema,
                $id: $id,
                type: type,
                additionalProperties: additionalProperties,
                properties: properties
            };
            /**
             * @internal
             */
            var TRANSFORMER_API = {
                VERSION: 1
            };
            /**
             * @public
             */
            exports.Severity = void 0;
            (function (Severity) {
                Severity[Severity["DISABLED"] = 0] = "DISABLED";
                Severity[Severity["WARN"] = 1] = "WARN";
                Severity[Severity["ERROR"] = 2] = "ERROR";
            })(exports.Severity || (exports.Severity = {}));
            /**
             * @internal
             */
            function parseSeverity(value) {
                switch (value) {
                    case 0:
                    case "off":
                        return exports.Severity.DISABLED;
                    case 1:
                    case "warn":
                        return exports.Severity.WARN;
                    case 2:
                    case "error":
                        return exports.Severity.ERROR;
                    default:
                        throw new Error("Invalid severity \"".concat(value, "\""));
                }
            }
            function escape(value) {
                return JSON.stringify(value);
            }
            function format(value, quote) {
                if (quote === void 0) { quote = false; }
                if (value === null) {
                    return "null";
                }
                if (typeof value === "number") {
                    return value.toString();
                }
                if (typeof value === "string") {
                    return quote ? escape(value) : value;
                }
                if (Array.isArray(value)) {
                    var content = value.map(function (it) { return format(it, true); }).join(", ");
                    return "[ ".concat(content, " ]");
                }
                if (typeof value === "object") {
                    var content = Object.entries(value)
                        .map(function (_1) {
                        var key = _1[0], nested = _1[1];
                        return "".concat(key, ": ").concat(format(nested, true));
                    })
                        .join(", ");
                    return "{ ".concat(content, " }");
                }
                return String(value);
            }
            /**
             * Replaces placeholder `{{ ... }}` with values from given object.
             *
             * @internal
             */
            function interpolate(text, data) {
                return text.replace(/{{\s*([^\s{}]+)\s*}}/g, function (match, key) {
                    return typeof data[key] !== "undefined" ? format(data[key]) : match;
                });
            }
            var patternCache = new Map();
            function compileStringPattern(pattern) {
                var regexp = pattern.replace(/[*]+/g, ".+");
                /* eslint-disable-next-line security/detect-non-literal-regexp -- technical debt, should do input sanitation and precompilation */
                return new RegExp("^".concat(regexp, "$"));
            }
            function compileRegExpPattern(pattern) {
                /* eslint-disable-next-line security/detect-non-literal-regexp -- technical debt, should do input sanitation and precompilation */
                return new RegExp("^".concat(pattern, "$"));
            }
            function compilePattern(pattern) {
                var cached = patternCache.get(pattern);
                if (cached) {
                    return cached;
                }
                var match = pattern.match(/^\/(.*)\/$/);
                var regexp = match ? compileRegExpPattern(match[1]) : compileStringPattern(pattern);
                patternCache.set(pattern, regexp);
                return regexp;
            }
            /**
             * @internal
             */
            function keywordPatternMatcher(list, keyword) {
                for (var _1 = 0, list_1 = list; _1 < list_1.length; _1++) {
                    var pattern = list_1[_1];
                    var regexp_1 = compilePattern(pattern);
                    if (regexp_1.test(keyword)) {
                        return true;
                    }
                }
                return false;
            }
            /**
             * @internal
             */
            function isKeywordIgnored(options, keyword, matcher) {
                if (matcher === void 0) { matcher = function (list, it) { return list.includes(it); }; }
                var include = options.include, exclude = options.exclude;
                /* ignore keyword if not present in "include" */
                if (include && !matcher(include, keyword)) {
                    return true;
                }
                /* ignore keyword if present in "excludes" */
                if (exclude && matcher(exclude, keyword)) {
                    return true;
                }
                return false;
            }
            var ARIA_HIDDEN_CACHE = Symbol(isAriaHidden.name);
            var HTML_HIDDEN_CACHE = Symbol(isHTMLHidden.name);
            var ROLE_PRESENTATION_CACHE = Symbol(isPresentation.name);
            /**
             * Tests if this element is present in the accessibility tree.
             *
             * In practice it tests whenever the element or its parents has
             * `role="presentation"` or `aria-hidden="false"`. Dynamic values counts as
             * visible since the element might be in the visibility tree sometimes.
             */
            function inAccessibilityTree(node) {
                return !isAriaHidden(node) && !isPresentation(node);
            }
            function isAriaHiddenImpl(node) {
                var isHidden = function (node) {
                    var ariaHidden = node.getAttribute("aria-hidden");
                    return Boolean(ariaHidden && ariaHidden.value === "true");
                };
                return {
                    byParent: node.parent ? isAriaHidden(node.parent) : false,
                    bySelf: isHidden(node)
                };
            }
            function isAriaHidden(node, details) {
                var cached = node.cacheGet(ARIA_HIDDEN_CACHE);
                if (cached) {
                    return details ? cached : cached.byParent || cached.bySelf;
                }
                var result = node.cacheSet(ARIA_HIDDEN_CACHE, isAriaHiddenImpl(node));
                return details ? result : result.byParent || result.bySelf;
            }
            function isHTMLHiddenImpl(node) {
                var isHidden = function (node) {
                    var hidden = node.getAttribute("hidden");
                    return hidden !== null && hidden.isStatic;
                };
                return {
                    byParent: node.parent ? isHTMLHidden(node.parent) : false,
                    bySelf: isHidden(node)
                };
            }
            function isHTMLHidden(node, details) {
                var cached = node.cacheGet(HTML_HIDDEN_CACHE);
                if (cached) {
                    return details ? cached : cached.byParent || cached.bySelf;
                }
                var result = node.cacheSet(HTML_HIDDEN_CACHE, isHTMLHiddenImpl(node));
                return details ? result : result.byParent || result.bySelf;
            }
            /**
             * Tests if this element or a parent element has role="presentation".
             *
             * Dynamic values yields `false` just as if the attribute wasn't present.
             */
            function isPresentation(node) {
                if (node.cacheExists(ROLE_PRESENTATION_CACHE)) {
                    return Boolean(node.cacheGet(ROLE_PRESENTATION_CACHE));
                }
                var cur = node;
                do {
                    var role = cur.getAttribute("role");
                    /* role="presentation" */
                    if (role && role.value === "presentation") {
                        return cur.cacheSet(ROLE_PRESENTATION_CACHE, true);
                    }
                    /* sanity check: break if no parent is present, normally not an issue as the
                     * root element should be found first */
                    if (!cur.parent) {
                        break;
                    }
                    /* check parents */
                    cur = cur.parent;
                } while (!cur.isRootElement());
                return node.cacheSet(ROLE_PRESENTATION_CACHE, false);
            }
            var cachePrefix = classifyNodeText.name;
            var HTML_CACHE_KEY = Symbol("".concat(cachePrefix, "|html"));
            var A11Y_CACHE_KEY = Symbol("".concat(cachePrefix, "|a11y"));
            var IGNORE_HIDDEN_ROOT_HTML_CACHE_KEY = Symbol("".concat(cachePrefix, "|html|ignore-hidden-root"));
            var IGNORE_HIDDEN_ROOT_A11Y_CACHE_KEY = Symbol("".concat(cachePrefix, "|a11y|ignore-hidden-root"));
            /**
             * @public
             */
            exports.TextClassification = void 0;
            (function (TextClassification) {
                TextClassification[TextClassification["EMPTY_TEXT"] = 0] = "EMPTY_TEXT";
                TextClassification[TextClassification["DYNAMIC_TEXT"] = 1] = "DYNAMIC_TEXT";
                TextClassification[TextClassification["STATIC_TEXT"] = 2] = "STATIC_TEXT";
            })(exports.TextClassification || (exports.TextClassification = {}));
            /**
             * @internal
             */
            function getCachekey(options) {
                var _1 = options.accessible, accessible = _1 === void 0 ? false : _1, _2 = options.ignoreHiddenRoot, ignoreHiddenRoot = _2 === void 0 ? false : _2;
                if (accessible && ignoreHiddenRoot) {
                    return IGNORE_HIDDEN_ROOT_A11Y_CACHE_KEY;
                }
                else if (ignoreHiddenRoot) {
                    return IGNORE_HIDDEN_ROOT_HTML_CACHE_KEY;
                }
                else if (accessible) {
                    return A11Y_CACHE_KEY;
                }
                else {
                    return HTML_CACHE_KEY;
                }
            }
            /* While I cannot find a reference about this in the standard the <select>
             * element kinda acts as if there is no text content, most particularly it
             * doesn't receive and accessible name. The `.textContent` property does
             * however include the <option> childrens text. But for the sake of the
             * validator it is probably best if the classification acts as if there is no
             * text as I think that is what is expected of the return values. Might have
             * to revisit this at some point or if someone could clarify what section of
             * the standard deals with this. */
            function isSpecialEmpty(node) {
                return node.is("select") || node.is("textarea");
            }
            /**
             * Checks text content of an element.
             *
             * Any text is considered including text from descendant elements. Whitespace is
             * ignored.
             *
             * If any text is dynamic `TextClassification.DYNAMIC_TEXT` is returned.
             *
             * @public
             */
            function classifyNodeText(node, options) {
                if (options === void 0) { options = {}; }
                var _1 = options.accessible, accessible = _1 === void 0 ? false : _1, _2 = options.ignoreHiddenRoot, ignoreHiddenRoot = _2 === void 0 ? false : _2;
                var cacheKey = getCachekey(options);
                if (node.cacheExists(cacheKey)) {
                    return node.cacheGet(cacheKey); // eslint-disable-line @typescript-eslint/no-non-null-assertion -- has/get combo
                }
                if (!ignoreHiddenRoot && isHTMLHidden(node)) {
                    return node.cacheSet(cacheKey, exports.TextClassification.EMPTY_TEXT);
                }
                if (!ignoreHiddenRoot && accessible && isAriaHidden(node)) {
                    return node.cacheSet(cacheKey, exports.TextClassification.EMPTY_TEXT);
                }
                if (isSpecialEmpty(node)) {
                    return node.cacheSet(cacheKey, exports.TextClassification.EMPTY_TEXT);
                }
                var text = findTextNodes(node, __assign(__assign({}, options), { ignoreHiddenRoot: false }));
                /* if any text is dynamic classify as dynamic */
                if (text.some(function (cur) { return cur.isDynamic; })) {
                    return node.cacheSet(cacheKey, exports.TextClassification.DYNAMIC_TEXT);
                }
                /* if any text has non-whitespace character classify as static */
                if (text.some(function (cur) { return cur.textContent.match(/\S/) !== null; })) {
                    return node.cacheSet(cacheKey, exports.TextClassification.STATIC_TEXT);
                }
                /* default to empty */
                return node.cacheSet(cacheKey, exports.TextClassification.EMPTY_TEXT);
            }
            function findTextNodes(node, options) {
                var _1 = options.accessible, accessible = _1 === void 0 ? false : _1;
                var text = [];
                for (var _2 = 0, _3 = node.childNodes; _2 < _3.length; _2++) {
                    var child = _3[_2];
                    if (isTextNode(child)) {
                        text.push(child);
                    }
                    else if (isElementNode(child)) {
                        if (isHTMLHidden(child, true).bySelf) {
                            continue;
                        }
                        if (accessible && isAriaHidden(child, true).bySelf) {
                            continue;
                        }
                        text = text.concat(findTextNodes(child, options));
                    }
                }
                return text;
            }
            function hasAltText(image) {
                var alt = image.getAttribute("alt");
                /* missing attribute */
                if (!alt) {
                    return false;
                }
                /* (incorrectly) set as boolean value */
                if (alt.value === null) {
                    return false;
                }
                return alt.isDynamic || alt.value.toString() !== "";
            }
            function hasAriaLabel(node) {
                var label = node.getAttribute("aria-label");
                /* missing attribute */
                if (!label) {
                    return false;
                }
                /* (incorrectly) set as boolean value */
                if (label.value === null) {
                    return false;
                }
                return label.isDynamic || label.value.toString() !== "";
            }
            /**
             * Partition an array to two new lists based on the result of a
             * predicate. Similar to `Array.filter` but returns both matching and
             * non-matching in the same call.
             *
             * Elements matching the predicate is placed in the first array and elements not
             * matching is placed in the second.
             *
             * @public
             * @param values - The array of values to partition.
             * @param predicate - A predicate function taking a single element and returning
             * a boolean.
             * @returns - Two arrays where the first contains all elements where the
             * predicate matched and second contains the rest of the elements.
             */
            function partition(values, predicate) {
                var initial = [[], []];
                return values.reduce(function (accumulator, value, index) {
                    var match = predicate(value, index, values);
                    accumulator[match ? 0 : 1].push(value);
                    return accumulator;
                }, initial);
            }
            var remapEvents = {
                "tag:open": "tag:start",
                "tag:close": "tag:end"
            };
            var ajv$1 = new Ajv__default["default"]({ strict: true, strictTuples: true, strictTypes: true });
            ajv$1.addMetaSchema(ajvSchemaDraft);
            /**
             * Get (cached) schema validator for rule options.
             *
             * @param ruleId - Rule ID used as key for schema lookups.
             * @param properties - Uncompiled schema.
             */
            function getSchemaValidator(ruleId, properties) {
                var $id = "rule/".concat(ruleId);
                var cached = ajv$1.getSchema($id);
                if (cached) {
                    return cached;
                }
                var schema = {
                    $id: $id,
                    type: "object",
                    additionalProperties: false,
                    properties: properties
                };
                return ajv$1.compile(schema);
            }
            function isErrorDescriptor(value) {
                return Boolean(value[0] && value[0].message);
            }
            function unpackErrorDescriptor(value) {
                if (isErrorDescriptor(value)) {
                    return value[0];
                }
                else {
                    var node = value[0], message = value[1], location_4 = value[2], context = value[3];
                    return { node: node, message: message, location: location_4, context: context };
                }
            }
            /**
             * @public
             */
            var Rule = /** @class */ (function () {
                function Rule(options) {
                    /* faux initialization, properly initialized by init(). This is to keep TS happy without adding null-checks everywhere */
                    this.reporter = null;
                    this.parser = null;
                    this.meta = null;
                    this.event = null;
                    this.options = options;
                    this.enabled = true;
                    this.blockers = [];
                    this.severity = exports.Severity.DISABLED;
                    this.name = "";
                }
                Rule.prototype.getSeverity = function () {
                    return this.severity;
                };
                Rule.prototype.setServerity = function (severity) {
                    this.severity = severity;
                };
                /**
                 * Block this rule from generating errors. Pass in an id generated by
                 * `createBlocker`. Can be unblocked by {@link Rule.unblock}.
                 *
                 * A blocked rule is similar to disabling it but it will still receive parser
                 * events. A list of all blockers is passed to the `rule:error` event.
                 *
                 * @internal
                 */
                Rule.prototype.block = function (id) {
                    this.blockers.push(id);
                };
                /**
                 * Unblock a rule previously blocked by {@link Rule.block}.
                 *
                 * @internal
                 */
                Rule.prototype.unblock = function (id) {
                    this.blockers = this.blockers.filter(function (it) { return it !== id; });
                };
                Rule.prototype.setEnabled = function (enabled) {
                    this.enabled = enabled;
                };
                Object.defineProperty(Rule.prototype, "deprecated", {
                    /**
                     * Returns `true` if rule is deprecated.
                     *
                     * Overridden by subclasses.
                     */
                    get: function () {
                        return false;
                    },
                    enumerable: false,
                    configurable: true
                });
                /**
                 * Test if rule is enabled.
                 *
                 * To be considered enabled the enabled flag must be true and the severity at
                 * least warning.
                 *
                 * @internal
                 */
                Rule.prototype.isEnabled = function (node) {
                    return this.enabled && this.severity >= exports.Severity.WARN && (!node || node.ruleEnabled(this.name));
                };
                /**
                 * Test if rule is enabled.
                 *
                 * To be considered enabled the enabled flag must be true and the severity at
                 * least warning.
                 *
                 * @internal
                 */
                Rule.prototype.isBlocked = function (node) {
                    if (this.blockers.length > 0) {
                        return true;
                    }
                    if (node && node.ruleBlockers(this.name).length > 0) {
                        return true;
                    }
                    return false;
                };
                /**
                 * Get a list of all blockers currently active this rule.
                 *
                 * @internal
                 */
                Rule.prototype.getBlockers = function (node) {
                    return __spreadArray(__spreadArray([], this.blockers, true), (node ? node.ruleBlockers(this.name) : []), true);
                };
                /**
                 * Check if keyword is being ignored by the current rule configuration.
                 *
                 * This method requires the [[RuleOption]] type to include two properties:
                 *
                 * - include: string[] | null
                 * - exclude: string[] | null
                 *
                 * This methods checks if the given keyword is included by "include" but not
                 * excluded by "exclude". If any property is unset it is skipped by the
                 * condition. Usually the user would use either one but not both but there is
                 * no limitation to use both but the keyword must satisfy both conditions. If
                 * either condition fails `true` is returned.
                 *
                 * For instance, given `{ include: ["foo"] }` the keyword `"foo"` would match
                 * but not `"bar"`.
                 *
                 * Similarly, given `{ exclude: ["foo"] }` the keyword `"bar"` would match but
                 * not `"foo"`.
                 *
                 * @param keyword - Keyword to match against `include` and `exclude` options.
                 * @param matcher - Optional function to compare items with.
                 * @returns `true` if keyword is not present in `include` or is present in
                 * `exclude`.
                 */
                Rule.prototype.isKeywordIgnored = function (keyword, matcher) {
                    if (matcher === void 0) { matcher = function (list, it) { return list.includes(it); }; }
                    return isKeywordIgnored(this.options, keyword, matcher);
                };
                /**
                 * Get [[MetaElement]] for the given tag. If no specific metadata is present
                 * the global metadata is returned or null if no global is present.
                 *
                 * @public
                 * @returns A shallow copy of metadata.
                 */
                Rule.prototype.getMetaFor = function (tagName) {
                    return this.meta.getMetaFor(tagName);
                };
                /**
                 * Find all tags which has enabled given property.
                 */
                Rule.prototype.getTagsWithProperty = function (propName) {
                    return this.meta.getTagsWithProperty(propName);
                };
                /**
                 * Find tag matching tagName or inheriting from it.
                 */
                Rule.prototype.getTagsDerivedFrom = function (tagName) {
                    return this.meta.getTagsDerivedFrom(tagName);
                };
                /**
                 * JSON schema for rule options.
                 *
                 * Rules should override this to return an object with JSON schema to validate
                 * rule options. If `null` or `undefined` is returned no validation is
                 * performed.
                 */
                Rule.schema = function () {
                    return null;
                };
                Rule.prototype.report = function () {
                    var args = [];
                    for (var _1 = 0; _1 < arguments.length; _1++) {
                        args[_1] = arguments[_1];
                    }
                    var _2 = unpackErrorDescriptor(args), node = _2.node, message = _2.message, location = _2.location, context = _2.context;
                    var enabled = this.isEnabled(node);
                    var blocked = this.isBlocked(node);
                    var where = this.findLocation({ node: node, location: location, event: this.event });
                    this.parser.trigger("rule:error", {
                        location: where,
                        ruleId: this.name,
                        enabled: enabled,
                        blockers: this.getBlockers(node)
                    });
                    if (enabled && !blocked) {
                        var interpolated = interpolate(message, context !== null && context !== void 0 ? context : {});
                        this.reporter.add(this, interpolated, this.severity, node, where, context);
                    }
                };
                Rule.prototype.findLocation = function (src) {
                    var _a, _b;
                    if (src.location) {
                        return src.location;
                    }
                    if ((_a = src.event) === null || _a === void 0 ? void 0 : _a.location) {
                        return src.event.location;
                    }
                    if ((_b = src.node) === null || _b === void 0 ? void 0 : _b.location) {
                        return src.node.location;
                    }
                    return {};
                };
                Rule.prototype.on = function (event) {
                    var _this_1 = this;
                    var args = [];
                    for (var _1 = 1; _1 < arguments.length; _1++) {
                        args[_1 - 1] = arguments[_1];
                    }
                    var _a;
                    /* handle deprecated aliases */
                    var remap = remapEvents[event];
                    if (remap) {
                        event = remap;
                    }
                    var callback = args.pop();
                    var filter = (_a = args.pop()) !== null && _a !== void 0 ? _a : (function () { return true; });
                    return this.parser.on(event, function (_event, data) {
                        if (_this_1.isEnabled() && filter(data)) {
                            _this_1.event = data;
                            callback(data);
                        }
                    });
                };
                /**
                 * Called by [[Engine]] when initializing the rule.
                 *
                 * Do not override this, use the `setup` callback instead.
                 *
                 * @internal
                 */
                Rule.prototype.init = function (parser, reporter, severity, meta) {
                    this.parser = parser;
                    this.reporter = reporter;
                    this.severity = severity;
                    this.meta = meta;
                };
                /**
                 * Validate rule options against schema. Throws error if object does not validate.
                 *
                 * For rules without schema this function does nothing.
                 *
                 * @throws {@link SchemaValidationError}
                 * Thrown when provided options does not validate against rule schema.
                 *
                 * @param cls - Rule class (constructor)
                 * @param ruleId - Rule identifier
                 * @param jsonPath - JSON path from which [[options]] can be found in [[config]]
                 * @param options - User configured options to be validated
                 * @param filename - Filename from which options originated
                 * @param config - Configuration from which options originated
                 *
                 * @internal
                 */
                Rule.validateOptions = function (cls, ruleId, jsonPath, options, filename, config) {
                    var _a;
                    if (!cls) {
                        return;
                    }
                    var schema = cls.schema();
                    if (!schema) {
                        return;
                    }
                    var isValid = getSchemaValidator(ruleId, schema);
                    if (!isValid(options)) {
                        /* istanbul ignore next: it is always set when validation fails */
                        var errors = (_a = isValid.errors) !== null && _a !== void 0 ? _a : [];
                        var mapped = errors.map(function (error) {
                            error.instancePath = "".concat(jsonPath).concat(error.instancePath);
                            return error;
                        });
                        throw new SchemaValidationError(filename, "Rule configuration error", config, schema, mapped);
                    }
                };
                /**
                 * Rule documentation callback.
                 *
                 * Called when requesting additional documentation for a rule. Some rules
                 * provide additional context to provide context-aware suggestions.
                 *
                 * @public
                 * @virtual
                 * @param context - Error context given by a reported error.
                 * @returns Rule documentation and url with additional details or `null` if no
                 * additional documentation is available.
                 */
                /* eslint-disable-next-line @typescript-eslint/no-unused-vars -- technical debt, prototype should be moved to interface */
                Rule.prototype.documentation = function (context) {
                    return null;
                };
                return Rule;
            }());
            var Style$1;
            (function (Style) {
                Style["EXTERNAL"] = "external";
                Style["RELATIVE_BASE"] = "relative-base";
                Style["RELATIVE_PATH"] = "relative-path";
                Style["ABSOLUTE"] = "absolute";
                Style["ANCHOR"] = "anchor";
            })(Style$1 || (Style$1 = {}));
            var defaults$u = {
                allowExternal: true,
                allowRelative: true,
                allowAbsolute: true,
                allowBase: true
            };
            var mapping = {
                a: "href",
                img: "src",
                link: "href",
                script: "src"
            };
            var description = (_1 = {},
                _1[Style$1.EXTERNAL] = "External links are not allowed by current configuration.",
                _1[Style$1.RELATIVE_BASE] = "Links relative to <base> are not allowed by current configuration.",
                _1[Style$1.RELATIVE_PATH] = "Relative links are not allowed by current configuration.",
                _1[Style$1.ABSOLUTE] = "Absolute links are not allowed by current configuration.",
                _1[Style$1.ANCHOR] = null,
                _1);
            function parseAllow(value) {
                if (typeof value === "boolean") {
                    return value;
                }
                return {
                    /* eslint-disable security/detect-non-literal-regexp -- expected to be regexp  */
                    include: value.include ? value.include.map(function (it) { return new RegExp(it); }) : null,
                    exclude: value.exclude ? value.exclude.map(function (it) { return new RegExp(it); }) : null
                };
            }
            /**
             * @internal
             */
            function matchList(value, list) {
                if (list.include && !list.include.some(function (it) { return it.test(value); })) {
                    return false;
                }
                if (list.exclude && list.exclude.some(function (it) { return it.test(value); })) {
                    return false;
                }
                return true;
            }
            var AllowedLinks = /** @class */ (function (_super) {
                __extends(AllowedLinks, _super);
                function AllowedLinks(options) {
                    var _this_1 = _super.call(this, __assign(__assign({}, defaults$u), options)) || this;
                    _this_1.allowExternal = parseAllow(_this_1.options.allowExternal);
                    _this_1.allowRelative = parseAllow(_this_1.options.allowRelative);
                    _this_1.allowAbsolute = parseAllow(_this_1.options.allowAbsolute);
                    return _this_1;
                }
                AllowedLinks.schema = function () {
                    var booleanOrObject = {
                        anyOf: [
                            { type: "boolean" },
                            {
                                type: "object",
                                properties: {
                                    include: {
                                        type: "array",
                                        items: { type: "string" }
                                    },
                                    exclude: {
                                        type: "array",
                                        items: { type: "string" }
                                    }
                                }
                            },
                        ]
                    };
                    return {
                        allowExternal: __assign({}, booleanOrObject),
                        allowRelative: __assign({}, booleanOrObject),
                        allowAbsolute: __assign({}, booleanOrObject),
                        allowBase: { type: "boolean" }
                    };
                };
                AllowedLinks.prototype.documentation = function (context) {
                    var _a;
                    var message = (_a = description[context]) !== null && _a !== void 0 ? _a : "This link type is not allowed by current configuration";
                    return {
                        description: message,
                        url: "https://html-validate.org/rules/allowed-links.html"
                    };
                };
                AllowedLinks.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("attr", function (event) {
                        if (!event.value || !_this_1.isRelevant(event)) {
                            return;
                        }
                        var link = event.value.toString();
                        var style = _this_1.getStyle(link);
                        switch (style) {
                            case Style$1.ANCHOR:
                                /* anchor links are always allowed by this rule */
                                break;
                            case Style$1.ABSOLUTE:
                                _this_1.handleAbsolute(link, event, style);
                                break;
                            case Style$1.EXTERNAL:
                                _this_1.handleExternal(link, event, style);
                                break;
                            case Style$1.RELATIVE_BASE:
                                _this_1.handleRelativeBase(link, event, style);
                                break;
                            case Style$1.RELATIVE_PATH:
                                _this_1.handleRelativePath(link, event, style);
                                break;
                        }
                    });
                };
                AllowedLinks.prototype.isRelevant = function (event) {
                    var target = event.target, key = event.key, value = event.value;
                    /* don't check links with dynamic values */
                    if (value instanceof DynamicValue) {
                        return false;
                    }
                    var attr = mapping[target.tagName];
                    return Boolean(attr && attr === key);
                };
                AllowedLinks.prototype.getStyle = function (value) {
                    /* http://example.net or //example.net */
                    if (value.match(/^([a-z]+:)?\/\//g)) {
                        return Style$1.EXTERNAL;
                    }
                    switch (value[0]) {
                        /* /foo/bar */
                        case "/":
                            return Style$1.ABSOLUTE;
                        /* ../foo/bar */
                        case ".":
                            return Style$1.RELATIVE_PATH;
                        /* #foo */
                        case "#":
                            return Style$1.ANCHOR;
                        /* foo/bar */
                        default:
                            return Style$1.RELATIVE_BASE;
                    }
                };
                AllowedLinks.prototype.handleAbsolute = function (target, event, style) {
                    var allowAbsolute = this.allowAbsolute;
                    if (allowAbsolute === true) {
                        return;
                    }
                    else if (allowAbsolute === false) {
                        this.report(event.target, "Link destination must not be absolute url", event.valueLocation, style);
                    }
                    else if (!matchList(target, allowAbsolute)) {
                        this.report(event.target, "Absolute link to this destination is not allowed by current configuration", event.valueLocation, style);
                    }
                };
                AllowedLinks.prototype.handleExternal = function (target, event, style) {
                    var allowExternal = this.allowExternal;
                    if (allowExternal === true) {
                        return;
                    }
                    else if (allowExternal === false) {
                        this.report(event.target, "Link destination must not be external url", event.valueLocation, style);
                    }
                    else if (!matchList(target, allowExternal)) {
                        this.report(event.target, "External link to this destination is not allowed by current configuration", event.valueLocation, style);
                    }
                };
                AllowedLinks.prototype.handleRelativePath = function (target, event, style) {
                    var allowRelative = this.allowRelative;
                    if (allowRelative === true) {
                        return false;
                    }
                    else if (allowRelative === false) {
                        this.report(event.target, "Link destination must not be relative url", event.valueLocation, style);
                        return true;
                    }
                    else if (!matchList(target, allowRelative)) {
                        this.report(event.target, "Relative link to this destination is not allowed by current configuration", event.valueLocation, style);
                        return true;
                    }
                    return false;
                };
                AllowedLinks.prototype.handleRelativeBase = function (target, event, style) {
                    var allowBase = this.options.allowBase;
                    if (this.handleRelativePath(target, event, style)) {
                        return;
                    }
                    else if (!allowBase) {
                        this.report(event.target, "Relative links must be relative to current folder", event.valueLocation, style);
                    }
                };
                return AllowedLinks;
            }(Rule));
            var RuleContext$1;
            (function (RuleContext) {
                RuleContext["MISSING_ALT"] = "missing-alt";
                RuleContext["MISSING_HREF"] = "missing-href";
            })(RuleContext$1 || (RuleContext$1 = {}));
            var defaults$t = {
                accessible: true
            };
            function findByTarget(target, siblings) {
                return siblings.filter(function (it) { return it.getAttributeValue("href") === target; });
            }
            function getAltText(node) {
                return node.getAttributeValue("alt");
            }
            function getDescription$1(context) {
                switch (context) {
                    case RuleContext$1.MISSING_ALT:
                        return [
                            "The `alt` attribute must be set (and not empty) when the `href` attribute is present on an `<area>` element.",
                            "",
                            "The attribute is used to provide an alternative text description for the area of the image map.",
                            "The text should describe the purpose of area and the resource referenced by the `href` attribute.",
                            "",
                            "Either add the `alt` attribute or remove the `href` attribute.",
                        ];
                    case RuleContext$1.MISSING_HREF:
                        return [
                            "The `alt` attribute must not be set when the `href` attribute is missing on an `<area>` element.",
                            "",
                            "Either add the `href` attribute or remove the `alt` attribute.",
                        ];
                }
            }
            var AreaAlt = /** @class */ (function (_super) {
                __extends(AreaAlt, _super);
                function AreaAlt(options) {
                    return _super.call(this, __assign(__assign({}, defaults$t), options)) || this;
                }
                AreaAlt.schema = function () {
                    return {
                        accessible: {
                            type: "boolean"
                        }
                    };
                };
                AreaAlt.prototype.documentation = function (context) {
                    return {
                        description: getDescription$1(context).join("\n"),
                        url: "https://html-validate.org/rules/area-alt.html"
                    };
                };
                AreaAlt.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("element:ready", this.isRelevant, function (event) {
                        var target = event.target;
                        var siblings = target.querySelectorAll("area");
                        for (var _1 = 0, siblings_1 = siblings; _1 < siblings_1.length; _1++) {
                            var child = siblings_1[_1];
                            _this_1.validateArea(child, siblings);
                        }
                    });
                };
                AreaAlt.prototype.validateArea = function (area, siblings) {
                    var accessible = this.options.accessible;
                    var href = area.getAttribute("href");
                    var alt = area.getAttribute("alt");
                    if (href) {
                        if (alt && alt.isDynamic) {
                            return;
                        }
                        var target = area.getAttributeValue("href");
                        var altTexts = accessible
                            ? [getAltText(area)]
                            : findByTarget(target, siblings).map(getAltText);
                        if (!altTexts.some(Boolean)) {
                            this.report({
                                node: area,
                                message: "\"alt\" attribute must be set and non-empty when the \"href\" attribute is present",
                                location: alt ? alt.keyLocation : href.keyLocation,
                                context: RuleContext$1.MISSING_ALT
                            });
                        }
                    }
                    else if (alt) {
                        this.report({
                            node: area,
                            message: "\"alt\" attribute cannot be used unless the \"href\" attribute is present",
                            location: alt.keyLocation,
                            context: RuleContext$1.MISSING_HREF
                        });
                    }
                };
                AreaAlt.prototype.isRelevant = function (event) {
                    var target = event.target;
                    return target.is("map");
                };
                return AreaAlt;
            }(Rule));
            var AriaHiddenBody = /** @class */ (function (_super) {
                __extends(AriaHiddenBody, _super);
                function AriaHiddenBody() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                AriaHiddenBody.prototype.documentation = function () {
                    return {
                        description: "`aria-hidden` must not be used on the `<body>` element as it makes the page inaccessible to assistive technology such as screenreaders",
                        url: "https://html-validate.org/rules/aria-hidden-body.html"
                    };
                };
                AriaHiddenBody.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("tag:ready", this.isRelevant, function (event) {
                        var target = event.target;
                        var attr = target.getAttribute("aria-hidden");
                        if (!attr || !attr.valueMatches("true", true)) {
                            return;
                        }
                        _this_1.report(target, "aria-hidden must not be used on <body>", attr.keyLocation);
                    });
                };
                AriaHiddenBody.prototype.isRelevant = function (event) {
                    return event.target.is("body");
                };
                return AriaHiddenBody;
            }(Rule));
            var whitelisted = [
                "main",
                "nav",
                "table",
                "td",
                "th",
                "aside",
                "header",
                "footer",
                "section",
                "article",
                "form",
                "img",
                "area",
                "fieldset",
                "summary",
                "figure",
            ];
            function isValidUsage(target, meta) {
                /* elements with explicit aria-label attribute are valid */
                var explicit = meta.attributes["aria-label"];
                if (explicit) {
                    return true;
                }
                /* landmark and other whitelisted elements are valid */
                if (whitelisted.includes(target.tagName)) {
                    return true;
                }
                /* elements with role are valid, @todo check if the role is widget or landmark */
                if (target.hasAttribute("role")) {
                    return true;
                }
                /* elements with tabindex (implicit interactive) are valid */
                if (target.hasAttribute("tabindex")) {
                    return true;
                }
                /* interactive and labelable elements are valid */
                if (Boolean(meta.interactive) || Boolean(meta.labelable)) {
                    return true;
                }
                return false;
            }
            var AriaLabelMisuse = /** @class */ (function (_super) {
                __extends(AriaLabelMisuse, _super);
                function AriaLabelMisuse() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                AriaLabelMisuse.prototype.documentation = function () {
                    var valid = [
                        "Interactive elements",
                        "Labelable elements",
                        "Landmark elements",
                        "Elements with roles inheriting from widget",
                        "`<area>`",
                        "`<form>` and `<fieldset>`",
                        "`<iframe>`",
                        "`<img>` and `<figure>`",
                        "`<summary>`",
                        "`<table>`, `<td>` and `<th>`",
                    ];
                    var lines = valid.map(function (it) { return "- ".concat(it, "\n"); }).join("");
                    return {
                        description: "`aria-label` can only be used on:\n\n".concat(lines),
                        url: "https://html-validate.org/rules/aria-label-misuse.html"
                    };
                };
                AriaLabelMisuse.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("dom:ready", function (event) {
                        var document = event.document;
                        for (var _1 = 0, _2 = document.querySelectorAll("[aria-label]"); _1 < _2.length; _1++) {
                            var target = _2[_1];
                            _this_1.validateElement(target);
                        }
                    });
                };
                AriaLabelMisuse.prototype.validateElement = function (target) {
                    /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- the
                     * earier [aria-label] selector ensures this is always present */
                    var attr = target.getAttribute("aria-label");
                    if (!attr.value || attr.valueMatches("", false)) {
                        return;
                    }
                    /* ignore elements without meta */
                    var meta = target.meta;
                    if (!meta) {
                        return;
                    }
                    /* ignore elements which is valid usage */
                    if (isValidUsage(target, meta)) {
                        return;
                    }
                    this.report(target, "\"aria-label\" cannot be used on this element", attr.keyLocation);
                };
                return AriaLabelMisuse;
            }(Rule));
            /**
             * @public
             */
            var ConfigError = /** @class */ (function (_super) {
                __extends(ConfigError, _super);
                function ConfigError(message, nested) {
                    var _this_1 = _super.call(this, message, nested) || this;
                    Error.captureStackTrace(_this_1, ConfigError);
                    _this_1.name = ConfigError.name;
                    return _this_1;
                }
                return ConfigError;
            }(UserError));
            /**
             * Represents casing for a name, e.g. lowercase, uppercase, etc.
             */
            var CaseStyle = /** @class */ (function () {
                /**
                 * @param style - Name of a valid case style.
                 */
                function CaseStyle(style, ruleId) {
                    if (!Array.isArray(style)) {
                        style = [style];
                    }
                    if (style.length === 0) {
                        throw new ConfigError("Missing style for ".concat(ruleId, " rule"));
                    }
                    this.styles = this.parseStyle(style, ruleId);
                }
                /**
                 * Test if a text matches this case style.
                 */
                CaseStyle.prototype.match = function (text) {
                    return this.styles.some(function (style) { return text.match(style.pattern); });
                };
                Object.defineProperty(CaseStyle.prototype, "name", {
                    get: function () {
                        var names = this.styles.map(function (style) { return style.name; });
                        switch (this.styles.length) {
                            case 1:
                                return names[0];
                            case 2:
                                return names.join(" or ");
                            default: {
                                var last = names.slice(-1);
                                var rest = names.slice(0, -1);
                                return "".concat(rest.join(", "), " or ").concat(last[0]);
                            }
                        }
                    },
                    enumerable: false,
                    configurable: true
                });
                CaseStyle.prototype.parseStyle = function (style, ruleId) {
                    return style.map(function (cur) {
                        switch (cur.toLowerCase()) {
                            case "lowercase":
                                return { pattern: /^[a-z]*$/, name: "lowercase" };
                            case "uppercase":
                                return { pattern: /^[A-Z]*$/, name: "uppercase" };
                            case "pascalcase":
                                return { pattern: /^[A-Z][A-Za-z]*$/, name: "PascalCase" };
                            case "camelcase":
                                return { pattern: /^[a-z][A-Za-z]*$/, name: "camelCase" };
                            default:
                                throw new ConfigError("Invalid style \"".concat(cur, "\" for ").concat(ruleId, " rule"));
                        }
                    });
                };
                return CaseStyle;
            }());
            var defaults$s = {
                style: "lowercase",
                ignoreForeign: true
            };
            var AttrCase = /** @class */ (function (_super) {
                __extends(AttrCase, _super);
                function AttrCase(options) {
                    var _this_1 = _super.call(this, __assign(__assign({}, defaults$s), options)) || this;
                    _this_1.style = new CaseStyle(_this_1.options.style, "attr-case");
                    return _this_1;
                }
                AttrCase.schema = function () {
                    var styleEnum = ["lowercase", "uppercase", "pascalcase", "camelcase"];
                    return {
                        ignoreForeign: {
                            type: "boolean"
                        },
                        style: {
                            anyOf: [
                                {
                                    "enum": styleEnum,
                                    type: "string"
                                },
                                {
                                    items: {
                                        "enum": styleEnum,
                                        type: "string"
                                    },
                                    type: "array"
                                },
                            ]
                        }
                    };
                };
                AttrCase.prototype.documentation = function () {
                    var style = this.options.style;
                    return {
                        description: Array.isArray(style)
                            ? __spreadArray(["Attribute name must be in one of:", ""], style.map(function (it) { return "- ".concat(it); }), true).join("\n")
                            : "Attribute name must be in ".concat(style, "."),
                        url: "https://html-validate.org/rules/attr-case.html"
                    };
                };
                AttrCase.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("attr", function (event) {
                        if (_this_1.isIgnored(event.target)) {
                            return;
                        }
                        /* ignore case for dynamic attributes, the original attributes will be
                         * checked instead (this prevents duplicated errors for the same source
                         * attribute) */
                        if (event.originalAttribute) {
                            return;
                        }
                        var letters = event.key.replace(/[^a-z]+/gi, "");
                        if (_this_1.style.match(letters)) {
                            return;
                        }
                        _this_1.report({
                            node: event.target,
                            message: "Attribute \"".concat(event.key, "\" should be ").concat(_this_1.style.name),
                            location: event.keyLocation
                        });
                    });
                };
                AttrCase.prototype.isIgnored = function (node) {
                    if (this.options.ignoreForeign) {
                        return Boolean(node.meta && node.meta.foreign);
                    }
                    else {
                        return false;
                    }
                };
                return AttrCase;
            }(Rule));
            /**
             * @internal
             */
            var TokenType;
            (function (TokenType) {
                TokenType[TokenType["UNICODE_BOM"] = 1] = "UNICODE_BOM";
                TokenType[TokenType["WHITESPACE"] = 2] = "WHITESPACE";
                TokenType[TokenType["DOCTYPE_OPEN"] = 3] = "DOCTYPE_OPEN";
                TokenType[TokenType["DOCTYPE_VALUE"] = 4] = "DOCTYPE_VALUE";
                TokenType[TokenType["DOCTYPE_CLOSE"] = 5] = "DOCTYPE_CLOSE";
                TokenType[TokenType["TAG_OPEN"] = 6] = "TAG_OPEN";
                TokenType[TokenType["TAG_CLOSE"] = 7] = "TAG_CLOSE";
                TokenType[TokenType["ATTR_NAME"] = 8] = "ATTR_NAME";
                TokenType[TokenType["ATTR_VALUE"] = 9] = "ATTR_VALUE";
                TokenType[TokenType["TEXT"] = 10] = "TEXT";
                TokenType[TokenType["TEMPLATING"] = 11] = "TEMPLATING";
                TokenType[TokenType["SCRIPT"] = 12] = "SCRIPT";
                TokenType[TokenType["STYLE"] = 13] = "STYLE";
                TokenType[TokenType["COMMENT"] = 14] = "COMMENT";
                TokenType[TokenType["CONDITIONAL"] = 15] = "CONDITIONAL";
                TokenType[TokenType["DIRECTIVE"] = 16] = "DIRECTIVE";
                TokenType[TokenType["EOF"] = 17] = "EOF";
            })(TokenType || (TokenType = {}));
            /* eslint-disable no-useless-escape -- false positives */
            var MATCH_UNICODE_BOM = /^\uFEFF/;
            var MATCH_WHITESPACE = /^(?:\r\n|\r|\n|[ \t]+(?:\r\n|\r|\n)?)/;
            var MATCH_DOCTYPE_OPEN = /^<!(DOCTYPE)\s/i;
            var MATCH_DOCTYPE_VALUE = /^[^>]+/;
            var MATCH_DOCTYPE_CLOSE = /^>/;
            var MATCH_XML_TAG = /^<\?xml.*?\?>\s+/;
            var MATCH_TAG_OPEN = /^<(\/?)([a-zA-Z0-9\-:]+)/; // https://www.w3.org/TR/html/syntax.html#start-tags
            var MATCH_TAG_CLOSE = /^\/?>/;
            var MATCH_TEXT = /^[^]*?(?=(?:[ \t]*(?:\r\n|\r|\n)|<[^ ]|$))/;
            var MATCH_TEMPLATING = /^(?:<%.*?%>|<\?.*?\?>|<\$.*?\$>)/s;
            var MATCH_TAG_LOOKAHEAD = /^[^]*?(?=<|$)/;
            var MATCH_ATTR_START = /^([^\t\r\n\f \/><"'=]+)/; // https://www.w3.org/TR/html/syntax.html#elements-attributes
            var MATCH_ATTR_SINGLE = /^(\s*=\s*)'([^']*?)(')/;
            var MATCH_ATTR_DOUBLE = /^(\s*=\s*)"([^"]*?)(")/;
            var MATCH_ATTR_UNQUOTED = /^(\s*=\s*)([^\t\r\n\f "'<>][^\t\r\n\f <>]*)/;
            var MATCH_CDATA_BEGIN = /^<!\[CDATA\[/;
            var MATCH_CDATA_END = /^[^]*?]]>/;
            var MATCH_SCRIPT_DATA = /^[^]*?(?=<\/script)/;
            var MATCH_SCRIPT_END = /^<(\/)(script)/;
            var MATCH_STYLE_DATA = /^[^]*?(?=<\/style)/;
            var MATCH_STYLE_END = /^<(\/)(style)/;
            var MATCH_DIRECTIVE = /^(<!--\s*\[html-validate-)([a-z0-9-]+)(\s*)(.*?)(]?\s*-->)/;
            var MATCH_COMMENT = /^<!--([^]*?)-->/;
            var MATCH_CONDITIONAL = /^<!\[([^\]]*?)\]>/;
            /* eslint-enable no-useless-escape */
            var InvalidTokenError = /** @class */ (function (_super) {
                __extends(InvalidTokenError, _super);
                function InvalidTokenError(location, message) {
                    var _this_1 = _super.call(this, message) || this;
                    _this_1.location = location;
                    return _this_1;
                }
                return InvalidTokenError;
            }(Error));
            var Lexer = /** @class */ (function () {
                function Lexer() {
                }
                /* eslint-disable-next-line complexity -- there isn't really a good way to refactor this while keeping readability */
                Lexer.prototype.tokenize = function (source) {
                    var context, previousState, previousLength, _1;
                    return __generator(this, function (_2) {
                        switch (_2.label) {
                            case 0:
                                context = new Context(source);
                                previousState = context.state;
                                previousLength = context.string.length;
                                _2.label = 1;
                            case 1:
                                if (!(context.string.length > 0)) return [3 /*break*/, 20];
                                _1 = context.state;
                                switch (_1) {
                                    case State.INITIAL: return [3 /*break*/, 2];
                                    case State.DOCTYPE: return [3 /*break*/, 4];
                                    case State.TAG: return [3 /*break*/, 6];
                                    case State.ATTR: return [3 /*break*/, 8];
                                    case State.TEXT: return [3 /*break*/, 10];
                                    case State.CDATA: return [3 /*break*/, 12];
                                    case State.SCRIPT: return [3 /*break*/, 14];
                                    case State.STYLE: return [3 /*break*/, 16];
                                }
                                return [3 /*break*/, 18];
                            case 2: return [5 /*yield**/, __values(this.tokenizeInitial(context))];
                            case 3:
                                _2.sent();
                                return [3 /*break*/, 19];
                            case 4: return [5 /*yield**/, __values(this.tokenizeDoctype(context))];
                            case 5:
                                _2.sent();
                                return [3 /*break*/, 19];
                            case 6: return [5 /*yield**/, __values(this.tokenizeTag(context))];
                            case 7:
                                _2.sent();
                                return [3 /*break*/, 19];
                            case 8: return [5 /*yield**/, __values(this.tokenizeAttr(context))];
                            case 9:
                                _2.sent();
                                return [3 /*break*/, 19];
                            case 10: return [5 /*yield**/, __values(this.tokenizeText(context))];
                            case 11:
                                _2.sent();
                                return [3 /*break*/, 19];
                            case 12: return [5 /*yield**/, __values(this.tokenizeCDATA(context))];
                            case 13:
                                _2.sent();
                                return [3 /*break*/, 19];
                            case 14: return [5 /*yield**/, __values(this.tokenizeScript(context))];
                            case 15:
                                _2.sent();
                                return [3 /*break*/, 19];
                            case 16: return [5 /*yield**/, __values(this.tokenizeStyle(context))];
                            case 17:
                                _2.sent();
                                return [3 /*break*/, 19];
                            case 18:
                                this.unhandled(context);
                                _2.label = 19;
                            case 19:
                                /* sanity check: state or string must change, if both are intact
                                 * we are stuck in an endless loop. */
                                /* istanbul ignore next: no easy way to test this as it is a condition which should never happen */
                                if (context.state === previousState && context.string.length === previousLength) {
                                    this.errorStuck(context);
                                }
                                previousState = context.state;
                                previousLength = context.string.length;
                                return [3 /*break*/, 1];
                            case 20: return [4 /*yield*/, this.token(context, TokenType.EOF, [])];
                            case 21:
                                _2.sent();
                                return [2 /*return*/];
                        }
                    });
                };
                Lexer.prototype.token = function (context, type, data) {
                    var size = data.length > 0 ? data[0].length : 0;
                    var location = context.getLocation(size);
                    return {
                        type: type,
                        location: location,
                        data: Array.from(data)
                    };
                };
                /* istanbul ignore next: used to provide a better error when an unhandled state happens */
                Lexer.prototype.unhandled = function (context) {
                    var truncated = JSON.stringify(context.string.length > 13 ? "".concat(context.string.slice(0, 15), "...") : context.string);
                    var state = State[context.state];
                    var message = "failed to tokenize ".concat(truncated, ", unhandled state ").concat(state, ".");
                    throw new InvalidTokenError(context.getLocation(1), message);
                };
                /* istanbul ignore next: used to provide a better error when lexer is detected to be stuck, no known way to reproduce */
                Lexer.prototype.errorStuck = function (context) {
                    var state = State[context.state];
                    var message = "failed to tokenize ".concat(context.getTruncatedLine(), ", state ").concat(state, " failed to consume data or change state.");
                    throw new InvalidTokenError(context.getLocation(1), message);
                };
                Lexer.prototype.evalNextState = function (nextState, token) {
                    if (typeof nextState === "function") {
                        return nextState(token);
                    }
                    else {
                        return nextState;
                    }
                };
                Lexer.prototype.match = function (context, tests, error) {
                    var n, i, _1, regex, nextState, tokenType, match, token, state, message;
                    return __generator(this, function (_2) {
                        switch (_2.label) {
                            case 0:
                                n = tests.length;
                                i = 0;
                                _2.label = 1;
                            case 1:
                                if (!(i < n)) return [3 /*break*/, 5];
                                _1 = tests[i], regex = _1[0], nextState = _1[1], tokenType = _1[2];
                                match = regex ? context.string.match(regex) : [""];
                                if (!match) return [3 /*break*/, 4];
                                token = null;
                                if (!(tokenType !== false)) return [3 /*break*/, 3];
                                token = this.token(context, tokenType, match);
                                return [4 /*yield*/, token];
                            case 2:
                                _2.sent();
                                _2.label = 3;
                            case 3:
                                state = this.evalNextState(nextState, token);
                                context.consume(match, state);
                                this.enter(context, state, match);
                                return [2 /*return*/];
                            case 4:
                                i++;
                                return [3 /*break*/, 1];
                            case 5:
                                message = "failed to tokenize ".concat(context.getTruncatedLine(), ", ").concat(error, ".");
                                throw new InvalidTokenError(context.getLocation(1), message);
                        }
                    });
                };
                /**
                 * Called when entering a new state.
                 */
                Lexer.prototype.enter = function (context, state, data) {
                    /* script/style tags require a different content model */
                    if (state === State.TAG && data && data[0].startsWith("<")) {
                        if (data[0] === "<script") {
                            context.contentModel = ContentModel.SCRIPT;
                        }
                        else if (data[0] === "<style") {
                            context.contentModel = ContentModel.STYLE;
                        }
                        else {
                            context.contentModel = ContentModel.TEXT;
                        }
                    }
                };
                Lexer.prototype.tokenizeInitial = function (context) {
                    return __generator(this, function (_1) {
                        switch (_1.label) {
                            case 0: return [5 /*yield**/, __values(this.match(context, [
                                    [MATCH_UNICODE_BOM, State.INITIAL, TokenType.UNICODE_BOM],
                                    [MATCH_XML_TAG, State.INITIAL, false],
                                    [MATCH_DOCTYPE_OPEN, State.DOCTYPE, TokenType.DOCTYPE_OPEN],
                                    [MATCH_WHITESPACE, State.INITIAL, TokenType.WHITESPACE],
                                    [MATCH_DIRECTIVE, State.INITIAL, TokenType.DIRECTIVE],
                                    [MATCH_CONDITIONAL, State.INITIAL, TokenType.CONDITIONAL],
                                    [MATCH_COMMENT, State.INITIAL, TokenType.COMMENT],
                                    [false, State.TEXT, false],
                                ], "expected doctype"))];
                            case 1:
                                _1.sent();
                                return [2 /*return*/];
                        }
                    });
                };
                Lexer.prototype.tokenizeDoctype = function (context) {
                    return __generator(this, function (_1) {
                        switch (_1.label) {
                            case 0: return [5 /*yield**/, __values(this.match(context, [
                                    [MATCH_WHITESPACE, State.DOCTYPE, TokenType.WHITESPACE],
                                    [MATCH_DOCTYPE_VALUE, State.DOCTYPE, TokenType.DOCTYPE_VALUE],
                                    [MATCH_DOCTYPE_CLOSE, State.TEXT, TokenType.DOCTYPE_CLOSE],
                                ], "expected doctype name"))];
                            case 1:
                                _1.sent();
                                return [2 /*return*/];
                        }
                    });
                };
                Lexer.prototype.tokenizeTag = function (context) {
                    function nextState(token) {
                        var tagCloseToken = token;
                        switch (context.contentModel) {
                            case ContentModel.TEXT:
                                return State.TEXT;
                            case ContentModel.SCRIPT:
                                if (tagCloseToken && !tagCloseToken.data[0].startsWith("/")) {
                                    return State.SCRIPT;
                                }
                                else {
                                    return State.TEXT; /* <script/> (not legal but handle it anyway so the lexer doesn't choke on it) */
                                }
                            case ContentModel.STYLE:
                                if (tagCloseToken && !tagCloseToken.data[0].startsWith("/")) {
                                    return State.STYLE;
                                }
                                else {
                                    return State.TEXT; /* <style/> */
                                }
                        }
                    }
                    return __generator(this, function (_1) {
                        switch (_1.label) {
                            case 0: return [5 /*yield**/, __values(this.match(context, [
                                    [MATCH_TAG_CLOSE, nextState, TokenType.TAG_CLOSE],
                                    [MATCH_ATTR_START, State.ATTR, TokenType.ATTR_NAME],
                                    [MATCH_WHITESPACE, State.TAG, TokenType.WHITESPACE],
                                ], 'expected attribute, ">" or "/>"'))];
                            case 1:
                                _1.sent();
                                return [2 /*return*/];
                        }
                    });
                };
                Lexer.prototype.tokenizeAttr = function (context) {
                    return __generator(this, function (_1) {
                        switch (_1.label) {
                            case 0: return [5 /*yield**/, __values(this.match(context, [
                                    [MATCH_ATTR_SINGLE, State.TAG, TokenType.ATTR_VALUE],
                                    [MATCH_ATTR_DOUBLE, State.TAG, TokenType.ATTR_VALUE],
                                    [MATCH_ATTR_UNQUOTED, State.TAG, TokenType.ATTR_VALUE],
                                    [false, State.TAG, false],
                                ], 'expected attribute, ">" or "/>"'))];
                            case 1:
                                _1.sent();
                                return [2 /*return*/];
                        }
                    });
                };
                Lexer.prototype.tokenizeText = function (context) {
                    return __generator(this, function (_1) {
                        switch (_1.label) {
                            case 0: return [5 /*yield**/, __values(this.match(context, [
                                    [MATCH_WHITESPACE, State.TEXT, TokenType.WHITESPACE],
                                    [MATCH_CDATA_BEGIN, State.CDATA, false],
                                    [MATCH_DIRECTIVE, State.TEXT, TokenType.DIRECTIVE],
                                    [MATCH_CONDITIONAL, State.TEXT, TokenType.CONDITIONAL],
                                    [MATCH_COMMENT, State.TEXT, TokenType.COMMENT],
                                    [MATCH_TEMPLATING, State.TEXT, TokenType.TEMPLATING],
                                    [MATCH_TAG_OPEN, State.TAG, TokenType.TAG_OPEN],
                                    [MATCH_TEXT, State.TEXT, TokenType.TEXT],
                                    [MATCH_TAG_LOOKAHEAD, State.TEXT, TokenType.TEXT],
                                ], 'expected text or "<"'))];
                            case 1:
                                _1.sent();
                                return [2 /*return*/];
                        }
                    });
                };
                Lexer.prototype.tokenizeCDATA = function (context) {
                    return __generator(this, function (_1) {
                        switch (_1.label) {
                            case 0: return [5 /*yield**/, __values(this.match(context, [[MATCH_CDATA_END, State.TEXT, false]], "expected ]]>"))];
                            case 1:
                                _1.sent();
                                return [2 /*return*/];
                        }
                    });
                };
                Lexer.prototype.tokenizeScript = function (context) {
                    return __generator(this, function (_1) {
                        switch (_1.label) {
                            case 0: return [5 /*yield**/, __values(this.match(context, [
                                    [MATCH_SCRIPT_END, State.TAG, TokenType.TAG_OPEN],
                                    [MATCH_SCRIPT_DATA, State.SCRIPT, TokenType.SCRIPT],
                                ], "expected </script>"))];
                            case 1:
                                _1.sent();
                                return [2 /*return*/];
                        }
                    });
                };
                Lexer.prototype.tokenizeStyle = function (context) {
                    return __generator(this, function (_1) {
                        switch (_1.label) {
                            case 0: return [5 /*yield**/, __values(this.match(context, [
                                    [MATCH_STYLE_END, State.TAG, TokenType.TAG_OPEN],
                                    [MATCH_STYLE_DATA, State.STYLE, TokenType.STYLE],
                                ], "expected </style>"))];
                            case 1:
                                _1.sent();
                                return [2 /*return*/];
                        }
                    });
                };
                return Lexer;
            }());
            var whitespace = /(\s+)/;
            var AttrDelimiter = /** @class */ (function (_super) {
                __extends(AttrDelimiter, _super);
                function AttrDelimiter() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                AttrDelimiter.prototype.documentation = function () {
                    return {
                        description: "Attribute value must not be separated by whitespace.",
                        url: "https://html-validate.org/rules/attr-delimiter.html"
                    };
                };
                AttrDelimiter.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("token", function (event) {
                        var token = event.token;
                        if (token.type !== TokenType.ATTR_VALUE) {
                            return;
                        }
                        var delimiter = token.data[1];
                        var match = whitespace.exec(delimiter);
                        if (match) {
                            var location_5 = sliceLocation(event.location, 0, delimiter.length);
                            _this_1.report(null, "Attribute value must not be delimited by whitespace", location_5);
                        }
                    });
                };
                return AttrDelimiter;
            }(Rule));
            var DEFAULT_PATTERN = "[a-z0-9-:]+";
            var defaults$r = {
                pattern: DEFAULT_PATTERN,
                ignoreForeign: true
            };
            function generateRegexp(pattern) {
                if (Array.isArray(pattern)) {
                    /* eslint-disable-next-line security/detect-non-literal-regexp -- expected to be regexp */
                    return new RegExp("^(".concat(pattern.join("|"), ")$"), "i");
                }
                else {
                    /* eslint-disable-next-line security/detect-non-literal-regexp -- expected to be regexp  */
                    return new RegExp("^".concat(pattern, "$"), "i");
                }
            }
            function generateMessage(name, pattern) {
                if (Array.isArray(pattern)) {
                    var patterns = pattern.map(function (it) { return "/".concat(it, "/"); }).join(", ");
                    return "Attribute \"".concat(name, "\" should match one of [").concat(patterns, "]");
                }
                else {
                    return "Attribute \"".concat(name, "\" should match /").concat(pattern, "/");
                }
            }
            function generateDescription(name, pattern) {
                if (Array.isArray(pattern)) {
                    return __spreadArray([
                        "Attribute \"".concat(name, "\" should match one of the configured regular expressions:"),
                        ""
                    ], pattern.map(function (it) { return "- `/".concat(it, "/`"); }), true).join("\n");
                }
                else {
                    return "Attribute \"".concat(name, "\" should match the regular expression `/").concat(pattern, "/`");
                }
            }
            var AttrPattern = /** @class */ (function (_super) {
                __extends(AttrPattern, _super);
                function AttrPattern(options) {
                    var _this_1 = _super.call(this, __assign(__assign({}, defaults$r), options)) || this;
                    _this_1.pattern = generateRegexp(_this_1.options.pattern);
                    return _this_1;
                }
                AttrPattern.schema = function () {
                    return {
                        pattern: {
                            oneOf: [{ type: "array", items: { type: "string" }, minItems: 1 }, { type: "string" }]
                        },
                        ignoreForeign: {
                            type: "boolean"
                        }
                    };
                };
                AttrPattern.prototype.documentation = function (context) {
                    return {
                        description: generateDescription(context.attr, context.pattern),
                        url: "https://html-validate.org/rules/attr-pattern.html"
                    };
                };
                AttrPattern.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("attr", function (event) {
                        if (_this_1.isIgnored(event.target)) {
                            return;
                        }
                        /* ignore case for dynamic attributes, the original attributes will be
                         * checked instead (this prevents duplicated errors for the same source
                         * attribute) */
                        if (event.originalAttribute) {
                            return;
                        }
                        if (_this_1.pattern.test(event.key)) {
                            return;
                        }
                        var message = generateMessage(event.key, _this_1.options.pattern);
                        var context = {
                            attr: event.key,
                            pattern: _this_1.options.pattern
                        };
                        _this_1.report(event.target, message, event.keyLocation, context);
                    });
                };
                AttrPattern.prototype.isIgnored = function (node) {
                    if (this.options.ignoreForeign) {
                        return Boolean(node.meta && node.meta.foreign);
                    }
                    else {
                        return false;
                    }
                };
                return AttrPattern;
            }(Rule));
            var QuoteStyle;
            (function (QuoteStyle) {
                QuoteStyle["SINGLE_QUOTE"] = "'";
                QuoteStyle["DOUBLE_QUOTE"] = "\"";
                QuoteStyle["AUTO_QUOTE"] = "auto";
                QuoteStyle["ANY_QUOTE"] = "any";
            })(QuoteStyle || (QuoteStyle = {}));
            var defaults$q = {
                style: "auto",
                unquoted: false
            };
            function describeError(context) {
                switch (context.error) {
                    case "style":
                        return "Attribute `".concat(context.attr, "` must use `").concat(context.expected, "` instead of `").concat(context.actual, "`.");
                    case "unquoted":
                        return "Attribute `".concat(context.attr, "` must not be unquoted.");
                }
            }
            function describeStyle(style, unquoted) {
                var description = [];
                switch (style) {
                    case QuoteStyle.AUTO_QUOTE:
                        description.push("- quoted with double quotes `\"` unless the value contains double quotes in which case single quotes `'` should be used instead");
                        break;
                    case QuoteStyle.ANY_QUOTE:
                        description.push("- quoted with single quotes `'`");
                        description.push('- quoted with double quotes `"`');
                        break;
                    case QuoteStyle.SINGLE_QUOTE:
                    case QuoteStyle.DOUBLE_QUOTE: {
                        var name_13 = style === QuoteStyle.SINGLE_QUOTE ? "single" : "double";
                        description.push("- quoted with ".concat(name_13, " quotes `").concat(style, "`"));
                        break;
                    }
                }
                if (unquoted) {
                    description.push("- unquoted (if applicable)");
                }
                return "".concat(description.join(" or\n"), "\n");
            }
            var AttrQuotes = /** @class */ (function (_super) {
                __extends(AttrQuotes, _super);
                function AttrQuotes(options) {
                    var _this_1 = _super.call(this, __assign(__assign({}, defaults$q), options)) || this;
                    _this_1.style = parseStyle$3(_this_1.options.style);
                    return _this_1;
                }
                AttrQuotes.schema = function () {
                    return {
                        style: {
                            "enum": ["auto", "double", "single", "any"],
                            type: "string"
                        },
                        unquoted: {
                            type: "boolean"
                        }
                    };
                };
                AttrQuotes.prototype.documentation = function (context) {
                    var style = this.style;
                    var unquoted = this.options.unquoted;
                    var description = [
                        describeError(context),
                        "",
                        "Under the current configuration attributes must be:",
                        "",
                        describeStyle(style, unquoted),
                    ];
                    return {
                        description: description.join("\n"),
                        url: "https://html-validate.org/rules/attr-quotes.html"
                    };
                };
                AttrQuotes.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("attr", function (event) {
                        /* ignore attributes with no value */
                        if (event.value === null) {
                            return;
                        }
                        if (!event.quote) {
                            if (!_this_1.options.unquoted) {
                                var message = "Attribute \"".concat(event.key, "\" using unquoted value");
                                var context = {
                                    error: "unquoted",
                                    attr: event.key
                                };
                                _this_1.report(event.target, message, null, context);
                            }
                            return;
                        }
                        /* if the style is set to any we skip the rest of the rule as the only
                         * thing that matters is if the "unquoted" options triggers an error or
                         * not */
                        if (_this_1.style === QuoteStyle.ANY_QUOTE) {
                            return;
                        }
                        var expected = _this_1.resolveQuotemark(event.value.toString(), _this_1.style);
                        if (event.quote !== expected) {
                            var message = "Attribute \"".concat(event.key, "\" used ").concat(event.quote, " instead of expected ").concat(expected);
                            var context = {
                                error: "style",
                                attr: event.key,
                                actual: event.quote,
                                expected: expected
                            };
                            _this_1.report(event.target, message, null, context);
                        }
                    });
                };
                AttrQuotes.prototype.resolveQuotemark = function (value, style) {
                    if (style === QuoteStyle.AUTO_QUOTE) {
                        return value.includes('"') ? "'" : '"';
                    }
                    else {
                        return style;
                    }
                };
                return AttrQuotes;
            }(Rule));
            function parseStyle$3(style) {
                switch (style.toLowerCase()) {
                    case "auto":
                        return QuoteStyle.AUTO_QUOTE;
                    case "double":
                        return QuoteStyle.DOUBLE_QUOTE;
                    case "single":
                        return QuoteStyle.SINGLE_QUOTE;
                    case "any":
                        return QuoteStyle.ANY_QUOTE;
                    /* istanbul ignore next: covered by schema validation */
                    default:
                        throw new ConfigError("Invalid style \"".concat(style, "\" for \"attr-quotes\" rule"));
                }
            }
            var AttrSpacing = /** @class */ (function (_super) {
                __extends(AttrSpacing, _super);
                function AttrSpacing() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                AttrSpacing.prototype.documentation = function () {
                    return {
                        description: "No space between attributes. At least one whitespace character (commonly space) must be used to separate attributes.",
                        url: "https://html-validate.org/rules/attr-spacing.html"
                    };
                };
                AttrSpacing.prototype.setup = function () {
                    var _this_1 = this;
                    var previousToken;
                    this.on("token", function (event) {
                        if (event.type === TokenType.ATTR_NAME && previousToken !== TokenType.WHITESPACE) {
                            _this_1.report(null, "No space between attributes", event.location);
                        }
                        previousToken = event.type;
                    });
                };
                return AttrSpacing;
            }(Rule));
            function pick(attr) {
                var result = {};
                if (typeof attr["enum"] !== "undefined") {
                    result["enum"] = attr["enum"];
                }
                if (typeof attr.boolean !== "undefined") {
                    result.boolean = attr.boolean;
                }
                return result;
            }
            var AttributeAllowedValues = /** @class */ (function (_super) {
                __extends(AttributeAllowedValues, _super);
                function AttributeAllowedValues() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                AttributeAllowedValues.prototype.documentation = function (context) {
                    var docs = {
                        description: "Attribute has invalid value.",
                        url: "https://html-validate.org/rules/attribute-allowed-values.html"
                    };
                    if (!context) {
                        return docs;
                    }
                    var allowed = context.allowed, attribute = context.attribute, element = context.element, value = context.value;
                    if (allowed["enum"]) {
                        var allowedList = allowed["enum"].map(function (value) {
                            if (typeof value === "string") {
                                return "- `\"".concat(value, "\"`");
                            }
                            else {
                                return "- `".concat(value.toString(), "`");
                            }
                        });
                        docs.description = __spreadArray([
                            "The `<".concat(element, ">` element does not allow the attribute `").concat(attribute, "` to have the value `\"").concat(value, "\"`."),
                            "",
                            "It must match one of the following:",
                            ""
                        ], allowedList, true).join("\n");
                    }
                    else if (allowed.boolean) {
                        docs.description = "The `<".concat(context.element, ">` attribute `").concat(context.attribute, "` must be a boolean attribute, e.g. `<").concat(context.element, " ").concat(context.attribute, ">`");
                    }
                    return docs;
                };
                AttributeAllowedValues.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("dom:ready", function (event) {
                        var doc = event.document;
                        doc.visitDepthFirst(function (node) {
                            var meta = node.meta;
                            /* ignore rule if element has no meta or meta does not specify attribute
                             * allowed values */
                            if (!(meta === null || meta === void 0 ? void 0 : meta.attributes))
                                return;
                            for (var _1 = 0, _2 = node.attributes; _1 < _2.length; _1++) {
                                var attr = _2[_1];
                                if (Validator.validateAttribute(attr, meta.attributes)) {
                                    continue;
                                }
                                var value = attr.value ? attr.value.toString() : "";
                                var context = {
                                    element: node.tagName,
                                    attribute: attr.key,
                                    value: value,
                                    allowed: pick(meta.attributes[attr.key])
                                };
                                var message = _this_1.getMessage(attr);
                                var location_6 = _this_1.getLocation(attr);
                                _this_1.report(node, message, location_6, context);
                            }
                        });
                    });
                };
                AttributeAllowedValues.prototype.getMessage = function (attr) {
                    var key = attr.key, value = attr.value;
                    if (value !== null) {
                        return "Attribute \"".concat(key, "\" has invalid value \"").concat(value.toString(), "\"");
                    }
                    else {
                        return "Attribute \"".concat(key, "\" is missing value");
                    }
                };
                AttributeAllowedValues.prototype.getLocation = function (attr) {
                    if (attr.value !== null) {
                        return attr.valueLocation;
                    }
                    else {
                        return attr.keyLocation;
                    }
                };
                return AttributeAllowedValues;
            }(Rule));
            var defaults$p = {
                style: "omit"
            };
            var AttributeBooleanStyle = /** @class */ (function (_super) {
                __extends(AttributeBooleanStyle, _super);
                function AttributeBooleanStyle(options) {
                    var _this_1 = _super.call(this, __assign(__assign({}, defaults$p), options)) || this;
                    _this_1.hasInvalidStyle = parseStyle$2(_this_1.options.style);
                    return _this_1;
                }
                AttributeBooleanStyle.schema = function () {
                    return {
                        style: {
                            "enum": ["empty", "name", "omit"],
                            type: "string"
                        }
                    };
                };
                AttributeBooleanStyle.prototype.documentation = function () {
                    return {
                        description: "Require a specific style when writing boolean attributes.",
                        url: "https://html-validate.org/rules/attribute-boolean-style.html"
                    };
                };
                AttributeBooleanStyle.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("dom:ready", function (event) {
                        var doc = event.document;
                        doc.visitDepthFirst(function (node) {
                            var meta = node.meta;
                            /* ignore rule if element has no meta or meta does not specify attribute
                             * allowed values */
                            if (!(meta === null || meta === void 0 ? void 0 : meta.attributes))
                                return;
                            /* check all boolean attributes */
                            for (var _1 = 0, _2 = node.attributes; _1 < _2.length; _1++) {
                                var attr = _2[_1];
                                if (!_this_1.isBoolean(attr, meta.attributes))
                                    continue;
                                /* ignore attribute if it is aliased by a dynamic value,
                                 * e.g. ng-required or v-bind:required, since it will probably have a
                                 * value despite the target attribute is a boolean. The framework is
                                 * assumed to handle it properly */
                                if (attr.originalAttribute) {
                                    continue;
                                }
                                if (_this_1.hasInvalidStyle(attr)) {
                                    _this_1.report(node, reportMessage$1(attr, _this_1.options.style), attr.keyLocation);
                                }
                            }
                        });
                    });
                };
                AttributeBooleanStyle.prototype.isBoolean = function (attr, rules) {
                    var meta = rules[attr.key];
                    return Boolean(meta === null || meta === void 0 ? void 0 : meta.boolean);
                };
                return AttributeBooleanStyle;
            }(Rule));
            function parseStyle$2(style) {
                switch (style.toLowerCase()) {
                    case "omit":
                        return function (attr) { return attr.value !== null; };
                    case "empty":
                        return function (attr) { return attr.value !== ""; };
                    case "name":
                        return function (attr) { return attr.value !== attr.key; };
                    /* istanbul ignore next: covered by schema validation */
                    default:
                        throw new Error("Invalid style \"".concat(style, "\" for \"attribute-boolean-style\" rule"));
                }
            }
            function reportMessage$1(attr, style) {
                var key = attr.key;
                switch (style.toLowerCase()) {
                    case "omit":
                        return "Attribute \"".concat(key, "\" should omit value");
                    case "empty":
                        return "Attribute \"".concat(key, "\" value should be empty string");
                    case "name":
                        return "Attribute \"".concat(key, "\" should be set to ").concat(key, "=\"").concat(key, "\"");
                }
                /* istanbul ignore next: the above switch should cover all cases */
                return "";
            }
            var defaults$o = {
                style: "omit"
            };
            var AttributeEmptyStyle = /** @class */ (function (_super) {
                __extends(AttributeEmptyStyle, _super);
                function AttributeEmptyStyle(options) {
                    var _this_1 = _super.call(this, __assign(__assign({}, defaults$o), options)) || this;
                    _this_1.hasInvalidStyle = parseStyle$1(_this_1.options.style);
                    return _this_1;
                }
                AttributeEmptyStyle.schema = function () {
                    return {
                        style: {
                            "enum": ["empty", "omit"],
                            type: "string"
                        }
                    };
                };
                AttributeEmptyStyle.prototype.documentation = function () {
                    return {
                        description: "Require a specific style for attributes with empty values.",
                        url: "https://html-validate.org/rules/attribute-empty-style.html"
                    };
                };
                AttributeEmptyStyle.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("dom:ready", function (event) {
                        var doc = event.document;
                        doc.visitDepthFirst(function (node) {
                            var meta = node.meta;
                            /* ignore rule if element has no meta or meta does not specify attribute
                             * allowed values */
                            if (!(meta === null || meta === void 0 ? void 0 : meta.attributes))
                                return;
                            /* check all boolean attributes */
                            for (var _1 = 0, _2 = node.attributes; _1 < _2.length; _1++) {
                                var attr = _2[_1];
                                /* only handle attributes which allows empty values */
                                if (!allowsEmpty(attr, meta.attributes)) {
                                    continue;
                                }
                                /* skip attribute if the attribute is set to non-empty value
                                 * (attribute-allowed-values deals with non-empty values)*/
                                if (!isEmptyValue(attr)) {
                                    continue;
                                }
                                /* skip attribute if the style is valid */
                                if (!_this_1.hasInvalidStyle(attr)) {
                                    continue;
                                }
                                /* report error */
                                _this_1.report(node, reportMessage(attr, _this_1.options.style), attr.keyLocation);
                            }
                        });
                    });
                };
                return AttributeEmptyStyle;
            }(Rule));
            function allowsEmpty(attr, rules) {
                var meta = rules[attr.key];
                return Boolean(meta === null || meta === void 0 ? void 0 : meta.omit);
            }
            function isEmptyValue(attr) {
                /* dynamic values are ignored, assumed to contain a value */
                if (attr.isDynamic) {
                    return false;
                }
                return attr.value === null || attr.value === "";
            }
            function parseStyle$1(style) {
                switch (style.toLowerCase()) {
                    case "omit":
                        return function (attr) { return attr.value !== null; };
                    case "empty":
                        return function (attr) { return attr.value !== ""; };
                    /* istanbul ignore next: covered by schema validation */
                    default:
                        throw new Error("Invalid style \"".concat(style, "\" for \"attribute-empty-style\" rule"));
                }
            }
            function reportMessage(attr, style) {
                var key = attr.key;
                switch (style.toLowerCase()) {
                    case "omit":
                        return "Attribute \"".concat(key, "\" should omit value");
                    case "empty":
                        return "Attribute \"".concat(key, "\" value should be empty string");
                }
                /* istanbul ignore next: the above switch should cover all cases */
                return "";
            }
            function ruleDescription(context) {
                var attr = context.attr, details = context.details;
                return "The \"".concat(attr, "\" attribute cannot be used in this context: ").concat(details);
            }
            var AttributeMisuse = /** @class */ (function (_super) {
                __extends(AttributeMisuse, _super);
                function AttributeMisuse() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                AttributeMisuse.prototype.documentation = function (context) {
                    return {
                        description: ruleDescription(context),
                        url: "https://html-validate.org/rules/attribute-misuse.html"
                    };
                };
                AttributeMisuse.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("element:ready", function (event) {
                        var target = event.target;
                        var meta = target.meta;
                        if (!meta) {
                            return;
                        }
                        for (var _1 = 0, _2 = target.attributes; _1 < _2.length; _1++) {
                            var attr = _2[_1];
                            var key = attr.key.toLowerCase();
                            _this_1.validateAttr(target, attr, meta.attributes[key]);
                        }
                    });
                };
                AttributeMisuse.prototype.validateAttr = function (node, attr, meta) {
                    if (!(meta === null || meta === void 0 ? void 0 : meta.allowed)) {
                        return;
                    }
                    var details = meta.allowed(node._adapter, attr.value);
                    if (details) {
                        this.report({
                            node: node,
                            message: "\"{{ attr }}\" attribute cannot be used in this context: {{ details }}",
                            location: attr.keyLocation,
                            context: {
                                attr: attr.key,
                                details: details
                            }
                        });
                    }
                };
                return AttributeMisuse;
            }(Rule));
            function parsePattern(pattern) {
                switch (pattern) {
                    case "kebabcase":
                        return /^[a-z0-9-]+$/;
                    case "camelcase":
                        return /^[a-z][a-zA-Z0-9]+$/;
                    case "underscore":
                        return /^[a-z0-9_]+$/;
                    default:
                        /* eslint-disable-next-line security/detect-non-literal-regexp -- expected to be regexp */
                        return new RegExp(pattern);
                }
            }
            function describePattern(pattern) {
                var regexp = parsePattern(pattern).toString();
                switch (pattern) {
                    case "kebabcase":
                    case "camelcase":
                    case "underscore": {
                        return "".concat(regexp, " (").concat(pattern, ")");
                    }
                    default:
                        return regexp;
                }
            }
            var defaults$n = {
                pattern: "kebabcase"
            };
            var ClassPattern = /** @class */ (function (_super) {
                __extends(ClassPattern, _super);
                function ClassPattern(options) {
                    var _this_1 = _super.call(this, __assign(__assign({}, defaults$n), options)) || this;
                    _this_1.pattern = parsePattern(_this_1.options.pattern);
                    return _this_1;
                }
                ClassPattern.schema = function () {
                    return {
                        pattern: {
                            type: "string"
                        }
                    };
                };
                ClassPattern.prototype.documentation = function () {
                    var pattern = describePattern(this.options.pattern);
                    return {
                        description: "For consistency all classes are required to match the pattern ".concat(pattern, "."),
                        url: "https://html-validate.org/rules/class-pattern.html"
                    };
                };
                ClassPattern.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("attr", function (event) {
                        if (event.key.toLowerCase() !== "class") {
                            return;
                        }
                        var classes = new DOMTokenList(event.value, event.valueLocation);
                        classes.forEach(function (cur, index) {
                            if (!cur.match(_this_1.pattern)) {
                                var location_7 = classes.location(index);
                                var pattern = _this_1.pattern.toString();
                                var message = "Class \"".concat(cur, "\" does not match required pattern \"").concat(pattern, "\"");
                                _this_1.report(event.target, message, location_7);
                            }
                        });
                    });
                };
                return ClassPattern;
            }(Rule));
            var CloseAttr = /** @class */ (function (_super) {
                __extends(CloseAttr, _super);
                function CloseAttr() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                CloseAttr.prototype.documentation = function () {
                    return {
                        description: "HTML disallows end tags to have attributes.",
                        url: "https://html-validate.org/rules/close-attr.html"
                    };
                };
                CloseAttr.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("tag:end", function (event) {
                        /* handle unclosed tags */
                        if (!event.target) {
                            return;
                        }
                        /* ignore self-closed and void */
                        if (event.previous === event.target) {
                            return;
                        }
                        var node = event.target;
                        if (Object.keys(node.attributes).length > 0) {
                            var first = node.attributes[0];
                            _this_1.report(null, "Close tags cannot have attributes", first.keyLocation);
                        }
                    });
                };
                return CloseAttr;
            }(Rule));
            var CloseOrder = /** @class */ (function (_super) {
                __extends(CloseOrder, _super);
                function CloseOrder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                CloseOrder.prototype.documentation = function () {
                    return {
                        description: "HTML requires elements to be closed in the same order as they were opened.",
                        url: "https://html-validate.org/rules/close-order.html"
                    };
                };
                CloseOrder.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("tag:end", function (event) {
                        var current = event.target; // The current element being closed
                        var active = event.previous; // The current active element (that is, the current element on the stack)
                        /* handle unclosed tags */
                        if (!current) {
                            _this_1.report(null, "Missing close-tag, expected '</".concat(active.tagName, ">' but document ended before it was found."), event.location);
                            return;
                        }
                        /* void elements are always closed in correct order but if the markup contains
                         * an end-tag for it it should be ignored here since the void element is
                         * implicitly closed in the right order, so the current active element is the
                         * parent. */
                        if (current.voidElement) {
                            return;
                        }
                        /* if the active element is implicitly closed when the parent is closed
                         * (such as a <li> by </ul>) no error should be reported. */
                        if (active.closed === exports.NodeClosed.ImplicitClosed) {
                            return;
                        }
                        /* handle unopened tags */
                        if (active.isRootElement()) {
                            var location_8 = {
                                filename: current.location.filename,
                                line: current.location.line,
                                column: current.location.column,
                                offset: current.location.offset,
                                size: current.tagName.length + 1
                            };
                            _this_1.report(null, "Unexpected close-tag, expected opening tag.", location_8);
                            return;
                        }
                        /* check for matching tagnames */
                        if (current.tagName !== active.tagName) {
                            _this_1.report(null, "Mismatched close-tag, expected '</".concat(active.tagName, ">' but found '</").concat(current.tagName, ">'."), current.location);
                        }
                    });
                };
                return CloseOrder;
            }(Rule));
            var defaults$m = {
                include: null,
                exclude: null
            };
            var Deprecated = /** @class */ (function (_super) {
                __extends(Deprecated, _super);
                function Deprecated(options) {
                    return _super.call(this, __assign(__assign({}, defaults$m), options)) || this;
                }
                Deprecated.schema = function () {
                    return {
                        exclude: {
                            anyOf: [
                                {
                                    items: {
                                        type: "string"
                                    },
                                    type: "array"
                                },
                                {
                                    type: "null"
                                },
                            ]
                        },
                        include: {
                            anyOf: [
                                {
                                    items: {
                                        type: "string"
                                    },
                                    type: "array"
                                },
                                {
                                    type: "null"
                                },
                            ]
                        }
                    };
                };
                Deprecated.prototype.documentation = function (context) {
                    var text = [];
                    if (context.source) {
                        var source = prettySource(context.source);
                        var message = "The `<$tagname>` element is deprecated ".concat(source, " and should not be used in new code.");
                        text.push(message);
                    }
                    else {
                        var message = "The `<$tagname>` element is deprecated and should not be used in new code.";
                        text.push(message);
                    }
                    if (context.documentation) {
                        text.push(context.documentation);
                    }
                    var doc = {
                        description: text.map(function (cur) { return cur.replace(/\$tagname/g, context.tagName); }).join("\n\n"),
                        url: "https://html-validate.org/rules/deprecated.html"
                    };
                    return doc;
                };
                Deprecated.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("tag:start", function (event) {
                        var node = event.target;
                        /* cannot validate if meta isn't known */
                        if (node.meta === null) {
                            return;
                        }
                        /* ignore if element is not deprecated */
                        var deprecated = node.meta.deprecated;
                        if (!deprecated) {
                            return;
                        }
                        /* ignore if element is ignored by used configuration */
                        if (_this_1.isKeywordIgnored(node.tagName)) {
                            return;
                        }
                        var location = sliceLocation(event.location, 1);
                        if (typeof deprecated === "string") {
                            _this_1.reportString(deprecated, node, location);
                        }
                        else if (typeof deprecated === "boolean") {
                            _this_1.reportBoolean(node, location);
                        }
                        else {
                            _this_1.reportObject(deprecated, node, location);
                        }
                    });
                };
                Deprecated.prototype.reportString = function (deprecated, node, location) {
                    var context = { tagName: node.tagName };
                    var message = "<".concat(node.tagName, "> is deprecated: ").concat(deprecated);
                    this.report(node, message, location, context);
                };
                Deprecated.prototype.reportBoolean = function (node, location) {
                    var context = { tagName: node.tagName };
                    var message = "<".concat(node.tagName, "> is deprecated");
                    this.report(node, message, location, context);
                };
                Deprecated.prototype.reportObject = function (deprecated, node, location) {
                    var context = __assign(__assign({}, deprecated), { tagName: node.tagName });
                    var notice = deprecated.message ? ": ".concat(deprecated.message) : "";
                    var message = "<".concat(node.tagName, "> is deprecated").concat(notice);
                    this.report(node, message, location, context);
                };
                return Deprecated;
            }(Rule));
            function prettySource(source) {
                var match = source.match(/html(\d)(\d)?/);
                if (match) {
                    var parts = match.slice(1);
                    var version_1 = parts.filter(Boolean).join(".");
                    return "in HTML ".concat(version_1);
                }
                switch (source) {
                    case "whatwg":
                        return "in HTML Living Standard";
                    case "non-standard":
                        return "and non-standard";
                    default:
                        return "by ".concat(source);
                }
            }
            var DeprecatedRule = /** @class */ (function (_super) {
                __extends(DeprecatedRule, _super);
                function DeprecatedRule() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                DeprecatedRule.prototype.documentation = function (context) {
                    var preamble = context ? "The rule \"".concat(context, "\"") : "This rule";
                    return {
                        description: "".concat(preamble, " is deprecated and should not be used any longer, consult documentation for further information."),
                        url: "https://html-validate.org/rules/deprecated-rule.html"
                    };
                };
                DeprecatedRule.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("config:ready", function (event) {
                        for (var _1 = 0, _2 = _this_1.getDeprecatedRules(event); _1 < _2.length; _1++) {
                            var rule = _2[_1];
                            if (rule.getSeverity() > exports.Severity.DISABLED) {
                                _this_1.report(null, "Usage of deprecated rule \"".concat(rule.name, "\""), null, rule.name);
                            }
                        }
                    });
                };
                DeprecatedRule.prototype.getDeprecatedRules = function (event) {
                    var rules = Object.values(event.rules);
                    return rules.filter(function (rule) { return rule.deprecated; });
                };
                return DeprecatedRule;
            }(Rule));
            var NoStyleTag$1 = /** @class */ (function (_super) {
                __extends(NoStyleTag, _super);
                function NoStyleTag() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                NoStyleTag.prototype.documentation = function () {
                    return {
                        description: [
                            'HTML5 documents should use the "html" doctype (short `form`, not legacy string):',
                            "",
                            "```html",
                            "<!DOCTYPE html>",
                            "```",
                        ].join("\n"),
                        url: "https://html-validate.org/rules/doctype-html.html"
                    };
                };
                NoStyleTag.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("doctype", function (event) {
                        var doctype = event.value.toLowerCase();
                        if (doctype !== "html") {
                            _this_1.report(null, 'doctype should be "html"', event.valueLocation);
                        }
                    });
                };
                return NoStyleTag;
            }(Rule));
            var defaults$l = {
                style: "uppercase"
            };
            var DoctypeStyle = /** @class */ (function (_super) {
                __extends(DoctypeStyle, _super);
                function DoctypeStyle(options) {
                    return _super.call(this, __assign(__assign({}, defaults$l), options)) || this;
                }
                DoctypeStyle.schema = function () {
                    return {
                        style: {
                            "enum": ["lowercase", "uppercase"],
                            type: "string"
                        }
                    };
                };
                DoctypeStyle.prototype.documentation = function (context) {
                    return {
                        description: "While DOCTYPE is case-insensitive in the standard the current configuration requires it to be ".concat(context.style),
                        url: "https://html-validate.org/rules/doctype-style.html"
                    };
                };
                DoctypeStyle.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("doctype", function (event) {
                        if (_this_1.options.style === "uppercase" && event.tag !== "DOCTYPE") {
                            _this_1.report(null, "DOCTYPE should be uppercase", event.location, _this_1.options);
                        }
                        if (_this_1.options.style === "lowercase" && event.tag !== "doctype") {
                            _this_1.report(null, "DOCTYPE should be lowercase", event.location, _this_1.options);
                        }
                    });
                };
                return DoctypeStyle;
            }(Rule));
            var defaults$k = {
                style: "lowercase"
            };
            var ElementCase = /** @class */ (function (_super) {
                __extends(ElementCase, _super);
                function ElementCase(options) {
                    var _this_1 = _super.call(this, __assign(__assign({}, defaults$k), options)) || this;
                    _this_1.style = new CaseStyle(_this_1.options.style, "element-case");
                    return _this_1;
                }
                ElementCase.schema = function () {
                    var styleEnum = ["lowercase", "uppercase", "pascalcase", "camelcase"];
                    return {
                        style: {
                            anyOf: [
                                {
                                    "enum": styleEnum,
                                    type: "string"
                                },
                                {
                                    items: {
                                        "enum": styleEnum,
                                        type: "string"
                                    },
                                    type: "array"
                                },
                            ]
                        }
                    };
                };
                ElementCase.prototype.documentation = function () {
                    var style = this.options.style;
                    return {
                        description: Array.isArray(style)
                            ? __spreadArray(["Element tagname must be in one of:", ""], style.map(function (it) { return "- ".concat(it); }), true).join("\n")
                            : "Element tagname must be in ".concat(style, "."),
                        url: "https://html-validate.org/rules/element-case.html"
                    };
                };
                ElementCase.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("tag:start", function (event) {
                        var target = event.target, location = event.location;
                        _this_1.validateCase(target, location);
                    });
                    this.on("tag:end", function (event) {
                        var target = event.target, previous = event.previous;
                        _this_1.validateMatchingCase(previous, target);
                    });
                };
                ElementCase.prototype.validateCase = function (target, targetLocation) {
                    var letters = target.tagName.replace(/[^a-z]+/gi, "");
                    if (!this.style.match(letters)) {
                        var location_9 = sliceLocation(targetLocation, 1);
                        this.report(target, "Element \"".concat(target.tagName, "\" should be ").concat(this.style.name), location_9);
                    }
                };
                ElementCase.prototype.validateMatchingCase = function (start, end) {
                    /* handle when elements have have missing start or end tag */
                    if (!start || !end || !start.tagName || !end.tagName) {
                        return;
                    }
                    /* only check case if the names are a lowercase match to each other or it
                     * will yield false positives when elements are closed in wrong order or
                     * otherwise mismatched */
                    if (start.tagName.toLowerCase() !== end.tagName.toLowerCase()) {
                        return;
                    }
                    if (start.tagName !== end.tagName) {
                        this.report(start, "Start and end tag must not differ in casing", end.location);
                    }
                };
                return ElementCase;
            }(Rule));
            var defaults$j = {
                pattern: "^[a-z][a-z0-9\\-._]*-[a-z0-9\\-._]*$",
                whitelist: [],
                blacklist: []
            };
            var ElementName = /** @class */ (function (_super) {
                __extends(ElementName, _super);
                function ElementName(options) {
                    var _this_1 = _super.call(this, __assign(__assign({}, defaults$j), options)) || this;
                    /* eslint-disable-next-line security/detect-non-literal-regexp -- expected to be a regexp */
                    _this_1.pattern = new RegExp(_this_1.options.pattern);
                    return _this_1;
                }
                ElementName.schema = function () {
                    return {
                        blacklist: {
                            items: {
                                type: "string"
                            },
                            type: "array"
                        },
                        pattern: {
                            type: "string"
                        },
                        whitelist: {
                            items: {
                                type: "string"
                            },
                            type: "array"
                        }
                    };
                };
                ElementName.prototype.documentation = function (context) {
                    return {
                        description: this.documentationMessages(context).join("\n"),
                        url: "https://html-validate.org/rules/element-name.html"
                    };
                };
                ElementName.prototype.documentationMessages = function (context) {
                    if (context.blacklist.includes(context.tagName)) {
                        return __spreadArray([
                            "<".concat(context.tagName, "> is blacklisted by the project configuration."),
                            "",
                            "The following names are blacklisted:"
                        ], context.blacklist.map(function (cur) { return "- ".concat(cur); }), true);
                    }
                    if (context.pattern !== defaults$j.pattern) {
                        return [
                            "<".concat(context.tagName, "> is not a valid element name. This project is configured to only allow names matching the following regular expression:"),
                            "",
                            "- `".concat(context.pattern, "`"),
                        ];
                    }
                    return [
                        "<".concat(context.tagName, "> is not a valid element name. If this is a custom element HTML requires the name to follow these rules:"),
                        "",
                        "- The name must begin with `a-z`",
                        "- The name must include a hyphen `-`",
                        "- It may include alphanumerical characters `a-z0-9` or hyphens `-`, dots `.` or underscores `_`.",
                    ];
                };
                ElementName.prototype.setup = function () {
                    var _this_1 = this;
                    var xmlns = /^(.+):.+$/;
                    this.on("tag:start", function (event) {
                        var target = event.target;
                        var tagName = target.tagName;
                        var location = sliceLocation(event.location, 1);
                        var context = {
                            tagName: tagName,
                            pattern: _this_1.options.pattern,
                            blacklist: _this_1.options.blacklist
                        };
                        /* check if element is blacklisted */
                        if (_this_1.options.blacklist.includes(tagName)) {
                            _this_1.report(target, "<".concat(tagName, "> element is blacklisted"), location, context);
                        }
                        /* assume that an element with meta has valid name as it is a builtin
                         * element */
                        if (target.meta) {
                            return;
                        }
                        /* ignore elements in xml namespaces, they should be validated against a
                         * DTD instead */
                        if (tagName.match(xmlns)) {
                            return;
                        }
                        /* check if element is whitelisted */
                        if (_this_1.options.whitelist.includes(tagName)) {
                            return;
                        }
                        if (!tagName.match(_this_1.pattern)) {
                            _this_1.report(target, "<".concat(tagName, "> is not a valid element name"), location, context);
                        }
                    });
                };
                return ElementName;
            }(Rule));
            var ErrorKind;
            (function (ErrorKind) {
                ErrorKind["CONTENT"] = "content";
                ErrorKind["DESCENDANT"] = "descendant";
            })(ErrorKind || (ErrorKind = {}));
            function getTransparentChildren(node, transparent) {
                if (typeof transparent === "boolean") {
                    return node.childElements;
                }
                else {
                    /* only return children which matches one of the given content categories */
                    return node.childElements.filter(function (it) {
                        return transparent.some(function (category) {
                            return Validator.validatePermittedCategory(it, category, false);
                        });
                    });
                }
            }
            function getRuleDescription$2(context) {
                switch (context.kind) {
                    case ErrorKind.CONTENT:
                        return [
                            "The `".concat(context.child, "` element is not permitted as content under the parent `").concat(context.parent, "` element."),
                        ];
                    case ErrorKind.DESCENDANT:
                        return [
                            "The `".concat(context.child, "` element is not permitted as a descendant of the `").concat(context.ancestor, "` element."),
                        ];
                }
            }
            var ElementPermittedContent = /** @class */ (function (_super) {
                __extends(ElementPermittedContent, _super);
                function ElementPermittedContent() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                ElementPermittedContent.prototype.documentation = function (context) {
                    return {
                        description: getRuleDescription$2(context).join("\n"),
                        url: "https://html-validate.org/rules/element-permitted-content.html"
                    };
                };
                ElementPermittedContent.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("dom:ready", function (event) {
                        var doc = event.document;
                        doc.visitDepthFirst(function (node) {
                            var parent = node.parent;
                            /* istanbul ignore next: satisfy typescript but will visitDepthFirst()
                             * will not yield nodes without a parent */
                            if (!parent) {
                                return;
                            }
                            /* Run each validation step, stop as soon as any errors are
                             * reported. This is to prevent multiple similar errors on the same
                             * element, such as "<dd> is not permitted content under <span>" and
                             * "<dd> has no permitted ancestors". */
                            [
                                function () { return _this_1.validatePermittedContent(node, parent); },
                                function () { return _this_1.validatePermittedDescendant(node, parent); },
                            ].some(function (fn) { return fn(); });
                        });
                    });
                };
                ElementPermittedContent.prototype.validatePermittedContent = function (cur, parent) {
                    var _a;
                    /* if parent doesn't have metadata (unknown element) skip checking permitted
                     * content */
                    if (!parent.meta) {
                        return false;
                    }
                    var rules = (_a = parent.meta.permittedContent) !== null && _a !== void 0 ? _a : null;
                    return this.validatePermittedContentImpl(cur, parent, rules);
                };
                ElementPermittedContent.prototype.validatePermittedContentImpl = function (cur, parent, rules) {
                    var _this_1 = this;
                    if (!Validator.validatePermitted(cur, rules)) {
                        var child = "<".concat(cur.tagName, ">");
                        var message = "".concat(child, " element is not permitted as content under ").concat(parent.annotatedName);
                        var context = {
                            kind: ErrorKind.CONTENT,
                            parent: parent.annotatedName,
                            child: child
                        };
                        this.report(cur, message, null, context);
                        return true;
                    }
                    /* for transparent elements all/listed children must be validated against
                     * the (this elements) parent, i.e. if this node was removed from the DOM it
                     * should still be valid. */
                    if (cur.meta && cur.meta.transparent) {
                        var children = getTransparentChildren(cur, cur.meta.transparent);
                        return children
                            .map(function (child) {
                            return _this_1.validatePermittedContentImpl(child, parent, rules);
                        })
                            .some(Boolean);
                    }
                    return false;
                };
                ElementPermittedContent.prototype.validatePermittedDescendant = function (node, parent) {
                    var _a;
                    for (var cur = parent; cur && !cur.isRootElement(); cur = /* istanbul ignore next */ (_a = cur === null || cur === void 0 ? void 0 : cur.parent) !== null && _a !== void 0 ? _a : null) {
                        var meta = cur.meta;
                        /* ignore checking parent without meta */
                        if (!meta) {
                            continue;
                        }
                        var rules_7 = meta.permittedDescendants;
                        if (!rules_7) {
                            continue;
                        }
                        if (Validator.validatePermitted(node, rules_7)) {
                            continue;
                        }
                        var child = "<".concat(node.tagName, ">");
                        var ancestor = cur.annotatedName;
                        var message = "".concat(child, " element is not permitted as a descendant of ").concat(ancestor);
                        var context = {
                            kind: ErrorKind.DESCENDANT,
                            ancestor: ancestor,
                            child: child
                        };
                        this.report(node, message, null, context);
                        return true;
                    }
                    return false;
                };
                return ElementPermittedContent;
            }(Rule));
            var ElementPermittedOccurrences = /** @class */ (function (_super) {
                __extends(ElementPermittedOccurrences, _super);
                function ElementPermittedOccurrences() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                ElementPermittedOccurrences.prototype.documentation = function () {
                    return {
                        description: "Some elements may only be used a fixed amount of times in given context.",
                        url: "https://html-validate.org/rules/element-permitted-occurrences.html"
                    };
                };
                ElementPermittedOccurrences.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("dom:ready", function (event) {
                        var doc = event.document;
                        doc.visitDepthFirst(function (node) {
                            if (!node.meta) {
                                return;
                            }
                            var rules = node.meta.permittedContent;
                            if (!rules) {
                                return;
                            }
                            Validator.validateOccurrences(node.childElements, rules, function (child, category) {
                                _this_1.report(child, "Element <".concat(category, "> can only appear once under ").concat(node.annotatedName));
                            });
                        });
                    });
                };
                return ElementPermittedOccurrences;
            }(Rule));
            var ElementPermittedOrder = /** @class */ (function (_super) {
                __extends(ElementPermittedOrder, _super);
                function ElementPermittedOrder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                ElementPermittedOrder.prototype.documentation = function () {
                    return {
                        description: "Some elements has a specific order the children must use.",
                        url: "https://html-validate.org/rules/element-permitted-order.html"
                    };
                };
                ElementPermittedOrder.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("dom:ready", function (event) {
                        var doc = event.document;
                        doc.visitDepthFirst(function (node) {
                            if (!node.meta) {
                                return;
                            }
                            var rules = node.meta.permittedOrder;
                            if (!rules) {
                                return;
                            }
                            Validator.validateOrder(node.childElements, rules, function (child, prev) {
                                _this_1.report(child, "Element <".concat(child.tagName, "> must be used before <").concat(prev.tagName, "> in this context"));
                            });
                        });
                    });
                };
                return ElementPermittedOrder;
            }(Rule));
            function isCategoryOrTag(value) {
                return typeof value === "string";
            }
            function isCategory$1(value) {
                return value.startsWith("@");
            }
            function formatCategoryOrTag(value) {
                return isCategory$1(value) ? value.slice(1) : "<".concat(value, ">");
            }
            function isFormattable(rules) {
                return rules.length > 0 && rules.every(isCategoryOrTag);
            }
            function getRuleDescription$1(context) {
                var child = context.child, parent = context.parent, rules = context.rules;
                var preamble = "The `".concat(child, "` element cannot have a `").concat(parent, "` element as parent.");
                if (isFormattable(rules)) {
                    var allowed = rules.filter(isCategoryOrTag).map(function (it) {
                        if (isCategory$1(it)) {
                            return "- any ".concat(it.slice(1), " element");
                        }
                        else {
                            return "- `<".concat(it, ">`");
                        }
                    });
                    return __spreadArray([preamble, "", "Allowed parents one of:", ""], allowed, true);
                }
                else {
                    return [preamble];
                }
            }
            function formatMessage$1(node, parent, rules) {
                var nodeName = node.annotatedName;
                var parentName = parent.annotatedName;
                if (!isFormattable(rules)) {
                    return "".concat(nodeName, " element cannot have ").concat(parentName, " element as parent");
                }
                var allowed = utils_naturalJoin.naturalJoin(rules.filter(isCategoryOrTag).map(formatCategoryOrTag));
                return "".concat(nodeName, " element requires a ").concat(allowed, " element as parent");
            }
            var ElementPermittedParent = /** @class */ (function (_super) {
                __extends(ElementPermittedParent, _super);
                function ElementPermittedParent() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                ElementPermittedParent.prototype.documentation = function (context) {
                    return {
                        description: getRuleDescription$1(context).join("\n"),
                        url: "https://html-validate.org/rules/element-permitted-parent.html"
                    };
                };
                ElementPermittedParent.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("dom:ready", function (event) {
                        var doc = event.document;
                        doc.visitDepthFirst(function (node) {
                            var _a;
                            var parent = node.parent;
                            /* istanbul ignore next: satisfy typescript but will visitDepthFirst()
                             * will not yield nodes without a parent */
                            if (!parent) {
                                return;
                            }
                            /* don't validate root element as the <html> and <body> tag is optional
                             * so anything could be directly under the root element. */
                            if (parent.isRootElement()) {
                                return;
                            }
                            /* when the parent element is the same as the current element we ignore
                             * this rule and let `element-permitted-content` handle it as it will
                             * create a lot of duplicate errors otherwise */
                            if (parent.tagName === node.tagName) {
                                return;
                            }
                            /* if parent doesn't have metadata (unknown element) skip checking permitted
                             * content */
                            var rules = (_a = node.meta) === null || _a === void 0 ? void 0 : _a.permittedParent;
                            if (!rules) {
                                return false;
                            }
                            if (Validator.validatePermitted(parent, rules)) {
                                return;
                            }
                            var message = formatMessage$1(node, parent, rules);
                            var context = {
                                parent: parent.annotatedName,
                                child: node.annotatedName,
                                rules: rules
                            };
                            _this_1.report(node, message, null, context);
                        });
                    });
                };
                return ElementPermittedParent;
            }(Rule));
            function isTagnameOnly(value) {
                return Boolean(value.match(/^[a-zA-Z0-9-]+$/));
            }
            function getRuleDescription(context) {
                var escaped = context.ancestor.map(function (it) { return "`".concat(it, "`"); });
                return ["The `".concat(context.child, "` element requires a ").concat(utils_naturalJoin.naturalJoin(escaped), " ancestor.")];
            }
            var ElementRequiredAncestor = /** @class */ (function (_super) {
                __extends(ElementRequiredAncestor, _super);
                function ElementRequiredAncestor() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                ElementRequiredAncestor.prototype.documentation = function (context) {
                    return {
                        description: getRuleDescription(context).join("\n"),
                        url: "https://html-validate.org/rules/element-required-ancestor.html"
                    };
                };
                ElementRequiredAncestor.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("dom:ready", function (event) {
                        var doc = event.document;
                        doc.visitDepthFirst(function (node) {
                            var parent = node.parent;
                            /* istanbul ignore next: satisfy typescript but will visitDepthFirst()
                             * will not yield nodes without a parent */
                            if (!parent) {
                                return;
                            }
                            _this_1.validateRequiredAncestors(node);
                        });
                    });
                };
                ElementRequiredAncestor.prototype.validateRequiredAncestors = function (node) {
                    if (!node.meta) {
                        return;
                    }
                    var rules = node.meta.requiredAncestors;
                    if (!rules) {
                        return;
                    }
                    if (Validator.validateAncestors(node, rules)) {
                        return;
                    }
                    var ancestor = rules.map(function (it) { return (isTagnameOnly(it) ? "<".concat(it, ">") : "\"".concat(it, "\"")); });
                    var child = "<".concat(node.tagName, ">");
                    var message = "<".concat(node.tagName, "> element requires a ").concat(utils_naturalJoin.naturalJoin(ancestor), " ancestor");
                    var context = {
                        ancestor: ancestor,
                        child: child
                    };
                    this.report(node, message, null, context);
                };
                return ElementRequiredAncestor;
            }(Rule));
            var ElementRequiredAttributes = /** @class */ (function (_super) {
                __extends(ElementRequiredAttributes, _super);
                function ElementRequiredAttributes() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                ElementRequiredAttributes.prototype.documentation = function (context) {
                    var docs = {
                        description: "Element is missing a required attribute",
                        url: "https://html-validate.org/rules/element-required-attributes.html"
                    };
                    if (context) {
                        docs.description = "The <".concat(context.element, "> element is required to have a \"").concat(context.attribute, "\" attribute.");
                    }
                    return docs;
                };
                ElementRequiredAttributes.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("tag:end", function (event) {
                        var node = event.previous;
                        var meta = node.meta;
                        /* handle missing metadata and missing attributes */
                        if (!(meta === null || meta === void 0 ? void 0 : meta.attributes)) {
                            return;
                        }
                        for (var _1 = 0, _2 = Object.entries(meta.attributes); _1 < _2.length; _1++) {
                            var _3 = _2[_1], key = _3[0], attr = _3[1];
                            if (!attr.required) {
                                continue;
                            }
                            if (node.hasAttribute(key))
                                continue;
                            var context = {
                                element: node.tagName,
                                attribute: key
                            };
                            _this_1.report(node, "".concat(node.annotatedName, " is missing required \"").concat(key, "\" attribute"), node.location, context);
                        }
                    });
                };
                return ElementRequiredAttributes;
            }(Rule));
            function isCategory(value) {
                return value.startsWith("@");
            }
            var ElementRequiredContent = /** @class */ (function (_super) {
                __extends(ElementRequiredContent, _super);
                function ElementRequiredContent() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                ElementRequiredContent.prototype.documentation = function (context) {
                    var element = context.element, missing = context.missing;
                    return {
                        description: "The `".concat(element, "` element requires a `").concat(missing, "` to be present as content."),
                        url: "https://html-validate.org/rules/element-required-content.html"
                    };
                };
                ElementRequiredContent.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("dom:ready", function (event) {
                        var doc = event.document;
                        doc.visitDepthFirst(function (node) {
                            /* if element doesn't have metadata (unknown element) skip checking
                             * required content */
                            if (!node.meta) {
                                return;
                            }
                            var rules = node.meta.requiredContent;
                            if (!rules) {
                                return;
                            }
                            for (var _1 = 0, _2 = Validator.validateRequiredContent(node, rules); _1 < _2.length; _1++) {
                                var missing = _2[_1];
                                var context = {
                                    element: node.annotatedName,
                                    missing: "<".concat(missing, ">")
                                };
                                var tag = isCategory(missing) ? "".concat(missing.slice(1), " element") : "<".concat(missing, ">");
                                var message = "".concat(node.annotatedName, " element must have ").concat(tag, " as content");
                                _this_1.report(node, message, null, context);
                            }
                        });
                    });
                };
                return ElementRequiredContent;
            }(Rule));
            var selector = ["h1", "h2", "h3", "h4", "h5", "h6"].join(",");
            function hasImgAltText$1(node) {
                if (node.is("img")) {
                    return hasAltText(node);
                }
                else if (node.is("svg")) {
                    return node.textContent.trim() !== "";
                }
                /* istanbul ignore next -- querySelector(..) is only going to return the two
                 * above tags but this serves as a sane default if above assumption changes  */
                return false;
            }
            var EmptyHeading = /** @class */ (function (_super) {
                __extends(EmptyHeading, _super);
                function EmptyHeading() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                EmptyHeading.prototype.documentation = function () {
                    return {
                        description: "Assistive technology such as screen readers require textual content in headings. Whitespace only is considered empty.",
                        url: "https://html-validate.org/rules/empty-heading.html"
                    };
                };
                EmptyHeading.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("dom:ready", function (_1) {
                        var document = _1.document;
                        var headings = document.querySelectorAll(selector);
                        for (var _2 = 0, headings_1 = headings; _2 < headings_1.length; _2++) {
                            var heading = headings_1[_2];
                            _this_1.validateHeading(heading);
                        }
                    });
                };
                EmptyHeading.prototype.validateHeading = function (heading) {
                    var images = heading.querySelectorAll("img, svg");
                    for (var _1 = 0, images_1 = images; _1 < images_1.length; _1++) {
                        var child = images_1[_1];
                        if (hasImgAltText$1(child)) {
                            return;
                        }
                    }
                    switch (classifyNodeText(heading, { ignoreHiddenRoot: true })) {
                        case exports.TextClassification.DYNAMIC_TEXT:
                        case exports.TextClassification.STATIC_TEXT:
                            /* have some text content, consider ok */
                            break;
                        case exports.TextClassification.EMPTY_TEXT:
                            /* no content or whitespace only */
                            this.report(heading, "<".concat(heading.tagName, "> cannot be empty, must have text content"));
                            break;
                    }
                };
                return EmptyHeading;
            }(Rule));
            var EmptyTitle = /** @class */ (function (_super) {
                __extends(EmptyTitle, _super);
                function EmptyTitle() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                EmptyTitle.prototype.documentation = function () {
                    return {
                        description: [
                            "The `<title>` element cannot be empty, it must have textual content.",
                            "",
                            "It is used to describe the document and is shown in the browser tab and titlebar.",
                            "WCAG and SEO requires a descriptive title and preferably unique within the site.",
                            "",
                            "Whitespace is ignored.",
                        ].join("\n"),
                        url: "https://html-validate.org/rules/empty-title.html"
                    };
                };
                EmptyTitle.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("tag:end", function (event) {
                        var node = event.previous;
                        if (node.tagName !== "title")
                            return;
                        switch (classifyNodeText(node)) {
                            case exports.TextClassification.DYNAMIC_TEXT:
                            case exports.TextClassification.STATIC_TEXT:
                                /* have some text content, consider ok */
                                break;
                            case exports.TextClassification.EMPTY_TEXT:
                                /* no content or whitespace only */
                                {
                                    var message = "<".concat(node.tagName, "> cannot be empty, must have text content");
                                    _this_1.report(node, message, node.location);
                                }
                                break;
                        }
                    });
                };
                return EmptyTitle;
            }(Rule));
            var defaults$i = {
                allowArrayBrackets: true,
                shared: ["radio", "button", "reset", "submit"]
            };
            var UNIQUE_CACHE_KEY = Symbol("form-elements-unique");
            var SHARED_CACHE_KEY = Symbol("form-elements-shared");
            function haveName(name) {
                return typeof name === "string" && name !== "";
            }
            function allowSharedName(node, shared) {
                var type = node.getAttribute("type");
                return Boolean(type && type.valueMatches(shared, false));
            }
            function getDocumentation(context) {
                var trailer = "Each form control must have a unique name.";
                var name = context.name;
                switch (context.kind) {
                    case "duplicate":
                        return ["Duplicate form control name \"".concat(name, "\""), trailer].join("\n");
                    case "mix":
                        return [
                            "Form control name cannot mix regular name \"{{ name }}\" with array brackets \"{{ name }}[]\"",
                            trailer,
                        ].join("\n");
                }
            }
            var FormDupName = /** @class */ (function (_super) {
                __extends(FormDupName, _super);
                function FormDupName(options) {
                    return _super.call(this, __assign(__assign({}, defaults$i), options)) || this;
                }
                FormDupName.schema = function () {
                    return {
                        allowArrayBrackets: {
                            type: "boolean"
                        },
                        shared: {
                            type: "array",
                            items: {
                                "enum": ["radio", "checkbox", "submit", "button", "reset"]
                            }
                        }
                    };
                };
                FormDupName.prototype.documentation = function (context) {
                    return {
                        description: getDocumentation(context),
                        url: "https://html-validate.org/rules/form-dup-name.html"
                    };
                };
                FormDupName.prototype.setup = function () {
                    var _this_1 = this;
                    var selector = this.getSelector();
                    var shared = this.options.shared;
                    this.on("dom:ready", function (event) {
                        var _a, _b;
                        var document = event.document;
                        var controls = document.querySelectorAll(selector);
                        var _1 = partition(controls, function (it) {
                            return allowSharedName(it, shared);
                        }), sharedControls = _1[0], uniqueControls = _1[1];
                        /* validate all form controls which require unique elements first so each
                         * form has a populated list of unique names */
                        for (var _2 = 0, uniqueControls_1 = uniqueControls; _2 < uniqueControls_1.length; _2++) {
                            var control = uniqueControls_1[_2];
                            var attr = control.getAttribute("name");
                            var name_14 = attr === null || attr === void 0 ? void 0 : attr.value;
                            if (!attr || !haveName(name_14)) {
                                continue;
                            }
                            var form = (_a = control.closest("form")) !== null && _a !== void 0 ? _a : document.root;
                            _this_1.validateUniqueName(control, form, attr, name_14);
                        }
                        /* validate all form controls which allows shared names to ensure there is
                         * no collision with other form controls */
                        for (var _3 = 0, sharedControls_1 = sharedControls; _3 < sharedControls_1.length; _3++) {
                            var control = sharedControls_1[_3];
                            var attr = control.getAttribute("name");
                            var name_15 = attr === null || attr === void 0 ? void 0 : attr.value;
                            if (!attr || !haveName(name_15)) {
                                continue;
                            }
                            var form = (_b = control.closest("form")) !== null && _b !== void 0 ? _b : document.root;
                            _this_1.validateSharedName(control, form, attr, name_15);
                        }
                    });
                };
                FormDupName.prototype.validateUniqueName = function (control, form, attr, name) {
                    var elements = this.getUniqueElements(form);
                    var allowArrayBrackets = this.options.allowArrayBrackets;
                    if (allowArrayBrackets) {
                        var isarray = name.endsWith("[]");
                        var basename = isarray ? name.slice(0, -2) : name;
                        var details = elements.get(basename);
                        if (details && details.array !== isarray) {
                            var context = {
                                name: basename,
                                kind: "mix"
                            };
                            this.report({
                                node: control,
                                location: attr.valueLocation,
                                message: 'Cannot mix "{{ name }}[]" and "{{ name }}"',
                                context: context
                            });
                            return;
                        }
                        else if (!details && isarray) {
                            elements.set(basename, {
                                array: true
                            });
                            return;
                        }
                    }
                    if (elements.has(name)) {
                        var context = {
                            name: name,
                            kind: "duplicate"
                        };
                        this.report({
                            node: control,
                            location: attr.valueLocation,
                            message: 'Duplicate form control name "{{ name }}"',
                            context: context
                        });
                    }
                    else {
                        elements.set(name, {
                            array: false
                        });
                    }
                };
                FormDupName.prototype.validateSharedName = function (control, form, attr, name) {
                    var _a;
                    var uniqueElements = this.getUniqueElements(form);
                    var sharedElements = this.getSharedElements(form);
                    /* istanbul ignore next: type will always be set or shared name wouldn't be allowed */
                    var type = (_a = control.getAttributeValue("type")) !== null && _a !== void 0 ? _a : "";
                    if (uniqueElements.has(name) ||
                        (sharedElements.has(name) && sharedElements.get(name) !== type)) {
                        var context = {
                            name: name,
                            kind: "duplicate"
                        };
                        this.report({
                            node: control,
                            location: attr.valueLocation,
                            message: 'Duplicate form control name "{{ name }}"',
                            context: context
                        });
                    }
                    sharedElements.set(name, type);
                };
                FormDupName.prototype.getSelector = function () {
                    var _this_1 = this;
                    var tags = this.getTagsWithProperty("formAssociated").filter(function (it) {
                        return _this_1.isListedElement(it);
                    });
                    return tags.join(", ");
                };
                FormDupName.prototype.isListedElement = function (tagName) {
                    var meta = this.getMetaFor(tagName);
                    /* istanbul ignore next: the earlier check for getTagsWithProperty ensures
                     * these will actually be set so this is just an untestable fallback */
                    if (!(meta === null || meta === void 0 ? void 0 : meta.formAssociated)) {
                        return false;
                    }
                    return meta.formAssociated.listed;
                };
                FormDupName.prototype.getUniqueElements = function (form) {
                    var existing = form.cacheGet(UNIQUE_CACHE_KEY);
                    if (existing) {
                        return existing;
                    }
                    else {
                        var elements_1 = new Map();
                        form.cacheSet(UNIQUE_CACHE_KEY, elements_1);
                        return elements_1;
                    }
                };
                FormDupName.prototype.getSharedElements = function (form) {
                    var existing = form.cacheGet(SHARED_CACHE_KEY);
                    if (existing) {
                        return existing;
                    }
                    else {
                        var elements_2 = new Map();
                        form.cacheSet(SHARED_CACHE_KEY, elements_2);
                        return elements_2;
                    }
                };
                return FormDupName;
            }(Rule));
            var defaults$h = {
                allowMultipleH1: false,
                minInitialRank: "h1",
                sectioningRoots: ["dialog", '[role="dialog"]', '[role="alertdialog"]']
            };
            function isRelevant$4(event) {
                var node = event.target;
                return Boolean(node.meta && node.meta.heading);
            }
            function extractLevel(node) {
                var match = node.tagName.match(/^[hH](\d)$/);
                if (match) {
                    return parseInt(match[1], 10);
                }
                else {
                    return null;
                }
            }
            function parseMaxInitial(value) {
                if (value === false || value === "any") {
                    return 6;
                }
                var match = value.match(/^h(\d)$/);
                /* istanbul ignore next: should never happen, schema validation should catch invalid values */
                if (!match) {
                    return 1;
                }
                return parseInt(match[1], 10);
            }
            var HeadingLevel = /** @class */ (function (_super) {
                __extends(HeadingLevel, _super);
                function HeadingLevel(options) {
                    var _this_1 = _super.call(this, __assign(__assign({}, defaults$h), options)) || this;
                    _this_1.stack = [];
                    _this_1.minInitialRank = parseMaxInitial(_this_1.options.minInitialRank);
                    _this_1.sectionRoots = _this_1.options.sectioningRoots.map(function (it) { return new Pattern(it); });
                    /* add a global sectioning root used by default */
                    _this_1.stack.push({
                        node: null,
                        current: 0,
                        h1Count: 0
                    });
                    return _this_1;
                }
                HeadingLevel.schema = function () {
                    return {
                        allowMultipleH1: {
                            type: "boolean"
                        },
                        minInitialRank: {
                            "enum": ["h1", "h2", "h3", "h4", "h5", "h6", "any", false]
                        },
                        sectioningRoots: {
                            items: {
                                type: "string"
                            },
                            type: "array"
                        }
                    };
                };
                HeadingLevel.prototype.documentation = function () {
                    var text = [];
                    var modality = this.minInitialRank > 1 ? "should" : "must";
                    text.push("Headings ".concat(modality, " start at <h1> and can only increase one level at a time."));
                    text.push("The headings should form a table of contents and make sense on its own.");
                    if (!this.options.allowMultipleH1) {
                        text.push("");
                        text.push("Under the current configuration only a single <h1> can be present at a time in the document.");
                    }
                    return {
                        description: text.join("\n"),
                        url: "https://html-validate.org/rules/heading-level.html"
                    };
                };
                HeadingLevel.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("tag:start", isRelevant$4, function (event) {
                        _this_1.onTagStart(event);
                    });
                    this.on("tag:ready", function (event) {
                        _this_1.onTagReady(event);
                    });
                    this.on("tag:close", function (event) {
                        _this_1.onTagClose(event);
                    });
                };
                HeadingLevel.prototype.onTagStart = function (event) {
                    /* extract heading level from tagName (e.g "h1" -> 1)*/
                    var level = extractLevel(event.target);
                    if (!level)
                        return;
                    /* fetch the current sectioning root */
                    var root = this.getCurrentRoot();
                    /* do not allow multiple h1 */
                    if (!this.options.allowMultipleH1 && level === 1) {
                        if (root.h1Count >= 1) {
                            var location_10 = sliceLocation(event.location, 1);
                            this.report(event.target, "Multiple <h1> are not allowed", location_10);
                            return;
                        }
                        root.h1Count++;
                    }
                    /* allow same level or decreasing to any level (e.g. from h4 to h2) */
                    if (level <= root.current) {
                        root.current = level;
                        return;
                    }
                    this.checkLevelIncrementation(root, event, level);
                    root.current = level;
                };
                /**
                 * Validate heading level was only incremented by one.
                 */
                HeadingLevel.prototype.checkLevelIncrementation = function (root, event, level) {
                    var expected = root.current + 1;
                    /* check if the new level is the expected one (headings with higher ranks
                     * are skipped already) */
                    if (level === expected) {
                        return;
                    }
                    /* if this is the initial heading of the document it is compared to the
                     * minimal allowed (default h1) */
                    var isInitial = this.stack.length === 1 && expected === 1;
                    if (isInitial && level <= this.minInitialRank) {
                        return;
                    }
                    /* if we reach this far the heading level is not accepted */
                    var location = sliceLocation(event.location, 1);
                    if (root.current > 0) {
                        var msg = "Heading level can only increase by one, expected <h".concat(expected, "> but got <h").concat(level, ">");
                        this.report(event.target, msg, location);
                    }
                    else {
                        this.checkInitialLevel(event, location, level, expected);
                    }
                };
                HeadingLevel.prototype.checkInitialLevel = function (event, location, level, expected) {
                    if (this.stack.length === 1) {
                        var msg = this.minInitialRank > 1
                            ? "Initial heading level must be <h".concat(this.minInitialRank, "> or higher rank but got <h").concat(level, ">")
                            : "Initial heading level must be <h".concat(expected, "> but got <h").concat(level, ">");
                        this.report(event.target, msg, location);
                    }
                    else {
                        var prevRoot = this.getPrevRoot();
                        var prevRootExpected = prevRoot.current + 1;
                        if (level > prevRootExpected) {
                            if (expected === prevRootExpected) {
                                var msg = "Initial heading level for sectioning root must be <h".concat(expected, "> but got <h").concat(level, ">");
                                this.report(event.target, msg, location);
                            }
                            else {
                                var msg = "Initial heading level for sectioning root must be between <h".concat(expected, "> and <h").concat(prevRootExpected, "> but got <h").concat(level, ">");
                                this.report(event.target, msg, location);
                            }
                        }
                    }
                };
                /**
                 * Check if the current element is a sectioning root and push a new root entry
                 * on the stack if it is.
                 */
                HeadingLevel.prototype.onTagReady = function (event) {
                    var target = event.target;
                    if (this.isSectioningRoot(target)) {
                        this.stack.push({
                            node: target.unique,
                            current: 0,
                            h1Count: 0
                        });
                    }
                };
                /**
                 * Check if the current element being closed is the element which opened the
                 * current sectioning root, in which case the entry is popped from the stack.
                 */
                HeadingLevel.prototype.onTagClose = function (event) {
                    var target = event.previous;
                    var root = this.getCurrentRoot();
                    if (target.unique !== root.node) {
                        return;
                    }
                    this.stack.pop();
                };
                HeadingLevel.prototype.getPrevRoot = function () {
                    return this.stack[this.stack.length - 2];
                };
                HeadingLevel.prototype.getCurrentRoot = function () {
                    return this.stack[this.stack.length - 1];
                };
                HeadingLevel.prototype.isSectioningRoot = function (node) {
                    var context = {
                        scope: node
                    };
                    return this.sectionRoots.some(function (it) { return it.match(node, context); });
                };
                return HeadingLevel;
            }(Rule));
            var defaults$g = {
                pattern: "kebabcase"
            };
            var IdPattern = /** @class */ (function (_super) {
                __extends(IdPattern, _super);
                function IdPattern(options) {
                    var _this_1 = _super.call(this, __assign(__assign({}, defaults$g), options)) || this;
                    _this_1.pattern = parsePattern(_this_1.options.pattern);
                    return _this_1;
                }
                IdPattern.schema = function () {
                    return {
                        pattern: {
                            type: "string"
                        }
                    };
                };
                IdPattern.prototype.documentation = function () {
                    var pattern = describePattern(this.options.pattern);
                    return {
                        description: "For consistency all IDs are required to match the pattern ".concat(pattern, "."),
                        url: "https://html-validate.org/rules/id-pattern.html"
                    };
                };
                IdPattern.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("attr", function (event) {
                        var _a, _b;
                        if (event.key.toLowerCase() !== "id") {
                            return;
                        }
                        /* consider dynamic value as always matching the pattern */
                        if (event.value instanceof DynamicValue) {
                            return;
                        }
                        if (!((_a = event.value) === null || _a === void 0 ? void 0 : _a.match(_this_1.pattern))) {
                            var value = (_b = event.value) !== null && _b !== void 0 ? _b : "";
                            var pattern = _this_1.pattern.toString();
                            var message = "ID \"".concat(value, "\" does not match required pattern \"").concat(pattern, "\"");
                            _this_1.report(event.target, message, event.valueLocation);
                        }
                    });
                };
                return IdPattern;
            }(Rule));
            /* eslint-disable sonarjs/no-duplicate-string -- wont be easier to read or manage with constants */
            var restricted = new Map([
                ["accept", ["file"]],
                ["alt", ["image"]],
                [
                    "autocomplete",
                    [
                        "hidden",
                        "text",
                        "search",
                        "url",
                        "tel",
                        "email",
                        "password",
                        "date",
                        "month",
                        "week",
                        "time",
                        "datetime-local",
                        "number",
                        "range",
                        "color",
                    ],
                ],
                ["capture", ["file"]],
                ["checked", ["checkbox", "radio"]],
                ["dirname", ["text", "search"]],
                ["height", ["image"]],
                [
                    "list",
                    [
                        "text",
                        "search",
                        "url",
                        "tel",
                        "email",
                        "date",
                        "month",
                        "week",
                        "time",
                        "datetime-local",
                        "number",
                        "range",
                        "color",
                    ],
                ],
                ["max", ["date", "month", "week", "time", "datetime-local", "number", "range"]],
                ["maxlength", ["text", "search", "url", "tel", "email", "password"]],
                ["min", ["date", "month", "week", "time", "datetime-local", "number", "range"]],
                ["minlength", ["text", "search", "url", "tel", "email", "password"]],
                ["multiple", ["email", "file"]],
                ["pattern", ["text", "search", "url", "tel", "email", "password"]],
                ["placeholder", ["text", "search", "url", "tel", "email", "password", "number"]],
                [
                    "readonly",
                    [
                        "text",
                        "search",
                        "url",
                        "tel",
                        "email",
                        "password",
                        "date",
                        "month",
                        "week",
                        "time",
                        "datetime-local",
                        "number",
                    ],
                ],
                [
                    "required",
                    [
                        "text",
                        "search",
                        "url",
                        "tel",
                        "email",
                        "password",
                        "date",
                        "month",
                        "week",
                        "time",
                        "datetime-local",
                        "number",
                        "checkbox",
                        "radio",
                        "file",
                    ],
                ],
                ["size", ["text", "search", "url", "tel", "email", "password"]],
                ["src", ["image"]],
                ["step", ["date", "month", "week", "time", "datetime-local", "number", "range"]],
                ["width", ["image"]],
            ]);
            function isInput(event) {
                var target = event.target;
                return target.is("input");
            }
            var InputAttributes = /** @class */ (function (_super) {
                __extends(InputAttributes, _super);
                function InputAttributes() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                InputAttributes.prototype.documentation = function (context) {
                    var _a, _b;
                    var attribute = context.attribute, type = context.type;
                    var summary = "Attribute `".concat(attribute, "` is not allowed on `<input type=\"").concat(type, "\">`\n");
                    var details = "`".concat(attribute, "` can only be used when `type` is:");
                    var list = (_b = (_a = restricted.get(attribute)) === null || _a === void 0 ? void 0 : _a.map(function (it) { return "- `".concat(it, "`"); })) !== null && _b !== void 0 ? _b : [];
                    return {
                        description: __spreadArray([summary, details], list, true).join("\n"),
                        url: "https://html-validate.org/rules/input-attributes.html"
                    };
                };
                InputAttributes.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("tag:ready", isInput, function (event) {
                        var target = event.target;
                        var type = target.getAttribute("type");
                        if (!type || type.isDynamic || !type.value) {
                            return;
                        }
                        var typeValue = type.value.toString();
                        for (var _1 = 0, _2 = target.attributes; _1 < _2.length; _1++) {
                            var attr = _2[_1];
                            var validTypes = restricted.get(attr.key);
                            if (!validTypes) {
                                continue;
                            }
                            if (validTypes.includes(typeValue)) {
                                continue;
                            }
                            var context = {
                                attribute: attr.key,
                                type: typeValue
                            };
                            var message = "Attribute \"".concat(attr.key, "\" is not allowed on <input type=\"").concat(typeValue, "\">");
                            _this_1.report(target, message, attr.keyLocation, context);
                        }
                    });
                };
                return InputAttributes;
            }(Rule));
            var HAS_ACCESSIBLE_TEXT_CACHE = Symbol(hasAccessibleName.name);
            function isHidden(node, context) {
                var reference = context.reference;
                if (reference && reference.isSameNode(node)) {
                    return false;
                }
                else {
                    return isHTMLHidden(node) || !inAccessibilityTree(node);
                }
            }
            function hasImgAltText(node, context) {
                if (node.is("img")) {
                    return hasAltText(node);
                }
                else if (node.is("svg")) {
                    return node.textContent.trim() !== "";
                }
                else {
                    for (var _1 = 0, _2 = node.querySelectorAll("img, svg"); _1 < _2.length; _1++) {
                        var img = _2[_1];
                        var hasName = hasAccessibleNameImpl(img, context);
                        if (hasName) {
                            return true;
                        }
                    }
                    return false;
                }
            }
            function hasLabel(node) {
                var _a;
                var value = (_a = node.getAttributeValue("aria-label")) !== null && _a !== void 0 ? _a : "";
                return Boolean(value.trim());
            }
            function isLabelledby(node, context) {
                var document = context.document, reference = context.reference;
                /* if we already have resolved one level of reference we don't resolve another
                 * level (as per accname step 2B) */
                if (reference) {
                    return false;
                }
                var ariaLabelledby = node.ariaLabelledby;
                /* consider dynamic aria-labelledby as having a name as we cannot resolve it
                 * so no way to prove correctness */
                if (ariaLabelledby instanceof DynamicValue) {
                    return true;
                }
                /* ignore elements without aria-labelledby */
                if (ariaLabelledby === null) {
                    return false;
                }
                return ariaLabelledby.some(function (id) {
                    var selector = generateIdSelector(id);
                    return document.querySelectorAll(selector).some(function (child) {
                        return hasAccessibleNameImpl(child, {
                            document: document,
                            reference: child
                        });
                    });
                });
            }
            /**
             * This algorithm is based on ["Accessible Name and Description Computation
             * 1.2"][accname] with some exceptions:
             *
             * It doesn't compute the actual name but only the presence of one, e.g. if a
             * non-empty flat string is present the algorithm terminates with a positive
             * result.
             *
             * It takes some optimization shortcuts such as starting with step F as it
             * would be more common usage and as there is no actual name being computed
             * the order wont matter.
             *
             * [accname]: https://w3c.github.io/accname
             */
            function hasAccessibleNameImpl(current, context) {
                var reference = context.reference;
                /* if this element is hidden (see function for exceptions) it does not have an accessible name */
                if (isHidden(current, context)) {
                    return false;
                }
                /* special case: when this element is directly referenced by aria-labelledby
                 * we ignore `hidden` */
                var ignoreHiddenRoot = Boolean(reference && reference.isSameNode(current));
                var text = classifyNodeText(current, { accessible: true, ignoreHiddenRoot: ignoreHiddenRoot });
                if (text !== exports.TextClassification.EMPTY_TEXT) {
                    return true;
                }
                if (hasImgAltText(current, context)) {
                    return true;
                }
                if (hasLabel(current)) {
                    return true;
                }
                if (isLabelledby(current, context)) {
                    return true;
                }
                return false;
            }
            /**
             * Returns `true` if the element has an accessible name.
             *
             * It does not yet consider if the elements role prohibits naming, e.g. a `<p>`
             * element will still show up as having an accessible name.
             *
             * @public
             * @param document - Document element.
             * @param current - The element to get accessible name for
             * @returns `true` if the element has an accessible name.
             */
            function hasAccessibleName(document, current) {
                /* istanbul ignore next: we're not testing cache */
                if (current.cacheExists(HAS_ACCESSIBLE_TEXT_CACHE)) {
                    return Boolean(current.cacheGet(HAS_ACCESSIBLE_TEXT_CACHE));
                }
                var result = hasAccessibleNameImpl(current, {
                    document: document,
                    reference: null
                });
                return current.cacheSet(HAS_ACCESSIBLE_TEXT_CACHE, result);
            }
            function isIgnored(node) {
                var _a;
                if (node.is("input")) {
                    var type_1 = (_a = node.getAttributeValue("type")) === null || _a === void 0 ? void 0 : _a.toLowerCase();
                    var ignored = ["hidden", "submit", "reset", "button"];
                    return Boolean(type_1 && ignored.includes(type_1));
                }
                return false;
            }
            var InputMissingLabel = /** @class */ (function (_super) {
                __extends(InputMissingLabel, _super);
                function InputMissingLabel() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                InputMissingLabel.prototype.documentation = function () {
                    return {
                        description: [
                            "Each form element must have an a label or accessible name.",
                            'Typically this is implemented using a `<label for="..">` element describing the purpose of the form element.',
                            "",
                            "This can be resolved in one of the following ways:",
                            "",
                            '  - Use an associated `<label for="..">` element.',
                            "  - Use a nested `<label>` as parent element.",
                            "  - Use `aria-label` or `aria-labelledby` attributes.",
                        ].join("\n"),
                        url: "https://html-validate.org/rules/input-missing-label.html"
                    };
                };
                InputMissingLabel.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("dom:ready", function (event) {
                        var root = event.document;
                        for (var _1 = 0, _2 = root.querySelectorAll("input, textarea, select"); _1 < _2.length; _1++) {
                            var elem = _2[_1];
                            _this_1.validateInput(root, elem);
                        }
                    });
                };
                InputMissingLabel.prototype.validateInput = function (root, elem) {
                    if (isHTMLHidden(elem) || isAriaHidden(elem)) {
                        return;
                    }
                    /* hidden, submit, reset or button should not have label */
                    if (isIgnored(elem)) {
                        return;
                    }
                    if (hasAccessibleName(root, elem)) {
                        return;
                    }
                    var label = [];
                    /* try to find label by id */
                    if ((label = findLabelById(root, elem.id)).length > 0) {
                        this.validateLabel(root, elem, label);
                        return;
                    }
                    /* try to find parent label (input nested in label) */
                    if ((label = findLabelByParent(elem)).length > 0) {
                        this.validateLabel(root, elem, label);
                        return;
                    }
                    if (elem.hasAttribute("aria-label")) {
                        this.report(elem, "<".concat(elem.tagName, "> element has aria-label but label has no text"));
                    }
                    else if (elem.hasAttribute("aria-labelledby")) {
                        this.report(elem, "<".concat(elem.tagName, "> element has aria-labelledby but referenced element has no text"));
                    }
                    else {
                        this.report(elem, "<".concat(elem.tagName, "> element does not have a <label>"));
                    }
                };
                /**
                 * Reports error if none of the labels are accessible.
                 */
                InputMissingLabel.prototype.validateLabel = function (root, elem, labels) {
                    var visible = labels.filter(isVisible);
                    if (visible.length === 0) {
                        this.report(elem, "<".concat(elem.tagName, "> element has <label> but <label> element is hidden"));
                        return;
                    }
                    if (!labels.some(function (label) { return hasAccessibleName(root, label); })) {
                        this.report(elem, "<".concat(elem.tagName, "> element has <label> but <label> has no text"));
                    }
                };
                return InputMissingLabel;
            }(Rule));
            function isVisible(elem) {
                var hidden = isHTMLHidden(elem) || isAriaHidden(elem);
                return !hidden;
            }
            function findLabelById(root, id) {
                if (!id)
                    return [];
                return root.querySelectorAll("label[for=\"".concat(id, "\"]"));
            }
            function findLabelByParent(el) {
                var cur = el.parent;
                while (cur) {
                    if (cur.is("label")) {
                        return [cur];
                    }
                    cur = cur.parent;
                }
                return [];
            }
            var defaults$f = {
                maxlength: 70
            };
            var LongTitle = /** @class */ (function (_super) {
                __extends(LongTitle, _super);
                function LongTitle(options) {
                    var _this_1 = _super.call(this, __assign(__assign({}, defaults$f), options)) || this;
                    _this_1.maxlength = _this_1.options.maxlength;
                    return _this_1;
                }
                LongTitle.schema = function () {
                    return {
                        maxlength: {
                            type: "number"
                        }
                    };
                };
                LongTitle.prototype.documentation = function () {
                    return {
                        description: "Search engines truncates titles with long text, possibly down-ranking the page in the process.",
                        url: "https://html-validate.org/rules/long-title.html"
                    };
                };
                LongTitle.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("tag:end", function (event) {
                        var node = event.previous;
                        if (node.tagName !== "title")
                            return;
                        var text = node.textContent;
                        if (text.length > _this_1.maxlength) {
                            _this_1.report(node, "title text cannot be longer than ".concat(_this_1.maxlength, " characters"));
                        }
                    });
                };
                return LongTitle;
            }(Rule));
            var MetaRefresh = /** @class */ (function (_super) {
                __extends(MetaRefresh, _super);
                function MetaRefresh() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                MetaRefresh.prototype.documentation = function () {
                    return {
                        description: "Meta refresh directive must use the `0;url=...` format. Non-zero values for time interval is disallowed as people with assistive technology might be unable to read and understand the page content before automatically reloading. For the same reason skipping the url is disallowed as it would put the browser in an infinite loop reloading the same page over and over again.",
                        url: "https://html-validate.org/rules/meta-refresh.html"
                    };
                };
                MetaRefresh.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("element:ready", function (_1) {
                        var target = _1.target;
                        /* only handle <meta> */
                        if (!target.is("meta")) {
                            return;
                        }
                        /* only handle refresh */
                        var httpEquiv = target.getAttributeValue("http-equiv");
                        if (httpEquiv !== "refresh") {
                            return;
                        }
                        /* ensure content attribute is set */
                        var content = target.getAttribute("content");
                        if (!(content === null || content === void 0 ? void 0 : content.value) || content.isDynamic) {
                            return;
                        }
                        /* ensure content attribute is valid */
                        var location = content.valueLocation;
                        var value = parseContent(content.value.toString());
                        if (!value) {
                            _this_1.report(target, "Malformed meta refresh directive", location);
                            return;
                        }
                        /* ensure a url is set */
                        if (!value.url) {
                            _this_1.report(target, "Don't use meta refresh to reload the page", location);
                        }
                        /* ensure delay is exactly 0 seconds */
                        if (value.delay !== 0) {
                            _this_1.report(target, "Meta refresh must use 0 second delay", location);
                        }
                    });
                };
                return MetaRefresh;
            }(Rule));
            function parseContent(text) {
                var match = text.match(/^(\d+)(?:\s*;\s*url=(.*))?/);
                if (match) {
                    return {
                        delay: parseInt(match[1], 10),
                        url: match[2]
                    };
                }
                else {
                    return null;
                }
            }
            function getName(attr) {
                var name = attr.value;
                if (!name || name instanceof DynamicValue) {
                    return null;
                }
                return name;
            }
            var MapDupName = /** @class */ (function (_super) {
                __extends(MapDupName, _super);
                function MapDupName() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                MapDupName.prototype.documentation = function () {
                    return {
                        description: "`<map>` must have a unique name, it cannot be the same name as another `<map>` element",
                        url: "https://html-validate.org/rules/map-dup-name.html"
                    };
                };
                MapDupName.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("dom:ready", function (event) {
                        var document = event.document;
                        var maps = document.querySelectorAll("map[name]");
                        var names = new Set();
                        for (var _1 = 0, maps_1 = maps; _1 < maps_1.length; _1++) {
                            var map = maps_1[_1];
                            var attr = map.getAttribute("name");
                            /* istanbul ignore next -- should not happen as querySelector matches
                             * only the elements with the name attribute */
                            if (!attr) {
                                continue;
                            }
                            var name_16 = getName(attr);
                            if (!name_16) {
                                continue;
                            }
                            if (names.has(name_16)) {
                                _this_1.report({
                                    node: map,
                                    message: "<map> name must be unique",
                                    location: attr.keyLocation
                                });
                            }
                            names.add(name_16);
                        }
                    });
                };
                return MapDupName;
            }(Rule));
            function isRelevant$3(event) {
                return event.target.is("map");
            }
            function hasStaticValue(attr) {
                return Boolean(attr && !(attr.value instanceof DynamicValue));
            }
            var MapIdName = /** @class */ (function (_super) {
                __extends(MapIdName, _super);
                function MapIdName() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                MapIdName.prototype.documentation = function () {
                    return {
                        description: "When the `id` attribute is present on a `<map>` element it must be equal to the `name` attribute.",
                        url: "https://html-validate.org/rules/map-id-name.html"
                    };
                };
                MapIdName.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("tag:ready", isRelevant$3, function (event) {
                        var _a;
                        var target = event.target;
                        var id = target.getAttribute("id");
                        var name = target.getAttribute("name");
                        // /* ignore missing attributes or dynamic value */
                        if (!hasStaticValue(id) || !hasStaticValue(name)) {
                            return;
                        }
                        /* ignore when id and name is the same */
                        if (id.value === name.value) {
                            return;
                        }
                        _this_1.report({
                            node: event.target,
                            message: "\"id\" and \"name\" attribute must be the same on <map> elements",
                            location: (_a = id.valueLocation) !== null && _a !== void 0 ? _a : name.valueLocation
                        });
                    });
                };
                return MapIdName;
            }(Rule));
            var MissingDoctype = /** @class */ (function (_super) {
                __extends(MissingDoctype, _super);
                function MissingDoctype() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                MissingDoctype.prototype.documentation = function () {
                    return {
                        description: "Requires that the document contains a doctype.",
                        url: "https://html-validate.org/rules/missing-doctype.html"
                    };
                };
                MissingDoctype.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("dom:ready", function (event) {
                        var dom = event.document;
                        if (!dom.doctype) {
                            _this_1.report(dom.root, "Document is missing doctype");
                        }
                    });
                };
                return MissingDoctype;
            }(Rule));
            var MultipleLabeledControls = /** @class */ (function (_super) {
                __extends(MultipleLabeledControls, _super);
                function MultipleLabeledControls() {
                    var _this_1 = _super.apply(this, arguments) || this;
                    _this_1.labelable = "";
                    return _this_1;
                }
                MultipleLabeledControls.prototype.documentation = function () {
                    return {
                        description: "A `<label>` element can only be associated with one control at a time.",
                        url: "https://html-validate.org/rules/multiple-labeled-controls.html"
                    };
                };
                MultipleLabeledControls.prototype.setup = function () {
                    var _this_1 = this;
                    this.labelable = this.getTagsWithProperty("labelable").join(",");
                    this.on("element:ready", function (event) {
                        var target = event.target;
                        /* only handle <label> */
                        if (target.tagName !== "label") {
                            return;
                        }
                        /* no error if it references 0 or 1 controls */
                        var numControls = _this_1.getNumLabledControls(target);
                        if (numControls <= 1) {
                            return;
                        }
                        _this_1.report(target, "<label> is associated with multiple controls", target.location);
                    });
                };
                MultipleLabeledControls.prototype.getNumLabledControls = function (src) {
                    /* get all controls wrapped by label element */
                    var controls = src.querySelectorAll(this.labelable).map(function (node) { return node.id; });
                    /* only count wrapped controls if the "for" attribute is missing or static,
                     * for dynamic "for" attributes it is better to run in document mode later */
                    var attr = src.getAttribute("for");
                    if (!attr || attr.isDynamic || !attr.value) {
                        return controls.length;
                    }
                    /* if "for" attribute references a wrapped element it should not be counted
                     * multiple times */
                    var redundant = controls.includes(attr.value.toString());
                    if (redundant) {
                        return controls.length;
                    }
                    /* has "for" attribute pointing to element outside wrapped controls */
                    return controls.length + 1;
                };
                return MultipleLabeledControls;
            }(Rule));
            var defaults$e = {
                include: null,
                exclude: null
            };
            var NoAutoplay = /** @class */ (function (_super) {
                __extends(NoAutoplay, _super);
                function NoAutoplay(options) {
                    return _super.call(this, __assign(__assign({}, defaults$e), options)) || this;
                }
                NoAutoplay.prototype.documentation = function (context) {
                    return {
                        description: [
                            "The autoplay attribute is not allowed on <".concat(context.tagName, ">."),
                            "Autoplaying content can be disruptive for users and has accessibilty concerns.",
                            "Prefer to let the user control playback.",
                        ].join("\n"),
                        url: "https://html-validate.org/rules/no-autoplay.html"
                    };
                };
                NoAutoplay.schema = function () {
                    return {
                        exclude: {
                            anyOf: [
                                {
                                    items: {
                                        type: "string"
                                    },
                                    type: "array"
                                },
                                {
                                    type: "null"
                                },
                            ]
                        },
                        include: {
                            anyOf: [
                                {
                                    items: {
                                        type: "string"
                                    },
                                    type: "array"
                                },
                                {
                                    type: "null"
                                },
                            ]
                        }
                    };
                };
                NoAutoplay.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("attr", function (event) {
                        /* only handle autoplay attribute */
                        if (event.key.toLowerCase() !== "autoplay") {
                            return;
                        }
                        /* ignore dynamic values */
                        if (event.value && event.value instanceof DynamicValue) {
                            return;
                        }
                        /* ignore tagnames configured to be ignored */
                        var tagName = event.target.tagName;
                        if (_this_1.isKeywordIgnored(tagName)) {
                            return;
                        }
                        /* report error */
                        var context = { tagName: tagName };
                        var location = event.location;
                        _this_1.report(event.target, "The autoplay attribute is not allowed on <".concat(tagName, ">"), location, context);
                    });
                };
                return NoAutoplay;
            }(Rule));
            var NoConditionalComment = /** @class */ (function (_super) {
                __extends(NoConditionalComment, _super);
                function NoConditionalComment() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                NoConditionalComment.prototype.documentation = function () {
                    return {
                        description: "Microsoft Internet Explorer previously supported using special HTML comments (conditional comments) for targeting specific versions of IE but since IE 10 it is deprecated and not supported in standards mode.",
                        url: "https://html-validate.org/rules/no-conditional-comment.html"
                    };
                };
                NoConditionalComment.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("conditional", function (event) {
                        _this_1.report(event.parent, "Use of conditional comments are deprecated", event.location);
                    });
                };
                return NoConditionalComment;
            }(Rule));
            var NoDeprecatedAttr = /** @class */ (function (_super) {
                __extends(NoDeprecatedAttr, _super);
                function NoDeprecatedAttr() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                NoDeprecatedAttr.prototype.documentation = function () {
                    return {
                        description: "HTML5 deprecated many old attributes.",
                        url: "https://html-validate.org/rules/no-deprecated-attr.html"
                    };
                };
                NoDeprecatedAttr.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("attr", function (event) {
                        var node = event.target;
                        var meta = node.meta;
                        var attr = event.key.toLowerCase();
                        /* cannot validate if meta isn't known */
                        if (meta === null) {
                            return;
                        }
                        var metaAttribute = meta.attributes[attr];
                        if (!metaAttribute) {
                            return;
                        }
                        var deprecated = metaAttribute.deprecated;
                        if (deprecated) {
                            _this_1.report(node, "Attribute \"".concat(event.key, "\" is deprecated on <").concat(node.tagName, "> element"), event.keyLocation);
                        }
                    });
                };
                return NoDeprecatedAttr;
            }(Rule));
            var NoDupAttr = /** @class */ (function (_super) {
                __extends(NoDupAttr, _super);
                function NoDupAttr() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                NoDupAttr.prototype.documentation = function () {
                    return {
                        description: "HTML disallows two or more attributes with the same (case-insensitive) name.",
                        url: "https://html-validate.org/rules/no-dup-attr.html"
                    };
                };
                NoDupAttr.prototype.setup = function () {
                    var _this_1 = this;
                    var attr = {};
                    this.on("tag:start", function () {
                        /* reset any time a new tag is opened */
                        attr = {};
                    });
                    this.on("attr", function (event) {
                        /* ignore dynamic attributes aliasing another, e.g class and ng-class */
                        if (event.originalAttribute) {
                            return;
                        }
                        var name = event.key.toLowerCase();
                        if (name in attr) {
                            _this_1.report(event.target, "Attribute \"".concat(name, "\" duplicated"), event.keyLocation);
                        }
                        attr[event.key] = true;
                    });
                };
                return NoDupAttr;
            }(Rule));
            var NoDupClass = /** @class */ (function (_super) {
                __extends(NoDupClass, _super);
                function NoDupClass() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                NoDupClass.prototype.documentation = function () {
                    return {
                        description: "Prevents unnecessary duplication of class names.",
                        url: "https://html-validate.org/rules/no-dup-class.html"
                    };
                };
                NoDupClass.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("attr", function (event) {
                        if (event.key.toLowerCase() !== "class") {
                            return;
                        }
                        var classes = new DOMTokenList(event.value, event.valueLocation);
                        var unique = new Set();
                        classes.forEach(function (cur, index) {
                            if (unique.has(cur)) {
                                var location_11 = classes.location(index);
                                _this_1.report(event.target, "Class \"".concat(cur, "\" duplicated"), location_11);
                            }
                            unique.add(cur);
                        });
                    });
                };
                return NoDupClass;
            }(Rule));
            var NoDupID = /** @class */ (function (_super) {
                __extends(NoDupID, _super);
                function NoDupID() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                NoDupID.prototype.documentation = function () {
                    return {
                        description: "The ID of an element must be unique.",
                        url: "https://html-validate.org/rules/no-dup-id.html"
                    };
                };
                NoDupID.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("dom:ready", function (event) {
                        var document = event.document;
                        var existing = new Set();
                        var elements = document.querySelectorAll("[id]");
                        var relevant = elements.filter(isRelevant$2);
                        for (var _1 = 0, relevant_1 = relevant; _1 < relevant_1.length; _1++) {
                            var el = relevant_1[_1];
                            var attr = el.getAttribute("id");
                            /* istanbul ignore next: this has already been tested in isRelevant once but for type-safety it is checked again */
                            if (!(attr === null || attr === void 0 ? void 0 : attr.value)) {
                                continue;
                            }
                            var id = attr.value.toString();
                            if (existing.has(id)) {
                                _this_1.report(el, "Duplicate ID \"".concat(id, "\""), attr.valueLocation);
                            }
                            existing.add(id);
                        }
                    });
                };
                return NoDupID;
            }(Rule));
            function isRelevant$2(element) {
                var attr = element.getAttribute("id");
                /* istanbul ignore next: can not really happen as querySelector will only return elements with id present */
                if (!attr) {
                    return false;
                }
                /* id without value is not relevant, e.g. <p id></p> */
                if (!attr.value) {
                    return false;
                }
                /* dynamic id (interpolated or otherwise currently unknown value) is not relevant */
                if (attr.isDynamic) {
                    return false;
                }
                return true;
            }
            function isRelevant$1(event) {
                return event.target.is("button");
            }
            var NoImplicitButtonType = /** @class */ (function (_super) {
                __extends(NoImplicitButtonType, _super);
                function NoImplicitButtonType() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                NoImplicitButtonType.prototype.documentation = function () {
                    return {
                        description: [
                            "`<button>` is missing required `type` attribute",
                            "",
                            "When the `type` attribute is omitted it defaults to `submit`.",
                            "Submit buttons are triggered when a keyboard user presses <kbd>Enter</kbd>.",
                            "",
                            "As this may or may not be inteded this rule enforces that the `type` attribute be explicitly set to one of the valid types:",
                            "",
                            "- `button` - a generic button.",
                            "- `submit` - a submit button.",
                            "- `reset`- a button to reset form fields.",
                        ].join("\n"),
                        url: "https://html-validate.org/rules/no-implicit-button-type.html"
                    };
                };
                NoImplicitButtonType.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("element:ready", isRelevant$1, function (event) {
                        var target = event.target;
                        var attr = target.getAttribute("type");
                        if (!attr) {
                            _this_1.report({
                                node: event.target,
                                message: "<button> is missing required \"type\" attribute"
                            });
                        }
                    });
                };
                return NoImplicitButtonType;
            }(Rule));
            var NoImplicitClose = /** @class */ (function (_super) {
                __extends(NoImplicitClose, _super);
                function NoImplicitClose() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                NoImplicitClose.prototype.documentation = function () {
                    return {
                        description: "Some elements in HTML has optional end tags. When an optional tag is omitted a browser must handle it as if the end tag was present.\n\nOmitted end tags can be ambigious for humans to read and many editors have trouble formatting the markup.",
                        url: "https://html-validate.org/rules/no-implicit-close.html"
                    };
                };
                NoImplicitClose.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("tag:end", function (event) {
                        var closed = event.previous;
                        var by = event.target;
                        /* not set when unclosed elements are being closed by tree, this rule does
                         * not consider such events (handled by close-order instead) */
                        if (!by) {
                            return;
                        }
                        if (closed.closed !== exports.NodeClosed.ImplicitClosed) {
                            return;
                        }
                        var closedByParent = closed.parent && closed.parent.tagName === by.tagName; /* <ul><li></ul> */
                        var sameTag = closed.tagName === by.tagName; /* <p>foo<p>bar */
                        if (closedByParent) {
                            _this_1.report(closed, "Element <".concat(closed.tagName, "> is implicitly closed by parent </").concat(by.tagName, ">"), closed.location);
                        }
                        else if (sameTag) {
                            _this_1.report(closed, "Element <".concat(closed.tagName, "> is implicitly closed by sibling"), closed.location);
                        }
                        else {
                            _this_1.report(closed, "Element <".concat(closed.tagName, "> is implicitly closed by adjacent <").concat(by.tagName, ">"), closed.location);
                        }
                    });
                };
                return NoImplicitClose;
            }(Rule));
            var defaults$d = {
                include: null,
                exclude: null,
                allowedProperties: ["display"]
            };
            var NoInlineStyle = /** @class */ (function (_super) {
                __extends(NoInlineStyle, _super);
                function NoInlineStyle(options) {
                    return _super.call(this, __assign(__assign({}, defaults$d), options)) || this;
                }
                NoInlineStyle.schema = function () {
                    return {
                        exclude: {
                            anyOf: [
                                {
                                    items: {
                                        type: "string"
                                    },
                                    type: "array"
                                },
                                {
                                    type: "null"
                                },
                            ]
                        },
                        include: {
                            anyOf: [
                                {
                                    items: {
                                        type: "string"
                                    },
                                    type: "array"
                                },
                                {
                                    type: "null"
                                },
                            ]
                        },
                        allowedProperties: {
                            items: {
                                type: "string"
                            },
                            type: "array"
                        }
                    };
                };
                NoInlineStyle.prototype.documentation = function () {
                    var text = [
                        "Inline style is not allowed.\n",
                        "Inline style is a sign of unstructured CSS. Use class or ID with a separate stylesheet.\n",
                    ];
                    if (this.options.allowedProperties.length > 0) {
                        text.push("Under the current configuration the following CSS properties are allowed:\n");
                        text.push(this.options.allowedProperties.map(function (it) { return "- `".concat(it, "`"); }).join("\n"));
                    }
                    return {
                        description: text.join("\n"),
                        url: "https://html-validate.org/rules/no-inline-style.html"
                    };
                };
                NoInlineStyle.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("attr", function (event) { return _this_1.isRelevant(event); }, function (event) {
                        var value = event.value;
                        if (_this_1.allPropertiesAllowed(value)) {
                            return;
                        }
                        _this_1.report(event.target, "Inline style is not allowed");
                    });
                };
                NoInlineStyle.prototype.isRelevant = function (event) {
                    var _a;
                    if (event.key !== "style") {
                        return false;
                    }
                    var _1 = this.options, include = _1.include, exclude = _1.exclude;
                    var key = (_a = event.originalAttribute) !== null && _a !== void 0 ? _a : event.key;
                    /* ignore attributes not present in "include" */
                    if (include && !include.includes(key)) {
                        return false;
                    }
                    /* ignore attributes present in "exclude" */
                    if (exclude && exclude.includes(key)) {
                        return false;
                    }
                    return true;
                };
                NoInlineStyle.prototype.allPropertiesAllowed = function (value) {
                    var allowProperties = this.options.allowedProperties;
                    /* quick path: no properties are allowed, no need to check each one individually */
                    if (allowProperties.length === 0) {
                        return false;
                    }
                    var declarations = Object.keys(parseCssDeclaration(value));
                    return (declarations.length > 0 &&
                        declarations.every(function (it) {
                            return allowProperties.includes(it);
                        }));
                };
                return NoInlineStyle;
            }(Rule));
            var ARIA = [
                { property: "aria-activedescendant", isList: false },
                { property: "aria-controls", isList: true },
                { property: "aria-describedby", isList: true },
                { property: "aria-details", isList: false },
                { property: "aria-errormessage", isList: false },
                { property: "aria-flowto", isList: true },
                { property: "aria-labelledby", isList: true },
                { property: "aria-owns", isList: true },
            ];
            function idMissing(document, id) {
                var nodes = document.querySelectorAll("[id=\"".concat(id, "\"]"));
                return nodes.length === 0;
            }
            var NoMissingReferences = /** @class */ (function (_super) {
                __extends(NoMissingReferences, _super);
                function NoMissingReferences() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                NoMissingReferences.prototype.documentation = function (context) {
                    return {
                        description: "The element ID \"".concat(context.value, "\" referenced by the ").concat(context.key, " attribute must point to an existing element."),
                        url: "https://html-validate.org/rules/no-missing-references.html"
                    };
                };
                NoMissingReferences.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("dom:ready", function (event) {
                        var document = event.document;
                        /* verify <label for=".."> */
                        for (var _1 = 0, _2 = document.querySelectorAll("label[for]"); _1 < _2.length; _1++) {
                            var node = _2[_1];
                            var attr = node.getAttribute("for");
                            _this_1.validateReference(document, node, attr, false);
                        }
                        /* verify <input list=".."> */
                        for (var _3 = 0, _4 = document.querySelectorAll("input[list]"); _3 < _4.length; _3++) {
                            var node = _4[_3];
                            var attr = node.getAttribute("list");
                            _this_1.validateReference(document, node, attr, false);
                        }
                        /* verify WAI-ARIA properties */
                        for (var _5 = 0, ARIA_1 = ARIA; _5 < ARIA_1.length; _5++) {
                            var _6 = ARIA_1[_5], property = _6.property, isList = _6.isList;
                            for (var _7 = 0, _8 = document.querySelectorAll("[".concat(property, "]")); _7 < _8.length; _7++) {
                                var node = _8[_7];
                                var attr = node.getAttribute(property);
                                _this_1.validateReference(document, node, attr, isList);
                            }
                        }
                    });
                };
                NoMissingReferences.prototype.validateReference = function (document, node, attr, isList) {
                    /* sanity check: querySelector should never return elements without the attribute */
                    /* istanbul ignore next */
                    if (!attr) {
                        return;
                    }
                    /* skip dynamic and empty values */
                    var value = attr.value;
                    if (value instanceof DynamicValue || value === null || value === "") {
                        return;
                    }
                    if (isList) {
                        this.validateList(document, node, attr, value);
                    }
                    else {
                        this.validateSingle(document, node, attr, value);
                    }
                };
                NoMissingReferences.prototype.validateSingle = function (document, node, attr, id) {
                    if (idMissing(document, id)) {
                        var context = { key: attr.key, value: id };
                        this.report(node, "Element references missing id \"".concat(id, "\""), attr.valueLocation, context);
                    }
                };
                NoMissingReferences.prototype.validateList = function (document, node, attr, values) {
                    var parsed = new DOMTokenList(values, attr.valueLocation);
                    for (var _1 = 0, _2 = parsed.iterator(); _1 < _2.length; _1++) {
                        var entry = _2[_1];
                        var id = entry.item;
                        if (idMissing(document, id)) {
                            var context = { key: attr.key, value: id };
                            this.report(node, "Element references missing id \"".concat(id, "\""), entry.location, context);
                        }
                    }
                };
                return NoMissingReferences;
            }(Rule));
            var NoMultipleMain = /** @class */ (function (_super) {
                __extends(NoMultipleMain, _super);
                function NoMultipleMain() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                NoMultipleMain.prototype.documentation = function () {
                    return {
                        description: [
                            "Only a single visible `<main>` element can be present at in a document at a time.",
                            "",
                            "Multiple `<main>` can be present in the DOM as long the others are hidden using the HTML5 `hidden` attribute.",
                        ].join("\n"),
                        url: "https://html-validate.org/rules/no-multiple-main.html"
                    };
                };
                NoMultipleMain.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("dom:ready", function (event) {
                        var document = event.document;
                        var main = document.querySelectorAll("main").filter(function (cur) { return !cur.hasAttribute("hidden"); });
                        main.shift(); /* ignore the first occurrence */
                        /* report all other occurrences */
                        for (var _1 = 0, main_1 = main; _1 < main_1.length; _1++) {
                            var elem = main_1[_1];
                            _this_1.report(elem, "Multiple <main> elements present in document");
                        }
                    });
                };
                return NoMultipleMain;
            }(Rule));
            var defaults$c = {
                relaxed: false
            };
            var textRegexp = /([<>]|&(?![a-zA-Z0-9#]+;))/g;
            var unquotedAttrRegexp = /([<>"'=`]|&(?![a-zA-Z0-9#]+;))/g;
            var matchTemplate = /^(<%.*?%>|<\?.*?\?>|<\$.*?\$>)$/s;
            var replacementTable = {
                '"': "&quot;",
                "&": "&amp;",
                "'": "&apos;",
                "<": "&lt;",
                "=": "&equals;",
                ">": "&gt;",
                "`": "&grave;"
            };
            var NoRawCharacters = /** @class */ (function (_super) {
                __extends(NoRawCharacters, _super);
                function NoRawCharacters(options) {
                    var _this_1 = _super.call(this, __assign(__assign({}, defaults$c), options)) || this;
                    _this_1.relaxed = _this_1.options.relaxed;
                    return _this_1;
                }
                NoRawCharacters.schema = function () {
                    return {
                        relaxed: {
                            type: "boolean"
                        }
                    };
                };
                NoRawCharacters.prototype.documentation = function () {
                    return {
                        description: "Some characters such as `<`, `>` and `&` hold special meaning in HTML and must be escaped using a character reference (html entity).",
                        url: "https://html-validate.org/rules/no-raw-characters.html"
                    };
                };
                NoRawCharacters.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("element:ready", function (event) {
                        var node = event.target;
                        /* only iterate over direct descendants */
                        for (var _1 = 0, _2 = node.childNodes; _1 < _2.length; _1++) {
                            var child = _2[_1];
                            if (child.nodeType !== exports.NodeType.TEXT_NODE) {
                                continue;
                            }
                            /* workaround for templating <% ... %> etc */
                            if (child.textContent.match(matchTemplate)) {
                                continue;
                            }
                            _this_1.findRawChars(node, child.textContent, child.location, textRegexp);
                        }
                    });
                    this.on("attr", function (event) {
                        /* boolean attributes has no value so nothing to validate */
                        if (!event.value) {
                            return;
                        }
                        /* quoted attribute values can contain most symbols except the quotemark
                         * itself but unescaped quotemarks would cause a parsing error */
                        if (event.quote) {
                            return;
                        }
                        _this_1.findRawChars(event.target, event.value.toString(), event.valueLocation, // eslint-disable-line @typescript-eslint/no-non-null-assertion -- technical debt, valueLocation is always set if a value is provided
                        unquotedAttrRegexp);
                    });
                };
                /**
                 * Find raw special characters and report as errors.
                 *
                 * @param text - The full text to find unescaped raw characters in.
                 * @param location - Location of text.
                 * @param regexp - Regexp pattern to match using.
                 */
                NoRawCharacters.prototype.findRawChars = function (node, text, location, regexp) {
                    var match;
                    do {
                        match = regexp.exec(text);
                        if (match) {
                            var char = match[0];
                            /* In relaxed mode & only needs to be encoded if it is ambiguous,
                             * however this rule will only match either non-ambiguous ampersands or
                             * ampersands part of a character reference. Whenever it is a valid
                             * character reference or not not checked by this rule */
                            if (this.relaxed && char === "&") {
                                continue;
                            }
                            /* determine replacement character and location */
                            var replacement_1 = replacementTable[char];
                            var charLocation = sliceLocation(location, match.index, match.index + 1);
                            /* report as error */
                            this.report(node, "Raw \"".concat(char, "\" must be encoded as \"").concat(replacement_1, "\""), charLocation);
                        }
                    } while (match);
                };
                return NoRawCharacters;
            }(Rule));
            var selectors = ["input[aria-label]", "textarea[aria-label]", "select[aria-label]"];
            var NoRedundantAriaLabel = /** @class */ (function (_super) {
                __extends(NoRedundantAriaLabel, _super);
                function NoRedundantAriaLabel() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                NoRedundantAriaLabel.prototype.documentation = function () {
                    return {
                        description: "`aria-label` is redundant when an associated `<label>` element containing the same text exists.",
                        url: "https://html-validate.org/rules/no-redundant-aria-label.html"
                    };
                };
                NoRedundantAriaLabel.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("dom:ready", function (event) {
                        var document = event.document;
                        var elements = document.querySelectorAll(selectors.join(","));
                        for (var _1 = 0, elements_3 = elements; _1 < elements_3.length; _1++) {
                            var element = elements_3[_1];
                            var ariaLabel = element.getAttribute("aria-label");
                            var id = element.id;
                            if (!id) {
                                continue;
                            }
                            var label = document.querySelector("label[for=\"".concat(id, "\"]"));
                            if (!ariaLabel || !label || label.textContent.trim() !== ariaLabel.value) {
                                continue;
                            }
                            var message = "aria-label is redundant when label containing same text exists";
                            _this_1.report({
                                message: message,
                                node: element,
                                location: ariaLabel.keyLocation
                            });
                        }
                    });
                };
                return NoRedundantAriaLabel;
            }(Rule));
            var NoRedundantFor = /** @class */ (function (_super) {
                __extends(NoRedundantFor, _super);
                function NoRedundantFor() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                NoRedundantFor.prototype.documentation = function () {
                    return {
                        description: "When the `<label>` element wraps the labelable control the `for` attribute is redundant and better left out.",
                        url: "https://html-validate.org/rules/no-redundant-for.html"
                    };
                };
                NoRedundantFor.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("element:ready", function (event) {
                        var target = event.target;
                        /* only handle <label> */
                        if (target.tagName !== "label") {
                            return;
                        }
                        /* ignore label without for or dynamic value */
                        var attr = target.getAttribute("for");
                        if (!attr || attr.isDynamic) {
                            return;
                        }
                        /* ignore omitted/empty values */
                        var id = attr.value;
                        if (!id) {
                            return;
                        }
                        /* try to find labeled control */
                        var escaped = escapeSelectorComponent(id);
                        var control = target.querySelector("[id=\"".concat(escaped, "\"]"));
                        if (!control) {
                            return;
                        }
                        _this_1.report(target, 'Redundant "for" attribute', attr.keyLocation);
                    });
                };
                return NoRedundantFor;
            }(Rule));
            var NoRedundantRole = /** @class */ (function (_super) {
                __extends(NoRedundantRole, _super);
                function NoRedundantRole() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                NoRedundantRole.prototype.documentation = function (context) {
                    var role = context.role, tagName = context.tagName;
                    return {
                        description: "Using the `".concat(role, "` role is redundant as it is already implied by the `<").concat(tagName, ">` element."),
                        url: "https://html-validate.org/rules/no-redundant-role.html"
                    };
                };
                NoRedundantRole.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("tag:ready", function (event) {
                        var target = event.target;
                        var role = target.getAttribute("role");
                        /* ignore missing and dynamic values */
                        if (!(role === null || role === void 0 ? void 0 : role.value) || role.value instanceof DynamicValue) {
                            return;
                        }
                        /* ignore elements without metadata */
                        var meta = target.meta;
                        if (!meta) {
                            return;
                        }
                        /* ignore elements without implicit role */
                        var implicitRole = meta.implicitRole(target._adapter);
                        if (!implicitRole) {
                            return;
                        }
                        /* ignore elements with non-redundant roles */
                        if (role.value !== implicitRole) {
                            return;
                        }
                        /* report error */
                        var context = {
                            tagName: target.tagName,
                            role: role.value
                        };
                        _this_1.report(event.target, "Redundant role \"".concat(role.value, "\" on <").concat(target.tagName, ">"), role.valueLocation, context);
                    });
                };
                return NoRedundantRole;
            }(Rule));
            var xmlns = /^(.+):.+$/;
            var defaults$b = {
                ignoreForeign: true,
                ignoreXML: true
            };
            var NoSelfClosing = /** @class */ (function (_super) {
                __extends(NoSelfClosing, _super);
                function NoSelfClosing(options) {
                    return _super.call(this, __assign(__assign({}, defaults$b), options)) || this;
                }
                NoSelfClosing.schema = function () {
                    return {
                        ignoreForeign: {
                            type: "boolean"
                        },
                        ignoreXML: {
                            type: "boolean"
                        }
                    };
                };
                NoSelfClosing.prototype.documentation = function (tagName) {
                    tagName = tagName || "element";
                    return {
                        description: "Self-closing elements are disallowed. Use regular end tag <".concat(tagName, "></").concat(tagName, "> instead of self-closing <").concat(tagName, "/>."),
                        url: "https://html-validate.org/rules/no-self-closing.html"
                    };
                };
                NoSelfClosing.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("tag:end", function (event) {
                        var active = event.previous; // The current active element (that is, the current element on the stack)
                        if (!isRelevant(active, _this_1.options)) {
                            return;
                        }
                        _this_1.validateElement(active);
                    });
                };
                NoSelfClosing.prototype.validateElement = function (node) {
                    if (node.closed !== exports.NodeClosed.VoidSelfClosed) {
                        return;
                    }
                    this.report(node, "<".concat(node.tagName, "> must not be self-closed"), null, node.tagName);
                };
                return NoSelfClosing;
            }(Rule));
            function isRelevant(node, options) {
                /* tags in XML namespaces are relevant only if ignoreXml is false, in which
                 * case assume all xml elements must not be self-closed */
                if (node.tagName.match(xmlns)) {
                    return !options.ignoreXML;
                }
                /* nodes with missing metadata is assumed relevant */
                if (!node.meta) {
                    return true;
                }
                if (node.meta["void"]) {
                    return false;
                }
                /* foreign elements are relevant only if ignoreForeign is false, in which case
                 * assume all foreign must not be self-closed */
                if (node.meta.foreign) {
                    return !options.ignoreForeign;
                }
                return true;
            }
            var NoStyleTag = /** @class */ (function (_super) {
                __extends(NoStyleTag, _super);
                function NoStyleTag() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                NoStyleTag.prototype.documentation = function () {
                    return {
                        description: "Prefer to use external stylesheets with the `<link>` tag instead of inlining the styling.",
                        url: "https://html-validate.org/rules/no-style-tag.html"
                    };
                };
                NoStyleTag.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("tag:start", function (event) {
                        var node = event.target;
                        if (node.tagName === "style") {
                            _this_1.report(node, "Use external stylesheet with <link> instead of <style> tag");
                        }
                    });
                };
                return NoStyleTag;
            }(Rule));
            var NoTrailingWhitespace = /** @class */ (function (_super) {
                __extends(NoTrailingWhitespace, _super);
                function NoTrailingWhitespace() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                NoTrailingWhitespace.prototype.documentation = function () {
                    return {
                        description: "Lines with trailing whitespace cause unnessecary diff when using version control and usually serve no special purpose in HTML.",
                        url: "https://html-validate.org/rules/no-trailing-whitespace.html"
                    };
                };
                NoTrailingWhitespace.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("whitespace", function (event) {
                        if (event.text.match(/^[ \t]+\r?\n$/)) {
                            _this_1.report(null, "Trailing whitespace", event.location);
                        }
                    });
                };
                return NoTrailingWhitespace;
            }(Rule));
            var defaults$a = {
                include: null,
                exclude: null
            };
            var NoUnknownElements = /** @class */ (function (_super) {
                __extends(NoUnknownElements, _super);
                function NoUnknownElements(options) {
                    return _super.call(this, __assign(__assign({}, defaults$a), options)) || this;
                }
                NoUnknownElements.schema = function () {
                    return {
                        exclude: {
                            anyOf: [
                                {
                                    items: {
                                        type: "string"
                                    },
                                    type: "array"
                                },
                                {
                                    type: "null"
                                },
                            ]
                        },
                        include: {
                            anyOf: [
                                {
                                    items: {
                                        type: "string"
                                    },
                                    type: "array"
                                },
                                {
                                    type: "null"
                                },
                            ]
                        }
                    };
                };
                NoUnknownElements.prototype.documentation = function (context) {
                    var element = context ? " <".concat(context, ">") : "";
                    return {
                        description: "An unknown element".concat(element, " was used. If this is a Custom Element you need to supply element metadata for it."),
                        url: "https://html-validate.org/rules/no-unknown-elements.html"
                    };
                };
                NoUnknownElements.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("tag:start", function (event) {
                        var node = event.target;
                        if (node.meta) {
                            return;
                        }
                        if (_this_1.isKeywordIgnored(node.tagName, keywordPatternMatcher)) {
                            return;
                        }
                        _this_1.report(node, "Unknown element <".concat(node.tagName, ">"), null, node.tagName);
                    });
                };
                return NoUnknownElements;
            }(Rule));
            var NoUnusedDisable = /** @class */ (function (_super) {
                __extends(NoUnusedDisable, _super);
                function NoUnusedDisable() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                NoUnusedDisable.prototype.documentation = function (context) {
                    return {
                        description: "`".concat(context.ruleId, "` rule is disabled but no error was reported."),
                        url: "https://html-validate.org/rules/no-unused-disable.html"
                    };
                };
                NoUnusedDisable.prototype.setup = function () {
                    /* this is a special rule, the `Engine` class directly emits errors on this
                     * rule, it exists only to be able to configure whenever the rule is enabled
                     * or not and to get the regular documentation and contextual help. */
                };
                NoUnusedDisable.prototype.reportUnused = function (unused, options, location) {
                    var tokens = new DOMTokenList(options.replace(/,/g, " "), location);
                    for (var _1 = 0, unused_1 = unused; _1 < unused_1.length; _1++) {
                        var ruleId = unused_1[_1];
                        var index = tokens.indexOf(ruleId);
                        /* istanbul ignore next: the token should be present or it wouldn't be
                         * reported as unused, this is just a sanity check and fallback */
                        var tokenLocation = index >= 0 ? tokens.location(index) : location;
                        this.report({
                            node: null,
                            message: '"{{ ruleId }}" rule is disabled but no error was reported',
                            location: tokenLocation,
                            context: {
                                ruleId: ruleId
                            }
                        });
                    }
                };
                return NoUnusedDisable;
            }(Rule));
            var NoUtf8Bom = /** @class */ (function (_super) {
                __extends(NoUtf8Bom, _super);
                function NoUtf8Bom() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                NoUtf8Bom.prototype.documentation = function () {
                    return {
                        description: "This file is saved with the UTF-8 byte order mark (BOM) present. It is neither required or recommended to use.\n\nInstead the document should be served with the `Content-Type: application/javascript; charset=utf-8` header.",
                        url: "https://html-validate.org/rules/no-utf8-bom.html"
                    };
                };
                NoUtf8Bom.prototype.setup = function () {
                    var _this_1 = this;
                    var unregister = this.on("token", function (event) {
                        if (event.type === TokenType.UNICODE_BOM) {
                            _this_1.report(null, "File should be saved without UTF-8 BOM", event.location);
                        }
                        /* since the BOM must be the very first thing the rule can now be disabled for the rest of the run */
                        _this_1.setEnabled(false);
                        unregister();
                    });
                };
                return NoUtf8Bom;
            }(Rule));
            var types = ["button", "submit", "reset", "image"];
            var replacement = {
                button: '<button type="button">',
                submit: '<button type="submit">',
                reset: '<button type="reset">',
                image: '<button type="button">'
            };
            var defaults$9 = {
                include: null,
                exclude: null
            };
            var PreferButton = /** @class */ (function (_super) {
                __extends(PreferButton, _super);
                function PreferButton(options) {
                    return _super.call(this, __assign(__assign({}, defaults$9), options)) || this;
                }
                PreferButton.schema = function () {
                    return {
                        exclude: {
                            anyOf: [
                                {
                                    items: {
                                        type: "string"
                                    },
                                    type: "array"
                                },
                                {
                                    type: "null"
                                },
                            ]
                        },
                        include: {
                            anyOf: [
                                {
                                    items: {
                                        type: "string"
                                    },
                                    type: "array"
                                },
                                {
                                    type: "null"
                                },
                            ]
                        }
                    };
                };
                PreferButton.prototype.documentation = function (context) {
                    var src = "<input type=\"".concat(context.type, "\">");
                    var dst = replacement[context.type] || "<button>";
                    return {
                        description: "Prefer to use `".concat(dst, "` instead of `\"").concat(src, "`."),
                        url: "https://html-validate.org/rules/prefer-button.html"
                    };
                };
                PreferButton.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("attr", function (event) {
                        var node = event.target;
                        /* only handle input elements */
                        if (node.tagName.toLowerCase() !== "input") {
                            return;
                        }
                        /* only handle type attribute */
                        if (event.key.toLowerCase() !== "type") {
                            return;
                        }
                        /* sanity check: handle missing, boolean and dynamic attributes */
                        if (!event.value || event.value instanceof DynamicValue) {
                            return;
                        }
                        /* ignore types configured to be ignored */
                        var type = event.value.toLowerCase();
                        if (_this_1.isKeywordIgnored(type)) {
                            return;
                        }
                        /* only values matching known type triggers error */
                        if (!types.includes(type)) {
                            return;
                        }
                        var context = { type: type };
                        var message = "Prefer to use <button> instead of <input type=\"".concat(type, "\"> when adding buttons");
                        _this_1.report(node, message, event.valueLocation, context);
                    });
                };
                return PreferButton;
            }(Rule));
            var defaults$8 = {
                mapping: {
                    article: "article",
                    banner: "header",
                    button: "button",
                    cell: "td",
                    checkbox: "input",
                    complementary: "aside",
                    contentinfo: "footer",
                    figure: "figure",
                    form: "form",
                    heading: "hN",
                    input: "input",
                    link: "a",
                    list: "ul",
                    listbox: "select",
                    listitem: "li",
                    main: "main",
                    navigation: "nav",
                    progressbar: "progress",
                    radio: "input",
                    region: "section",
                    table: "table",
                    textbox: "textarea"
                },
                include: null,
                exclude: null
            };
            var PreferNativeElement = /** @class */ (function (_super) {
                __extends(PreferNativeElement, _super);
                function PreferNativeElement(options) {
                    return _super.call(this, __assign(__assign({}, defaults$8), options)) || this;
                }
                PreferNativeElement.schema = function () {
                    return {
                        exclude: {
                            anyOf: [
                                {
                                    items: {
                                        type: "string"
                                    },
                                    type: "array"
                                },
                                {
                                    type: "null"
                                },
                            ]
                        },
                        include: {
                            anyOf: [
                                {
                                    items: {
                                        type: "string"
                                    },
                                    type: "array"
                                },
                                {
                                    type: "null"
                                },
                            ]
                        },
                        mapping: {
                            type: "object"
                        }
                    };
                };
                PreferNativeElement.prototype.documentation = function (context) {
                    return {
                        description: "Instead of using the WAI-ARIA role \"".concat(context.role, "\" prefer to use the native <").concat(context.replacement, "> element."),
                        url: "https://html-validate.org/rules/prefer-native-element.html"
                    };
                };
                PreferNativeElement.prototype.setup = function () {
                    var _this_1 = this;
                    var mapping = this.options.mapping;
                    this.on("attr", function (event) {
                        /* ignore non-role attributes */
                        if (event.key.toLowerCase() !== "role") {
                            return;
                        }
                        /* ignore missing and dynamic values */
                        if (!event.value || event.value instanceof DynamicValue) {
                            return;
                        }
                        /* ignore roles configured to be ignored */
                        var role = event.value.toLowerCase();
                        if (_this_1.isIgnored(role)) {
                            return;
                        }
                        /* dont report when the element is already of the right type but has a
                         * redundant role, such as <main role="main"> */
                        var replacement = mapping[role];
                        if (event.target.is(replacement)) {
                            return;
                        }
                        /* report error */
                        var context = { role: role, replacement: replacement };
                        var location = _this_1.getLocation(event);
                        _this_1.report(event.target, "Prefer to use the native <".concat(replacement, "> element"), location, context);
                    });
                };
                PreferNativeElement.prototype.isIgnored = function (role) {
                    var mapping = this.options.mapping;
                    /* ignore roles not mapped to native elements */
                    var replacement = mapping[role];
                    if (!replacement) {
                        return true;
                    }
                    return this.isKeywordIgnored(role);
                };
                PreferNativeElement.prototype.getLocation = function (event) {
                    var begin = event.location;
                    var end = event.valueLocation; // eslint-disable-line @typescript-eslint/no-non-null-assertion -- technical debt, valueLocation will always be set when a value is provided
                    var quote = event.quote ? 1 : 0;
                    var size = end.offset + end.size - begin.offset + quote;
                    return {
                        filename: begin.filename,
                        line: begin.line,
                        column: begin.column,
                        offset: begin.offset,
                        size: size
                    };
                };
                return PreferNativeElement;
            }(Rule));
            var PreferTbody = /** @class */ (function (_super) {
                __extends(PreferTbody, _super);
                function PreferTbody() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                PreferTbody.prototype.documentation = function () {
                    return {
                        description: "While `<tbody>` is optional is relays semantic information about its contents. Where applicable it should also be combined with `<thead>` and `<tfoot>`.",
                        url: "https://html-validate.org/rules/prefer-tbody.html"
                    };
                };
                PreferTbody.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("dom:ready", function (event) {
                        var doc = event.document;
                        for (var _1 = 0, _2 = doc.querySelectorAll("table"); _1 < _2.length; _1++) {
                            var table_1 = _2[_1];
                            if (table_1.querySelector("> tbody")) {
                                continue;
                            }
                            var tr = table_1.querySelectorAll("> tr");
                            if (tr.length >= 1) {
                                _this_1.report(tr[0], "Prefer to wrap <tr> elements in <tbody>");
                            }
                        }
                    });
                };
                return PreferTbody;
            }(Rule));
            var defaults$7 = {
                tags: ["script", "style"]
            };
            var RequireCSPNonce = /** @class */ (function (_super) {
                __extends(RequireCSPNonce, _super);
                function RequireCSPNonce(options) {
                    return _super.call(this, __assign(__assign({}, defaults$7), options)) || this;
                }
                RequireCSPNonce.schema = function () {
                    return {
                        tags: {
                            type: "array",
                            items: {
                                "enum": ["script", "style"],
                                type: "string"
                            }
                        }
                    };
                };
                RequireCSPNonce.prototype.documentation = function () {
                    return {
                        description: [
                            "Required Content-Security-Policy (CSP) nonce is missing or empty.",
                            "",
                            "This is set by the `nonce` attribute and must match the `Content-Security-Policy` header.",
                            "For instance, if the header contains `script-src 'nonce-r4nd0m'` the `nonce` attribute must be set to `nonce=\"r4nd0m\">`",
                            "",
                            "The nonce should be unique per each request and set to a cryptography secure random token.",
                            "It is used to prevent cross site scripting (XSS) by preventing malicious actors from injecting scripts onto the page.",
                        ].join("\n"),
                        url: "https://html-validate.org/rules/require-csp-nonce.html"
                    };
                };
                RequireCSPNonce.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("tag:end", function (event) {
                        var _a;
                        var tags = _this_1.options.tags;
                        var node = event.previous;
                        /* ignore other tags */
                        if (!tags.includes(node.tagName)) {
                            return;
                        }
                        /* ignore if nonce is set to non-empty value (or dynamic) */
                        var nonce = (_a = node.getAttribute("nonce")) === null || _a === void 0 ? void 0 : _a.value;
                        if (nonce && nonce !== "") {
                            return;
                        }
                        /* ignore <script src> */
                        if (node.is("script") && node.hasAttribute("src")) {
                            return;
                        }
                        var message = "required CSP nonce is missing";
                        _this_1.report(node, message, node.location);
                    });
                };
                return RequireCSPNonce;
            }(Rule));
            var defaults$6 = {
                target: "all",
                include: null,
                exclude: null
            };
            var crossorigin = new RegExp("^(\\w+://|//)"); /* e.g. https:// or // */
            var supportSri = {
                link: "href",
                script: "src"
            };
            var RequireSri = /** @class */ (function (_super) {
                __extends(RequireSri, _super);
                function RequireSri(options) {
                    var _this_1 = _super.call(this, __assign(__assign({}, defaults$6), options)) || this;
                    _this_1.target = _this_1.options.target;
                    return _this_1;
                }
                RequireSri.schema = function () {
                    return {
                        target: {
                            "enum": ["all", "crossorigin"],
                            type: "string"
                        },
                        include: {
                            anyOf: [
                                {
                                    items: {
                                        type: "string"
                                    },
                                    type: "array"
                                },
                                {
                                    type: "null"
                                },
                            ]
                        },
                        exclude: {
                            anyOf: [
                                {
                                    items: {
                                        type: "string"
                                    },
                                    type: "array"
                                },
                                {
                                    type: "null"
                                },
                            ]
                        }
                    };
                };
                RequireSri.prototype.documentation = function () {
                    return {
                        description: "Subresource Integrity (SRI) `integrity` attribute is required to prevent manipulation from Content Delivery Networks or other third-party hosting.",
                        url: "https://html-validate.org/rules/require-sri.html"
                    };
                };
                RequireSri.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("tag:end", function (event) {
                        /* only handle thats supporting and requires sri */
                        var node = event.previous;
                        if (!(_this_1.supportSri(node) && _this_1.needSri(node))) {
                            return;
                        }
                        /* check if sri attribute is present */
                        if (node.hasAttribute("integrity")) {
                            return;
                        }
                        _this_1.report(node, "SRI \"integrity\" attribute is required on <".concat(node.tagName, "> element"), node.location);
                    });
                };
                RequireSri.prototype.supportSri = function (node) {
                    return Object.keys(supportSri).includes(node.tagName);
                };
                RequireSri.prototype.needSri = function (node) {
                    var attr = this.elementSourceAttr(node);
                    if (!attr) {
                        return false;
                    }
                    if (attr.value === null || attr.value === "" || attr.isDynamic) {
                        return false;
                    }
                    var url = attr.value.toString();
                    if (this.target === "all" || crossorigin.test(url)) {
                        return !this.isIgnored(url);
                    }
                    return false;
                };
                RequireSri.prototype.elementSourceAttr = function (node) {
                    var key = supportSri[node.tagName];
                    return node.getAttribute(key);
                };
                RequireSri.prototype.isIgnored = function (url) {
                    return this.isKeywordIgnored(url, function (list, it) {
                        return list.some(function (pattern) { return it.includes(pattern); });
                    });
                };
                return RequireSri;
            }(Rule));
            var ScriptElement = /** @class */ (function (_super) {
                __extends(ScriptElement, _super);
                function ScriptElement() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                ScriptElement.prototype.documentation = function () {
                    return {
                        description: "The end tag for `<script>` is a hard requirement and must never be omitted even when using the `src` attribute.",
                        url: "https://html-validate.org/rules/script-element.html"
                    };
                };
                ScriptElement.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("tag:end", function (event) {
                        var node = event.target; // The current element being closed.
                        if (!node || node.tagName !== "script") {
                            return;
                        }
                        if (node.closed !== exports.NodeClosed.EndTag) {
                            _this_1.report(node, "End tag for <".concat(node.tagName, "> must not be omitted"));
                        }
                    });
                };
                return ScriptElement;
            }(Rule));
            var javascript = [
                "",
                "application/ecmascript",
                "application/javascript",
                "text/ecmascript",
                "text/javascript",
            ];
            var ScriptType = /** @class */ (function (_super) {
                __extends(ScriptType, _super);
                function ScriptType() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                ScriptType.prototype.documentation = function () {
                    return {
                        description: "While valid the HTML5 standard encourages authors to omit the type element for JavaScript resources.",
                        url: "https://html-validate.org/rules/script-type.html"
                    };
                };
                ScriptType.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("tag:end", function (event) {
                        var node = event.previous;
                        if (node.tagName !== "script") {
                            return;
                        }
                        var attr = node.getAttribute("type");
                        if (!attr || attr.isDynamic) {
                            return;
                        }
                        var value = attr.value ? attr.value.toString() : "";
                        if (!_this_1.isJavascript(value)) {
                            return;
                        }
                        _this_1.report(node, '"type" attribute is unnecessary for javascript resources', attr.keyLocation);
                    });
                };
                ScriptType.prototype.isJavascript = function (mime) {
                    /* remove mime parameters, e.g. ";charset=utf-8" */
                    var type = mime.replace(/;.*/, "");
                    return javascript.includes(type);
                };
                return ScriptType;
            }(Rule));
            var SvgFocusable = /** @class */ (function (_super) {
                __extends(SvgFocusable, _super);
                function SvgFocusable() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                SvgFocusable.prototype.documentation = function () {
                    return {
                        description: "Inline SVG elements in IE are focusable by default which may cause issues with tab-ordering. The `focusable` attribute should explicitly be set to avoid unintended behaviour.",
                        url: "https://html-validate.org/rules/svg-focusable.html"
                    };
                };
                SvgFocusable.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("element:ready", function (event) {
                        if (event.target.is("svg")) {
                            _this_1.validate(event.target);
                        }
                    });
                };
                SvgFocusable.prototype.validate = function (svg) {
                    if (svg.hasAttribute("focusable")) {
                        return;
                    }
                    this.report(svg, "<".concat(svg.tagName, "> is missing required \"focusable\" attribute"));
                };
                return SvgFocusable;
            }(Rule));
            var defaults$5 = {
                characters: [
                    { pattern: " ", replacement: "&nbsp;", description: "non-breaking space" },
                    { pattern: "-", replacement: "&#8209;", description: "non-breaking hyphen" },
                ],
                ignoreClasses: [],
                ignoreStyle: true
            };
            function constructRegex(characters) {
                var disallowed = characters
                    .map(function (it) {
                    return it.pattern;
                })
                    .join("|");
                var pattern = "(".concat(disallowed, ")");
                /* eslint-disable-next-line security/detect-non-literal-regexp -- technical debt, should do more input sanitation */
                return new RegExp(pattern, "g");
            }
            function getText(node) {
                /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- this will always match something, it cannot be null */
                var match = node.textContent.match(/^(\s*)(.*)$/);
                var leading = match[1], text = match[2];
                return [leading.length, text.trimEnd()];
            }
            /**
             * Node 12 does not support String.matchAll, this simulates it's behavior.
             */
            function matchAll(text, regexp) {
                /* eslint-disable-next-line security/detect-non-literal-regexp -- makes copy of existing one only */
                var copy = new RegExp(regexp);
                var matches = [];
                var match;
                while ((match = copy.exec(text))) {
                    matches.push(match);
                }
                return matches;
            }
            var TelNonBreaking = /** @class */ (function (_super) {
                __extends(TelNonBreaking, _super);
                function TelNonBreaking(options) {
                    var _this_1 = _super.call(this, __assign(__assign({}, defaults$5), options)) || this;
                    _this_1.regex = constructRegex(_this_1.options.characters);
                    return _this_1;
                }
                TelNonBreaking.schema = function () {
                    return {
                        characters: {
                            type: "array",
                            items: {
                                type: "object",
                                additionalProperties: false,
                                properties: {
                                    pattern: {
                                        type: "string"
                                    },
                                    replacement: {
                                        type: "string"
                                    },
                                    description: {
                                        type: "string"
                                    }
                                }
                            }
                        },
                        ignoreClasses: {
                            type: "array",
                            items: {
                                type: "string"
                            }
                        },
                        ignoreStyle: {
                            type: "boolean"
                        }
                    };
                };
                TelNonBreaking.prototype.documentation = function (context) {
                    var characters = this.options.characters;
                    var replacements = characters.map(function (it) {
                        return "  - `".concat(it.pattern, "` - replace with `").concat(it.replacement, "` (").concat(it.description, ").");
                    });
                    return {
                        description: __spreadArray([
                            "The `".concat(context.pattern, "` character should be replaced with `").concat(context.replacement, "` character (").concat(context.description, ") when used in a telephone number."),
                            "",
                            "Unless non-breaking characters is used there could be a line break inserted at that character.",
                            "Line breaks make is harder to read and understand the telephone number.",
                            "",
                            "The following characters should be avoided:",
                            ""
                        ], replacements, true).join("\n"),
                        url: "https://html-validate.org/rules/tel-non-breaking.html"
                    };
                };
                TelNonBreaking.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("element:ready", this.isRelevant, function (event) {
                        var target = event.target;
                        if (_this_1.isIgnored(target)) {
                            return;
                        }
                        _this_1.walk(target, target);
                    });
                };
                TelNonBreaking.prototype.isRelevant = function (event) {
                    var target = event.target;
                    /* should only deal with anchors */
                    if (!target.is("a")) {
                        return false;
                    }
                    /* ignore if anchor does not have tel href */
                    var attr = target.getAttribute("href");
                    if (!attr || !attr.valueMatches(/^tel:/, false)) {
                        return false;
                    }
                    return true;
                };
                TelNonBreaking.prototype.isIgnoredClass = function (node) {
                    var ignoreClasses = this.options.ignoreClasses;
                    var classList = node.classList;
                    return ignoreClasses.some(function (it) { return classList.contains(it); });
                };
                TelNonBreaking.prototype.isIgnoredStyle = function (node) {
                    var ignoreStyle = this.options.ignoreStyle;
                    var style = node.style;
                    if (!ignoreStyle) {
                        return false;
                    }
                    if (style["white-space"] === "nowrap" || style["white-space"] === "pre") {
                        return true;
                    }
                    return false;
                };
                TelNonBreaking.prototype.isIgnored = function (node) {
                    return this.isIgnoredClass(node) || this.isIgnoredStyle(node);
                };
                TelNonBreaking.prototype.walk = function (anchor, node) {
                    for (var _1 = 0, _2 = node.childNodes; _1 < _2.length; _1++) {
                        var child = _2[_1];
                        if (isTextNode(child)) {
                            this.detectDisallowed(anchor, child);
                        }
                        else if (isElementNode(child)) {
                            this.walk(anchor, child);
                        }
                    }
                };
                TelNonBreaking.prototype.detectDisallowed = function (anchor, node) {
                    var _1 = getText(node), offset = _1[0], text = _1[1];
                    var matches = matchAll(text, this.regex);
                    var _loop_21 = function (match) {
                        var detected = match[0];
                        var entry = this_2.options.characters.find(function (it) { return it.pattern === detected; });
                        /* istanbul ignore next: should never happen and cannot be tested, just a sanity check */
                        if (!entry) {
                            throw new Error("Failed to find entry for \"".concat(detected, "\" when searching text \"").concat(text, "\""));
                        }
                        var message = "\"".concat(detected, "\" should be replaced with \"").concat(entry.replacement, "\" (").concat(entry.description, ") in telephone number");
                        var begin = offset + match.index;
                        var end = begin + detected.length;
                        var location_12 = sliceLocation(node.location, begin, end);
                        var context = entry;
                        this_2.report(anchor, message, location_12, context);
                    };
                    var this_2 = this;
                    for (var _2 = 0, matches_2 = matches; _2 < matches_2.length; _2++) {
                        var match = matches_2[_2];
                        _loop_21(match);
                    }
                };
                return TelNonBreaking;
            }(Rule));
            /**
             * Check if attribute is present and non-empty or dynamic.
             */
            function hasNonEmptyAttribute(node, key) {
                var attr = node.getAttribute(key);
                return Boolean(attr && attr.valueMatches(/.+/, true));
            }
            /**
             * Check if element has default text.
             *
             * Only <input type="submit"> and <input type="reset"> at the moment.
             */
            function hasDefaultText(node) {
                /* only input element have default text */
                if (!node.is("input")) {
                    return false;
                }
                /* default text is not available if value attribute is present */
                if (node.hasAttribute("value")) {
                    return false;
                }
                /* default text is only present when type is submit or reset */
                var type = node.getAttribute("type");
                return Boolean(type && type.valueMatches(/submit|reset/, false));
            }
            function isNonEmptyText(node) {
                if (isTextNode(node)) {
                    return node.isDynamic || node.textContent.trim() !== "";
                }
                else {
                    return false;
                }
            }
            /**
             * Walk nodes (depth-first, preorder) searching for accessible text. Children
             * hidden from accessibility tree are ignored.
             *
             * For each node the current conditions satisfies as accessible text:
             *
             * - Non-empty or dynamic `aria-label`
             * - Non-empty or dynamic `aria-labelledby` (reference not validated, use [[no-missing-references]]
             * - Image with non-empty or dynamic `alt` text
             * - Elements with default text
             */
            function haveAccessibleText(node) {
                if (!inAccessibilityTree(node)) {
                    return false;
                }
                /* check direct descendants for non-empty or dynamic text */
                var haveText = node.childNodes.some(function (child) { return isNonEmptyText(child); });
                if (haveText) {
                    return true;
                }
                if (hasNonEmptyAttribute(node, "aria-label")) {
                    return true;
                }
                if (hasNonEmptyAttribute(node, "aria-labelledby")) {
                    return true;
                }
                if (node.is("img") && hasNonEmptyAttribute(node, "alt")) {
                    return true;
                }
                if (hasDefaultText(node)) {
                    return true;
                }
                return node.childElements.some(function (child) {
                    return haveAccessibleText(child);
                });
            }
            var TextContent = /** @class */ (function (_super) {
                __extends(TextContent, _super);
                function TextContent() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                TextContent.prototype.documentation = function (context) {
                    var doc = {
                        description: "The textual content for this element is not valid.",
                        url: "https://html-validate.org/rules/text-content.html"
                    };
                    switch (context.textContent) {
                        case exports.TextContent.NONE:
                            doc.description = "The `<".concat(context.tagName, ">` element must not have textual content.");
                            break;
                        case exports.TextContent.REQUIRED:
                            doc.description = "The `<".concat(context.tagName, ">` element must have textual content.");
                            break;
                        case exports.TextContent.ACCESSIBLE:
                            doc.description = "The `<".concat(context.tagName, ">` element must have accessible text.");
                            break;
                    }
                    return doc;
                };
                TextContent.filter = function (event) {
                    var target = event.target;
                    /* skip elements without metadata */
                    if (!target.meta) {
                        return false;
                    }
                    /* skip elements without explicit and default textContent */
                    var textContent = target.meta.textContent;
                    if (!textContent || textContent === exports.TextContent.DEFAULT) {
                        return false;
                    }
                    return true;
                };
                TextContent.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("element:ready", TextContent.filter, function (event) {
                        var target = event.target;
                        var textContent = target.meta.textContent;
                        switch (textContent) {
                            case exports.TextContent.NONE:
                                _this_1.validateNone(target);
                                break;
                            case exports.TextContent.REQUIRED:
                                _this_1.validateRequired(target);
                                break;
                            case exports.TextContent.ACCESSIBLE:
                                _this_1.validateAccessible(target);
                                break;
                        }
                    });
                };
                /**
                 * Validate element has empty text (inter-element whitespace is not considered text)
                 */
                TextContent.prototype.validateNone = function (node) {
                    if (classifyNodeText(node) === exports.TextClassification.EMPTY_TEXT) {
                        return;
                    }
                    this.reportError(node, node.meta, "".concat(node.annotatedName, " must not have text content"));
                };
                /**
                 * Validate element has any text (inter-element whitespace is not considered text)
                 */
                TextContent.prototype.validateRequired = function (node) {
                    if (classifyNodeText(node) !== exports.TextClassification.EMPTY_TEXT) {
                        return;
                    }
                    this.reportError(node, node.meta, "".concat(node.annotatedName, " must have text content"));
                };
                /**
                 * Validate element has accessible text (either regular text or text only
                 * exposed in accessibility tree via aria-label or similar)
                 */
                TextContent.prototype.validateAccessible = function (node) {
                    /* skip this element if the element isn't present in accessibility tree */
                    if (!inAccessibilityTree(node)) {
                        return;
                    }
                    /* if the element or a child has aria-label, alt or default text, etc the
                     * element has accessible text */
                    if (haveAccessibleText(node)) {
                        return;
                    }
                    this.reportError(node, node.meta, "".concat(node.annotatedName, " must have accessible text"));
                };
                TextContent.prototype.reportError = function (node, meta, message) {
                    this.report(node, message, null, {
                        tagName: node.tagName,
                        textContent: meta.textContent
                    });
                };
                return TextContent;
            }(Rule));
            var defaults$4 = {
                ignoreCase: false,
                requireSemicolon: true
            };
            var regexp$1 = /&(?:[a-z0-9]+|#x?[0-9a-f]+)(;|[^a-z0-9]|$)/gi;
            var lowercaseEntities = elements.entities.map(function (it) { return it.toLowerCase(); });
            function isNumerical(entity) {
                return entity.startsWith("&#");
            }
            function getLocation(location, entity, match) {
                var _a;
                /* istanbul ignore next: never happens in practive */
                var index = (_a = match.index) !== null && _a !== void 0 ? _a : 0;
                return sliceLocation(location, index, index + entity.length);
            }
            function getDescription(context, options) {
                var url = "https://html.spec.whatwg.org/multipage/named-characters.html";
                var message;
                if (context.terminated) {
                    message = "Unrecognized character reference `".concat(context.entity, "`.");
                }
                else {
                    message = "Character reference `".concat(context.entity, "` must be terminated by a semicolon.");
                }
                return __spreadArray(__spreadArray([
                    message,
                    "HTML5 defines a set of [valid character references](".concat(url, ") but this is not a valid one."),
                    "",
                    "Ensure that:",
                    "",
                    "1. The character is one of the listed names."
                ], (options.ignoreCase ? [] : ["1. The case is correct (names are case sensitive)."]), true), (options.requireSemicolon ? ["1. The name is terminated with a `;`."] : []), true).join("\n");
            }
            var UnknownCharReference = /** @class */ (function (_super) {
                __extends(UnknownCharReference, _super);
                function UnknownCharReference(options) {
                    return _super.call(this, __assign(__assign({}, defaults$4), options)) || this;
                }
                UnknownCharReference.schema = function () {
                    return {
                        ignoreCase: {
                            type: "boolean"
                        },
                        requireSemicolon: {
                            type: "boolean"
                        }
                    };
                };
                UnknownCharReference.prototype.documentation = function (context) {
                    return {
                        description: getDescription(context, this.options),
                        url: "https://html-validate.org/rules/unrecognized-char-ref.html"
                    };
                };
                UnknownCharReference.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("element:ready", function (event) {
                        var node = event.target;
                        /* only iterate over direct descendants */
                        for (var _1 = 0, _2 = node.childNodes; _1 < _2.length; _1++) {
                            var child = _2[_1];
                            if (child.nodeType !== exports.NodeType.TEXT_NODE) {
                                continue;
                            }
                            _this_1.findCharacterReferences(node, child.textContent, child.location, {
                                isAttribute: false
                            });
                        }
                    });
                    this.on("attr", function (event) {
                        /* boolean attributes has no value so nothing to validate */
                        if (!event.value) {
                            return;
                        }
                        _this_1.findCharacterReferences(event.target, event.value.toString(), event.valueLocation, {
                            isAttribute: true
                        });
                    });
                };
                Object.defineProperty(UnknownCharReference.prototype, "entities", {
                    get: function () {
                        if (this.options.ignoreCase) {
                            return lowercaseEntities;
                        }
                        else {
                            return elements.entities;
                        }
                    },
                    enumerable: false,
                    configurable: true
                });
                UnknownCharReference.prototype.findCharacterReferences = function (node, text, location, _1) {
                    var isAttribute = _1.isAttribute;
                    var isQuerystring = isAttribute && text.includes("?");
                    for (var _2 = 0, _3 = this.getMatches(text); _2 < _3.length; _2++) {
                        var match = _3[_2];
                        this.validateCharacterReference(node, location, match, { isQuerystring: isQuerystring });
                    }
                };
                UnknownCharReference.prototype.validateCharacterReference = function (node, location, foobar, _1) {
                    var isQuerystring = _1.isQuerystring;
                    var requireSemicolon = this.options.requireSemicolon;
                    var match = foobar.match, entity = foobar.entity, raw = foobar.raw, terminated = foobar.terminated;
                    /* assume numeric entities are valid for now */
                    if (isNumerical(entity)) {
                        return;
                    }
                    /* special case: when attributes use query parameters we skip checking
                     * unterminated attributes */
                    if (isQuerystring && !terminated) {
                        return;
                    }
                    var found = this.entities.includes(entity);
                    /* ignore if this is a known character reference name */
                    if (found && (terminated || !requireSemicolon)) {
                        return;
                    }
                    if (found && !terminated) {
                        var entityLocation_1 = getLocation(location, entity, match);
                        var message_1 = "Character reference \"{{ entity }}\" must be terminated by a semicolon";
                        var context_1 = {
                            entity: raw,
                            terminated: false
                        };
                        this.report(node, message_1, entityLocation_1, context_1);
                        return;
                    }
                    var entityLocation = getLocation(location, entity, match);
                    var message = "Unrecognized character reference \"{{ entity }}\"";
                    var context = {
                        entity: raw,
                        terminated: true
                    };
                    this.report(node, message, entityLocation, context);
                };
                UnknownCharReference.prototype.getMatches = function (text) {
                    var match, terminator, terminated, needSlice, entity;
                    return __generator(this, function (_1) {
                        switch (_1.label) {
                            case 0:
                                match = regexp$1.exec(text);
                                if (!match) return [3 /*break*/, 4];
                                terminator = match[1];
                                terminated = terminator === ";";
                                needSlice = terminator !== ";" && terminator.length > 0;
                                entity = needSlice ? match[0].slice(0, -1) : match[0];
                                if (!this.options.ignoreCase) return [3 /*break*/, 2];
                                return [4 /*yield*/, { match: match, entity: entity.toLowerCase(), raw: entity, terminated: terminated }];
                            case 1:
                                _1.sent();
                                return [3 /*break*/, 4];
                            case 2: return [4 /*yield*/, { match: match, entity: entity, raw: entity, terminated: terminated }];
                            case 3:
                                _1.sent();
                                _1.label = 4;
                            case 4:
                                if (match) return [3 /*break*/, 0];
                                _1.label = 5;
                            case 5: return [2 /*return*/];
                        }
                    });
                };
                return UnknownCharReference;
            }(Rule));
            var RuleContext;
            (function (RuleContext) {
                RuleContext[RuleContext["EMPTY"] = 1] = "EMPTY";
                RuleContext[RuleContext["WHITESPACE"] = 2] = "WHITESPACE";
                RuleContext[RuleContext["LEADING_CHARACTER"] = 3] = "LEADING_CHARACTER";
                RuleContext[RuleContext["DISALLOWED_CHARACTER"] = 4] = "DISALLOWED_CHARACTER";
            })(RuleContext || (RuleContext = {}));
            var defaults$3 = {
                relaxed: false
            };
            var ValidID = /** @class */ (function (_super) {
                __extends(ValidID, _super);
                function ValidID(options) {
                    return _super.call(this, __assign(__assign({}, defaults$3), options)) || this;
                }
                ValidID.schema = function () {
                    return {
                        relaxed: {
                            type: "boolean"
                        }
                    };
                };
                ValidID.prototype.documentation = function (context) {
                    var relaxed = this.options.relaxed;
                    var message = this.messages[context]
                        .replace("id", "ID")
                        .replace(/^(.)/, function (m) { return m.toUpperCase(); });
                    var relaxedDescription = relaxed
                        ? []
                        : [
                            "  - ID must begin with a letter",
                            "  - ID must only contain alphanumerical characters, `-` and `_`",
                        ];
                    return {
                        description: __spreadArray([
                            "".concat(message, "."),
                            "",
                            "Under the current configuration the following rules are applied:",
                            "",
                            "  - ID must not be empty",
                            "  - ID must not contain any whitespace characters"
                        ], relaxedDescription, true).join("\n"),
                        url: "https://html-validate.org/rules/valid-id.html"
                    };
                };
                ValidID.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("attr", this.isRelevant, function (event) {
                        var value = event.value;
                        if (value === null || value instanceof DynamicValue) {
                            return;
                        }
                        if (value === "") {
                            var context = RuleContext.EMPTY;
                            _this_1.report(event.target, _this_1.messages[context], event.location, context);
                            return;
                        }
                        if (value.match(/\s/)) {
                            var context = RuleContext.WHITESPACE;
                            _this_1.report(event.target, _this_1.messages[context], event.valueLocation, context);
                            return;
                        }
                        var relaxed = _this_1.options.relaxed;
                        if (relaxed) {
                            return;
                        }
                        if (value.match(/^[^a-zA-Z]/)) {
                            var context = RuleContext.LEADING_CHARACTER;
                            _this_1.report(event.target, _this_1.messages[context], event.valueLocation, context);
                            return;
                        }
                        if (value.match(/[^a-zA-Z0-9-_]/)) {
                            var context = RuleContext.DISALLOWED_CHARACTER;
                            _this_1.report(event.target, _this_1.messages[context], event.valueLocation, context);
                        }
                    });
                };
                Object.defineProperty(ValidID.prototype, "messages", {
                    get: function () {
                        var _1;
                        return _1 = {},
                            _1[RuleContext.EMPTY] = "element id must not be empty",
                            _1[RuleContext.WHITESPACE] = "element id must not contain whitespace",
                            _1[RuleContext.LEADING_CHARACTER] = "element id must begin with a letter",
                            _1[RuleContext.DISALLOWED_CHARACTER] = "element id must only contain alphanumerical, dash and underscore characters",
                            _1;
                    },
                    enumerable: false,
                    configurable: true
                });
                ValidID.prototype.isRelevant = function (event) {
                    return event.key === "id";
                };
                return ValidID;
            }(Rule));
            var VoidContent = /** @class */ (function (_super) {
                __extends(VoidContent, _super);
                function VoidContent() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                VoidContent.prototype.documentation = function (tagName) {
                    var doc = {
                        description: "HTML void elements cannot have any content and must not have content or end tag.",
                        url: "https://html-validate.org/rules/void-content.html"
                    };
                    if (tagName) {
                        doc.description = "<".concat(tagName, "> is a void element and must not have content or end tag.");
                    }
                    return doc;
                };
                VoidContent.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("tag:end", function (event) {
                        var node = event.target; // The current element being closed.
                        if (!node) {
                            return;
                        }
                        if (!node.voidElement) {
                            return;
                        }
                        if (node.closed === exports.NodeClosed.EndTag) {
                            _this_1.report(null, "End tag for <".concat(node.tagName, "> must be omitted"), node.location, node.tagName);
                        }
                    });
                };
                return VoidContent;
            }(Rule));
            var Style;
            (function (Style) {
                Style[Style["AlwaysOmit"] = 1] = "AlwaysOmit";
                Style[Style["AlwaysSelfclose"] = 2] = "AlwaysSelfclose";
            })(Style || (Style = {}));
            var defaults$2 = {
                style: "omit"
            };
            var VoidStyle = /** @class */ (function (_super) {
                __extends(VoidStyle, _super);
                function VoidStyle(options) {
                    var _this_1 = _super.call(this, __assign(__assign({}, defaults$2), options)) || this;
                    _this_1.style = parseStyle(_this_1.options.style);
                    return _this_1;
                }
                VoidStyle.schema = function () {
                    return {
                        style: {
                            "enum": ["omit", "selfclose", "selfclosing"],
                            type: "string"
                        }
                    };
                };
                VoidStyle.prototype.documentation = function (context) {
                    var _1 = styleDescription(context.style), desc = _1[0], end = _1[1];
                    return {
                        description: "The current configuration requires void elements to ".concat(desc, ", use <").concat(context.tagName).concat(end, "> instead."),
                        url: "https://html-validate.org/rules/void-style.html"
                    };
                };
                VoidStyle.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("tag:end", function (event) {
                        var active = event.previous; // The current active element (that is, the current element on the stack)
                        if (active.meta) {
                            _this_1.validateActive(active);
                        }
                    });
                };
                VoidStyle.prototype.validateActive = function (node) {
                    /* ignore non-void elements, they must be closed with regular end tag */
                    if (!node.voidElement) {
                        return;
                    }
                    if (this.shouldBeOmitted(node)) {
                        this.reportError(node, "Expected omitted end tag <".concat(node.tagName, "> instead of self-closing element <").concat(node.tagName, "/>"));
                    }
                    if (this.shouldBeSelfClosed(node)) {
                        this.reportError(node, "Expected self-closing element <".concat(node.tagName, "/> instead of omitted end-tag <").concat(node.tagName, ">"));
                    }
                };
                VoidStyle.prototype.reportError = function (node, message) {
                    var context = {
                        style: this.style,
                        tagName: node.tagName
                    };
                    _super.prototype.report.call(this, node, message, null, context);
                };
                VoidStyle.prototype.shouldBeOmitted = function (node) {
                    return this.style === Style.AlwaysOmit && node.closed === exports.NodeClosed.VoidSelfClosed;
                };
                VoidStyle.prototype.shouldBeSelfClosed = function (node) {
                    return this.style === Style.AlwaysSelfclose && node.closed === exports.NodeClosed.VoidOmitted;
                };
                return VoidStyle;
            }(Rule));
            function parseStyle(name) {
                switch (name) {
                    case "omit":
                        return Style.AlwaysOmit;
                    case "selfclose":
                    case "selfclosing":
                        return Style.AlwaysSelfclose;
                    /* istanbul ignore next: covered by schema validation */
                    default:
                        throw new Error("Invalid style \"".concat(name, "\" for \"void-style\" rule"));
                }
            }
            function styleDescription(style) {
                switch (style) {
                    case Style.AlwaysOmit:
                        return ["omit end tag", ""];
                    case Style.AlwaysSelfclose:
                        return ["be self-closed", "/"];
                    // istanbul ignore next: will only happen if new styles are added, otherwise this isn't reached
                    default:
                        throw new Error("Unknown style");
                }
            }
            var H30 = /** @class */ (function (_super) {
                __extends(H30, _super);
                function H30() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                H30.prototype.documentation = function () {
                    return {
                        description: "WCAG 2.1 requires each `<a>` anchor link to have a text describing the purpose of the link using either plain text or an `<img>` with the `alt` attribute set.",
                        url: "https://html-validate.org/rules/wcag/h30.html"
                    };
                };
                H30.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("dom:ready", function (event) {
                        var links = event.document.getElementsByTagName("a");
                        for (var _1 = 0, links_1 = links; _1 < links_1.length; _1++) {
                            var link = links_1[_1];
                            /* ignore links with aria-hidden="true" */
                            if (!inAccessibilityTree(link)) {
                                continue;
                            }
                            /* check if text content is present (or dynamic) */
                            var textClassification = classifyNodeText(link, { ignoreHiddenRoot: true });
                            if (textClassification !== exports.TextClassification.EMPTY_TEXT) {
                                continue;
                            }
                            /* check if image with alt-text is present */
                            var images = link.querySelectorAll("img");
                            if (images.some(function (image) { return hasAltText(image); })) {
                                continue;
                            }
                            /* check if aria-label is present on either the <a> element or a descendant */
                            var labels = link.querySelectorAll("[aria-label]");
                            if (hasAriaLabel(link) || labels.some(function (cur) { return hasAriaLabel(cur); })) {
                                continue;
                            }
                            _this_1.report(link, "Anchor link must have a text describing its purpose");
                        }
                    });
                };
                return H30;
            }(Rule));
            var H32 = /** @class */ (function (_super) {
                __extends(H32, _super);
                function H32() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                H32.prototype.documentation = function () {
                    return {
                        description: "WCAG 2.1 requires each `<form>` element to have at least one submit button.",
                        url: "https://html-validate.org/rules/wcag/h32.html"
                    };
                };
                H32.prototype.setup = function () {
                    var _this_1 = this;
                    /* query all tags with form property, normally this is only the <form> tag
                     * but with custom element metadata other tags might be considered form
                     * (usually a component wrapping a <form> element) */
                    var formTags = this.getTagsWithProperty("form");
                    var formSelector = formTags.join(",");
                    this.on("dom:ready", function (event) {
                        var document = event.document;
                        var forms = document.querySelectorAll(formSelector);
                        for (var _1 = 0, forms_1 = forms; _1 < forms_1.length; _1++) {
                            var form = forms_1[_1];
                            /* find nested submit buttons */
                            if (hasNestedSubmit(form)) {
                                continue;
                            }
                            /* find explicitly associated submit buttons */
                            if (hasAssociatedSubmit(document, form)) {
                                continue;
                            }
                            _this_1.report(form, "<".concat(form.tagName, "> element must have a submit button"));
                        }
                    });
                };
                return H32;
            }(Rule));
            function isSubmit(node) {
                var type = node.getAttribute("type");
                return Boolean(type && type.valueMatches(/submit|image/));
            }
            function isAssociated(id, node) {
                var form = node.getAttribute("form");
                return Boolean(form && form.valueMatches(id, true));
            }
            function hasNestedSubmit(form) {
                var matches = form
                    .querySelectorAll("button,input")
                    .filter(isSubmit)
                    .filter(function (node) { return !node.hasAttribute("form"); });
                return matches.length > 0;
            }
            function hasAssociatedSubmit(document, form) {
                var id = form.id;
                if (!id) {
                    return false;
                }
                var matches = document
                    .querySelectorAll("button[form],input[form]")
                    .filter(isSubmit)
                    .filter(function (node) { return isAssociated(id, node); });
                return matches.length > 0;
            }
            var H36 = /** @class */ (function (_super) {
                __extends(H36, _super);
                function H36() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                H36.prototype.documentation = function () {
                    return {
                        description: 'WCAG 2.1 requires all images used as submit buttons to have a textual description using the alt attribute. The alt text cannot be empty (`alt=""`).',
                        url: "https://html-validate.org/rules/wcag/h36.html"
                    };
                };
                H36.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("tag:end", function (event) {
                        /* only handle input elements */
                        var node = event.previous;
                        if (node.tagName !== "input")
                            return;
                        /* only handle images with type="image" */
                        if (node.getAttributeValue("type") !== "image") {
                            return;
                        }
                        if (!hasAltText(node)) {
                            _this_1.report(node, "image used as submit button must have alt text");
                        }
                    });
                };
                return H36;
            }(Rule));
            var defaults$1 = {
                allowEmpty: true,
                alias: []
            };
            function needsAlt(node) {
                if (node.is("img")) {
                    return true;
                }
                if (node.is("input") && node.getAttributeValue("type") === "image") {
                    return true;
                }
                return false;
            }
            function getTag(node) {
                var _a;
                return node.is("input")
                    ? "<input type=\"".concat(/* istanbul ignore next */ (_a = node.getAttributeValue("type")) !== null && _a !== void 0 ? _a : "", "\">")
                    : "<".concat(node.tagName, ">");
            }
            var H37 = /** @class */ (function (_super) {
                __extends(H37, _super);
                function H37(options) {
                    var _this_1 = _super.call(this, __assign(__assign({}, defaults$1), options)) || this;
                    /* ensure alias is array */
                    if (!Array.isArray(_this_1.options.alias)) {
                        _this_1.options.alias = [_this_1.options.alias];
                    }
                    return _this_1;
                }
                H37.schema = function () {
                    return {
                        alias: {
                            anyOf: [
                                {
                                    items: {
                                        type: "string"
                                    },
                                    type: "array"
                                },
                                {
                                    type: "string"
                                },
                            ]
                        },
                        allowEmpty: {
                            type: "boolean"
                        }
                    };
                };
                H37.prototype.documentation = function () {
                    return {
                        description: "Both HTML5 and WCAG 2.0 requires images to have a alternative text for each image.",
                        url: "https://html-validate.org/rules/wcag/h37.html"
                    };
                };
                H37.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("tag:end", function (event) {
                        var node = event.previous;
                        /* only validate images */
                        if (!needsAlt(node)) {
                            return;
                        }
                        /* ignore images with aria-hidden="true" or role="presentation" */
                        if (!inAccessibilityTree(node)) {
                            return;
                        }
                        /* validate plain alt-attribute */
                        if (Boolean(node.getAttributeValue("alt")) ||
                            Boolean(node.hasAttribute("alt") && _this_1.options.allowEmpty)) {
                            return;
                        }
                        /* validate if any non-empty alias is present */
                        for (var _1 = 0, _2 = _this_1.options.alias; _1 < _2.length; _1++) {
                            var attr = _2[_1];
                            if (node.getAttribute(attr)) {
                                return;
                            }
                        }
                        if (node.hasAttribute("alt")) {
                            var attr = node.getAttribute("alt");
                            /* istanbul ignore next */
                            _this_1.report(node, "".concat(getTag(node), " cannot have empty \"alt\" attribute"), attr === null || attr === void 0 ? void 0 : attr.keyLocation);
                        }
                        else {
                            _this_1.report(node, "".concat(getTag(node), " is missing required \"alt\" attribute"), node.location);
                        }
                    });
                };
                return H37;
            }(Rule));
            var _a;
            /* istanbul ignore next: this will always be present for the <th>
             * attribute (or the tests would fail) */
            var validScopes = ((_a = elements.html5.th.attributes) === null || _a === void 0 ? void 0 : _a.scope)["enum"];
            var joinedScopes = utils_naturalJoin.naturalJoin(validScopes);
            var H63 = /** @class */ (function (_super) {
                __extends(H63, _super);
                function H63() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                H63.prototype.documentation = function () {
                    return {
                        description: "H63: Using the scope attribute to associate header cells and data cells in data tables",
                        url: "https://html-validate.org/rules/wcag/h63.html"
                    };
                };
                H63.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("tag:ready", function (event) {
                        var _a, _b;
                        var node = event.target;
                        /* only validate th */
                        if (node.tagName !== "th") {
                            return;
                        }
                        var scope = node.getAttribute("scope");
                        var value = scope === null || scope === void 0 ? void 0 : scope.value;
                        /* ignore dynamic scope */
                        if (value instanceof DynamicValue) {
                            return;
                        }
                        /* ignore elements with valid scope values */
                        if (value && validScopes.includes(value)) {
                            return;
                        }
                        var message = "<th> element must have a valid scope attribute: ".concat(joinedScopes);
                        var location = (_b = (_a = scope === null || scope === void 0 ? void 0 : scope.valueLocation) !== null && _a !== void 0 ? _a : scope === null || scope === void 0 ? void 0 : scope.keyLocation) !== null && _b !== void 0 ? _b : node.location;
                        _this_1.report(node, message, location);
                    });
                };
                return H63;
            }(Rule));
            var H67 = /** @class */ (function (_super) {
                __extends(H67, _super);
                function H67() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                H67.prototype.documentation = function () {
                    return {
                        description: "A decorative image cannot have a title attribute. Either remove `title` or add a descriptive `alt` text.",
                        url: "https://html-validate.org/rules/wcag/h67.html"
                    };
                };
                H67.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("tag:end", function (event) {
                        var node = event.target;
                        /* only validate images */
                        if (!node || node.tagName !== "img") {
                            return;
                        }
                        /* ignore images without title */
                        var title = node.getAttribute("title");
                        if (!title || title.value === "") {
                            return;
                        }
                        /* ignore elements with non-empty alt-text */
                        var alt = node.getAttributeValue("alt");
                        if (alt && alt !== "") {
                            return;
                        }
                        _this_1.report(node, "<img> with empty alt text cannot have title attribute", title.keyLocation);
                    });
                };
                return H67;
            }(Rule));
            var H71 = /** @class */ (function (_super) {
                __extends(H71, _super);
                function H71() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                H71.prototype.documentation = function () {
                    return {
                        description: "H71: Providing a description for groups of form controls using fieldset and legend elements",
                        url: "https://html-validate.org/rules/wcag/h71.html"
                    };
                };
                H71.prototype.setup = function () {
                    var _this_1 = this;
                    this.on("dom:ready", function (event) {
                        var document = event.document;
                        var fieldsets = document.querySelectorAll(_this_1.selector);
                        for (var _1 = 0, fieldsets_1 = fieldsets; _1 < fieldsets_1.length; _1++) {
                            var fieldset = fieldsets_1[_1];
                            _this_1.validate(fieldset);
                        }
                    });
                };
                H71.prototype.validate = function (fieldset) {
                    var legend = fieldset.querySelectorAll("> legend");
                    if (legend.length === 0) {
                        this.reportNode(fieldset);
                    }
                };
                H71.prototype.reportNode = function (node) {
                    _super.prototype.report.call(this, node, "".concat(node.annotatedName, " must have a <legend> as the first child"));
                };
                Object.defineProperty(H71.prototype, "selector", {
                    get: function () {
                        return this.getTagsDerivedFrom("fieldset").join(",");
                    },
                    enumerable: false,
                    configurable: true
                });
                return H71;
            }(Rule));
            var bundledRules$1 = {
                "wcag/h30": H30,
                "wcag/h32": H32,
                "wcag/h36": H36,
                "wcag/h37": H37,
                "wcag/h63": H63,
                "wcag/h67": H67,
                "wcag/h71": H71
            };
            var WCAG = bundledRules$1;
            var bundledRules = __assign({ "allowed-links": AllowedLinks, "area-alt": AreaAlt, "aria-hidden-body": AriaHiddenBody, "aria-label-misuse": AriaLabelMisuse, "attr-case": AttrCase, "attr-delimiter": AttrDelimiter, "attr-pattern": AttrPattern, "attr-quotes": AttrQuotes, "attr-spacing": AttrSpacing, "attribute-allowed-values": AttributeAllowedValues, "attribute-boolean-style": AttributeBooleanStyle, "attribute-empty-style": AttributeEmptyStyle, "attribute-misuse": AttributeMisuse, "class-pattern": ClassPattern, "close-attr": CloseAttr, "close-order": CloseOrder, deprecated: Deprecated, "deprecated-rule": DeprecatedRule, "doctype-html": NoStyleTag$1, "doctype-style": DoctypeStyle, "element-case": ElementCase, "element-name": ElementName, "element-permitted-content": ElementPermittedContent, "element-permitted-occurrences": ElementPermittedOccurrences, "element-permitted-order": ElementPermittedOrder, "element-permitted-parent": ElementPermittedParent, "element-required-ancestor": ElementRequiredAncestor, "element-required-attributes": ElementRequiredAttributes, "element-required-content": ElementRequiredContent, "empty-heading": EmptyHeading, "empty-title": EmptyTitle, "form-dup-name": FormDupName, "heading-level": HeadingLevel, "id-pattern": IdPattern, "input-attributes": InputAttributes, "input-missing-label": InputMissingLabel, "long-title": LongTitle, "map-dup-name": MapDupName, "map-id-name": MapIdName, "meta-refresh": MetaRefresh, "missing-doctype": MissingDoctype, "multiple-labeled-controls": MultipleLabeledControls, "no-autoplay": NoAutoplay, "no-conditional-comment": NoConditionalComment, "no-deprecated-attr": NoDeprecatedAttr, "no-dup-attr": NoDupAttr, "no-dup-class": NoDupClass, "no-dup-id": NoDupID, "no-implicit-button-type": NoImplicitButtonType, "no-implicit-close": NoImplicitClose, "no-inline-style": NoInlineStyle, "no-missing-references": NoMissingReferences, "no-multiple-main": NoMultipleMain, "no-raw-characters": NoRawCharacters, "no-redundant-aria-label": NoRedundantAriaLabel, "no-redundant-for": NoRedundantFor, "no-redundant-role": NoRedundantRole, "no-self-closing": NoSelfClosing, "no-style-tag": NoStyleTag, "no-trailing-whitespace": NoTrailingWhitespace, "no-unknown-elements": NoUnknownElements, "no-unused-disable": NoUnusedDisable, "no-utf8-bom": NoUtf8Bom, "prefer-button": PreferButton, "prefer-native-element": PreferNativeElement, "prefer-tbody": PreferTbody, "require-csp-nonce": RequireCSPNonce, "require-sri": RequireSri, "script-element": ScriptElement, "script-type": ScriptType, "svg-focusable": SvgFocusable, "tel-non-breaking": TelNonBreaking, "text-content": TextContent, "unrecognized-char-ref": UnknownCharReference, "valid-id": ValidID, "void-content": VoidContent, "void-style": VoidStyle }, WCAG);
            var rules = bundledRules;
            var defaultConfig = {};
            var config$4 = {
                rules: {
                    "area-alt": ["error", { accessible: true }],
                    "aria-hidden-body": "error",
                    "aria-label-misuse": "error",
                    "deprecated-rule": "warn",
                    "empty-heading": "error",
                    "empty-title": "error",
                    "meta-refresh": "error",
                    "multiple-labeled-controls": "error",
                    "no-autoplay": ["error", { include: ["audio", "video"] }],
                    "no-dup-id": "error",
                    "no-implicit-button-type": "error",
                    "no-redundant-aria-label": "error",
                    "no-redundant-for": "error",
                    "no-redundant-role": "error",
                    "prefer-native-element": "error",
                    "svg-focusable": "off",
                    "text-content": "error",
                    "wcag/h30": "error",
                    "wcag/h32": "error",
                    "wcag/h36": "error",
                    "wcag/h37": "error",
                    "wcag/h63": "error",
                    "wcag/h67": "error",
                    "wcag/h71": "error"
                }
            };
            var a11y = config$4;
            var config$3 = {
                rules: {
                    "input-missing-label": "error",
                    "heading-level": "error",
                    "missing-doctype": "error",
                    "no-missing-references": "error",
                    "require-sri": "error"
                }
            };
            var document = config$3;
            var config$2 = {
                rules: {
                    "attr-quotes": "off",
                    "void-style": "off"
                }
            };
            var prettier = config$2;
            var config$1 = {
                rules: {
                    "area-alt": ["error", { accessible: true }],
                    "aria-hidden-body": "error",
                    "aria-label-misuse": "error",
                    "attr-case": "error",
                    "attr-delimiter": "error",
                    "attr-quotes": "error",
                    "attr-spacing": "error",
                    "attribute-allowed-values": "error",
                    "attribute-boolean-style": "error",
                    "attribute-empty-style": "error",
                    "attribute-misuse": "error",
                    "close-attr": "error",
                    "close-order": "error",
                    deprecated: "error",
                    "deprecated-rule": "warn",
                    "doctype-html": "error",
                    "doctype-style": "error",
                    "element-case": "error",
                    "element-name": "error",
                    "element-permitted-content": "error",
                    "element-permitted-occurrences": "error",
                    "element-permitted-order": "error",
                    "element-permitted-parent": "error",
                    "element-required-ancestor": "error",
                    "element-required-attributes": "error",
                    "element-required-content": "error",
                    "empty-heading": "error",
                    "empty-title": "error",
                    "form-dup-name": "error",
                    "input-attributes": "error",
                    "long-title": "error",
                    "map-dup-name": "error",
                    "map-id-name": "error",
                    "meta-refresh": "error",
                    "multiple-labeled-controls": "error",
                    "no-autoplay": ["error", { include: ["audio", "video"] }],
                    "no-conditional-comment": "error",
                    "no-deprecated-attr": "error",
                    "no-dup-attr": "error",
                    "no-dup-class": "error",
                    "no-dup-id": "error",
                    "no-implicit-button-type": "error",
                    "no-implicit-close": "error",
                    "no-inline-style": "error",
                    "no-multiple-main": "error",
                    "no-raw-characters": "error",
                    "no-redundant-aria-label": "error",
                    "no-redundant-for": "error",
                    "no-redundant-role": "error",
                    "no-self-closing": "error",
                    "no-trailing-whitespace": "error",
                    "no-utf8-bom": "error",
                    "no-unused-disable": "error",
                    "prefer-button": "error",
                    "prefer-native-element": "error",
                    "prefer-tbody": "error",
                    "script-element": "error",
                    "script-type": "error",
                    "svg-focusable": "off",
                    "tel-non-breaking": "error",
                    "text-content": "error",
                    "unrecognized-char-ref": "error",
                    "valid-id": ["error", { relaxed: false }],
                    "void": "off",
                    "void-content": "error",
                    "void-style": "error",
                    "wcag/h30": "error",
                    "wcag/h32": "error",
                    "wcag/h36": "error",
                    "wcag/h37": "error",
                    "wcag/h63": "error",
                    "wcag/h67": "error",
                    "wcag/h71": "error"
                }
            };
            var recommended = config$1;
            var config = {
                rules: {
                    "area-alt": ["error", { accessible: false }],
                    "attr-spacing": "error",
                    "attribute-allowed-values": "error",
                    "attribute-misuse": "error",
                    "close-attr": "error",
                    "close-order": "error",
                    deprecated: "error",
                    "deprecated-rule": "warn",
                    "doctype-html": "error",
                    "element-name": "error",
                    "element-permitted-content": "error",
                    "element-permitted-occurrences": "error",
                    "element-permitted-order": "error",
                    "element-permitted-parent": "error",
                    "element-required-ancestor": "error",
                    "element-required-attributes": "error",
                    "element-required-content": "error",
                    "map-dup-name": "error",
                    "map-id-name": "error",
                    "multiple-labeled-controls": "error",
                    "no-deprecated-attr": "error",
                    "no-dup-attr": "error",
                    "no-dup-id": "error",
                    "no-multiple-main": "error",
                    "no-raw-characters": ["error", { relaxed: true }],
                    "no-unused-disable": "error",
                    "script-element": "error",
                    "unrecognized-char-ref": "error",
                    "valid-id": ["error", { relaxed: true }],
                    "void-content": "error"
                }
            };
            var standard = config;
            /**
             * @internal
             */
            var presets = {
                "html-validate:a11y": a11y,
                "html-validate:document": document,
                "html-validate:prettier": prettier,
                "html-validate:recommended": recommended,
                "html-validate:standard": standard,
                /* @deprecated aliases */
                "htmlvalidate:recommended": recommended,
                "htmlvalidate:document": document,
                "html-validate:a17y": a11y
            };
            var Presets = presets;
            /**
             * A resolved configuration is a normalized configuration with all extends,
             * plugins etc resolved.
             *
             * @public
             */
            var ResolvedConfig = /** @class */ (function () {
                /**
                 * @internal
                 */
                function ResolvedConfig(_1, original) {
                    var metaTable = _1.metaTable, plugins = _1.plugins, rules = _1.rules, transformers = _1.transformers;
                    this.metaTable = metaTable;
                    this.plugins = plugins;
                    this.rules = rules;
                    this.transformers = transformers;
                    this.original = original;
                }
                /**
                 * Returns the (merged) configuration data used to create this resolved
                 * configuration.
                 */
                ResolvedConfig.prototype.getConfigData = function () {
                    return this.original;
                };
                ResolvedConfig.prototype.getMetaTable = function () {
                    return this.metaTable;
                };
                ResolvedConfig.prototype.getPlugins = function () {
                    return this.plugins;
                };
                ResolvedConfig.prototype.getRules = function () {
                    return this.rules;
                };
                /**
                 * Transform a source.
                 *
                 * When transforming zero or more new sources will be generated.
                 *
                 * @param source - Current source to transform.
                 * @param filename - If set it is the filename used to match
                 * transformer. Default is to use filename from source.
                 * @returns A list of transformed sources ready for validation.
                 */
                ResolvedConfig.prototype.transformSource = function (source, filename) {
                    var _this_1 = this;
                    var transformer = this.findTransformer(filename !== null && filename !== void 0 ? filename : source.filename);
                    var context = {
                        hasChain: function (filename) {
                            return !!_this_1.findTransformer(filename);
                        },
                        chain: function (source, filename) {
                            return _this_1.transformSource(source, filename);
                        }
                    };
                    if (transformer) {
                        try {
                            return Array.from(transformer.fn.call(context, source), function (cur) {
                                var _a;
                                /* keep track of which transformers that has been run on this source
                                 * by appending this entry to the transformedBy array */
                                (_a = cur.transformedBy) !== null && _a !== void 0 ? _a : (cur.transformedBy = []);
                                cur.transformedBy.push(transformer.name);
                                return cur;
                            });
                        }
                        catch (err) {
                            /* istanbul ignore next: only used as a fallback */
                            var message = err instanceof Error ? err.message : String(err);
                            throw new NestedError("When transforming \"".concat(source.filename, "\": ").concat(message), ensureError(err));
                        }
                    }
                    else {
                        return [source];
                    }
                };
                /**
                 * Wrapper around [[transformSource]] which reads a file before passing it
                 * as-is to transformSource.
                 *
                 * @param filename - Filename to transform (according to configured
                 * transformations)
                 * @returns A list of transformed sources ready for validation.
                 */
                ResolvedConfig.prototype.transformFilename = function (filename) {
                    var stdin = 0;
                    var src = filename !== "/dev/stdin" ? filename : stdin;
                    var data = fs__default["default"].readFileSync(src, { encoding: "utf8" });
                    var source = {
                        data: data,
                        filename: filename,
                        line: 1,
                        column: 1,
                        offset: 0,
                        originalData: data
                    };
                    return this.transformSource(source);
                };
                /**
                 * Returns true if a transformer matches given filename.
                 */
                ResolvedConfig.prototype.canTransform = function (filename) {
                    var entry = this.findTransformer(filename);
                    return !!entry;
                };
                ResolvedConfig.prototype.findTransformer = function (filename) {
                    var match = this.transformers.find(function (entry) { return entry.pattern.test(filename); });
                    return match !== null && match !== void 0 ? match : null;
                };
                return ResolvedConfig;
            }());
            function haveResolver(key, value) {
                return key in value;
            }
            function haveConfigResolver(value) {
                return haveResolver("resolveConfig", value);
            }
            function haveElementsResolver(value) {
                return haveResolver("resolveElements", value);
            }
            function havePluginResolver(value) {
                return haveResolver("resolvePlugin", value);
            }
            function haveTransformerResolver(value) {
                return haveResolver("resolveTransformer", value);
            }
            /**
             * @internal
             */
            function resolveConfig(resolvers, id, options) {
                for (var _1 = 0, _2 = resolvers.filter(haveConfigResolver); _1 < _2.length; _1++) {
                    var resolver = _2[_1];
                    var config_1 = resolver.resolveConfig(id, options);
                    if (config_1) {
                        return config_1;
                    }
                }
                throw new UserError("Failed to load configuration from \"".concat(id, "\""));
            }
            /**
             * @internal
             */
            function resolveElements(resolvers, id, options) {
                for (var _1 = 0, _2 = resolvers.filter(haveElementsResolver); _1 < _2.length; _1++) {
                    var resolver = _2[_1];
                    var elements_4 = resolver.resolveElements(id, options);
                    if (elements_4) {
                        return elements_4;
                    }
                }
                throw new UserError("Failed to load elements from \"".concat(id, "\""));
            }
            /**
             * @internal
             */
            function resolvePlugin(resolvers, id, options) {
                for (var _1 = 0, _2 = resolvers.filter(havePluginResolver); _1 < _2.length; _1++) {
                    var resolver = _2[_1];
                    var plugin = resolver.resolvePlugin(id, options);
                    if (plugin) {
                        return plugin;
                    }
                }
                throw new UserError("Failed to load plugin from \"".concat(id, "\""));
            }
            /**
             * @internal
             */
            function resolveTransformer(resolvers, id, options) {
                for (var _1 = 0, _2 = resolvers.filter(haveTransformerResolver); _1 < _2.length; _1++) {
                    var resolver = _2[_1];
                    var transformer = resolver.resolveTransformer(id, options);
                    if (transformer) {
                        return transformer;
                    }
                }
                throw new UserError("Failed to load transformer from \"".concat(id, "\""));
            }
            /**
             * Create a new resolver for static content, i.e. plugins or transformers known
             * at compile time.
             *
             * @public
             * @since 8.0.0
             */
            function staticResolver(map) {
                if (map === void 0) { map = {}; }
                var _1 = map.elements, elements = _1 === void 0 ? {} : _1, _2 = map.configs, configs = _2 === void 0 ? {} : _2, _3 = map.plugins, plugins = _3 === void 0 ? {} : _3, _4 = map.transformers, transformers = _4 === void 0 ? {} : _4;
                return {
                    name: "static-qresolver",
                    addElements: function (id, value) {
                        elements[id] = value;
                    },
                    addConfig: function (id, value) {
                        configs[id] = value;
                    },
                    addPlugin: function (id, value) {
                        plugins[id] = value;
                    },
                    addTransformer: function (id, value) {
                        transformers[id] = value;
                    },
                    resolveElements: function (id) {
                        var _a;
                        return (_a = elements[id]) !== null && _a !== void 0 ? _a : null;
                    },
                    resolveConfig: function (id) {
                        var _a;
                        return (_a = configs[id]) !== null && _a !== void 0 ? _a : null;
                    },
                    resolvePlugin: function (id) {
                        var _a;
                        return (_a = plugins[id]) !== null && _a !== void 0 ? _a : null;
                    },
                    resolveTransformer: function (id) {
                        var _a;
                        return (_a = transformers[id]) !== null && _a !== void 0 ? _a : null;
                    }
                };
            }
            var ajv = new Ajv__default["default"]({ strict: true, strictTuples: true, strictTypes: true });
            ajv.addMetaSchema(ajvSchemaDraft);
            var validator = ajv.compile(configurationSchema);
            function overwriteMerge(a, b) {
                return b;
            }
            function mergeInternal(base, rhs) {
                var dst = deepmerge__default["default"](base, __assign(__assign({}, rhs), { rules: {} }));
                /* rules need some special care, should overwrite arrays instead of
                 * concaternation, i.e. ["error", {...options}] should not be merged by
                 * appending to old value */
                if (rhs.rules) {
                    dst.rules = deepmerge__default["default"](dst.rules, rhs.rules, { arrayMerge: overwriteMerge });
                }
                /* root property is merged with boolean "or" since it should always be truthy
                 * if any config has it set. */
                var root = Boolean(base.root) || Boolean(rhs.root);
                if (root) {
                    dst.root = root;
                }
                return dst;
            }
            function toArray(value) {
                if (Array.isArray(value)) {
                    return value;
                }
                else {
                    return [value];
                }
            }
            /**
             * Configuration holder.
             *
             * Each file being validated will have a unique instance of this class.
             *
             * @public
             */
            var Config = /** @class */ (function () {
                /**
                 * @internal
                 */
                function Config(resolvers, options) {
                    var _a, _b;
                    this.transformers = [];
                    var initial = {
                        "extends": [],
                        plugins: [],
                        rules: {},
                        transform: {}
                    };
                    this.config = mergeInternal(initial, options);
                    this.metaTable = null;
                    this.initialized = false;
                    this.resolvers = toArray(resolvers);
                    /* load plugins */
                    this.plugins = this.loadPlugins((_a = this.config.plugins) !== null && _a !== void 0 ? _a : []);
                    this.configurations = this.loadConfigurations(this.plugins);
                    this.extendMeta(this.plugins);
                    /* process extended configs */
                    this.config = this.extendConfig((_b = this.config["extends"]) !== null && _b !== void 0 ? _b : []);
                    /* reset extends as we already processed them, this prevents the next config
                     * from reapplying config from extended config as well as duplicate entries
                     * when merging arrays */
                    this.config["extends"] = [];
                    /* rules explicitly set by passed options should have precedence over any
                     * extended rules, not the other way around. */
                    if (options.rules) {
                        this.config = mergeInternal(this.config, { rules: options.rules });
                    }
                }
                /**
                 * Create a new blank configuration. See also `Config.defaultConfig()`.
                 */
                Config.empty = function () {
                    return new Config([], {
                        "extends": [],
                        rules: {},
                        plugins: [],
                        transform: {}
                    });
                };
                /**
                 * Create configuration from object.
                 */
                Config.fromObject = function (resolvers, options, filename) {
                    if (filename === void 0) { filename = null; }
                    Config.validate(options, filename);
                    return new Config(resolvers, options);
                };
                /**
                 * Read configuration from filename.
                 *
                 * Note: this reads configuration data from a file. If you intent to load
                 * configuration for a file to validate use `ConfigLoader.fromTarget()`.
                 *
                 * @internal
                 * @param filename - The file to read from
                 */
                Config.fromFile = function (resolvers, filename) {
                    var configData = resolveConfig(toArray(resolvers), filename, { cache: false });
                    return Config.fromObject(resolvers, configData, filename);
                };
                /**
                 * Validate configuration data.
                 *
                 * Throws SchemaValidationError if invalid.
                 *
                 * @internal
                 */
                Config.validate = function (configData, filename) {
                    if (filename === void 0) { filename = null; }
                    var _a;
                    var valid = validator(configData);
                    if (!valid) {
                        throw new SchemaValidationError(filename, "Invalid configuration", configData, configurationSchema, 
                        /* istanbul ignore next: will be set when a validation error has occurred */
                        (_a = validator.errors) !== null && _a !== void 0 ? _a : []);
                    }
                    if (configData.rules) {
                        var normalizedRules = Config.getRulesObject(configData.rules);
                        for (var _1 = 0, _2 = normalizedRules.entries(); _1 < _2.length; _1++) {
                            var _3 = _2[_1], ruleId = _3[0], _4 = _3[1], ruleOptions = _4[1];
                            var cls = rules[ruleId];
                            var path = "/rules/".concat(ruleId, "/1");
                            Rule.validateOptions(cls, ruleId, path, ruleOptions, filename, configData);
                        }
                    }
                };
                /**
                 * Load a default configuration object.
                 */
                Config.defaultConfig = function () {
                    return new Config([], defaultConfig);
                };
                /**
                 * Initialize plugins, transforms etc.
                 *
                 * Must be called before trying to use config. Can safely be called multiple
                 * times.
                 *
                 * @public
                 */
                Config.prototype.init = function () {
                    var _a;
                    if (this.initialized) {
                        return;
                    }
                    /* precompile transform patterns */
                    this.transformers = this.precompileTransformers((_a = this.config.transform) !== null && _a !== void 0 ? _a : {});
                    this.initialized = true;
                };
                /**
                 * Returns true if this configuration is marked as "root".
                 */
                Config.prototype.isRootFound = function () {
                    return Boolean(this.config.root);
                };
                /**
                 * Returns a new configuration as a merge of the two. Entries from the passed
                 * object takes priority over this object.
                 *
                 * @public
                 * @param rhs - Configuration to merge with this one.
                 */
                Config.prototype.merge = function (resolvers, rhs) {
                    return new Config(resolvers, mergeInternal(this.config, rhs.config));
                };
                Config.prototype.extendConfig = function (entries) {
                    if (entries.length === 0) {
                        return this.config;
                    }
                    var base = {};
                    for (var _1 = 0, entries_2 = entries; _1 < entries_2.length; _1++) {
                        var entry = entries_2[_1];
                        var extended = void 0;
                        if (this.configurations.has(entry)) {
                            extended = this.configurations.get(entry); // eslint-disable-line @typescript-eslint/no-non-null-assertion -- map has/get combo
                        }
                        else {
                            extended = Config.fromFile(this.resolvers, entry).config;
                        }
                        base = mergeInternal(base, extended);
                    }
                    return mergeInternal(base, this.config);
                };
                /**
                 * Get element metadata.
                 *
                 * @internal
                 */
                Config.prototype.getMetaTable = function () {
                    var _a;
                    /* use cached table if it exists */
                    if (this.metaTable) {
                        return this.metaTable;
                    }
                    var metaTable = new MetaTable();
                    var source = (_a = this.config.elements) !== null && _a !== void 0 ? _a : ["html5"];
                    /* extend validation schema from plugins */
                    for (var _1 = 0, _2 = this.getPlugins(); _1 < _2.length; _1++) {
                        var plugin = _2[_1];
                        if (plugin.elementSchema) {
                            metaTable.extendValidationSchema(plugin.elementSchema);
                        }
                    }
                    /* load from all entries */
                    for (var _3 = 0, source_1 = source; _3 < source_1.length; _3++) {
                        var entry = source_1[_3];
                        /* load meta directly from entry */
                        if (typeof entry !== "string") {
                            metaTable.loadFromObject(entry);
                            continue;
                        }
                        /* try searching builtin metadata */
                        var bundled = elements.bundledElements[entry];
                        if (bundled) {
                            metaTable.loadFromObject(bundled);
                            continue;
                        }
                        /* load with resolver */
                        try {
                            var data = resolveElements(this.resolvers, entry, { cache: false });
                            metaTable.loadFromObject(data, entry);
                        }
                        catch (err) {
                            /* istanbul ignore next: only used as a fallback */
                            var message = err instanceof Error ? err.message : String(err);
                            throw new ConfigError("Failed to load elements from \"".concat(entry, "\": ").concat(message), ensureError(err));
                        }
                    }
                    metaTable.init();
                    return (this.metaTable = metaTable);
                };
                /**
                 * Get a copy of internal configuration data.
                 *
                 * @internal primary purpose is unittests
                 */
                /* istanbul ignore next: used for testing only */
                Config.prototype.get = function () {
                    return __assign({}, this.config);
                };
                /**
                 * Get all configured rules, their severity and options.
                 *
                 * @internal
                 */
                Config.prototype.getRules = function () {
                    var _a;
                    /* istanbul ignore next: only used as a fallback */
                    return Config.getRulesObject((_a = this.config.rules) !== null && _a !== void 0 ? _a : {});
                };
                Config.getRulesObject = function (src) {
                    var rules = new Map();
                    for (var _1 = 0, _2 = Object.entries(src); _1 < _2.length; _1++) {
                        var _3 = _2[_1], ruleId = _3[0], data = _3[1];
                        var options = data;
                        if (!Array.isArray(options)) {
                            options = [options, {}];
                        }
                        else if (options.length === 1) {
                            options = [options[0], {}];
                        }
                        var severity = parseSeverity(options[0]);
                        rules.set(ruleId, [severity, options[1]]);
                    }
                    return rules;
                };
                /**
                 * Get all configured plugins.
                 *
                 * @internal
                 */
                Config.prototype.getPlugins = function () {
                    return this.plugins;
                };
                Config.prototype.loadPlugins = function (plugins) {
                    var _this_1 = this;
                    return plugins.map(function (moduleName, index) {
                        if (typeof moduleName !== "string") {
                            var plugin = moduleName;
                            plugin.name = plugin.name || ":unnamedPlugin@".concat(index + 1);
                            plugin.originalName = ":unnamedPlugin@".concat(index + 1);
                            return plugin;
                        }
                        try {
                            var plugin = resolvePlugin(_this_1.resolvers, moduleName, { cache: true });
                            plugin.name = plugin.name || moduleName;
                            plugin.originalName = moduleName;
                            return plugin;
                        }
                        catch (err) {
                            /* istanbul ignore next: only used as a fallback */
                            var message = err instanceof Error ? err.message : String(err);
                            throw new ConfigError("Failed to load plugin \"".concat(moduleName, "\": ").concat(message), ensureError(err));
                        }
                    });
                };
                Config.prototype.loadConfigurations = function (plugins) {
                    var _a;
                    var configs = new Map();
                    /* builtin presets */
                    for (var _1 = 0, _2 = Object.entries(Presets); _1 < _2.length; _1++) {
                        var _3 = _2[_1], name_17 = _3[0], config_2 = _3[1];
                        Config.validate(config_2, name_17);
                        configs.set(name_17, config_2);
                    }
                    /* presets from plugins */
                    for (var _4 = 0, plugins_1 = plugins; _4 < plugins_1.length; _4++) {
                        var plugin = plugins_1[_4];
                        for (var _5 = 0, _6 = Object.entries((_a = plugin.configs) !== null && _a !== void 0 ? _a : {}); _5 < _6.length; _5++) {
                            var _7 = _6[_5], name_18 = _7[0], config_3 = _7[1];
                            if (!config_3)
                                continue;
                            Config.validate(config_3, name_18);
                            /* add configuration with name provided by plugin */
                            configs.set("".concat(plugin.name, ":").concat(name_18), config_3);
                            /* add configuration with name provided by user (in config file) */
                            if (plugin.name !== plugin.originalName) {
                                configs.set("".concat(plugin.originalName, ":").concat(name_18), config_3);
                            }
                        }
                    }
                    return configs;
                };
                Config.prototype.extendMeta = function (plugins) {
                    for (var _1 = 0, plugins_2 = plugins; _1 < plugins_2.length; _1++) {
                        var plugin = plugins_2[_1];
                        if (!plugin.elementSchema) {
                            continue;
                        }
                        var properties_3 = plugin.elementSchema.properties;
                        if (!properties_3) {
                            continue;
                        }
                        for (var _2 = 0, _3 = Object.entries(properties_3); _2 < _3.length; _2++) {
                            var _4 = _3[_2], raw = _4[0], schema_4 = _4[1];
                            /* at compile time this is a fixed list but the point of this method is
                             * to augment the runtime with additional keys so it is a bit of lying
                             * to typescript */
                            var key = raw;
                            if (schema_4.copyable && !MetaCopyableProperty.includes(key)) {
                                MetaCopyableProperty.push(key);
                            }
                        }
                    }
                };
                /**
                 * Resolve all configuration and return a [[ResolvedConfig]] instance.
                 *
                 * A resolved configuration will merge all extended configs and load all
                 * plugins and transformers, and normalize the rest of the configuration.
                 *
                 * @public
                 */
                Config.prototype.resolve = function () {
                    return new ResolvedConfig(this.resolveData(), this.get());
                };
                /**
                 * Same as [[resolve]] but returns the raw configuration data instead of
                 * [[ResolvedConfig]] instance. Mainly used for testing.
                 *
                 * @internal
                 */
                Config.prototype.resolveData = function () {
                    return {
                        metaTable: this.getMetaTable(),
                        plugins: this.getPlugins(),
                        rules: this.getRules(),
                        transformers: this.transformers
                    };
                };
                Config.prototype.precompileTransformers = function (transform) {
                    var _this_1 = this;
                    return Object.entries(transform).map(function (_1) {
                        var pattern = _1[0], name = _1[1];
                        var _a;
                        try {
                            var fn = _this_1.getTransformFunction(name);
                            /* istanbul ignore next */
                            var version_2 = (_a = fn.api) !== null && _a !== void 0 ? _a : 0;
                            /* check if transformer version is supported */
                            if (version_2 !== TRANSFORMER_API.VERSION) {
                                throw new ConfigError("Transformer uses API version ".concat(version_2, " but only version ").concat(TRANSFORMER_API.VERSION, " is supported"));
                            }
                            return {
                                // eslint-disable-next-line security/detect-non-literal-regexp -- expected to be a regexp
                                pattern: new RegExp(pattern),
                                name: name,
                                fn: fn
                            };
                        }
                        catch (err) {
                            if (err instanceof ConfigError) {
                                throw new ConfigError("Failed to load transformer \"".concat(name, "\": ").concat(err.message), err);
                            }
                            else {
                                throw new ConfigError("Failed to load transformer \"".concat(name, "\""), ensureError(err));
                            }
                        }
                    });
                };
                /**
                 * Get transformation function requested by configuration.
                 *
                 * Searches:
                 *
                 * - Named transformers from plugins.
                 * - Unnamed transformer from plugin.
                 * - Standalone modules (local or node_modules)
                 *
                 * @param name - Key from configuration
                 */
                Config.prototype.getTransformFunction = function (name) {
                    /* try to match a named transformer from plugin */
                    var match = name.match(/(.*):(.*)/);
                    if (match) {
                        var pluginName = match[1], key = match[2];
                        return this.getNamedTransformerFromPlugin(name, pluginName, key);
                    }
                    /* try to match an unnamed transformer from plugin */
                    var plugin = this.plugins.find(function (cur) { return cur.name === name; });
                    if (plugin) {
                        return this.getUnnamedTransformerFromPlugin(name, plugin);
                    }
                    /* assume transformer refers to a regular module */
                    return this.getTransformerFromModule(name);
                };
                /**
                 * @param name - Original name from configuration
                 * @param pluginName - Name of plugin
                 * @param key - Name of transform (from plugin)
                 */
                Config.prototype.getNamedTransformerFromPlugin = function (name, pluginName, key) {
                    var plugin = this.plugins.find(function (cur) { return cur.name === pluginName; });
                    if (!plugin) {
                        throw new ConfigError("No plugin named \"".concat(pluginName, "\" has been loaded"));
                    }
                    if (!plugin.transformer) {
                        throw new ConfigError("Plugin does not expose any transformer");
                    }
                    if (typeof plugin.transformer === "function") {
                        throw new ConfigError("Transformer \"".concat(name, "\" refers to named transformer but plugin exposes only unnamed, use \"").concat(pluginName, "\" instead."));
                    }
                    var transformer = plugin.transformer[key];
                    if (!transformer) {
                        throw new ConfigError("Plugin \"".concat(pluginName, "\" does not expose a transformer named \"").concat(key, "\"."));
                    }
                    return transformer;
                };
                /**
                 * @param name - Original name from configuration
                 * @param plugin - Plugin instance
                 */
                Config.prototype.getUnnamedTransformerFromPlugin = function (name, plugin) {
                    if (!plugin.transformer) {
                        throw new ConfigError("Plugin does not expose any transformer");
                    }
                    if (typeof plugin.transformer !== "function") {
                        if (plugin.transformer["default"]) {
                            return plugin.transformer["default"];
                        }
                        throw new ConfigError("Transformer \"".concat(name, "\" refers to unnamed transformer but plugin exposes only named."));
                    }
                    return plugin.transformer;
                };
                Config.prototype.getTransformerFromModule = function (name) {
                    return resolveTransformer(this.resolvers, name, { cache: true });
                };
                return Config;
            }());
            /**
             * Configuration loader interface.
             *
             * A configuration loader takes a handle (typically a filename) and returns a
             * configuration for it.
             *
             * @public
             */
            var ConfigLoader = /** @class */ (function () {
                function ConfigLoader(resolvers, config) {
                    var defaults = Config.empty();
                    this.resolvers = resolvers;
                    this.globalConfig = defaults.merge(this.resolvers, config ? this.loadFromObject(config) : this.defaultConfig());
                }
                /**
                 * @internal For testing only
                 */
                ConfigLoader.prototype._getGlobalConfig = function () {
                    return this.globalConfig.get();
                };
                ConfigLoader.prototype.empty = function () {
                    return Config.empty();
                };
                ConfigLoader.prototype.loadFromObject = function (options, filename) {
                    return Config.fromObject(this.resolvers, options, filename);
                };
                ConfigLoader.prototype.loadFromFile = function (filename) {
                    return Config.fromFile(this.resolvers, filename);
                };
                return ConfigLoader;
            }());
            /**
             * @public
             */
            var EventHandler = /** @class */ (function () {
                function EventHandler() {
                    this.listeners = {};
                }
                /**
                 * Add an event listener.
                 *
                 * @param event - Event names (comma separated) or '*' for any event.
                 * @param callback - Called any time even triggers.
                 * @returns Unregistration function.
                 */
                EventHandler.prototype.on = function (event, callback) {
                    var _this_1 = this;
                    var names = event.split(",").map(function (x) { return x.trim(); });
                    for (var _1 = 0, names_2 = names; _1 < names_2.length; _1++) {
                        var name_19 = names_2[_1];
                        this.listeners[name_19] = this.listeners[name_19] || [];
                        this.listeners[name_19].push(callback);
                    }
                    return function () {
                        for (var _1 = 0, names_3 = names; _1 < names_3.length; _1++) {
                            var name_20 = names_3[_1];
                            _this_1.listeners[name_20] = _this_1.listeners[name_20].filter(function (fn) {
                                return fn !== callback;
                            });
                        }
                    };
                };
                /**
                 * Add a onetime event listener. The listener will automatically be removed
                 * after being triggered once.
                 *
                 * @param event - Event names (comma separated) or '*' for any event.
                 * @param callback - Called any time even triggers.
                 * @returns Unregistration function.
                 */
                EventHandler.prototype.once = function (event, callback) {
                    var deregister = this.on(event, function (event, data) {
                        callback(event, data);
                        deregister();
                    });
                    return deregister;
                };
                /**
                 * Trigger event causing all listeners to be called.
                 *
                 * @param event - Event name.
                 * @param data - Event data.
                 */
                EventHandler.prototype.trigger = function (event, data) {
                    var _a, _b;
                    var callbacks = __spreadArray(__spreadArray([], ((_a = this.listeners[event]) !== null && _a !== void 0 ? _a : []), true), ((_b = this.listeners["*"]) !== null && _b !== void 0 ? _b : []), true);
                    callbacks.forEach(function (listener) {
                        listener.call(null, event, data);
                    });
                };
                return EventHandler;
            }());
            var regexp = /<!(?:--)?\[(.*?)\](?:--)?>/g;
            function parseConditionalComment(comment, commentLocation) {
                var match, expression, begin, end, location_13;
                return __generator(this, function (_1) {
                    switch (_1.label) {
                        case 0:
                            if (!((match = regexp.exec(comment)) !== null)) return [3 /*break*/, 2];
                            expression = match[1];
                            begin = match.index;
                            end = begin + match[0].length;
                            location_13 = sliceLocation(commentLocation, begin, end, comment);
                            return [4 /*yield*/, {
                                    expression: expression,
                                    location: location_13
                                }];
                        case 1:
                            _1.sent();
                            return [3 /*break*/, 0];
                        case 2: return [2 /*return*/];
                    }
                });
            }
            var ParserError = /** @class */ (function (_super) {
                __extends(ParserError, _super);
                function ParserError(location, message) {
                    var _this_1 = _super.call(this, message) || this;
                    _this_1.location = location;
                    return _this_1;
                }
                return ParserError;
            }(Error));
            function isAttrValueToken(token) {
                return Boolean(token && token.type === TokenType.ATTR_VALUE);
            }
            function svgShouldRetainTag(foreignTagName, tagName) {
                return foreignTagName === "svg" && ["title", "desc"].includes(tagName);
            }
            function isValidDirective(action) {
                var validActions = ["enable", "disable", "disable-block", "disable-next"];
                return validActions.includes(action);
            }
            /**
             * Parse HTML document into a DOM tree.
             *
             * @public
             */
            var Parser = /** @class */ (function () {
                /**
                 * Create a new parser instance.
                 *
                 * @public
                 * @param config - Configuration
                 */
                function Parser(config) {
                    this.currentNamespace = "";
                    this.event = new EventHandler();
                    this.dom = null;
                    this.metaTable = config.getMetaTable();
                }
                /**
                 * Parse HTML markup.
                 *
                 * @public
                 * @param source - HTML markup.
                 * @returns DOM tree representing the HTML markup.
                 */
                Parser.prototype.parseHtml = function (source) {
                    var _a, _b, _c, _d;
                    if (typeof source === "string") {
                        source = {
                            data: source,
                            filename: "inline",
                            line: 1,
                            column: 1,
                            offset: 0
                        };
                    }
                    /* trigger starting event */
                    this.trigger("parse:begin", {
                        location: null
                    });
                    /* reset DOM in case there are multiple calls in the same session */
                    this.dom = new DOMTree({
                        filename: (_a = source.filename) !== null && _a !== void 0 ? _a : "",
                        offset: (_b = source.offset) !== null && _b !== void 0 ? _b : 0,
                        line: (_c = source.line) !== null && _c !== void 0 ? _c : 1,
                        column: (_d = source.column) !== null && _d !== void 0 ? _d : 1,
                        size: 0
                    });
                    /* trigger any rules waiting for DOM load event */
                    this.trigger("dom:load", {
                        source: source,
                        location: null
                    });
                    var lexer = new Lexer();
                    var tokenStream = lexer.tokenize(source);
                    /* consume all tokens from the stream */
                    var it = this.next(tokenStream);
                    while (!it.done) {
                        var token = it.value;
                        this.consume(source, token, tokenStream);
                        it = this.next(tokenStream);
                    }
                    /* resolve any dynamic meta element properties */
                    this.dom.resolveMeta(this.metaTable);
                    /* enable cache on root element, all children already have cached enabled */
                    this.dom.root.cacheEnable();
                    /* trigger any rules waiting for DOM ready */
                    this.trigger("dom:ready", {
                        document: this.dom,
                        source: source,
                        /* disable location for this event so rules can use implicit node location
                         * instead */
                        location: null
                    });
                    /* trigger ending event */
                    this.trigger("parse:end", {
                        location: null
                    });
                    return this.dom.root;
                };
                /**
                 * Detect optional end tag.
                 *
                 * Some tags have optional end tags (e.g. <ul><li>foo<li>bar</ul> is
                 * valid). The parser handles this by checking if the element on top of the
                 * stack when is allowed to omit.
                 */
                Parser.prototype.closeOptional = function (token) {
                    var _a;
                    /* if the element doesn't have metadata it cannot have optional end
                     * tags. Period. */
                    var active = this.dom.getActive();
                    if (!((_a = active.meta) === null || _a === void 0 ? void 0 : _a.implicitClosed)) {
                        return false;
                    }
                    var tagName = token.data[2];
                    var open = !token.data[1];
                    var meta = active.meta.implicitClosed;
                    if (open) {
                        /* a new element is opened, check if the new element should close the
                         * previous */
                        return meta.includes(tagName);
                    }
                    else {
                        /* if we are explicitly closing the active element, ignore implicit */
                        if (active.is(tagName)) {
                            return false;
                        }
                        /* the parent element is closed, check if the active element would be
                         * implicitly closed when parent is. */
                        return Boolean(active.parent && active.parent.is(tagName) && meta.includes(active.tagName));
                    }
                };
                /**
                 * @internal
                 */
                /* eslint-disable-next-line complexity -- there isn't really a good other way to structure this method (that is still readable) */
                Parser.prototype.consume = function (source, token, tokenStream) {
                    switch (token.type) {
                        case TokenType.UNICODE_BOM:
                            /* ignore */
                            break;
                        case TokenType.TAG_OPEN:
                            this.consumeTag(source, token, tokenStream);
                            break;
                        case TokenType.WHITESPACE:
                            this.trigger("whitespace", {
                                text: token.data[0],
                                location: token.location
                            });
                            this.appendText(token.data[0], token.location);
                            break;
                        case TokenType.DIRECTIVE:
                            this.consumeDirective(token);
                            break;
                        case TokenType.CONDITIONAL:
                            this.consumeConditional(token);
                            break;
                        case TokenType.COMMENT:
                            this.consumeComment(token);
                            break;
                        case TokenType.DOCTYPE_OPEN:
                            this.consumeDoctype(token, tokenStream);
                            break;
                        case TokenType.TEXT:
                        case TokenType.TEMPLATING:
                            this.appendText(token.data[0], token.location);
                            break;
                        case TokenType.EOF:
                            this.closeTree(source, token.location);
                            break;
                    }
                };
                /**
                 * @internal
                 */
                /* eslint-disable-next-line complexity, sonarjs/cognitive-complexity -- technical debt, chould be refactored a bit */
                Parser.prototype.consumeTag = function (source, startToken, tokenStream) {
                    var tokens = Array.from(this.consumeUntil(tokenStream, TokenType.TAG_CLOSE, startToken.location));
                    var endToken = tokens.slice(-1)[0];
                    var closeOptional = this.closeOptional(startToken);
                    var parent = closeOptional ? this.dom.getActive().parent : this.dom.getActive();
                    var node = HtmlElement.fromTokens(startToken, endToken, parent, this.metaTable, this.currentNamespace);
                    var isStartTag = !startToken.data[1];
                    var isClosing = !isStartTag || node.closed !== exports.NodeClosed.Open;
                    var isForeign = node.meta && node.meta.foreign;
                    /* if the previous tag to be implicitly closed by the current tag we close
                     * it and pop it from the stack before continuing processing this tag */
                    if (closeOptional) {
                        var active = this.dom.getActive();
                        active.closed = exports.NodeClosed.ImplicitClosed;
                        this.closeElement(source, node, active, startToken.location);
                        this.dom.popActive();
                    }
                    if (isStartTag) {
                        this.dom.pushActive(node);
                        this.trigger("tag:start", {
                            target: node,
                            location: startToken.location
                        });
                    }
                    for (var i = 0; i < tokens.length; i++) {
                        var token = tokens[i];
                        switch (token.type) {
                            case TokenType.WHITESPACE:
                                break;
                            case TokenType.ATTR_NAME:
                                this.consumeAttribute(source, node, token, tokens[i + 1]);
                                break;
                        }
                    }
                    /* emit tag:ready unless this is a end tag */
                    if (isStartTag) {
                        this.trigger("tag:ready", {
                            target: node,
                            location: endToken.location
                        });
                    }
                    if (isClosing) {
                        var active = this.dom.getActive();
                        /* if this is not an open tag it is a close tag and thus we force it to be
                         * one, in case it is detected as void */
                        if (!isStartTag) {
                            node.closed = exports.NodeClosed.EndTag;
                        }
                        this.closeElement(source, node, active, endToken.location);
                        /* if this element is closed with an end tag but is would it will not be
                         * closed again (it is already closed automatically since it is
                         * void). Closing again will have side-effects as it will close the parent
                         * and cause a mess later. */
                        var voidClosed = !isStartTag && node.voidElement;
                        if (!voidClosed) {
                            this.dom.popActive();
                        }
                    }
                    else if (isForeign) {
                        /* consume the body of the foreign element so it won't be part of the
                         * document (only the root foreign element is).  */
                        this.discardForeignBody(source, node.tagName, tokenStream, startToken.location);
                    }
                };
                /**
                 * @internal
                 */
                Parser.prototype.closeElement = function (source, node, active, location) {
                    /* call processElement hook */
                    this.processElement(active, source);
                    /* trigger event for the closing of the element (the </> tag)*/
                    var event = {
                        target: node,
                        previous: active,
                        location: location
                    };
                    this.trigger("tag:end", event);
                    /* trigger event for for an element being fully constructed. Special care
                     * for void elements explicit closed <input></input> */
                    if (active && !active.isRootElement()) {
                        this.trigger("element:ready", {
                            target: active,
                            location: active.location
                        });
                    }
                };
                Parser.prototype.processElement = function (node, source) {
                    var _a;
                    /* enable cache on node now that it is fully constructed */
                    node.cacheEnable();
                    if ((_a = source.hooks) === null || _a === void 0 ? void 0 : _a.processElement) {
                        var processElement = source.hooks.processElement;
                        var metaTable_1 = this.metaTable;
                        var context = {
                            getMetaFor: function (tagName) {
                                return metaTable_1.getMetaFor(tagName);
                            }
                        };
                        processElement.call(context, node);
                    }
                };
                /**
                 * Discard tokens until the end tag for the foreign element is found.
                 *
                 * @internal
                 */
                Parser.prototype.discardForeignBody = function (source, foreignTagName, tokenStream, errorLocation) {
                    /* consume elements until the end tag for this foreign element is found */
                    var nested = 1;
                    var startToken;
                    var endToken;
                    do {
                        /* search for tags */
                        var tokens = Array.from(this.consumeUntil(tokenStream, TokenType.TAG_OPEN, errorLocation));
                        var last = tokens.slice(-1)[0];
                        var _1 = last.data, tagClosed = _1[1], tagName = _1[2];
                        /* special case: svg <title> and <desc> should be intact as it affects accessibility */
                        if (!tagClosed && svgShouldRetainTag(foreignTagName, tagName)) {
                            var oldNamespace = this.currentNamespace;
                            this.currentNamespace = "svg";
                            this.consumeTag(source, last, tokenStream);
                            this.consumeUntilMatchingTag(source, tokenStream, tagName);
                            this.currentNamespace = oldNamespace;
                            continue;
                        }
                        /* keep going unless the new tag matches the foreign root element */
                        if (tagName !== foreignTagName) {
                            continue;
                        }
                        /* locate end token and determine if this is a self-closed tag */
                        var endTokens = Array.from(this.consumeUntil(tokenStream, TokenType.TAG_CLOSE, last.location));
                        endToken = endTokens.slice(-1)[0];
                        var selfClosed = endToken.data[0] === "/>";
                        /* since foreign element may be nested keep a count for the number of
                         * opened/closed elements */
                        if (tagClosed) {
                            startToken = last;
                            nested--;
                        }
                        else if (!selfClosed) {
                            nested++;
                        }
                    } while (nested > 0);
                    /* istanbul ignore next: this should never happen because `consumeUntil`
                     * would have thrown errors however typescript does not know that */
                    if (!startToken || !endToken) {
                        return;
                    }
                    var active = this.dom.getActive();
                    var node = HtmlElement.fromTokens(startToken, endToken, active, this.metaTable);
                    this.closeElement(source, node, active, endToken.location);
                    this.dom.popActive();
                };
                /**
                 * @internal
                 */
                Parser.prototype.consumeAttribute = function (source, node, token, next) {
                    var _a;
                    var keyLocation = this.getAttributeKeyLocation(token);
                    var valueLocation = this.getAttributeValueLocation(next);
                    var location = this.getAttributeLocation(token, next);
                    var haveValue = isAttrValueToken(next);
                    var attrData = {
                        key: token.data[1],
                        value: null,
                        quote: null
                    };
                    if (haveValue) {
                        var _1 = next.data, value = _1[2], quote = _1[3];
                        attrData.value = value;
                        attrData.quote = quote !== null && quote !== void 0 ? quote : null;
                    }
                    /* get callback to process attributes, default is to just return attribute
                     * data right away but a transformer may override it to allow aliasing
                     * attributes, e.g ng-attr-foo or v-bind:foo */
                    var processAttribute = function (attr) { return [attr]; };
                    if ((_a = source.hooks) === null || _a === void 0 ? void 0 : _a.processAttribute) {
                        processAttribute = source.hooks.processAttribute;
                    }
                    /* handle deprecated callbacks */
                    var iterator;
                    var legacy = processAttribute.call({}, attrData);
                    if (typeof legacy[Symbol.iterator] !== "function") {
                        /* AttributeData */
                        iterator = [attrData];
                    }
                    else {
                        /* Iterable<AttributeData> */
                        iterator = legacy;
                    }
                    /* process attribute(s) */
                    for (var _2 = 0, iterator_1 = iterator; _2 < iterator_1.length; _2++) {
                        var attr = iterator_1[_2];
                        var event_1 = {
                            target: node,
                            key: attr.key,
                            value: attr.value,
                            quote: attr.quote,
                            originalAttribute: attr.originalAttribute,
                            location: location,
                            keyLocation: keyLocation,
                            valueLocation: valueLocation
                        };
                        this.trigger("attr", event_1);
                        node.setAttribute(attr.key, attr.value, keyLocation, valueLocation, attr.originalAttribute);
                    }
                };
                /**
                 * Takes attribute key token an returns location.
                 */
                Parser.prototype.getAttributeKeyLocation = function (token) {
                    return token.location;
                };
                /**
                 * Take attribute value token and return a new location referring to only the
                 * value.
                 *
                 * foo="bar"    foo='bar'    foo=bar    foo      foo=""
                 *      ^^^          ^^^         ^^^    (null)   (null)
                 */
                Parser.prototype.getAttributeValueLocation = function (token) {
                    if (!token || token.type !== TokenType.ATTR_VALUE || token.data[2] === "") {
                        return null;
                    }
                    var quote = token.data[3];
                    if (quote) {
                        return sliceLocation(token.location, 2, -1);
                    }
                    else {
                        return sliceLocation(token.location, 1);
                    }
                };
                /**
                 * Take attribute key and value token an returns a new location referring to
                 * an aggregate location covering key, quotes if present and value.
                 */
                Parser.prototype.getAttributeLocation = function (key, value) {
                    var _a;
                    var begin = key.location;
                    var end = value && value.type === TokenType.ATTR_VALUE ? value.location : undefined;
                    return {
                        filename: begin.filename,
                        line: begin.line,
                        column: begin.column,
                        size: begin.size + ((_a = end === null || end === void 0 ? void 0 : end.size) !== null && _a !== void 0 ? _a : 0),
                        offset: begin.offset
                    };
                };
                /**
                 * @internal
                 */
                Parser.prototype.consumeDirective = function (token) {
                    var _1 = token.data, text = _1[0], preamble = _1[1], action = _1[2], separator1 = _1[3], directive = _1[4], postamble = _1[5];
                    if (!postamble.startsWith("]")) {
                        throw new ParserError(token.location, "Missing end bracket \"]\" on directive \"".concat(text, "\""));
                    }
                    var match = directive.match(/^(.*?)(?:(\s*(?:--|:)\s*)(.*))?$/);
                    /* istanbul ignore next: should not be possible, would be emitted as comment token */
                    if (!match) {
                        throw new Error("Failed to parse directive \"".concat(text, "\""));
                    }
                    if (!isValidDirective(action)) {
                        throw new ParserError(token.location, "Unknown directive \"".concat(action, "\""));
                    }
                    var data = match[1], separator2 = match[2], comment = match[3];
                    var prefix = "html-validate-";
                    /* <!-- [html-validate-action options -- comment] -->
                     *                     ^      ^          ^--------------- comment offset
                     *                     |      \-------------------------- options offset
                     *                     \--------------------------------- action offset
                     */
                    var actionOffset = preamble.length;
                    var optionsOffset = actionOffset + action.length + separator1.length;
                    var commentOffset = optionsOffset + data.length + (separator2 || "").length;
                    var location = sliceLocation(token.location, preamble.length - prefix.length - 1, -postamble.length + 1);
                    var actionLocation = sliceLocation(token.location, actionOffset, actionOffset + action.length);
                    var optionsLocation = data
                        ? sliceLocation(token.location, optionsOffset, optionsOffset + data.length)
                        : undefined;
                    var commentLocation = comment
                        ? sliceLocation(token.location, commentOffset, commentOffset + comment.length)
                        : undefined;
                    this.trigger("directive", {
                        action: action,
                        data: data,
                        comment: comment || "",
                        location: location,
                        actionLocation: actionLocation,
                        optionsLocation: optionsLocation,
                        commentLocation: commentLocation
                    });
                };
                /**
                 * Consumes conditional comment in tag form.
                 *
                 * See also the related [[consumeCommend]] method.
                 *
                 * @internal
                 */
                Parser.prototype.consumeConditional = function (token) {
                    var element = this.dom.getActive();
                    this.trigger("conditional", {
                        condition: token.data[1],
                        location: token.location,
                        parent: element
                    });
                };
                /**
                 * Consumes comment token.
                 *
                 * Tries to find IE conditional comments and emits conditional token if
                 * found. See also the related [[consumeConditional]] method.
                 *
                 * @internal
                 */
                Parser.prototype.consumeComment = function (token) {
                    var comment = token.data[0];
                    var element = this.dom.getActive();
                    for (var _1 = 0, _2 = parseConditionalComment(comment, token.location); _1 < _2.length; _1++) {
                        var conditional = _2[_1];
                        this.trigger("conditional", {
                            condition: conditional.expression,
                            location: conditional.location,
                            parent: element
                        });
                    }
                };
                /**
                 * Consumes doctype tokens. Emits doctype event.
                 *
                 * @internal
                 */
                Parser.prototype.consumeDoctype = function (startToken, tokenStream) {
                    var tokens = Array.from(this.consumeUntil(tokenStream, TokenType.DOCTYPE_CLOSE, startToken.location));
                    /* first token is the doctype, second is the closing ">" */
                    var doctype = tokens[0];
                    var value = doctype.data[0];
                    this.dom.doctype = value;
                    this.trigger("doctype", {
                        tag: startToken.data[1],
                        value: value,
                        valueLocation: tokens[0].location,
                        location: startToken.location
                    });
                };
                /**
                 * Return a list of tokens found until the expected token was found.
                 *
                 * @internal
                 * @param errorLocation - What location to use if an error occurs
                 */
                Parser.prototype.consumeUntil = function (tokenStream, search, errorLocation) {
                    var it, token;
                    return __generator(this, function (_1) {
                        switch (_1.label) {
                            case 0:
                                it = this.next(tokenStream);
                                _1.label = 1;
                            case 1:
                                if (!!it.done) return [3 /*break*/, 3];
                                token = it.value;
                                return [4 /*yield*/, token];
                            case 2:
                                _1.sent();
                                if (token.type === search)
                                    return [2 /*return*/];
                                it = this.next(tokenStream);
                                return [3 /*break*/, 1];
                            case 3: throw new ParserError(errorLocation, "stream ended before ".concat(TokenType[search], " token was found"));
                        }
                    });
                };
                /**
                 * Consumes tokens until a matching close-tag is found. Tags are appended to
                 * the document.
                 *
                 * @internal
                 */
                Parser.prototype.consumeUntilMatchingTag = function (source, tokenStream, searchTag) {
                    var numOpen = 1;
                    var it = this.next(tokenStream);
                    while (!it.done) {
                        var token = it.value;
                        this.consume(source, token, tokenStream);
                        if (token.type === TokenType.TAG_OPEN) {
                            var _1 = token.data, close_1 = _1[1], tagName = _1[2];
                            if (tagName === searchTag) {
                                if (close_1) {
                                    numOpen--;
                                }
                                else {
                                    numOpen++;
                                }
                                if (numOpen === 0) {
                                    return;
                                }
                            }
                        }
                        it = this.next(tokenStream);
                    }
                };
                Parser.prototype.next = function (tokenStream) {
                    var it = tokenStream.next();
                    if (!it.done) {
                        var token = it.value;
                        this.trigger("token", {
                            location: token.location,
                            type: token.type,
                            data: Array.from(token.data),
                            token: token
                        });
                    }
                    return it;
                };
                Parser.prototype.on = function (event, listener) {
                    return this.event.on(event, listener);
                };
                Parser.prototype.once = function (event, listener) {
                    return this.event.once(event, listener);
                };
                /**
                 * Defer execution. Will call function sometime later.
                 *
                 * @internal
                 * @param cb - Callback to execute later.
                 */
                Parser.prototype.defer = function (cb) {
                    this.event.once("*", cb);
                };
                Parser.prototype.trigger = function (event, data) {
                    if (typeof data.location === "undefined") {
                        throw new Error("Triggered event must contain location");
                    }
                    this.event.trigger(event, data);
                };
                /**
                 * @internal
                 */
                Parser.prototype.getEventHandler = function () {
                    return this.event;
                };
                /**
                 * Appends a text node to the current element on the stack.
                 */
                Parser.prototype.appendText = function (text, location) {
                    this.dom.getActive().appendText(text, location);
                };
                /**
                 * Trigger close events for any still open elements.
                 */
                Parser.prototype.closeTree = function (source, location) {
                    var active;
                    while ((active = this.dom.getActive()) && !active.isRootElement()) {
                        this.closeElement(source, null, active, location);
                        this.dom.popActive();
                    }
                };
                return Parser;
            }());
            function freeze(src) {
                return __assign(__assign({}, src), { selector: src.selector() });
            }
            /**
             * @public
             */
            var Reporter = /** @class */ (function () {
                function Reporter() {
                    this.result = {};
                }
                /**
                 * Merge two or more reports into a single one.
                 */
                Reporter.merge = function (reports) {
                    var valid = reports.every(function (report) { return report.valid; });
                    var merged = {};
                    reports.forEach(function (report) {
                        report.results.forEach(function (result) {
                            var key = result.filePath;
                            if (key in merged) {
                                merged[key].messages = __spreadArray(__spreadArray([], merged[key].messages, true), result.messages, true);
                            }
                            else {
                                merged[key] = __assign({}, result);
                            }
                        });
                    });
                    var results = Object.values(merged).map(function (result) {
                        /* recalculate error- and warning-count */
                        result.errorCount = countErrors(result.messages);
                        result.warningCount = countWarnings(result.messages);
                        return result;
                    });
                    return {
                        valid: valid,
                        results: results,
                        errorCount: sumErrors(results),
                        warningCount: sumWarnings(results)
                    };
                };
                Reporter.prototype.add = function (rule, message, severity, node, location, context) {
                    var _a;
                    if (!(location.filename in this.result)) {
                        this.result[location.filename] = [];
                    }
                    var ruleUrl = (_a = rule.documentation(context)) === null || _a === void 0 ? void 0 : _a.url;
                    var entry = {
                        ruleId: rule.name,
                        severity: severity,
                        message: message,
                        offset: location.offset,
                        line: location.line,
                        column: location.column,
                        size: location.size || 0,
                        selector: function () {
                            return node ? node.generateSelector() : null;
                        }
                    };
                    if (ruleUrl) {
                        entry.ruleUrl = ruleUrl;
                    }
                    if (context) {
                        entry.context = context;
                    }
                    this.result[location.filename].push(entry);
                };
                Reporter.prototype.addManual = function (filename, message) {
                    if (!(filename in this.result)) {
                        this.result[filename] = [];
                    }
                    this.result[filename].push(message);
                };
                Reporter.prototype.save = function (sources) {
                    var _this_1 = this;
                    var report = {
                        valid: this.isValid(),
                        results: Object.keys(this.result).map(function (filePath) {
                            var _a;
                            var messages = Array.from(_this_1.result[filePath], freeze).sort(messageSort);
                            var source = (sources !== null && sources !== void 0 ? sources : []).find(function (source) { var _a; return filePath === ((_a = source.filename) !== null && _a !== void 0 ? _a : ""); });
                            return {
                                filePath: filePath,
                                messages: messages,
                                errorCount: countErrors(messages),
                                warningCount: countWarnings(messages),
                                source: source ? (_a = source.originalData) !== null && _a !== void 0 ? _a : source.data : null
                            };
                        }),
                        errorCount: 0,
                        warningCount: 0
                    };
                    report.errorCount = sumErrors(report.results);
                    report.warningCount = sumWarnings(report.results);
                    return report;
                };
                Reporter.prototype.isValid = function () {
                    var numErrors = Object.values(this.result).reduce(function (sum, messages) {
                        return sum + countErrors(messages);
                    }, 0);
                    return numErrors === 0;
                };
                return Reporter;
            }());
            function countErrors(messages) {
                return messages.filter(function (m) { return m.severity === Number(exports.Severity.ERROR); }).length;
            }
            function countWarnings(messages) {
                return messages.filter(function (m) { return m.severity === Number(exports.Severity.WARN); }).length;
            }
            function sumErrors(results) {
                return results.reduce(function (sum, result) {
                    return sum + result.errorCount;
                }, 0);
            }
            function sumWarnings(results) {
                return results.reduce(function (sum, result) {
                    return sum + result.warningCount;
                }, 0);
            }
            function messageSort(a, b) {
                if (a.line < b.line) {
                    return -1;
                }
                if (a.line > b.line) {
                    return 1;
                }
                if (a.column < b.column) {
                    return -1;
                }
                if (a.column > b.column) {
                    return 1;
                }
                return 0;
            }
            var blockerCounter = 1;
            /**
             * Creates a new rule blocker for using when blocking rules from generating
             * errors.
             *
             * @internal
             */
            function createBlocker() {
                var id = blockerCounter++;
                return id;
            }
            /**
             * @internal
             */
            var Engine = /** @class */ (function () {
                function Engine(config, ParserClass) {
                    this.report = new Reporter();
                    this.config = config;
                    this.ParserClass = ParserClass;
                    /* initialize plugins and rules */
                    var result = this.initPlugins(this.config);
                    this.availableRules = __assign(__assign({}, rules), result.availableRules);
                }
                /**
                 * Lint sources and return report
                 *
                 * @param sources - Sources to lint.
                 * @returns Report output.
                 */
                Engine.prototype.lint = function (sources) {
                    var _this_1 = this;
                    var _loop_22 = function (source) {
                        /* create parser for source */
                        var parser = this_3.instantiateParser();
                        /* setup plugins and rules */
                        var rules_8 = this_3.setupPlugins(source, this_3.config, parser).rules;
                        var noUnusedDisable = rules_8["no-unused-disable"];
                        var directiveContext = {
                            rules: rules_8,
                            reportUnused: function (rules, unused, options, location) {
                                if (noUnusedDisable && !rules.has(noUnusedDisable.name)) {
                                    noUnusedDisable.reportUnused(unused, options, location);
                                }
                            }
                        };
                        /* create a faux location at the start of the stream for the next events */
                        var location_14 = {
                            filename: source.filename,
                            line: 1,
                            column: 1,
                            offset: 0,
                            size: 1
                        };
                        /* trigger configuration ready event */
                        var configEvent = {
                            location: location_14,
                            config: this_3.config,
                            rules: rules_8
                        };
                        parser.trigger("config:ready", configEvent);
                        /* trigger source ready event */
                        var _ = source.hooks, sourceData = __rest(source, ["hooks"]);
                        var sourceEvent = {
                            location: location_14,
                            source: sourceData
                        };
                        parser.trigger("source:ready", sourceEvent);
                        /* setup directive handling */
                        parser.on("directive", function (_, event) {
                            _this_1.processDirective(event, parser, directiveContext);
                        });
                        /* parse token stream */
                        try {
                            parser.parseHtml(source);
                        }
                        catch (e) {
                            if (e instanceof InvalidTokenError || e instanceof ParserError) {
                                this_3.reportError("parser-error", e.message, e.location);
                            }
                            else {
                                throw e;
                            }
                        }
                    };
                    var this_3 = this;
                    for (var _1 = 0, sources_1 = sources; _1 < sources_1.length; _1++) {
                        var source = sources_1[_1];
                        _loop_22(source);
                    }
                    /* generate results from report */
                    return this.report.save(sources);
                };
                /**
                 * Returns a list of all events generated while parsing the source.
                 *
                 * For verbosity, token events are ignored (use [[dumpTokens]] to inspect
                 * token stream).
                 */
                Engine.prototype.dumpEvents = function (source) {
                    var parser = this.instantiateParser();
                    var lines = [];
                    parser.on("*", function (event, data) {
                        /* ignore token events as it becomes to verbose */
                        if (event === "token") {
                            return;
                        }
                        lines.push({ event: event, data: data });
                    });
                    source.forEach(function (src) { return parser.parseHtml(src); });
                    return lines;
                };
                Engine.prototype.dumpTokens = function (source) {
                    var _a;
                    var lexer = new Lexer();
                    var lines = [];
                    for (var _1 = 0, source_2 = source; _1 < source_2.length; _1++) {
                        var src = source_2[_1];
                        for (var _2 = 0, _3 = lexer.tokenize(src); _2 < _3.length; _2++) {
                            var token = _3[_2];
                            var data = (_a = token.data[0]) !== null && _a !== void 0 ? _a : "";
                            lines.push({
                                token: TokenType[token.type],
                                data: data,
                                location: "".concat(token.location.filename, ":").concat(token.location.line, ":").concat(token.location.column)
                            });
                        }
                    }
                    return lines;
                };
                Engine.prototype.dumpTree = function (source) {
                    /* @todo handle dumping each tree */
                    var parser = this.instantiateParser();
                    var document = parser.parseHtml(source[0]);
                    var lines = [];
                    function decoration(node) {
                        var output = "";
                        if (node.id) {
                            output += "#".concat(node.id);
                        }
                        if (node.hasAttribute("class")) {
                            output += ".".concat(node.classList.join("."));
                        }
                        return output;
                    }
                    function writeNode(node, level, sibling) {
                        if (node.parent) {
                            var indent = "  ".repeat(level - 1);
                            var l = node.childElements.length > 0 ? "" : "";
                            var b = sibling < node.parent.childElements.length - 1 ? "" : "";
                            lines.push("".concat(indent).concat(b, "\u2500").concat(l, " ").concat(node.tagName).concat(decoration(node)));
                        }
                        else {
                            lines.push("(root)");
                        }
                        node.childElements.forEach(function (child, index) {
                            writeNode(child, level + 1, index);
                        });
                    }
                    writeNode(document, 0, 0);
                    return lines;
                };
                /**
                 * Get rule documentation.
                 */
                Engine.prototype.getRuleDocumentation = function (_1) {
                    var ruleId = _1.ruleId, context = _1.context;
                    var rules = this.config.getRules();
                    var ruleData = rules.get(ruleId);
                    if (ruleData) {
                        var options = ruleData[1];
                        var rule = this.instantiateRule(ruleId, options);
                        return rule.documentation(context);
                    }
                    else {
                        return null;
                    }
                };
                /**
                 * Create a new parser instance with the current configuration.
                 *
                 * @internal
                 */
                Engine.prototype.instantiateParser = function () {
                    return new this.ParserClass(this.config);
                };
                Engine.prototype.processDirective = function (event, parser, context) {
                    var _a;
                    var rules = event.data
                        .split(",")
                        .map(function (name) { return name.trim(); })
                        .map(function (name) { return context.rules[name]; })
                        .filter(function (rule) { return rule; }); /* filter out missing rules */
                    /* istanbul ignore next: option must be present or there would be no rules to disable */
                    var location = (_a = event.optionsLocation) !== null && _a !== void 0 ? _a : event.location;
                    switch (event.action) {
                        case "enable":
                            this.processEnableDirective(rules, parser);
                            break;
                        case "disable":
                            this.processDisableDirective(rules, parser);
                            break;
                        case "disable-block":
                            this.processDisableBlockDirective(context, rules, parser, event.data, location);
                            break;
                        case "disable-next":
                            this.processDisableNextDirective(context, rules, parser, event.data, location);
                            break;
                    }
                };
                Engine.prototype.processEnableDirective = function (rules, parser) {
                    for (var _1 = 0, rules_9 = rules; _1 < rules_9.length; _1++) {
                        var rule = rules_9[_1];
                        rule.setEnabled(true);
                        if (rule.getSeverity() === exports.Severity.DISABLED) {
                            rule.setServerity(exports.Severity.ERROR);
                        }
                    }
                    /* enable rules on node */
                    parser.on("tag:start", function (event, data) {
                        data.target.enableRules(rules.map(function (rule) { return rule.name; }));
                    });
                };
                Engine.prototype.processDisableDirective = function (rules, parser) {
                    for (var _1 = 0, rules_10 = rules; _1 < rules_10.length; _1++) {
                        var rule = rules_10[_1];
                        rule.setEnabled(false);
                    }
                    /* disable rules on node */
                    parser.on("tag:start", function (event, data) {
                        data.target.disableRules(rules.map(function (rule) { return rule.name; }));
                    });
                };
                Engine.prototype.processDisableBlockDirective = function (context, rules, parser, options, location) {
                    var ruleIds = new Set(rules.map(function (it) { return it.name; }));
                    var unused = new Set(ruleIds);
                    var blocker = createBlocker();
                    var directiveBlock = null;
                    for (var _1 = 0, rules_11 = rules; _1 < rules_11.length; _1++) {
                        var rule = rules_11[_1];
                        rule.block(blocker);
                    }
                    var unregisterOpen = parser.on("tag:start", function (event, data) {
                        var _a, _b;
                        /* wait for a tag to open and find the current block by using its parent */
                        if (directiveBlock === null) {
                            /* istanbul ignore next: there will always be a parent (root element if
                             * nothing else) but typescript doesn't know that */
                            directiveBlock = (_b = (_a = data.target.parent) === null || _a === void 0 ? void 0 : _a.unique) !== null && _b !== void 0 ? _b : null;
                        }
                        /* disable rules directly on the node so it will be recorded for later,
                         * more specifically when using the domtree to trigger errors */
                        data.target.blockRules(ruleIds, blocker);
                    });
                    var unregisterClose = parser.on("tag:end", function (event, data) {
                        /* if the directive is the last thing in a block no id would be set */
                        var lastNode = directiveBlock === null;
                        /* test if the block is being closed by checking the parent of the block
                         * element is being closed */
                        var parentClosed = directiveBlock === data.previous.unique;
                        /* remove listeners and restore state */
                        if (lastNode || parentClosed) {
                            unregisterClose();
                            unregisterOpen();
                            for (var _1 = 0, rules_12 = rules; _1 < rules_12.length; _1++) {
                                var rule = rules_12[_1];
                                rule.unblock(blocker);
                            }
                        }
                    });
                    parser.on("rule:error", function (event, data) {
                        if (data.blockers.includes(blocker)) {
                            unused["delete"](data.ruleId);
                        }
                    });
                    parser.on("parse:end", function () {
                        context.reportUnused(ruleIds, unused, options, location);
                    });
                };
                Engine.prototype.processDisableNextDirective = function (context, rules, parser, options, location) {
                    var ruleIds = new Set(rules.map(function (it) { return it.name; }));
                    var unused = new Set(ruleIds);
                    var blocker = createBlocker();
                    for (var _1 = 0, rules_13 = rules; _1 < rules_13.length; _1++) {
                        var rule = rules_13[_1];
                        rule.block(blocker);
                    }
                    /* block rules directly on the node so it will be recorded for later,
                     * more specifically when using the domtree to trigger errors */
                    var unregister = parser.on("tag:start", function (event, data) {
                        data.target.blockRules(ruleIds, blocker);
                    });
                    parser.on("rule:error", function (event, data) {
                        if (data.blockers.includes(blocker)) {
                            unused["delete"](data.ruleId);
                        }
                    });
                    parser.on("parse:end", function () {
                        context.reportUnused(ruleIds, unused, options, location);
                    });
                    /* disable directive after next event occurs */
                    parser.once("tag:ready, tag:end, attr", function () {
                        unregister();
                        parser.defer(function () {
                            for (var _1 = 0, rules_14 = rules; _1 < rules_14.length; _1++) {
                                var rule = rules_14[_1];
                                rule.unblock(blocker);
                            }
                        });
                    });
                };
                /*
                 * Initialize all plugins. This should only be done once for all sessions.
                 */
                Engine.prototype.initPlugins = function (config) {
                    for (var _1 = 0, _2 = config.getPlugins(); _1 < _2.length; _1++) {
                        var plugin = _2[_1];
                        if (plugin.init) {
                            plugin.init();
                        }
                    }
                    return {
                        availableRules: this.initRules(config)
                    };
                };
                /**
                 * Initializes all rules from plugins and returns an object with a mapping
                 * between rule name and its constructor.
                 */
                Engine.prototype.initRules = function (config) {
                    var _a;
                    var availableRules = {};
                    for (var _1 = 0, _2 = config.getPlugins(); _1 < _2.length; _1++) {
                        var plugin = _2[_1];
                        for (var _3 = 0, _4 = Object.entries((_a = plugin.rules) !== null && _a !== void 0 ? _a : {}); _3 < _4.length; _3++) {
                            var _5 = _4[_3], name_21 = _5[0], rule = _5[1];
                            if (!rule)
                                continue;
                            availableRules[name_21] = rule;
                        }
                    }
                    return availableRules;
                };
                /**
                 * Setup all plugins for this session.
                 */
                Engine.prototype.setupPlugins = function (source, config, parser) {
                    var eventHandler = parser.getEventHandler();
                    for (var _1 = 0, _2 = config.getPlugins(); _1 < _2.length; _1++) {
                        var plugin = _2[_1];
                        if (plugin.setup) {
                            plugin.setup(source, eventHandler);
                        }
                    }
                    return {
                        rules: this.setupRules(config, parser)
                    };
                };
                /**
                 * Load and setup all rules for current configuration.
                 */
                Engine.prototype.setupRules = function (config, parser) {
                    var rules = {};
                    for (var _1 = 0, _2 = config.getRules().entries(); _1 < _2.length; _1++) {
                        var _3 = _2[_1], ruleId = _3[0], _4 = _3[1], severity = _4[0], options = _4[1];
                        rules[ruleId] = this.loadRule(ruleId, config, severity, options, parser, this.report);
                    }
                    return rules;
                };
                /**
                 * Load and setup a rule using current config.
                 */
                Engine.prototype.loadRule = function (ruleId, config, severity, options, parser, report) {
                    var meta = config.getMetaTable();
                    var rule = this.instantiateRule(ruleId, options);
                    rule.name = ruleId;
                    rule.init(parser, report, severity, meta);
                    /* call setup callback if present */
                    if (rule.setup) {
                        rule.setup();
                    }
                    return rule;
                };
                Engine.prototype.instantiateRule = function (name, options) {
                    if (this.availableRules[name]) {
                        var RuleConstructor = this.availableRules[name];
                        return new RuleConstructor(options);
                    }
                    else {
                        return this.missingRule(name);
                    }
                };
                Engine.prototype.missingRule = function (name) {
                    return new (/** @class */ (function (_super) {
                        __extends(MissingRule, _super);
                        function MissingRule() {
                            return _super !== null && _super.apply(this, arguments) || this;
                        }
                        MissingRule.prototype.setup = function () {
                            var _this_1 = this;
                            this.on("dom:load", function () {
                                _this_1.report(null, "Definition for rule '".concat(name, "' was not found"));
                            });
                        };
                        return MissingRule;
                    }(Rule)))();
                };
                Engine.prototype.reportError = function (ruleId, message, location) {
                    this.report.addManual(location.filename, {
                        ruleId: ruleId,
                        severity: exports.Severity.ERROR,
                        message: message,
                        offset: location.offset,
                        line: location.line,
                        column: location.column,
                        size: location.size,
                        selector: function () { return null; }
                    });
                };
                return Engine;
            }());
            var defaultResolvers = [];
            function hasResolver(value) {
                return Array.isArray(value[0]);
            }
            /**
             * The static configuration loader does not do any per-handle lookup. Only the
             * global or per-call configuration is used.
             *
             * In practice this means no configuration is fetched by traversing the
             * filesystem.
             *
             * @public
             */
            var StaticConfigLoader = /** @class */ (function (_super) {
                __extends(StaticConfigLoader, _super);
                function StaticConfigLoader() {
                    var args = [];
                    for (var _1 = 0; _1 < arguments.length; _1++) {
                        args[_1] = arguments[_1];
                    }
                    var _this_1 = this;
                    if (hasResolver(args)) {
                        var resolvers = args[0], config_4 = args[1];
                        _this_1 = _super.call(this, resolvers, config_4) || this;
                    }
                    else {
                        var config_5 = args[0];
                        _this_1 = _super.call(this, defaultResolvers, config_5) || this;
                    }
                    return _this_1;
                }
                StaticConfigLoader.prototype.getConfigFor = function (_handle, configOverride) {
                    var override = this.loadFromObject(configOverride !== null && configOverride !== void 0 ? configOverride : {});
                    if (override.isRootFound()) {
                        override.init();
                        return override.resolve();
                    }
                    var merged = this.globalConfig.merge(this.resolvers, override);
                    merged.init();
                    return merged.resolve();
                };
                StaticConfigLoader.prototype.flushCache = function () {
                    /* do nothing */
                };
                StaticConfigLoader.prototype.defaultConfig = function () {
                    return this.loadFromObject({
                        "extends": ["html-validate:recommended"],
                        elements: ["html5"]
                    });
                };
                return StaticConfigLoader;
            }(ConfigLoader));
            function isSourceHooks(value) {
                if (!value || typeof value === "string") {
                    return false;
                }
                return Boolean(value.processAttribute || value.processElement);
            }
            function isConfigData(value) {
                if (!value || typeof value === "string") {
                    return false;
                }
                return !(value.processAttribute || value.processElement);
            }
            /**
             * Primary API for using HTML-validate.
             *
             * Provides high-level abstractions for common operations.
             *
             * @public
             */
            var HtmlValidate = /** @class */ (function () {
                function HtmlValidate(arg) {
                    var _1 = arg instanceof ConfigLoader ? [arg, undefined] : [undefined, arg], loader = _1[0], config = _1[1];
                    this.configLoader = loader !== null && loader !== void 0 ? loader : new StaticConfigLoader(config);
                }
                /* eslint-enable @typescript-eslint/unified-signatures */
                HtmlValidate.prototype.validateString = function (str, arg1, arg2, arg3) {
                    var filename = typeof arg1 === "string" ? arg1 : "inline";
                    var options = isConfigData(arg1) ? arg1 : isConfigData(arg2) ? arg2 : undefined;
                    var hooks = isSourceHooks(arg1) ? arg1 : isSourceHooks(arg2) ? arg2 : arg3;
                    var source = {
                        data: str,
                        filename: filename,
                        line: 1,
                        column: 1,
                        offset: 0,
                        hooks: hooks
                    };
                    return this.validateSource(source, options);
                };
                /* eslint-enable @typescript-eslint/unified-signatures */
                HtmlValidate.prototype.validateStringSync = function (str, arg1, arg2, arg3) {
                    var filename = typeof arg1 === "string" ? arg1 : "inline";
                    var options = isConfigData(arg1) ? arg1 : isConfigData(arg2) ? arg2 : undefined;
                    var hooks = isSourceHooks(arg1) ? arg1 : isSourceHooks(arg2) ? arg2 : arg3;
                    var source = {
                        data: str,
                        filename: filename,
                        line: 1,
                        column: 1,
                        offset: 0,
                        hooks: hooks
                    };
                    return this.validateSourceSync(source, options);
                };
                /**
                 * Parse and validate HTML from [[Source]].
                 *
                 * @public
                 * @param input - Source to parse.
                 * @returns Report output.
                 */
                HtmlValidate.prototype.validateSource = function (input, configOverride) {
                    return __awaiter(this, void 0, void 0, function () {
                        var config, source, engine;
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0: return [4 /*yield*/, this.getConfigFor(input.filename, configOverride)];
                                case 1:
                                    config = _1.sent();
                                    source = config.transformSource(input);
                                    engine = new Engine(config, Parser);
                                    return [2 /*return*/, engine.lint(source)];
                            }
                        });
                    });
                };
                /**
                 * Parse and validate HTML from [[Source]].
                 *
                 * @public
                 * @param input - Source to parse.
                 * @returns Report output.
                 */
                HtmlValidate.prototype.validateSourceSync = function (input, configOverride) {
                    var config = this.getConfigForSync(input.filename, configOverride);
                    var source = config.transformSource(input);
                    var engine = new Engine(config, Parser);
                    return engine.lint(source);
                };
                /**
                 * Parse and validate HTML from file.
                 *
                 * @public
                 * @param filename - Filename to read and parse.
                 * @returns Report output.
                 */
                HtmlValidate.prototype.validateFile = function (filename) {
                    return __awaiter(this, void 0, void 0, function () {
                        var config, source, engine;
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0: return [4 /*yield*/, this.getConfigFor(filename)];
                                case 1:
                                    config = _1.sent();
                                    source = config.transformFilename(filename);
                                    engine = new Engine(config, Parser);
                                    return [2 /*return*/, Promise.resolve(engine.lint(source))];
                            }
                        });
                    });
                };
                /**
                 * Parse and validate HTML from file.
                 *
                 * @public
                 * @param filename - Filename to read and parse.
                 * @returns Report output.
                 */
                HtmlValidate.prototype.validateFileSync = function (filename) {
                    var config = this.getConfigForSync(filename);
                    var source = config.transformFilename(filename);
                    var engine = new Engine(config, Parser);
                    return engine.lint(source);
                };
                /**
                 * Parse and validate HTML from multiple files. Result is merged together to a
                 * single report.
                 *
                 * @param filenames - Filenames to read and parse.
                 * @returns Report output.
                 */
                HtmlValidate.prototype.validateMultipleFiles = function (filenames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var report;
                        var _this_1 = this;
                        return __generator(this, function (_1) {
                            report = Reporter.merge(filenames.map(function (filename) { return _this_1.validateFileSync(filename); }));
                            return [2 /*return*/, Promise.resolve(report)];
                        });
                    });
                };
                /**
                 * Parse and validate HTML from multiple files. Result is merged together to a
                 * single report.
                 *
                 * @param filenames - Filenames to read and parse.
                 * @returns Report output.
                 */
                HtmlValidate.prototype.validateMultipleFilesSync = function (filenames) {
                    var _this_1 = this;
                    return Reporter.merge(filenames.map(function (filename) { return _this_1.validateFileSync(filename); }));
                };
                /**
                 * Returns true if the given filename can be validated.
                 *
                 * A file is considered to be validatable if the extension is `.html` or if a
                 * transformer matches the filename.
                 *
                 * This is mostly useful for tooling to determine whenever to validate the
                 * file or not. CLI tools will run on all the given files anyway.
                 */
                HtmlValidate.prototype.canValidate = function (filename) {
                    return __awaiter(this, void 0, void 0, function () {
                        var config;
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0:
                                    /* .html is always supported */
                                    if (filename.toLowerCase().endsWith(".html")) {
                                        return [2 /*return*/, true];
                                    }
                                    return [4 /*yield*/, this.getConfigFor(filename)];
                                case 1:
                                    config = _1.sent();
                                    return [2 /*return*/, config.canTransform(filename)];
                            }
                        });
                    });
                };
                /**
                 * Returns true if the given filename can be validated.
                 *
                 * A file is considered to be validatable if the extension is `.html` or if a
                 * transformer matches the filename.
                 *
                 * This is mostly useful for tooling to determine whenever to validate the
                 * file or not. CLI tools will run on all the given files anyway.
                 */
                HtmlValidate.prototype.canValidateSync = function (filename) {
                    /* .html is always supported */
                    if (filename.toLowerCase().endsWith(".html")) {
                        return true;
                    }
                    /* test if there is a matching transformer */
                    var config = this.getConfigForSync(filename);
                    return config.canTransform(filename);
                };
                /**
                 * Tokenize filename and output all tokens.
                 *
                 * Using CLI this is enabled with `--dump-tokens`. Mostly useful for
                 * debugging.
                 *
                 * @internal
                 * @param filename - Filename to tokenize.
                 */
                HtmlValidate.prototype.dumpTokens = function (filename) {
                    var config = this.getConfigForSync(filename);
                    var source = config.transformFilename(filename);
                    var engine = new Engine(config, Parser);
                    return engine.dumpTokens(source);
                };
                /**
                 * Parse filename and output all events.
                 *
                 * Using CLI this is enabled with `--dump-events`. Mostly useful for
                 * debugging.
                 *
                 * @internal
                 * @param filename - Filename to dump events from.
                 */
                HtmlValidate.prototype.dumpEvents = function (filename) {
                    var config = this.getConfigForSync(filename);
                    var source = config.transformFilename(filename);
                    var engine = new Engine(config, Parser);
                    return engine.dumpEvents(source);
                };
                /**
                 * Parse filename and output DOM tree.
                 *
                 * Using CLI this is enabled with `--dump-tree`. Mostly useful for
                 * debugging.
                 *
                 * @internal
                 * @param filename - Filename to dump DOM tree from.
                 */
                HtmlValidate.prototype.dumpTree = function (filename) {
                    var config = this.getConfigForSync(filename);
                    var source = config.transformFilename(filename);
                    var engine = new Engine(config, Parser);
                    return engine.dumpTree(source);
                };
                /**
                 * Transform filename and output source data.
                 *
                 * Using CLI this is enabled with `--dump-source`. Mostly useful for
                 * debugging.
                 *
                 * @internal
                 * @param filename - Filename to dump source from.
                 */
                HtmlValidate.prototype.dumpSource = function (filename) {
                    var config = this.getConfigForSync(filename);
                    var sources = config.transformFilename(filename);
                    return sources.reduce(function (result, source) {
                        result.push("Source ".concat(source.filename, "@").concat(source.line, ":").concat(source.column, " (offset: ").concat(source.offset, ")"));
                        if (source.transformedBy) {
                            result.push("Transformed by:");
                            result = result.concat(source.transformedBy.reverse().map(function (name) { return " - ".concat(name); }));
                        }
                        if (source.hooks && Object.keys(source.hooks).length > 0) {
                            result.push("Hooks");
                            for (var _1 = 0, _2 = Object.entries(source.hooks); _1 < _2.length; _1++) {
                                var _3 = _2[_1], key = _3[0], present = _3[1];
                                if (present) {
                                    result.push(" - ".concat(key));
                                }
                            }
                        }
                        result.push("---");
                        result = result.concat(source.data.split("\n"));
                        result.push("---");
                        return result;
                    }, []);
                };
                /**
                 * Get effective configuration schema.
                 */
                HtmlValidate.prototype.getConfigurationSchema = function () {
                    return configurationSchema;
                };
                /**
                 * Get effective metadata element schema.
                 *
                 * If a filename is given the configured plugins can extend the
                 * schema. Filename must not be an existing file or a filetype normally
                 * handled by html-validate but the path will be used when resolving
                 * configuration. As a rule-of-thumb, set it to the elements json file.
                 */
                HtmlValidate.prototype.getElementsSchema = function (filename) {
                    return __awaiter(this, void 0, void 0, function () {
                        var config, metaTable;
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0: return [4 /*yield*/, this.getConfigFor(filename !== null && filename !== void 0 ? filename : "inline")];
                                case 1:
                                    config = _1.sent();
                                    metaTable = config.getMetaTable();
                                    return [2 /*return*/, metaTable.getJSONSchema()];
                            }
                        });
                    });
                };
                /**
                 * Get effective metadata element schema.
                 *
                 * If a filename is given the configured plugins can extend the
                 * schema. Filename must not be an existing file or a filetype normally
                 * handled by html-validate but the path will be used when resolving
                 * configuration. As a rule-of-thumb, set it to the elements json file.
                 */
                HtmlValidate.prototype.getElementsSchemaSync = function (filename) {
                    var config = this.getConfigForSync(filename !== null && filename !== void 0 ? filename : "inline");
                    var metaTable = config.getMetaTable();
                    return metaTable.getJSONSchema();
                };
                HtmlValidate.prototype.getContextualDocumentation = function (message, filenameOrConfig) {
                    if (filenameOrConfig === void 0) { filenameOrConfig = "inline"; }
                    return __awaiter(this, void 0, void 0, function () {
                        var config, _1, engine;
                        return __generator(this, function (_2) {
                            switch (_2.label) {
                                case 0:
                                    if (!(typeof filenameOrConfig === "string")) return [3 /*break*/, 2];
                                    return [4 /*yield*/, this.getConfigFor(filenameOrConfig)];
                                case 1:
                                    _1 = _2.sent();
                                    return [3 /*break*/, 4];
                                case 2: return [4 /*yield*/, filenameOrConfig];
                                case 3:
                                    _1 = _2.sent();
                                    _2.label = 4;
                                case 4:
                                    config = _1;
                                    engine = new Engine(config, Parser);
                                    return [2 /*return*/, engine.getRuleDocumentation(message)];
                            }
                        });
                    });
                };
                HtmlValidate.prototype.getContextualDocumentationSync = function (message, filenameOrConfig) {
                    if (filenameOrConfig === void 0) { filenameOrConfig = "inline"; }
                    var config = typeof filenameOrConfig === "string"
                        ? this.getConfigForSync(filenameOrConfig)
                        : filenameOrConfig;
                    var engine = new Engine(config, Parser);
                    return engine.getRuleDocumentation(message);
                };
                /**
                 * Get contextual documentation for the given rule.
                 *
                 * Typical usage:
                 *
                 * ```js
                 * const report = await htmlvalidate.validateFile("my-file.html");
                 * for (const result of report.results){
                 *   const config = await htmlvalidate.getConfigFor(result.filePath);
                 *   for (const message of result.messages){
                 *     const documentation = await htmlvalidate.getRuleDocumentation(message.ruleId, config, message.context);
                 *     // do something with documentation
                 *   }
                 * }
                 * ```
                 *
                 * @public
                 * @deprecated Deprecated since 8.0.0, use [[getContextualDocumentation]] instead.
                 * @param ruleId - Rule to get documentation for.
                 * @param config - If set it provides more accurate description by using the
                 * correct configuration for the file.
                 * @param context - If set to `Message.context` some rules can provide
                 * contextual details and suggestions.
                 */
                HtmlValidate.prototype.getRuleDocumentation = function (ruleId, config, context) {
                    if (config === void 0) { config = null; }
                    if (context === void 0) { context = null; }
                    return __awaiter(this, void 0, void 0, function () {
                        var c, engine, _1;
                        return __generator(this, function (_2) {
                            switch (_2.label) {
                                case 0:
                                    c = config !== null && config !== void 0 ? config : this.getConfigFor("inline");
                                    _1 = Engine.bind;
                                    return [4 /*yield*/, c];
                                case 1:
                                    engine = new (_1.apply(Engine, [void 0, _2.sent(), Parser]))();
                                    return [2 /*return*/, engine.getRuleDocumentation({ ruleId: ruleId, context: context })];
                            }
                        });
                    });
                };
                /**
                 * Get contextual documentation for the given rule.
                 *
                 * Typical usage:
                 *
                 * ```js
                 * const report = htmlvalidate.validateFileSync("my-file.html");
                 * for (const result of report.results){
                 *   const config = htmlvalidate.getConfigForSync(result.filePath);
                 *   for (const message of result.messages){
                 *     const documentation = htmlvalidate.getRuleDocumentationSync(message.ruleId, config, message.context);
                 *     // do something with documentation
                 *   }
                 * }
                 * ```
                 *
                 * @public
                 * @deprecated Deprecated since 8.0.0, use [[getContextualDocumentationSync]] instead.
                 * @param ruleId - Rule to get documentation for.
                 * @param config - If set it provides more accurate description by using the
                 * correct configuration for the file.
                 * @param context - If set to `Message.context` some rules can provide
                 * contextual details and suggestions.
                 */
                HtmlValidate.prototype.getRuleDocumentationSync = function (ruleId, config, context) {
                    if (config === void 0) { config = null; }
                    if (context === void 0) { context = null; }
                    var c = config !== null && config !== void 0 ? config : this.getConfigForSync("inline");
                    var engine = new Engine(c, Parser);
                    return engine.getRuleDocumentation({ ruleId: ruleId, context: context });
                };
                /**
                 * Create a parser configured for given filename.
                 *
                 * @internal
                 * @param source - Source to use.
                 */
                HtmlValidate.prototype.getParserFor = function (source) {
                    return __awaiter(this, void 0, void 0, function () {
                        var config;
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0: return [4 /*yield*/, this.getConfigFor(source.filename)];
                                case 1:
                                    config = _1.sent();
                                    return [2 /*return*/, new Parser(config)];
                            }
                        });
                    });
                };
                /**
                 * Get configuration for given filename.
                 *
                 * See [[FileSystemConfigLoader]] for details.
                 *
                 * @public
                 * @param filename - Filename to get configuration for.
                 * @param configOverride - Configuration to apply last.
                 */
                HtmlValidate.prototype.getConfigFor = function (filename, configOverride) {
                    var config = this.configLoader.getConfigFor(filename, configOverride);
                    return Promise.resolve(config);
                };
                /**
                 * Get configuration for given filename.
                 *
                 * See [[FileSystemConfigLoader]] for details.
                 *
                 * @public
                 * @param filename - Filename to get configuration for.
                 * @param configOverride - Configuration to apply last.
                 */
                HtmlValidate.prototype.getConfigForSync = function (filename, configOverride) {
                    return this.configLoader.getConfigFor(filename, configOverride);
                };
                /**
                 * Flush configuration cache. Clears full cache unless a filename is given.
                 *
                 * See [[FileSystemConfigLoader]] for details.
                 *
                 * @public
                 * @param filename - If set, only flush cache for given filename.
                 */
                HtmlValidate.prototype.flushConfigCache = function (filename) {
                    this.configLoader.flushCache(filename);
                };
                return HtmlValidate;
            }());
            /* generated file, changes will be overwritten */
            /** @public */
            var name = "html-validate";
            /** @public */
            var version = "8.4.1";
            /** @public */
            var bugs = "https://gitlab.com/html-validate/html-validate/issues/new";
            /**
             * Helper function to assist IDE with completion and type-checking.
             *
             * @public
             */
            function definePlugin(plugin) {
                return plugin;
            }
            var ruleIds = new Set(Object.keys(rules));
            /**
             * Returns true if given ruleId is an existing builtin rule. It does not handle
             * rules loaded via plugins.
             *
             * Can be used to create forward/backward compatibility by checking if a rule
             * exists to enable/disable it.
             *
             * @public
             * @param ruleId - Rule id to check
             * @returns `true` if rule exists
             */
            function ruleExists(ruleId) {
                return ruleIds.has(ruleId);
            }
            var entities = {
                ">": "&gt;",
                "<": "&lt;",
                "'": "&apos;",
                '"': "&quot;",
                "&": "&amp;"
            };
            function xmlescape(src) {
                return src.toString().replace(/[><'"&]/g, function (match) {
                    return entities[match];
                });
            }
            function getMessageType(message) {
                switch (message.severity) {
                    case 2:
                        return "error";
                    case 1:
                        return "warning";
                    default:
                        return "error";
                }
            }
            function checkstyleFormatter(results) {
                var output = "";
                output += "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n";
                output += "<checkstyle version=\"4.3\">\n";
                results.forEach(function (result) {
                    var messages = result.messages;
                    output += "  <file name=\"".concat(xmlescape(result.filePath), "\">\n");
                    messages.forEach(function (message) {
                        var ruleId = xmlescape("htmlvalidate.rules.".concat(message.ruleId));
                        output += "    ";
                        output += [
                            "<error line=\"".concat(xmlescape(message.line), "\""),
                            "column=\"".concat(xmlescape(message.column), "\""),
                            "severity=\"".concat(xmlescape(getMessageType(message)), "\""),
                            "message=\"".concat(xmlescape(message.message), " (").concat(message.ruleId, ")\""),
                            "source=\"".concat(ruleId, "\" />"),
                        ].join(" ");
                        output += "\n";
                    });
                    output += "  </file>\n";
                });
                output += "</checkstyle>\n";
                return output;
            }
            var formatter$3 = checkstyleFormatter;
            var checkstyle = formatter$3;
            var defaults = {
                showLink: true,
                showSummary: true,
                showSelector: false
            };
            /**
             * Codeframe formatter based on ESLint codeframe.
             */
            /**
             * Given a word and a count, append an s if count is not one.
             * @param word - A word in its singular form.
             * @param count - A number controlling whether word should be pluralized.
             * @returns The original word with an s on the end if count is not one.
             */
            function pluralize(word, count) {
                return count === 1 ? word : "".concat(word, "s");
            }
            /**
             * Gets a formatted relative file path from an absolute path and a line/column in the file.
             * @param filePath - The absolute file path to format.
             * @param line - The line from the file to use for formatting.
             * @param column -The column from the file to use for formatting.
             * @returns The formatted file path.
             */
            function formatFilePath(filePath, line, column) {
                /* istanbul ignore next: safety check from original implementation */
                if (line && column) {
                    filePath += ":".concat(line, ":").concat(column);
                }
                return kleur__default["default"].green(filePath);
            }
            function getStartLocation(message) {
                return {
                    line: message.line,
                    column: message.column
                };
            }
            function getEndLocation(message, source) {
                var line = message.line;
                var column = message.column;
                for (var i = 0; i < message.size; i++) {
                    if (source.charAt(message.offset + i) === "\n") {
                        line++;
                        column = 0;
                    }
                    else {
                        column++;
                    }
                }
                return { line: line, column: column };
            }
            /**
             * Gets the formatted output for a given message.
             * @param message - The object that represents this message.
             * @param parentResult - The result object that this message belongs to.
             * @returns The formatted output.
             */
            function formatMessage(message, parentResult, options) {
                var _a;
                var type = message.severity === 2 ? kleur__default["default"].red("error") : kleur__default["default"].yellow("warning");
                var msg = "".concat(kleur__default["default"].bold(message.message.replace(/([^ ])\.$/, "$1")));
                var ruleId = kleur__default["default"].dim("(".concat(message.ruleId, ")"));
                var filePath = formatFilePath(parentResult.filePath, message.line, message.column);
                var sourceCode = parentResult.source;
                /* istanbul ignore next: safety check from original implementation */
                var firstLine = [
                    "".concat(type, ":"),
                    "".concat(msg),
                    ruleId ? "".concat(ruleId) : "",
                    sourceCode ? "at ".concat(filePath, ":") : "at ".concat(filePath),
                ]
                    .filter(String)
                    .join(" ");
                var result = [firstLine];
                /* istanbul ignore next: safety check from original implementation */
                if (sourceCode) {
                    result.push(codeFrame.codeFrameColumns(sourceCode, {
                        start: getStartLocation(message),
                        end: getEndLocation(message, sourceCode)
                    }, { highlightCode: false }));
                }
                if (options.showSelector) {
                    result.push("".concat(kleur__default["default"].bold("Selector:"), " ").concat((_a = message.selector) !== null && _a !== void 0 ? _a : "-"));
                }
                if (options.showLink && message.ruleUrl) {
                    result.push("".concat(kleur__default["default"].bold("Details:"), " ").concat(message.ruleUrl));
                }
                return result.join("\n");
            }
            /**
             * Gets the formatted output summary for a given number of errors and warnings.
             * @param errors - The number of errors.
             * @param warnings - The number of warnings.
             * @returns The formatted output summary.
             */
            function formatSummary(errors, warnings) {
                var summaryColor = errors > 0 ? "red" : "yellow";
                var summary = [];
                if (errors > 0) {
                    summary.push("".concat(errors, " ").concat(pluralize("error", errors)));
                }
                if (warnings > 0) {
                    summary.push("".concat(warnings, " ").concat(pluralize("warning", warnings)));
                }
                return kleur__default["default"][summaryColor]().bold("".concat(summary.join(" and "), " found."));
            }
            function codeframe(results, options) {
                var merged = __assign(__assign({}, defaults), options);
                var errors = 0;
                var warnings = 0;
                var resultsWithMessages = results.filter(function (result) { return result.messages.length > 0; });
                var output = resultsWithMessages
                    .reduce(function (resultsOutput, result) {
                    var messages = result.messages.map(function (message) {
                        return "".concat(formatMessage(message, result, merged), "\n\n");
                    });
                    errors += result.errorCount;
                    warnings += result.warningCount;
                    return resultsOutput.concat(messages);
                }, [])
                    .join("\n");
                if (merged.showSummary) {
                    output += "\n";
                    output += formatSummary(errors, warnings);
                    output += "\n";
                }
                return errors + warnings > 0 ? output : "";
            }
            function jsonFormatter(results) {
                return JSON.stringify(results);
            }
            var formatter$2 = jsonFormatter;
            var json = formatter$2;
            function linkSummary(results) {
                var urls = results.reduce(function (result, it) {
                    var urls = it.messages
                        .map(function (error) { return error.ruleUrl; })
                        .filter(function (error) { return Boolean(error); });
                    return __spreadArray(__spreadArray([], result, true), urls, true);
                }, []);
                var unique = Array.from(new Set(urls));
                if (unique.length === 0) {
                    return "";
                }
                var lines = unique.map(function (url) { return "  ".concat(url, "\n"); });
                return "\n".concat(kleur__default["default"].bold("More information"), ":\n").concat(lines.join(""), "\n");
            }
            function stylish(results) {
                var errors = stylish$2.stylish(results.map(function (it) { return (__assign(__assign({}, it), { fixableErrorCount: 0, fixableWarningCount: 0 })); }));
                var links = linkSummary(results);
                return "".concat(errors).concat(links);
            }
            var formatter$1 = stylish;
            var stylish$1 = formatter$1;
            function textFormatter(results) {
                var output = "";
                var total = 0;
                results.forEach(function (result) {
                    var messages = result.messages;
                    if (messages.length === 0) {
                        return;
                    }
                    total += messages.length;
                    output += messages
                        .map(function (message) {
                        var messageType;
                        if (message.severity === 2) {
                            messageType = "error";
                        }
                        else {
                            messageType = "warning";
                        }
                        var location = "".concat(result.filePath, ":").concat(message.line, ":").concat(message.column);
                        return "".concat(location, ": ").concat(messageType, " [").concat(message.ruleId, "] ").concat(message.message, "\n");
                    })
                        .join("");
                });
                return total > 0 ? output : "";
            }
            var formatter = textFormatter;
            var text = formatter;
            var availableFormatters = {
                checkstyle: checkstyle,
                codeframe: codeframe,
                json: json,
                stylish: stylish$1,
                text: text
            };
            function getFormatter(name) {
                var _a;
                return (_a = availableFormatters[name]) !== null && _a !== void 0 ? _a : null;
            }
            /**
             * @internal
             */
            function compatibilityCheckImpl(name, declared, options) {
                var silent = options.silent, current = options.version, logger = options.logger;
                var valid = semver__default["default"].satisfies(current, declared);
                if (valid || silent) {
                    return valid;
                }
                var text = [
                    "-----------------------------------------------------------------------------------------------------",
                    "".concat(name, " requires html-validate version \"").concat(declared, "\" but current installed version is ").concat(current),
                    "This is not a supported configuration. Please install a supported version before reporting bugs.",
                    "-----------------------------------------------------------------------------------------------------",
                ].join("\n");
                logger(text);
                return false;
            }
            exports.Attribute = Attribute;
            exports.Config = Config;
            exports.ConfigError = ConfigError;
            exports.ConfigLoader = ConfigLoader;
            exports.DOMNode = DOMNode;
            exports.DOMTokenList = DOMTokenList;
            exports.DOMTree = DOMTree;
            exports.DynamicValue = DynamicValue;
            exports.EventHandler = EventHandler;
            exports.HtmlElement = HtmlElement;
            exports.HtmlValidate = HtmlValidate;
            exports.MetaCopyableProperty = MetaCopyableProperty;
            exports.MetaTable = MetaTable;
            exports.NestedError = NestedError;
            exports.Parser = Parser;
            exports.Presets = Presets;
            exports.Reporter = Reporter;
            exports.ResolvedConfig = ResolvedConfig;
            exports.Rule = Rule;
            exports.SchemaValidationError = SchemaValidationError;
            exports.StaticConfigLoader = StaticConfigLoader;
            exports.TextNode = TextNode;
            exports.UserError = UserError;
            exports.Validator = Validator;
            exports.WrappedError = WrappedError;
            exports.bugs = bugs;
            exports.classifyNodeText = classifyNodeText;
            exports.codeframe = codeframe;
            exports.compatibilityCheckImpl = compatibilityCheckImpl;
            exports.definePlugin = definePlugin;
            exports.ensureError = ensureError;
            exports.getFormatter = getFormatter;
            exports.keywordPatternMatcher = keywordPatternMatcher;
            exports.name = name;
            exports.ruleExists = ruleExists;
            exports.sliceLocation = sliceLocation;
            exports.staticResolver = staticResolver;
            exports.version = version;
            //# sourceMappingURL=core.js.map
            /***/ 
        }),
        /***/ 6420: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var metaHelper = __nccwpck_require__(9800);
            /* eslint-disable sonarjs/no-duplicate-string -- easier to read without constants */
            var _1 = metaHelper.metadataHelper, allowedIfAttributeIsPresent = _1.allowedIfAttributeIsPresent, allowedIfAttributeIsAbsent = _1.allowedIfAttributeIsAbsent, allowedIfAttributeHasValue = _1.allowedIfAttributeHasValue, allowedIfParentIsPresent = _1.allowedIfParentIsPresent;
            var validId = "/\\S+/";
            var html5 = metaHelper.defineMetadata({
                "*": {
                    attributes: {
                        contenteditable: {
                            omit: true,
                            "enum": ["true", "false"]
                        },
                        contextmenu: {
                            deprecated: true
                        },
                        dir: {
                            "enum": ["ltr", "rtl", "auto"]
                        },
                        draggable: {
                            "enum": ["true", "false"]
                        },
                        hidden: {
                            boolean: true
                        },
                        id: {
                            "enum": [validId]
                        },
                        tabindex: {
                            "enum": ["/-?\\d+/"]
                        }
                    }
                },
                a: {
                    flow: true,
                    phrasing: true,
                    interactive: true,
                    transparent: true,
                    attributes: {
                        charset: {
                            deprecated: true
                        },
                        coords: {
                            deprecated: true
                        },
                        datafld: {
                            deprecated: true
                        },
                        datasrc: {
                            deprecated: true
                        },
                        download: {
                            allowed: allowedIfAttributeIsPresent("href"),
                            omit: true,
                            "enum": ["/.+/"]
                        },
                        href: {
                            "enum": ["/.*/"]
                        },
                        hreflang: {
                            allowed: allowedIfAttributeIsPresent("href")
                        },
                        itemprop: {
                            allowed: allowedIfAttributeIsPresent("href")
                        },
                        methods: {
                            deprecated: true
                        },
                        name: {
                            deprecated: true
                        },
                        ping: {
                            allowed: allowedIfAttributeIsPresent("href")
                        },
                        referrerpolicy: {
                            allowed: allowedIfAttributeIsPresent("href")
                        },
                        rel: {
                            allowed: allowedIfAttributeIsPresent("href")
                        },
                        shape: {
                            deprecated: true
                        },
                        target: {
                            allowed: allowedIfAttributeIsPresent("href"),
                            "enum": ["/[^_].*/", "_blank", "_self", "_parent", "_top"]
                        },
                        type: {
                            allowed: allowedIfAttributeIsPresent("href")
                        },
                        urn: {
                            deprecated: true
                        }
                    },
                    permittedDescendants: [{ exclude: "@interactive" }],
                    implicitRole: function (node) {
                        return node.hasAttribute("href") ? "link" : null;
                    }
                },
                abbr: {
                    flow: true,
                    phrasing: true,
                    permittedContent: ["@phrasing"]
                },
                acronym: {
                    deprecated: {
                        message: "use <abbr> instead",
                        documentation: "`<abbr>` can be used as a replacement.",
                        source: "html5"
                    }
                },
                address: {
                    flow: true,
                    implicitRole: function () {
                        return "group";
                    },
                    permittedContent: ["@flow"],
                    permittedDescendants: [{ exclude: ["address", "header", "footer", "@heading", "@sectioning"] }]
                },
                applet: {
                    deprecated: {
                        source: "html5"
                    },
                    attributes: {
                        datafld: {
                            deprecated: true
                        },
                        datasrc: {
                            deprecated: true
                        }
                    }
                },
                area: {
                    flow: ["isDescendant", "map"],
                    phrasing: ["isDescendant", "map"],
                    "void": true,
                    attributes: {
                        alt: {},
                        coords: {
                            allowed: function (node) {
                                var attr = node.getAttribute("shape");
                                if (attr === "default") {
                                    return "cannot be used when \"shape\" attribute is \"default\"";
                                }
                                else {
                                    return null;
                                }
                            }
                        },
                        download: {
                            allowed: allowedIfAttributeIsPresent("href")
                        },
                        nohref: {
                            deprecated: true
                        },
                        itemprop: {
                            allowed: allowedIfAttributeIsPresent("href")
                        },
                        ping: {
                            allowed: allowedIfAttributeIsPresent("href")
                        },
                        referrerpolicy: {
                            allowed: allowedIfAttributeIsPresent("href")
                        },
                        rel: {
                            allowed: allowedIfAttributeIsPresent("href")
                        },
                        shape: {
                            allowed: function (node, attr) {
                                var shape = attr !== null && attr !== void 0 ? attr : "rect";
                                switch (shape) {
                                    case "circ":
                                    case "circle":
                                    case "poly":
                                    case "polygon":
                                    case "rect":
                                    case "rectangle":
                                        return allowedIfAttributeIsPresent("coords")(node, attr);
                                    default:
                                        return null;
                                }
                            },
                            "enum": ["rect", "circle", "poly", "default"]
                        },
                        target: {
                            allowed: allowedIfAttributeIsPresent("href"),
                            "enum": ["/[^_].*/", "_blank", "_self", "_parent", "_top"]
                        }
                    },
                    implicitRole: function (node) {
                        return node.hasAttribute("href") ? "link" : null;
                    },
                    requiredAncestors: ["map"]
                },
                article: {
                    flow: true,
                    sectioning: true,
                    permittedContent: ["@flow"],
                    permittedDescendants: [{ exclude: ["main"] }],
                    implicitRole: function () {
                        return "article";
                    }
                },
                aside: {
                    flow: true,
                    sectioning: true,
                    permittedContent: ["@flow"],
                    permittedDescendants: [{ exclude: ["main"] }],
                    implicitRole: function () {
                        return "complementary";
                    }
                },
                audio: {
                    flow: true,
                    phrasing: true,
                    embedded: true,
                    interactive: ["hasAttribute", "controls"],
                    transparent: ["@flow"],
                    attributes: {
                        crossorigin: {
                            omit: true,
                            "enum": ["anonymous", "use-credentials"]
                        },
                        itemprop: {
                            allowed: allowedIfAttributeIsPresent("src")
                        },
                        preload: {
                            omit: true,
                            "enum": ["none", "metadata", "auto"]
                        }
                    },
                    permittedContent: ["@flow", "track", "source"],
                    permittedDescendants: [{ exclude: ["audio", "video"] }],
                    permittedOrder: ["source", "track", "@flow"]
                },
                b: {
                    flow: true,
                    phrasing: true,
                    permittedContent: ["@phrasing"]
                },
                base: {
                    metadata: true,
                    "void": true,
                    permittedParent: ["head"]
                },
                basefont: {
                    deprecated: {
                        message: "use CSS instead",
                        documentation: "Use CSS `font-size` property instead.",
                        source: "html4"
                    }
                },
                bdi: {
                    flow: true,
                    phrasing: true,
                    permittedContent: ["@phrasing"]
                },
                bdo: {
                    flow: true,
                    phrasing: true,
                    permittedContent: ["@phrasing"]
                },
                bgsound: {
                    deprecated: {
                        message: "use <audio> instead",
                        documentation: "Use the `<audio>` element instead but consider accessibility concerns with autoplaying sounds.",
                        source: "non-standard"
                    }
                },
                big: {
                    deprecated: {
                        message: "use CSS instead",
                        documentation: "Use CSS `font-size` property instead.",
                        source: "html5"
                    }
                },
                blink: {
                    deprecated: {
                        documentation: "`<blink>` has no direct replacement and blinking text is frowned upon by accessibility standards.",
                        source: "non-standard"
                    }
                },
                blockquote: {
                    flow: true,
                    sectioning: true,
                    implicitRole: function () {
                        return "blockquote";
                    },
                    permittedContent: ["@flow"]
                },
                body: {
                    permittedContent: ["@flow"],
                    permittedParent: ["html"],
                    attributes: {
                        alink: {
                            deprecated: true
                        },
                        background: {
                            deprecated: true
                        },
                        bgcolor: {
                            deprecated: true
                        },
                        link: {
                            deprecated: true
                        },
                        marginbottom: {
                            deprecated: true
                        },
                        marginheight: {
                            deprecated: true
                        },
                        marginleft: {
                            deprecated: true
                        },
                        marginright: {
                            deprecated: true
                        },
                        margintop: {
                            deprecated: true
                        },
                        marginwidth: {
                            deprecated: true
                        },
                        text: {
                            deprecated: true
                        },
                        vlink: {
                            deprecated: true
                        }
                    }
                },
                br: {
                    flow: true,
                    phrasing: true,
                    "void": true,
                    attributes: {
                        clear: {
                            deprecated: true
                        }
                    }
                },
                button: {
                    flow: true,
                    phrasing: true,
                    interactive: true,
                    formAssociated: {
                        listed: true
                    },
                    labelable: true,
                    attributes: {
                        autofocus: {
                            boolean: true
                        },
                        datafld: {
                            deprecated: true
                        },
                        dataformatas: {
                            deprecated: true
                        },
                        datasrc: {
                            deprecated: true
                        },
                        disabled: {
                            boolean: true
                        },
                        formaction: {
                            allowed: allowedIfAttributeHasValue("type", ["submit"], { defaultValue: "submit" })
                        },
                        formenctype: {
                            allowed: allowedIfAttributeHasValue("type", ["submit"], { defaultValue: "submit" })
                        },
                        formmethod: {
                            allowed: allowedIfAttributeHasValue("type", ["submit"], { defaultValue: "submit" }),
                            "enum": ["get", "post", "dialog"]
                        },
                        formnovalidate: {
                            allowed: allowedIfAttributeHasValue("type", ["submit"], { defaultValue: "submit" }),
                            boolean: true
                        },
                        formtarget: {
                            allowed: allowedIfAttributeHasValue("type", ["submit"], { defaultValue: "submit" }),
                            "enum": ["/[^_].*/", "_blank", "_self", "_parent", "_top"]
                        },
                        type: {
                            "enum": ["submit", "reset", "button"]
                        }
                    },
                    implicitRole: function () {
                        return "button";
                    },
                    permittedContent: ["@phrasing"],
                    permittedDescendants: [{ exclude: ["@interactive"] }],
                    textContent: "accessible"
                },
                canvas: {
                    flow: true,
                    phrasing: true,
                    embedded: true,
                    transparent: true
                },
                caption: {
                    permittedContent: ["@flow"],
                    permittedDescendants: [{ exclude: ["table"] }],
                    attributes: {
                        align: {
                            deprecated: true
                        }
                    }
                },
                center: {
                    deprecated: {
                        message: "use CSS instead",
                        documentation: "Use the CSS `text-align` or `margin: auto` properties instead.",
                        source: "html4"
                    }
                },
                cite: {
                    flow: true,
                    phrasing: true,
                    permittedContent: ["@phrasing"]
                },
                code: {
                    flow: true,
                    phrasing: true,
                    permittedContent: ["@phrasing"]
                },
                col: {
                    attributes: {
                        align: {
                            deprecated: true
                        },
                        char: {
                            deprecated: true
                        },
                        charoff: {
                            deprecated: true
                        },
                        span: {
                            "enum": ["/\\d+/"]
                        },
                        valign: {
                            deprecated: true
                        },
                        width: {
                            deprecated: true
                        }
                    },
                    "void": true
                },
                colgroup: {
                    implicitClosed: ["colgroup"],
                    attributes: {
                        span: {
                            "enum": ["/\\d+/"]
                        }
                    },
                    permittedContent: ["col", "template"]
                },
                data: {
                    flow: true,
                    phrasing: true,
                    permittedContent: ["@phrasing"]
                },
                datalist: {
                    flow: true,
                    phrasing: true,
                    implicitRole: function () {
                        return "listbox";
                    },
                    permittedContent: ["@phrasing", "option"]
                },
                dd: {
                    implicitClosed: ["dd", "dt"],
                    permittedContent: ["@flow"],
                    requiredAncestors: ["dl > dd", "dl > div > dd"]
                },
                del: {
                    flow: true,
                    phrasing: true,
                    transparent: true
                },
                details: {
                    flow: true,
                    sectioning: true,
                    interactive: true,
                    attributes: {
                        open: {
                            boolean: true
                        }
                    },
                    implicitRole: function () {
                        return "group";
                    },
                    permittedContent: ["summary", "@flow"],
                    permittedOrder: ["summary", "@flow"],
                    requiredContent: ["summary"]
                },
                dfn: {
                    flow: true,
                    phrasing: true,
                    implicitRole: function () {
                        return "term";
                    },
                    permittedContent: ["@phrasing"],
                    permittedDescendants: [{ exclude: ["dfn"] }]
                },
                dialog: {
                    flow: true,
                    permittedContent: ["@flow"],
                    attributes: {
                        open: {
                            boolean: true
                        }
                    },
                    implicitRole: function () {
                        return "dialog";
                    }
                },
                dir: {
                    deprecated: {
                        documentation: "The non-standard `<dir>` element has no direct replacement but MDN recommends replacing with `<ul>` and CSS.",
                        source: "html4"
                    }
                },
                div: {
                    flow: true,
                    permittedContent: ["@flow", "dt", "dd"],
                    attributes: {
                        align: {
                            deprecated: true
                        },
                        datafld: {
                            deprecated: true
                        },
                        dataformatas: {
                            deprecated: true
                        },
                        datasrc: {
                            deprecated: true
                        }
                    }
                },
                dl: {
                    flow: true,
                    permittedContent: ["@script", "dt", "dd", "div"],
                    attributes: {
                        compact: {
                            deprecated: true
                        }
                    }
                },
                dt: {
                    implicitClosed: ["dd", "dt"],
                    permittedContent: ["@flow"],
                    permittedDescendants: [{ exclude: ["header", "footer", "@sectioning", "@heading"] }],
                    requiredAncestors: ["dl > dt", "dl > div > dt"]
                },
                em: {
                    flow: true,
                    phrasing: true,
                    permittedContent: ["@phrasing"]
                },
                embed: {
                    flow: true,
                    phrasing: true,
                    embedded: true,
                    interactive: true,
                    "void": true,
                    attributes: {
                        src: {
                            required: true,
                            "enum": ["/.+/"]
                        },
                        title: {
                            required: true
                        }
                    }
                },
                fieldset: {
                    flow: true,
                    formAssociated: {
                        listed: true
                    },
                    attributes: {
                        datafld: {
                            deprecated: true
                        },
                        disabled: {
                            boolean: true
                        }
                    },
                    implicitRole: function () {
                        return "group";
                    },
                    permittedContent: ["@flow", "legend?"],
                    permittedOrder: ["legend", "@flow"]
                },
                figcaption: {
                    permittedContent: ["@flow"]
                },
                figure: {
                    flow: true,
                    implicitRole: function () {
                        return "figure";
                    },
                    permittedContent: ["@flow", "figcaption?"],
                    permittedOrder: ["figcaption", "@flow", "figcaption"]
                },
                font: {
                    deprecated: {
                        message: "use CSS instead",
                        documentation: "Use CSS font properties instead.",
                        source: "html4"
                    }
                },
                footer: {
                    flow: true,
                    implicitRole: function (node) {
                        var selectors = [
                            "article",
                            "aside",
                            "main",
                            "nav",
                            "section",
                            '[role="article"]',
                            '[role="complementary"]',
                            '[role="main"]',
                            '[role="navigation"]',
                            '[role="region"]',
                        ];
                        if (node.closest(selectors.join(","))) {
                            return null;
                        }
                        else {
                            return "contentinfo";
                        }
                    },
                    permittedContent: ["@flow"],
                    permittedDescendants: [{ exclude: ["header", "footer", "main"] }]
                },
                form: {
                    flow: true,
                    form: true,
                    attributes: {
                        action: {
                            "enum": [/^\s*\S+\s*$/]
                        },
                        accept: {
                            deprecated: true
                        },
                        autocomplete: {
                            "enum": ["on", "off"]
                        },
                        method: {
                            "enum": ["get", "post", "dialog"]
                        },
                        novalidate: {
                            boolean: true
                        },
                        target: {
                            "enum": ["/[^_].*/", "_blank", "_self", "_parent", "_top"]
                        }
                    },
                    implicitRole: function () {
                        return "form";
                    },
                    permittedContent: ["@flow"],
                    permittedDescendants: [{ exclude: ["@form"] }]
                },
                frame: {
                    deprecated: {
                        documentation: "The `<frame>` element can be replaced with the `<iframe>` element but a better solution is to remove usage of frames entirely.",
                        source: "html5"
                    },
                    attributes: {
                        datafld: {
                            deprecated: true
                        },
                        datasrc: {
                            deprecated: true
                        },
                        title: {
                            required: true
                        }
                    }
                },
                frameset: {
                    deprecated: {
                        documentation: "The `<frameset>` element can be replaced with the `<iframe>` element but a better solution is to remove usage of frames entirely.",
                        source: "html5"
                    }
                },
                h1: {
                    flow: true,
                    heading: true,
                    permittedContent: ["@phrasing"],
                    attributes: {
                        align: {
                            deprecated: true
                        }
                    },
                    implicitRole: function () {
                        return "heading";
                    }
                },
                h2: {
                    flow: true,
                    heading: true,
                    permittedContent: ["@phrasing"],
                    attributes: {
                        align: {
                            deprecated: true
                        }
                    },
                    implicitRole: function () {
                        return "heading";
                    }
                },
                h3: {
                    flow: true,
                    heading: true,
                    permittedContent: ["@phrasing"],
                    attributes: {
                        align: {
                            deprecated: true
                        }
                    },
                    implicitRole: function () {
                        return "heading";
                    }
                },
                h4: {
                    flow: true,
                    heading: true,
                    permittedContent: ["@phrasing"],
                    attributes: {
                        align: {
                            deprecated: true
                        }
                    },
                    implicitRole: function () {
                        return "heading";
                    }
                },
                h5: {
                    flow: true,
                    heading: true,
                    permittedContent: ["@phrasing"],
                    attributes: {
                        align: {
                            deprecated: true
                        }
                    },
                    implicitRole: function () {
                        return "heading";
                    }
                },
                h6: {
                    flow: true,
                    heading: true,
                    permittedContent: ["@phrasing"],
                    attributes: {
                        align: {
                            deprecated: true
                        }
                    },
                    implicitRole: function () {
                        return "heading";
                    }
                },
                head: {
                    permittedContent: ["base?", "title?", "@meta"],
                    permittedParent: ["html"],
                    requiredContent: ["title"],
                    attributes: {
                        profile: {
                            deprecated: true
                        }
                    }
                },
                header: {
                    flow: true,
                    implicitRole: function (node) {
                        var selectors = [
                            "article",
                            "aside",
                            "main",
                            "nav",
                            "section",
                            '[role="article"]',
                            '[role="complementary"]',
                            '[role="main"]',
                            '[role="navigation"]',
                            '[role="region"]',
                        ];
                        if (node.closest(selectors.join(","))) {
                            return null;
                        }
                        else {
                            return "banner";
                        }
                    },
                    permittedContent: ["@flow"],
                    permittedDescendants: [{ exclude: ["header", "footer", "main"] }]
                },
                hgroup: {
                    flow: true,
                    heading: true,
                    permittedContent: ["p", "@heading?"],
                    permittedDescendants: [{ exclude: ["hgroup"] }],
                    requiredContent: ["@heading"]
                },
                hr: {
                    flow: true,
                    "void": true,
                    attributes: {
                        align: {
                            deprecated: true
                        },
                        color: {
                            deprecated: true
                        },
                        noshade: {
                            deprecated: true
                        },
                        size: {
                            deprecated: true
                        },
                        width: {
                            deprecated: true
                        }
                    },
                    implicitRole: function () {
                        return "separator";
                    }
                },
                html: {
                    permittedContent: ["head?", "body?"],
                    permittedOrder: ["head", "body"],
                    requiredContent: ["head", "body"],
                    attributes: {
                        lang: {
                            required: true
                        },
                        version: {
                            deprecated: true
                        }
                    },
                    implicitRole: function () {
                        return "document";
                    }
                },
                i: {
                    flow: true,
                    phrasing: true,
                    permittedContent: ["@phrasing"]
                },
                iframe: {
                    flow: true,
                    phrasing: true,
                    embedded: true,
                    interactive: true,
                    attributes: {
                        align: {
                            deprecated: true
                        },
                        allowtransparency: {
                            deprecated: true
                        },
                        datafld: {
                            deprecated: true
                        },
                        datasrc: {
                            deprecated: true
                        },
                        frameborder: {
                            deprecated: true
                        },
                        hspace: {
                            deprecated: true
                        },
                        marginheight: {
                            deprecated: true
                        },
                        marginwidth: {
                            deprecated: true
                        },
                        scrolling: {
                            deprecated: true
                        },
                        src: {
                            "enum": ["/.+/"]
                        },
                        title: {
                            required: true
                        },
                        vspace: {
                            deprecated: true
                        }
                    },
                    permittedContent: []
                },
                img: {
                    flow: true,
                    phrasing: true,
                    embedded: true,
                    interactive: ["hasAttribute", "usemap"],
                    "void": true,
                    attributes: {
                        align: {
                            deprecated: true
                        },
                        border: {
                            deprecated: true
                        },
                        crossorigin: {
                            omit: true,
                            "enum": ["anonymous", "use-credentials"]
                        },
                        datafld: {
                            deprecated: true
                        },
                        datasrc: {
                            deprecated: true
                        },
                        decoding: {
                            "enum": ["sync", "async", "auto"]
                        },
                        hspace: {
                            deprecated: true
                        },
                        ismap: {
                            boolean: true
                        },
                        lowsrc: {
                            deprecated: true
                        },
                        name: {
                            deprecated: true
                        },
                        src: {
                            required: true,
                            "enum": ["/.+/"]
                        },
                        srcset: {
                            "enum": ["/[^]+/"]
                        },
                        vspace: {
                            deprecated: true
                        }
                    },
                    implicitRole: function (node) {
                        var alt = node.getAttribute("alt");
                        if (alt === "") {
                            return "presentation";
                        }
                        else {
                            return "img";
                        }
                    }
                },
                input: {
                    flow: true,
                    phrasing: true,
                    interactive: ["matchAttribute", ["type", "!=", "hidden"]],
                    "void": true,
                    formAssociated: {
                        listed: true
                    },
                    labelable: ["matchAttribute", ["type", "!=", "hidden"]],
                    attributes: {
                        align: {
                            deprecated: true
                        },
                        autofocus: {
                            boolean: true
                        },
                        capture: {
                            omit: true,
                            "enum": ["environment", "user"]
                        },
                        checked: {
                            boolean: true
                        },
                        datafld: {
                            deprecated: true
                        },
                        dataformatas: {
                            deprecated: true
                        },
                        datasrc: {
                            deprecated: true
                        },
                        disabled: {
                            boolean: true
                        },
                        formaction: {
                            allowed: allowedIfAttributeHasValue("type", ["submit", "image"], {
                                defaultValue: "submit"
                            })
                        },
                        formenctype: {
                            allowed: allowedIfAttributeHasValue("type", ["submit", "image"], {
                                defaultValue: "submit"
                            })
                        },
                        formmethod: {
                            allowed: allowedIfAttributeHasValue("type", ["submit", "image"], {
                                defaultValue: "submit"
                            }),
                            "enum": ["get", "post", "dialog"]
                        },
                        formnovalidate: {
                            allowed: allowedIfAttributeHasValue("type", ["submit", "image"], {
                                defaultValue: "submit"
                            }),
                            boolean: true
                        },
                        formtarget: {
                            allowed: allowedIfAttributeHasValue("type", ["submit", "image"], {
                                defaultValue: "submit"
                            }),
                            "enum": ["/[^_].*/", "_blank", "_self", "_parent", "_top"]
                        },
                        hspace: {
                            deprecated: true
                        },
                        inputmode: {
                            "enum": ["none", "text", "decimal", "numeric", "tel", "search", "email", "url"]
                        },
                        ismap: {
                            deprecated: true
                        },
                        multiple: {
                            boolean: true
                        },
                        readonly: {
                            boolean: true
                        },
                        required: {
                            boolean: true
                        },
                        spellcheck: {
                            "enum": ["default", "false", "true"]
                        },
                        type: {
                            required: true,
                            "enum": [
                                "button",
                                "checkbox",
                                "color",
                                "date",
                                "datetime-local",
                                "email",
                                "file",
                                "hidden",
                                "image",
                                "month",
                                "number",
                                "password",
                                "radio",
                                "range",
                                "reset",
                                "search",
                                "submit",
                                "tel",
                                "text",
                                "time",
                                "url",
                                "week",
                            ]
                        },
                        usemap: {
                            deprecated: true
                        },
                        vspace: {
                            deprecated: true
                        }
                    },
                    /* eslint-disable-next-line complexity -- the standard is complicated */
                    implicitRole: function (node) {
                        var list = node.hasAttribute("list");
                        if (list) {
                            return "combobox";
                        }
                        var type = node.getAttribute("type");
                        switch (type) {
                            case "button":
                                return "button";
                            case "checkbox":
                                return "checkbox";
                            case "email":
                                return "textbox";
                            case "image":
                                return "button";
                            case "number":
                                return "spinbutton";
                            case "radio":
                                return "radio";
                            case "range":
                                return "slider";
                            case "reset":
                                return "button";
                            case "search":
                                return "searchbox";
                            case "submit":
                                return "button";
                            case "tel":
                                return "textbox";
                            case "text":
                                return "textbox";
                            case "url":
                                return "textbox";
                            default:
                                return "textbox";
                        }
                    }
                },
                ins: {
                    flow: true,
                    phrasing: true,
                    transparent: true
                },
                isindex: {
                    deprecated: {
                        source: "html4"
                    }
                },
                kbd: {
                    flow: true,
                    phrasing: true,
                    permittedContent: ["@phrasing"]
                },
                keygen: {
                    flow: true,
                    phrasing: true,
                    interactive: true,
                    "void": true,
                    labelable: true,
                    deprecated: true
                },
                label: {
                    flow: true,
                    phrasing: true,
                    interactive: true,
                    permittedContent: ["@phrasing"],
                    permittedDescendants: [{ exclude: ["label"] }],
                    attributes: {
                        datafld: {
                            deprecated: true
                        },
                        dataformatas: {
                            deprecated: true
                        },
                        datasrc: {
                            deprecated: true
                        },
                        "for": {
                            "enum": [validId]
                        }
                    }
                },
                legend: {
                    permittedContent: ["@phrasing", "@heading"],
                    attributes: {
                        align: {
                            deprecated: true
                        },
                        datafld: {
                            deprecated: true
                        },
                        dataformatas: {
                            deprecated: true
                        },
                        datasrc: {
                            deprecated: true
                        }
                    }
                },
                li: {
                    implicitClosed: ["li"],
                    permittedContent: ["@flow"],
                    permittedParent: ["ul", "ol", "menu", "template"],
                    attributes: {
                        type: {
                            deprecated: true
                        }
                    },
                    implicitRole: function (node) {
                        return node.closest("ul, ol, menu") ? "listitem" : null;
                    }
                },
                link: {
                    metadata: true,
                    "void": true,
                    attributes: {
                        as: {
                            allowed: allowedIfAttributeHasValue("rel", ["prefetch", "preload", "modulepreload"]),
                            "enum": [
                                "audio",
                                "audioworklet",
                                "document",
                                "embed",
                                "fetch",
                                "font",
                                "frame",
                                "iframe",
                                "image",
                                "manifest",
                                "object",
                                "paintworklet",
                                "report",
                                "script",
                                "serviceworker",
                                "sharedworker",
                                "style",
                                "track",
                                "video",
                                "webidentity",
                                "worker",
                                "xslt",
                            ]
                        },
                        blocking: {
                            allowed: allowedIfAttributeHasValue("rel", ["stylesheet", "preload", "modulepreload"]),
                            list: true,
                            "enum": ["render"]
                        },
                        charset: {
                            deprecated: true
                        },
                        crossorigin: {
                            omit: true,
                            "enum": ["anonymous", "use-credentials"]
                        },
                        disabled: {
                            allowed: allowedIfAttributeHasValue("rel", ["stylesheet"]),
                            boolean: true
                        },
                        href: {
                            required: true,
                            "enum": ["/.+/"]
                        },
                        integrity: {
                            allowed: allowedIfAttributeHasValue("rel", ["stylesheet", "preload", "modulepreload"]),
                            "enum": ["/.+/"]
                        },
                        methods: {
                            deprecated: true
                        },
                        target: {
                            deprecated: true
                        },
                        urn: {
                            deprecated: true
                        }
                    }
                },
                listing: {
                    deprecated: {
                        source: "html32"
                    }
                },
                main: {
                    flow: true,
                    implicitRole: function () {
                        return "main";
                    }
                },
                map: {
                    flow: true,
                    phrasing: true,
                    transparent: true,
                    attributes: {
                        name: {
                            required: true,
                            "enum": ["/\\S+/"]
                        }
                    }
                },
                mark: {
                    flow: true,
                    phrasing: true,
                    permittedContent: ["@phrasing"]
                },
                marquee: {
                    deprecated: {
                        documentation: "Marked as obsolete by both W3C and WHATWG standards but still implemented in most browsers. Animated text should be avoided for accessibility reasons as well.",
                        source: "html5"
                    },
                    attributes: {
                        datafld: {
                            deprecated: true
                        },
                        dataformatas: {
                            deprecated: true
                        },
                        datasrc: {
                            deprecated: true
                        }
                    }
                },
                math: {
                    flow: true,
                    foreign: true,
                    phrasing: true,
                    embedded: true,
                    attributes: {
                        align: {
                            deprecated: true
                        },
                        dir: {
                            "enum": ["ltr", "rtl"]
                        },
                        display: {
                            "enum": ["block", "inline"]
                        },
                        hspace: {
                            deprecated: true
                        },
                        name: {
                            deprecated: true
                        },
                        overflow: {
                            "enum": ["linebreak", "scroll", "elide", "truncate", "scale"]
                        },
                        vspace: {
                            deprecated: true
                        }
                    },
                    implicitRole: function () {
                        return "math";
                    }
                },
                menu: {
                    flow: true,
                    implicitRole: function () {
                        return "list";
                    },
                    permittedContent: ["@script", "li"]
                },
                meta: {
                    flow: ["hasAttribute", "itemprop"],
                    phrasing: ["hasAttribute", "itemprop"],
                    metadata: true,
                    "void": true,
                    attributes: {
                        charset: {
                            "enum": ["utf-8"]
                        },
                        content: {
                            allowed: allowedIfAttributeIsPresent("name", "http-equiv", "itemprop", "property")
                        },
                        itemprop: {
                            allowed: allowedIfAttributeIsAbsent("http-equiv", "name")
                        },
                        name: {
                            allowed: allowedIfAttributeIsAbsent("http-equiv", "itemprop")
                        },
                        "http-equiv": {
                            allowed: allowedIfAttributeIsAbsent("name", "itemprop")
                        },
                        scheme: {
                            deprecated: true
                        }
                    }
                },
                meter: {
                    flow: true,
                    phrasing: true,
                    labelable: true,
                    implicitRole: function () {
                        return "meter";
                    },
                    permittedContent: ["@phrasing"],
                    permittedDescendants: [{ exclude: "meter" }]
                },
                multicol: {
                    deprecated: {
                        message: "use CSS instead",
                        documentation: "Use CSS columns instead.",
                        source: "html5"
                    }
                },
                nav: {
                    flow: true,
                    sectioning: true,
                    implicitRole: function () {
                        return "navigation";
                    },
                    permittedContent: ["@flow"],
                    permittedDescendants: [{ exclude: "main" }]
                },
                nextid: {
                    deprecated: {
                        source: "html32"
                    }
                },
                nobr: {
                    deprecated: {
                        message: "use CSS instead",
                        documentation: "Use CSS `white-space` property instead.",
                        source: "non-standard"
                    }
                },
                noembed: {
                    deprecated: {
                        source: "non-standard"
                    }
                },
                noframes: {
                    deprecated: {
                        source: "html5"
                    }
                },
                noscript: {
                    metadata: true,
                    flow: true,
                    phrasing: true,
                    transparent: true,
                    permittedDescendants: [{ exclude: "noscript" }]
                },
                object: {
                    flow: true,
                    phrasing: true,
                    embedded: true,
                    interactive: ["hasAttribute", "usemap"],
                    transparent: true,
                    formAssociated: {
                        listed: true
                    },
                    attributes: {
                        align: {
                            deprecated: true
                        },
                        archive: {
                            deprecated: true
                        },
                        blocking: {
                            list: true,
                            "enum": ["render"]
                        },
                        border: {
                            deprecated: true
                        },
                        classid: {
                            deprecated: true
                        },
                        code: {
                            deprecated: true
                        },
                        codebase: {
                            deprecated: true
                        },
                        codetype: {
                            deprecated: true
                        },
                        data: {
                            "enum": ["/.+/"],
                            required: true
                        },
                        datafld: {
                            deprecated: true
                        },
                        dataformatas: {
                            deprecated: true
                        },
                        datasrc: {
                            deprecated: true
                        },
                        declare: {
                            deprecated: true
                        },
                        hspace: {
                            deprecated: true
                        },
                        name: {
                            "enum": ["/[^_].*/"]
                        },
                        standby: {
                            deprecated: true
                        },
                        vspace: {
                            deprecated: true
                        }
                    },
                    permittedContent: ["param", "@flow"],
                    permittedOrder: ["param", "@flow"]
                },
                ol: {
                    flow: true,
                    attributes: {
                        compact: {
                            deprecated: true
                        },
                        reversed: {
                            boolean: true
                        },
                        type: {
                            "enum": ["a", "A", "i", "I", "1"]
                        }
                    },
                    implicitRole: function () {
                        return "list";
                    },
                    permittedContent: ["@script", "li"]
                },
                optgroup: {
                    implicitClosed: ["optgroup"],
                    attributes: {
                        disabled: {
                            boolean: true
                        }
                    },
                    implicitRole: function () {
                        return "group";
                    },
                    permittedContent: ["@script", "option"]
                },
                option: {
                    implicitClosed: ["option"],
                    attributes: {
                        dataformatas: {
                            deprecated: true
                        },
                        datasrc: {
                            deprecated: true
                        },
                        disabled: {
                            boolean: true
                        },
                        name: {
                            deprecated: true
                        },
                        selected: {
                            boolean: true
                        }
                    },
                    implicitRole: function () {
                        return "option";
                    },
                    permittedContent: []
                },
                output: {
                    flow: true,
                    phrasing: true,
                    formAssociated: {
                        listed: true
                    },
                    labelable: true,
                    implicitRole: function () {
                        return "status";
                    },
                    permittedContent: ["@phrasing"]
                },
                p: {
                    flow: true,
                    implicitClosed: [
                        "address",
                        "article",
                        "aside",
                        "blockquote",
                        "div",
                        "dl",
                        "fieldset",
                        "footer",
                        "form",
                        "h1",
                        "h2",
                        "h3",
                        "h4",
                        "h5",
                        "h6",
                        "header",
                        "hgroup",
                        "hr",
                        "main",
                        "nav",
                        "ol",
                        "p",
                        "pre",
                        "section",
                        "table",
                        "ul",
                    ],
                    permittedContent: ["@phrasing"],
                    attributes: {
                        align: {
                            deprecated: true
                        }
                    }
                },
                param: {
                    "void": true,
                    attributes: {
                        datafld: {
                            deprecated: true
                        },
                        type: {
                            deprecated: true
                        },
                        valuetype: {
                            deprecated: true
                        }
                    }
                },
                picture: {
                    flow: true,
                    phrasing: true,
                    embedded: true,
                    permittedContent: ["@script", "source", "img"],
                    permittedOrder: ["source", "img"]
                },
                plaintext: {
                    deprecated: {
                        message: "use <pre> or CSS instead",
                        documentation: "Use the `<pre>` element or use CSS to set a monospace font.",
                        source: "html2"
                    }
                },
                pre: {
                    flow: true,
                    permittedContent: ["@phrasing"],
                    attributes: {
                        width: {
                            deprecated: true
                        }
                    }
                },
                progress: {
                    flow: true,
                    phrasing: true,
                    labelable: true,
                    implicitRole: function () {
                        return "progressbar";
                    },
                    permittedContent: ["@phrasing"],
                    permittedDescendants: [{ exclude: "progress" }]
                },
                q: {
                    flow: true,
                    phrasing: true,
                    permittedContent: ["@phrasing"]
                },
                rb: {
                    implicitClosed: ["rb", "rt", "rtc", "rp"],
                    permittedContent: ["@phrasing"]
                },
                rp: {
                    implicitClosed: ["rb", "rt", "rtc", "rp"],
                    permittedContent: ["@phrasing"]
                },
                rt: {
                    implicitClosed: ["rb", "rt", "rtc", "rp"],
                    permittedContent: ["@phrasing"]
                },
                rtc: {
                    implicitClosed: ["rb", "rtc", "rp"],
                    permittedContent: ["@phrasing", "rt"]
                },
                ruby: {
                    flow: true,
                    phrasing: true,
                    permittedContent: ["@phrasing", "rb", "rp", "rt", "rtc"]
                },
                s: {
                    flow: true,
                    phrasing: true,
                    permittedContent: ["@phrasing"]
                },
                samp: {
                    flow: true,
                    phrasing: true,
                    permittedContent: ["@phrasing"]
                },
                script: {
                    metadata: true,
                    flow: true,
                    phrasing: true,
                    scriptSupporting: true,
                    attributes: {
                        async: {
                            boolean: true
                        },
                        crossorigin: {
                            omit: true,
                            "enum": ["anonymous", "use-credentials"]
                        },
                        defer: {
                            boolean: true
                        },
                        event: {
                            deprecated: true
                        },
                        "for": {
                            deprecated: true
                        },
                        integrity: {
                            allowed: allowedIfAttributeIsPresent("src"),
                            "enum": ["/.+/"]
                        },
                        language: {
                            deprecated: true
                        },
                        nomodule: {
                            boolean: true
                        },
                        src: {
                            "enum": ["/.+/"]
                        }
                    }
                },
                search: {
                    flow: true,
                    implicitRole: function () {
                        return "search";
                    }
                },
                section: {
                    flow: true,
                    sectioning: true,
                    implicitRole: function () {
                        return "region";
                    },
                    permittedContent: ["@flow"]
                },
                select: {
                    flow: true,
                    phrasing: true,
                    interactive: true,
                    formAssociated: {
                        listed: true
                    },
                    labelable: true,
                    attributes: {
                        autofocus: {
                            boolean: true
                        },
                        disabled: {
                            boolean: true
                        },
                        multiple: {
                            boolean: true
                        },
                        required: {
                            boolean: true
                        },
                        size: {
                            "enum": ["/\\d+/"]
                        }
                    },
                    implicitRole: function (node) {
                        var multiple = node.hasAttribute("multiple");
                        if (multiple) {
                            return "listbox";
                        }
                        var size = node.getAttribute("size");
                        if (typeof size === "string") {
                            var parsed = parseInt(size, 10);
                            if (parsed > 1) {
                                return "listbox";
                            }
                        }
                        return "combobox";
                    },
                    permittedContent: ["@script", "datasrc", "datafld", "dataformatas", "option", "optgroup"]
                },
                slot: {
                    flow: true,
                    phrasing: true,
                    transparent: true
                },
                small: {
                    flow: true,
                    phrasing: true,
                    permittedContent: ["@phrasing"]
                },
                source: {
                    "void": true,
                    attributes: {
                        type: {},
                        media: {},
                        src: {
                            allowed: allowedIfParentIsPresent("audio", "video")
                        },
                        srcset: {
                            allowed: allowedIfParentIsPresent("picture")
                        },
                        sizes: {
                            allowed: allowedIfParentIsPresent("picture")
                        },
                        width: {
                            allowed: allowedIfParentIsPresent("picture"),
                            "enum": ["/\\d+/"]
                        },
                        height: {
                            allowed: allowedIfParentIsPresent("picture"),
                            "enum": ["/\\d+/"]
                        }
                    }
                },
                spacer: {
                    deprecated: {
                        message: "use CSS instead",
                        documentation: "Use CSS margin or padding instead.",
                        source: "non-standard"
                    }
                },
                span: {
                    flow: true,
                    phrasing: true,
                    permittedContent: ["@phrasing"],
                    attributes: {
                        datafld: {
                            deprecated: true
                        },
                        dataformatas: {
                            deprecated: true
                        },
                        datasrc: {
                            deprecated: true
                        }
                    }
                },
                strike: {
                    deprecated: {
                        message: "use <del> or <s> instead",
                        documentation: "Use the `<del>` or `<s>` element instead.",
                        source: "html5"
                    }
                },
                strong: {
                    flow: true,
                    phrasing: true,
                    permittedContent: ["@phrasing"]
                },
                style: {
                    metadata: true
                },
                sub: {
                    flow: true,
                    phrasing: true,
                    permittedContent: ["@phrasing"]
                },
                summary: {
                    permittedContent: ["@phrasing", "@heading"]
                },
                sup: {
                    flow: true,
                    phrasing: true,
                    permittedContent: ["@phrasing"]
                },
                svg: {
                    flow: true,
                    foreign: true,
                    phrasing: true,
                    embedded: true
                },
                /* while not part of HTML 5 specification these two elements are handled as
                 * special cases to allow them as accessible text and to avoid issues with
                 * "no-unknown-elements" they are added here */
                "svg:desc": {},
                "svg:title": {},
                table: {
                    flow: true,
                    permittedContent: ["@script", "caption?", "colgroup", "tbody", "tfoot?", "thead?", "tr"],
                    permittedOrder: ["caption", "colgroup", "thead", "tbody", "tr", "tfoot"],
                    attributes: {
                        align: {
                            deprecated: true
                        },
                        background: {
                            deprecated: true
                        },
                        bgcolor: {
                            deprecated: true
                        },
                        bordercolor: {
                            deprecated: true
                        },
                        cellpadding: {
                            deprecated: true
                        },
                        cellspacing: {
                            deprecated: true
                        },
                        dataformatas: {
                            deprecated: true
                        },
                        datapagesize: {
                            deprecated: true
                        },
                        datasrc: {
                            deprecated: true
                        },
                        frame: {
                            deprecated: true
                        },
                        rules: {
                            deprecated: true
                        },
                        summary: {
                            deprecated: true
                        },
                        width: {
                            deprecated: true
                        }
                    },
                    implicitRole: function () {
                        return "table";
                    }
                },
                tbody: {
                    implicitClosed: ["tbody", "tfoot"],
                    permittedContent: ["@script", "tr"],
                    attributes: {
                        align: {
                            deprecated: true
                        },
                        background: {
                            deprecated: true
                        },
                        char: {
                            deprecated: true
                        },
                        charoff: {
                            deprecated: true
                        },
                        valign: {
                            deprecated: true
                        }
                    },
                    implicitRole: function () {
                        return "rowgroup";
                    }
                },
                td: {
                    flow: true,
                    implicitClosed: ["td", "th"],
                    attributes: {
                        align: {
                            deprecated: true
                        },
                        axis: {
                            deprecated: true
                        },
                        background: {
                            deprecated: true
                        },
                        bgcolor: {
                            deprecated: true
                        },
                        char: {
                            deprecated: true
                        },
                        charoff: {
                            deprecated: true
                        },
                        colspan: {
                            "enum": ["/\\d+/"]
                        },
                        height: {
                            deprecated: true
                        },
                        nowrap: {
                            deprecated: true
                        },
                        rowspan: {
                            "enum": ["/\\d+/"]
                        },
                        scope: {
                            deprecated: true
                        },
                        valign: {
                            deprecated: true
                        },
                        width: {
                            deprecated: true
                        }
                    },
                    implicitRole: function (node) {
                        if (node.closest('table[role="grid"], table[role="treegrid"]')) {
                            return "gridcell";
                        }
                        else if (node.closest("table")) {
                            return "cell";
                        }
                        else {
                            return null;
                        }
                    },
                    permittedContent: ["@flow"]
                },
                template: {
                    metadata: true,
                    flow: true,
                    phrasing: true,
                    scriptSupporting: true
                },
                textarea: {
                    flow: true,
                    phrasing: true,
                    interactive: true,
                    formAssociated: {
                        listed: true
                    },
                    labelable: true,
                    attributes: {
                        autocomplete: {
                            "enum": ["on", "off"]
                        },
                        autofocus: {
                            boolean: true
                        },
                        cols: {
                            "enum": ["/\\d+/"]
                        },
                        datafld: {
                            deprecated: true
                        },
                        datasrc: {
                            deprecated: true
                        },
                        disabled: {
                            boolean: true
                        },
                        maxlength: {
                            "enum": ["/\\d+/"]
                        },
                        minlength: {
                            "enum": ["/\\d+/"]
                        },
                        readonly: {
                            boolean: true
                        },
                        required: {
                            boolean: true
                        },
                        rows: {
                            "enum": ["/\\d+/"]
                        },
                        spellcheck: {
                            "enum": ["true", "default", "false"]
                        },
                        wrap: {
                            "enum": ["hard", "soft"]
                        }
                    },
                    implicitRole: function () {
                        return "textbox";
                    },
                    permittedContent: []
                },
                tfoot: {
                    implicitClosed: ["tbody"],
                    permittedContent: ["@script", "tr"],
                    attributes: {
                        align: {
                            deprecated: true
                        },
                        background: {
                            deprecated: true
                        },
                        char: {
                            deprecated: true
                        },
                        charoff: {
                            deprecated: true
                        },
                        valign: {
                            deprecated: true
                        }
                    },
                    implicitRole: function () {
                        return "rowgroup";
                    }
                },
                th: {
                    flow: true,
                    implicitClosed: ["td", "th"],
                    attributes: {
                        align: {
                            deprecated: true
                        },
                        axis: {
                            deprecated: true
                        },
                        background: {
                            deprecated: true
                        },
                        bgcolor: {
                            deprecated: true
                        },
                        char: {
                            deprecated: true
                        },
                        charoff: {
                            deprecated: true
                        },
                        colspan: {
                            "enum": ["/\\d+/"]
                        },
                        height: {
                            deprecated: true
                        },
                        nowrap: {
                            deprecated: true
                        },
                        rowspan: {
                            "enum": ["/\\d+/"]
                        },
                        scope: {
                            "enum": ["row", "col", "rowgroup", "colgroup"]
                        },
                        valign: {
                            deprecated: true
                        },
                        width: {
                            deprecated: true
                        }
                    },
                    implicitRole: function (node) {
                        var _a;
                        var table = node.closest("table");
                        if (!table) {
                            return null;
                        }
                        var tableRole = (_a = table.getAttribute("role")) !== null && _a !== void 0 ? _a : "table";
                        if (typeof tableRole !== "string" || !["table", "grid", "treegrid"].includes(tableRole)) {
                            return null;
                        }
                        var scope = node.getAttribute("scope");
                        switch (scope) {
                            case "col":
                                return "columnheader";
                            case "row":
                                return "rowheader";
                            default:
                                return tableRole === "table" ? "cell" : "gridcell";
                        }
                    },
                    permittedContent: ["@flow"],
                    permittedDescendants: [{ exclude: ["header", "footer", "@sectioning", "@heading"] }]
                },
                thead: {
                    implicitClosed: ["tbody", "tfoot"],
                    permittedContent: ["@script", "tr"],
                    attributes: {
                        align: {
                            deprecated: true
                        },
                        background: {
                            deprecated: true
                        },
                        char: {
                            deprecated: true
                        },
                        charoff: {
                            deprecated: true
                        },
                        valign: {
                            deprecated: true
                        }
                    },
                    implicitRole: function () {
                        return "rowgroup";
                    }
                },
                time: {
                    flow: true,
                    phrasing: true,
                    implicitRole: function () {
                        return "time";
                    },
                    permittedContent: ["@phrasing"]
                },
                title: {
                    metadata: true,
                    permittedContent: [],
                    permittedParent: ["head"]
                },
                tr: {
                    implicitClosed: ["tr"],
                    permittedContent: ["@script", "td", "th"],
                    attributes: {
                        align: {
                            deprecated: true
                        },
                        background: {
                            deprecated: true
                        },
                        bgcolor: {
                            deprecated: true
                        },
                        char: {
                            deprecated: true
                        },
                        charoff: {
                            deprecated: true
                        },
                        valign: {
                            deprecated: true
                        }
                    },
                    implicitRole: function () {
                        return "row";
                    }
                },
                track: {
                    "void": true
                },
                tt: {
                    deprecated: {
                        documentation: "Use a more semantically correct element such as `<code>`, `<var>` or `<pre>`.",
                        source: "html4"
                    }
                },
                u: {
                    flow: true,
                    phrasing: true,
                    permittedContent: ["@phrasing"]
                },
                ul: {
                    flow: true,
                    permittedContent: ["@script", "li"],
                    attributes: {
                        compact: {
                            deprecated: true
                        },
                        type: {
                            deprecated: true
                        }
                    },
                    implicitRole: function () {
                        return "list";
                    }
                },
                "var": {
                    flow: true,
                    phrasing: true,
                    permittedContent: ["@phrasing"]
                },
                video: {
                    flow: true,
                    phrasing: true,
                    embedded: true,
                    interactive: ["hasAttribute", "controls"],
                    transparent: ["@flow"],
                    attributes: {
                        crossorigin: {
                            omit: true,
                            "enum": ["anonymous", "use-credentials"]
                        },
                        itemprop: {
                            allowed: allowedIfAttributeIsPresent("src")
                        },
                        preload: {
                            omit: true,
                            "enum": ["none", "metadata", "auto"]
                        }
                    },
                    permittedContent: ["@flow", "track", "source"],
                    permittedDescendants: [{ exclude: ["audio", "video"] }],
                    permittedOrder: ["source", "track", "@flow"]
                },
                wbr: {
                    flow: true,
                    phrasing: true,
                    "void": true
                },
                xmp: {
                    deprecated: {
                        documentation: "Use `<pre>` or `<code>` and escape content using HTML entities instead.",
                        source: "html32"
                    }
                }
            });
            var bundledElements = {
                html5: html5
            };
            var entities = [
                "&Aacute",
                "&aacute",
                "&Aacute;",
                "&aacute;",
                "&Abreve;",
                "&abreve;",
                "&ac;",
                "&acd;",
                "&acE;",
                "&Acirc",
                "&acirc",
                "&Acirc;",
                "&acirc;",
                "&acute",
                "&acute;",
                "&Acy;",
                "&acy;",
                "&AElig",
                "&aelig",
                "&AElig;",
                "&aelig;",
                "&af;",
                "&Afr;",
                "&afr;",
                "&Agrave",
                "&agrave",
                "&Agrave;",
                "&agrave;",
                "&alefsym;",
                "&aleph;",
                "&Alpha;",
                "&alpha;",
                "&Amacr;",
                "&amacr;",
                "&amalg;",
                "&AMP",
                "&amp",
                "&AMP;",
                "&amp;",
                "&And;",
                "&and;",
                "&andand;",
                "&andd;",
                "&andslope;",
                "&andv;",
                "&ang;",
                "&ange;",
                "&angle;",
                "&angmsd;",
                "&angmsdaa;",
                "&angmsdab;",
                "&angmsdac;",
                "&angmsdad;",
                "&angmsdae;",
                "&angmsdaf;",
                "&angmsdag;",
                "&angmsdah;",
                "&angrt;",
                "&angrtvb;",
                "&angrtvbd;",
                "&angsph;",
                "&angst;",
                "&angzarr;",
                "&Aogon;",
                "&aogon;",
                "&Aopf;",
                "&aopf;",
                "&ap;",
                "&apacir;",
                "&apE;",
                "&ape;",
                "&apid;",
                "&apos;",
                "&ApplyFunction;",
                "&approx;",
                "&approxeq;",
                "&Aring",
                "&aring",
                "&Aring;",
                "&aring;",
                "&Ascr;",
                "&ascr;",
                "&Assign;",
                "&ast;",
                "&asymp;",
                "&asympeq;",
                "&Atilde",
                "&atilde",
                "&Atilde;",
                "&atilde;",
                "&Auml",
                "&auml",
                "&Auml;",
                "&auml;",
                "&awconint;",
                "&awint;",
                "&backcong;",
                "&backepsilon;",
                "&backprime;",
                "&backsim;",
                "&backsimeq;",
                "&Backslash;",
                "&Barv;",
                "&barvee;",
                "&Barwed;",
                "&barwed;",
                "&barwedge;",
                "&bbrk;",
                "&bbrktbrk;",
                "&bcong;",
                "&Bcy;",
                "&bcy;",
                "&bdquo;",
                "&becaus;",
                "&Because;",
                "&because;",
                "&bemptyv;",
                "&bepsi;",
                "&bernou;",
                "&Bernoullis;",
                "&Beta;",
                "&beta;",
                "&beth;",
                "&between;",
                "&Bfr;",
                "&bfr;",
                "&bigcap;",
                "&bigcirc;",
                "&bigcup;",
                "&bigodot;",
                "&bigoplus;",
                "&bigotimes;",
                "&bigsqcup;",
                "&bigstar;",
                "&bigtriangledown;",
                "&bigtriangleup;",
                "&biguplus;",
                "&bigvee;",
                "&bigwedge;",
                "&bkarow;",
                "&blacklozenge;",
                "&blacksquare;",
                "&blacktriangle;",
                "&blacktriangledown;",
                "&blacktriangleleft;",
                "&blacktriangleright;",
                "&blank;",
                "&blk12;",
                "&blk14;",
                "&blk34;",
                "&block;",
                "&bne;",
                "&bnequiv;",
                "&bNot;",
                "&bnot;",
                "&Bopf;",
                "&bopf;",
                "&bot;",
                "&bottom;",
                "&bowtie;",
                "&boxbox;",
                "&boxDL;",
                "&boxDl;",
                "&boxdL;",
                "&boxdl;",
                "&boxDR;",
                "&boxDr;",
                "&boxdR;",
                "&boxdr;",
                "&boxH;",
                "&boxh;",
                "&boxHD;",
                "&boxHd;",
                "&boxhD;",
                "&boxhd;",
                "&boxHU;",
                "&boxHu;",
                "&boxhU;",
                "&boxhu;",
                "&boxminus;",
                "&boxplus;",
                "&boxtimes;",
                "&boxUL;",
                "&boxUl;",
                "&boxuL;",
                "&boxul;",
                "&boxUR;",
                "&boxUr;",
                "&boxuR;",
                "&boxur;",
                "&boxV;",
                "&boxv;",
                "&boxVH;",
                "&boxVh;",
                "&boxvH;",
                "&boxvh;",
                "&boxVL;",
                "&boxVl;",
                "&boxvL;",
                "&boxvl;",
                "&boxVR;",
                "&boxVr;",
                "&boxvR;",
                "&boxvr;",
                "&bprime;",
                "&Breve;",
                "&breve;",
                "&brvbar",
                "&brvbar;",
                "&Bscr;",
                "&bscr;",
                "&bsemi;",
                "&bsim;",
                "&bsime;",
                "&bsol;",
                "&bsolb;",
                "&bsolhsub;",
                "&bull;",
                "&bullet;",
                "&bump;",
                "&bumpE;",
                "&bumpe;",
                "&Bumpeq;",
                "&bumpeq;",
                "&Cacute;",
                "&cacute;",
                "&Cap;",
                "&cap;",
                "&capand;",
                "&capbrcup;",
                "&capcap;",
                "&capcup;",
                "&capdot;",
                "&CapitalDifferentialD;",
                "&caps;",
                "&caret;",
                "&caron;",
                "&Cayleys;",
                "&ccaps;",
                "&Ccaron;",
                "&ccaron;",
                "&Ccedil",
                "&ccedil",
                "&Ccedil;",
                "&ccedil;",
                "&Ccirc;",
                "&ccirc;",
                "&Cconint;",
                "&ccups;",
                "&ccupssm;",
                "&Cdot;",
                "&cdot;",
                "&cedil",
                "&cedil;",
                "&Cedilla;",
                "&cemptyv;",
                "&cent",
                "&cent;",
                "&CenterDot;",
                "&centerdot;",
                "&Cfr;",
                "&cfr;",
                "&CHcy;",
                "&chcy;",
                "&check;",
                "&checkmark;",
                "&Chi;",
                "&chi;",
                "&cir;",
                "&circ;",
                "&circeq;",
                "&circlearrowleft;",
                "&circlearrowright;",
                "&circledast;",
                "&circledcirc;",
                "&circleddash;",
                "&CircleDot;",
                "&circledR;",
                "&circledS;",
                "&CircleMinus;",
                "&CirclePlus;",
                "&CircleTimes;",
                "&cirE;",
                "&cire;",
                "&cirfnint;",
                "&cirmid;",
                "&cirscir;",
                "&ClockwiseContourIntegral;",
                "&CloseCurlyDoubleQuote;",
                "&CloseCurlyQuote;",
                "&clubs;",
                "&clubsuit;",
                "&Colon;",
                "&colon;",
                "&Colone;",
                "&colone;",
                "&coloneq;",
                "&comma;",
                "&commat;",
                "&comp;",
                "&compfn;",
                "&complement;",
                "&complexes;",
                "&cong;",
                "&congdot;",
                "&Congruent;",
                "&Conint;",
                "&conint;",
                "&ContourIntegral;",
                "&Copf;",
                "&copf;",
                "&coprod;",
                "&Coproduct;",
                "&COPY",
                "&copy",
                "&COPY;",
                "&copy;",
                "&copysr;",
                "&CounterClockwiseContourIntegral;",
                "&crarr;",
                "&Cross;",
                "&cross;",
                "&Cscr;",
                "&cscr;",
                "&csub;",
                "&csube;",
                "&csup;",
                "&csupe;",
                "&ctdot;",
                "&cudarrl;",
                "&cudarrr;",
                "&cuepr;",
                "&cuesc;",
                "&cularr;",
                "&cularrp;",
                "&Cup;",
                "&cup;",
                "&cupbrcap;",
                "&CupCap;",
                "&cupcap;",
                "&cupcup;",
                "&cupdot;",
                "&cupor;",
                "&cups;",
                "&curarr;",
                "&curarrm;",
                "&curlyeqprec;",
                "&curlyeqsucc;",
                "&curlyvee;",
                "&curlywedge;",
                "&curren",
                "&curren;",
                "&curvearrowleft;",
                "&curvearrowright;",
                "&cuvee;",
                "&cuwed;",
                "&cwconint;",
                "&cwint;",
                "&cylcty;",
                "&Dagger;",
                "&dagger;",
                "&daleth;",
                "&Darr;",
                "&dArr;",
                "&darr;",
                "&dash;",
                "&Dashv;",
                "&dashv;",
                "&dbkarow;",
                "&dblac;",
                "&Dcaron;",
                "&dcaron;",
                "&Dcy;",
                "&dcy;",
                "&DD;",
                "&dd;",
                "&ddagger;",
                "&ddarr;",
                "&DDotrahd;",
                "&ddotseq;",
                "&deg",
                "&deg;",
                "&Del;",
                "&Delta;",
                "&delta;",
                "&demptyv;",
                "&dfisht;",
                "&Dfr;",
                "&dfr;",
                "&dHar;",
                "&dharl;",
                "&dharr;",
                "&DiacriticalAcute;",
                "&DiacriticalDot;",
                "&DiacriticalDoubleAcute;",
                "&DiacriticalGrave;",
                "&DiacriticalTilde;",
                "&diam;",
                "&Diamond;",
                "&diamond;",
                "&diamondsuit;",
                "&diams;",
                "&die;",
                "&DifferentialD;",
                "&digamma;",
                "&disin;",
                "&div;",
                "&divide",
                "&divide;",
                "&divideontimes;",
                "&divonx;",
                "&DJcy;",
                "&djcy;",
                "&dlcorn;",
                "&dlcrop;",
                "&dollar;",
                "&Dopf;",
                "&dopf;",
                "&Dot;",
                "&dot;",
                "&DotDot;",
                "&doteq;",
                "&doteqdot;",
                "&DotEqual;",
                "&dotminus;",
                "&dotplus;",
                "&dotsquare;",
                "&doublebarwedge;",
                "&DoubleContourIntegral;",
                "&DoubleDot;",
                "&DoubleDownArrow;",
                "&DoubleLeftArrow;",
                "&DoubleLeftRightArrow;",
                "&DoubleLeftTee;",
                "&DoubleLongLeftArrow;",
                "&DoubleLongLeftRightArrow;",
                "&DoubleLongRightArrow;",
                "&DoubleRightArrow;",
                "&DoubleRightTee;",
                "&DoubleUpArrow;",
                "&DoubleUpDownArrow;",
                "&DoubleVerticalBar;",
                "&DownArrow;",
                "&Downarrow;",
                "&downarrow;",
                "&DownArrowBar;",
                "&DownArrowUpArrow;",
                "&DownBreve;",
                "&downdownarrows;",
                "&downharpoonleft;",
                "&downharpoonright;",
                "&DownLeftRightVector;",
                "&DownLeftTeeVector;",
                "&DownLeftVector;",
                "&DownLeftVectorBar;",
                "&DownRightTeeVector;",
                "&DownRightVector;",
                "&DownRightVectorBar;",
                "&DownTee;",
                "&DownTeeArrow;",
                "&drbkarow;",
                "&drcorn;",
                "&drcrop;",
                "&Dscr;",
                "&dscr;",
                "&DScy;",
                "&dscy;",
                "&dsol;",
                "&Dstrok;",
                "&dstrok;",
                "&dtdot;",
                "&dtri;",
                "&dtrif;",
                "&duarr;",
                "&duhar;",
                "&dwangle;",
                "&DZcy;",
                "&dzcy;",
                "&dzigrarr;",
                "&Eacute",
                "&eacute",
                "&Eacute;",
                "&eacute;",
                "&easter;",
                "&Ecaron;",
                "&ecaron;",
                "&ecir;",
                "&Ecirc",
                "&ecirc",
                "&Ecirc;",
                "&ecirc;",
                "&ecolon;",
                "&Ecy;",
                "&ecy;",
                "&eDDot;",
                "&Edot;",
                "&eDot;",
                "&edot;",
                "&ee;",
                "&efDot;",
                "&Efr;",
                "&efr;",
                "&eg;",
                "&Egrave",
                "&egrave",
                "&Egrave;",
                "&egrave;",
                "&egs;",
                "&egsdot;",
                "&el;",
                "&Element;",
                "&elinters;",
                "&ell;",
                "&els;",
                "&elsdot;",
                "&Emacr;",
                "&emacr;",
                "&empty;",
                "&emptyset;",
                "&EmptySmallSquare;",
                "&emptyv;",
                "&EmptyVerySmallSquare;",
                "&emsp13;",
                "&emsp14;",
                "&emsp;",
                "&ENG;",
                "&eng;",
                "&ensp;",
                "&Eogon;",
                "&eogon;",
                "&Eopf;",
                "&eopf;",
                "&epar;",
                "&eparsl;",
                "&eplus;",
                "&epsi;",
                "&Epsilon;",
                "&epsilon;",
                "&epsiv;",
                "&eqcirc;",
                "&eqcolon;",
                "&eqsim;",
                "&eqslantgtr;",
                "&eqslantless;",
                "&Equal;",
                "&equals;",
                "&EqualTilde;",
                "&equest;",
                "&Equilibrium;",
                "&equiv;",
                "&equivDD;",
                "&eqvparsl;",
                "&erarr;",
                "&erDot;",
                "&Escr;",
                "&escr;",
                "&esdot;",
                "&Esim;",
                "&esim;",
                "&Eta;",
                "&eta;",
                "&ETH",
                "&eth",
                "&ETH;",
                "&eth;",
                "&Euml",
                "&euml",
                "&Euml;",
                "&euml;",
                "&euro;",
                "&excl;",
                "&exist;",
                "&Exists;",
                "&expectation;",
                "&ExponentialE;",
                "&exponentiale;",
                "&fallingdotseq;",
                "&Fcy;",
                "&fcy;",
                "&female;",
                "&ffilig;",
                "&fflig;",
                "&ffllig;",
                "&Ffr;",
                "&ffr;",
                "&filig;",
                "&FilledSmallSquare;",
                "&FilledVerySmallSquare;",
                "&fjlig;",
                "&flat;",
                "&fllig;",
                "&fltns;",
                "&fnof;",
                "&Fopf;",
                "&fopf;",
                "&ForAll;",
                "&forall;",
                "&fork;",
                "&forkv;",
                "&Fouriertrf;",
                "&fpartint;",
                "&frac12",
                "&frac12;",
                "&frac13;",
                "&frac14",
                "&frac14;",
                "&frac15;",
                "&frac16;",
                "&frac18;",
                "&frac23;",
                "&frac25;",
                "&frac34",
                "&frac34;",
                "&frac35;",
                "&frac38;",
                "&frac45;",
                "&frac56;",
                "&frac58;",
                "&frac78;",
                "&frasl;",
                "&frown;",
                "&Fscr;",
                "&fscr;",
                "&gacute;",
                "&Gamma;",
                "&gamma;",
                "&Gammad;",
                "&gammad;",
                "&gap;",
                "&Gbreve;",
                "&gbreve;",
                "&Gcedil;",
                "&Gcirc;",
                "&gcirc;",
                "&Gcy;",
                "&gcy;",
                "&Gdot;",
                "&gdot;",
                "&gE;",
                "&ge;",
                "&gEl;",
                "&gel;",
                "&geq;",
                "&geqq;",
                "&geqslant;",
                "&ges;",
                "&gescc;",
                "&gesdot;",
                "&gesdoto;",
                "&gesdotol;",
                "&gesl;",
                "&gesles;",
                "&Gfr;",
                "&gfr;",
                "&Gg;",
                "&gg;",
                "&ggg;",
                "&gimel;",
                "&GJcy;",
                "&gjcy;",
                "&gl;",
                "&gla;",
                "&glE;",
                "&glj;",
                "&gnap;",
                "&gnapprox;",
                "&gnE;",
                "&gne;",
                "&gneq;",
                "&gneqq;",
                "&gnsim;",
                "&Gopf;",
                "&gopf;",
                "&grave;",
                "&GreaterEqual;",
                "&GreaterEqualLess;",
                "&GreaterFullEqual;",
                "&GreaterGreater;",
                "&GreaterLess;",
                "&GreaterSlantEqual;",
                "&GreaterTilde;",
                "&Gscr;",
                "&gscr;",
                "&gsim;",
                "&gsime;",
                "&gsiml;",
                "&GT",
                "&gt",
                "&GT;",
                "&Gt;",
                "&gt;",
                "&gtcc;",
                "&gtcir;",
                "&gtdot;",
                "&gtlPar;",
                "&gtquest;",
                "&gtrapprox;",
                "&gtrarr;",
                "&gtrdot;",
                "&gtreqless;",
                "&gtreqqless;",
                "&gtrless;",
                "&gtrsim;",
                "&gvertneqq;",
                "&gvnE;",
                "&Hacek;",
                "&hairsp;",
                "&half;",
                "&hamilt;",
                "&HARDcy;",
                "&hardcy;",
                "&hArr;",
                "&harr;",
                "&harrcir;",
                "&harrw;",
                "&Hat;",
                "&hbar;",
                "&Hcirc;",
                "&hcirc;",
                "&hearts;",
                "&heartsuit;",
                "&hellip;",
                "&hercon;",
                "&Hfr;",
                "&hfr;",
                "&HilbertSpace;",
                "&hksearow;",
                "&hkswarow;",
                "&hoarr;",
                "&homtht;",
                "&hookleftarrow;",
                "&hookrightarrow;",
                "&Hopf;",
                "&hopf;",
                "&horbar;",
                "&HorizontalLine;",
                "&Hscr;",
                "&hscr;",
                "&hslash;",
                "&Hstrok;",
                "&hstrok;",
                "&HumpDownHump;",
                "&HumpEqual;",
                "&hybull;",
                "&hyphen;",
                "&Iacute",
                "&iacute",
                "&Iacute;",
                "&iacute;",
                "&ic;",
                "&Icirc",
                "&icirc",
                "&Icirc;",
                "&icirc;",
                "&Icy;",
                "&icy;",
                "&Idot;",
                "&IEcy;",
                "&iecy;",
                "&iexcl",
                "&iexcl;",
                "&iff;",
                "&Ifr;",
                "&ifr;",
                "&Igrave",
                "&igrave",
                "&Igrave;",
                "&igrave;",
                "&ii;",
                "&iiiint;",
                "&iiint;",
                "&iinfin;",
                "&iiota;",
                "&IJlig;",
                "&ijlig;",
                "&Im;",
                "&Imacr;",
                "&imacr;",
                "&image;",
                "&ImaginaryI;",
                "&imagline;",
                "&imagpart;",
                "&imath;",
                "&imof;",
                "&imped;",
                "&Implies;",
                "&in;",
                "&incare;",
                "&infin;",
                "&infintie;",
                "&inodot;",
                "&Int;",
                "&int;",
                "&intcal;",
                "&integers;",
                "&Integral;",
                "&intercal;",
                "&Intersection;",
                "&intlarhk;",
                "&intprod;",
                "&InvisibleComma;",
                "&InvisibleTimes;",
                "&IOcy;",
                "&iocy;",
                "&Iogon;",
                "&iogon;",
                "&Iopf;",
                "&iopf;",
                "&Iota;",
                "&iota;",
                "&iprod;",
                "&iquest",
                "&iquest;",
                "&Iscr;",
                "&iscr;",
                "&isin;",
                "&isindot;",
                "&isinE;",
                "&isins;",
                "&isinsv;",
                "&isinv;",
                "&it;",
                "&Itilde;",
                "&itilde;",
                "&Iukcy;",
                "&iukcy;",
                "&Iuml",
                "&iuml",
                "&Iuml;",
                "&iuml;",
                "&Jcirc;",
                "&jcirc;",
                "&Jcy;",
                "&jcy;",
                "&Jfr;",
                "&jfr;",
                "&jmath;",
                "&Jopf;",
                "&jopf;",
                "&Jscr;",
                "&jscr;",
                "&Jsercy;",
                "&jsercy;",
                "&Jukcy;",
                "&jukcy;",
                "&Kappa;",
                "&kappa;",
                "&kappav;",
                "&Kcedil;",
                "&kcedil;",
                "&Kcy;",
                "&kcy;",
                "&Kfr;",
                "&kfr;",
                "&kgreen;",
                "&KHcy;",
                "&khcy;",
                "&KJcy;",
                "&kjcy;",
                "&Kopf;",
                "&kopf;",
                "&Kscr;",
                "&kscr;",
                "&lAarr;",
                "&Lacute;",
                "&lacute;",
                "&laemptyv;",
                "&lagran;",
                "&Lambda;",
                "&lambda;",
                "&Lang;",
                "&lang;",
                "&langd;",
                "&langle;",
                "&lap;",
                "&Laplacetrf;",
                "&laquo",
                "&laquo;",
                "&Larr;",
                "&lArr;",
                "&larr;",
                "&larrb;",
                "&larrbfs;",
                "&larrfs;",
                "&larrhk;",
                "&larrlp;",
                "&larrpl;",
                "&larrsim;",
                "&larrtl;",
                "&lat;",
                "&lAtail;",
                "&latail;",
                "&late;",
                "&lates;",
                "&lBarr;",
                "&lbarr;",
                "&lbbrk;",
                "&lbrace;",
                "&lbrack;",
                "&lbrke;",
                "&lbrksld;",
                "&lbrkslu;",
                "&Lcaron;",
                "&lcaron;",
                "&Lcedil;",
                "&lcedil;",
                "&lceil;",
                "&lcub;",
                "&Lcy;",
                "&lcy;",
                "&ldca;",
                "&ldquo;",
                "&ldquor;",
                "&ldrdhar;",
                "&ldrushar;",
                "&ldsh;",
                "&lE;",
                "&le;",
                "&LeftAngleBracket;",
                "&LeftArrow;",
                "&Leftarrow;",
                "&leftarrow;",
                "&LeftArrowBar;",
                "&LeftArrowRightArrow;",
                "&leftarrowtail;",
                "&LeftCeiling;",
                "&LeftDoubleBracket;",
                "&LeftDownTeeVector;",
                "&LeftDownVector;",
                "&LeftDownVectorBar;",
                "&LeftFloor;",
                "&leftharpoondown;",
                "&leftharpoonup;",
                "&leftleftarrows;",
                "&LeftRightArrow;",
                "&Leftrightarrow;",
                "&leftrightarrow;",
                "&leftrightarrows;",
                "&leftrightharpoons;",
                "&leftrightsquigarrow;",
                "&LeftRightVector;",
                "&LeftTee;",
                "&LeftTeeArrow;",
                "&LeftTeeVector;",
                "&leftthreetimes;",
                "&LeftTriangle;",
                "&LeftTriangleBar;",
                "&LeftTriangleEqual;",
                "&LeftUpDownVector;",
                "&LeftUpTeeVector;",
                "&LeftUpVector;",
                "&LeftUpVectorBar;",
                "&LeftVector;",
                "&LeftVectorBar;",
                "&lEg;",
                "&leg;",
                "&leq;",
                "&leqq;",
                "&leqslant;",
                "&les;",
                "&lescc;",
                "&lesdot;",
                "&lesdoto;",
                "&lesdotor;",
                "&lesg;",
                "&lesges;",
                "&lessapprox;",
                "&lessdot;",
                "&lesseqgtr;",
                "&lesseqqgtr;",
                "&LessEqualGreater;",
                "&LessFullEqual;",
                "&LessGreater;",
                "&lessgtr;",
                "&LessLess;",
                "&lesssim;",
                "&LessSlantEqual;",
                "&LessTilde;",
                "&lfisht;",
                "&lfloor;",
                "&Lfr;",
                "&lfr;",
                "&lg;",
                "&lgE;",
                "&lHar;",
                "&lhard;",
                "&lharu;",
                "&lharul;",
                "&lhblk;",
                "&LJcy;",
                "&ljcy;",
                "&Ll;",
                "&ll;",
                "&llarr;",
                "&llcorner;",
                "&Lleftarrow;",
                "&llhard;",
                "&lltri;",
                "&Lmidot;",
                "&lmidot;",
                "&lmoust;",
                "&lmoustache;",
                "&lnap;",
                "&lnapprox;",
                "&lnE;",
                "&lne;",
                "&lneq;",
                "&lneqq;",
                "&lnsim;",
                "&loang;",
                "&loarr;",
                "&lobrk;",
                "&LongLeftArrow;",
                "&Longleftarrow;",
                "&longleftarrow;",
                "&LongLeftRightArrow;",
                "&Longleftrightarrow;",
                "&longleftrightarrow;",
                "&longmapsto;",
                "&LongRightArrow;",
                "&Longrightarrow;",
                "&longrightarrow;",
                "&looparrowleft;",
                "&looparrowright;",
                "&lopar;",
                "&Lopf;",
                "&lopf;",
                "&loplus;",
                "&lotimes;",
                "&lowast;",
                "&lowbar;",
                "&LowerLeftArrow;",
                "&LowerRightArrow;",
                "&loz;",
                "&lozenge;",
                "&lozf;",
                "&lpar;",
                "&lparlt;",
                "&lrarr;",
                "&lrcorner;",
                "&lrhar;",
                "&lrhard;",
                "&lrm;",
                "&lrtri;",
                "&lsaquo;",
                "&Lscr;",
                "&lscr;",
                "&Lsh;",
                "&lsh;",
                "&lsim;",
                "&lsime;",
                "&lsimg;",
                "&lsqb;",
                "&lsquo;",
                "&lsquor;",
                "&Lstrok;",
                "&lstrok;",
                "&LT",
                "&lt",
                "&LT;",
                "&Lt;",
                "&lt;",
                "&ltcc;",
                "&ltcir;",
                "&ltdot;",
                "&lthree;",
                "&ltimes;",
                "&ltlarr;",
                "&ltquest;",
                "&ltri;",
                "&ltrie;",
                "&ltrif;",
                "&ltrPar;",
                "&lurdshar;",
                "&luruhar;",
                "&lvertneqq;",
                "&lvnE;",
                "&macr",
                "&macr;",
                "&male;",
                "&malt;",
                "&maltese;",
                "&Map;",
                "&map;",
                "&mapsto;",
                "&mapstodown;",
                "&mapstoleft;",
                "&mapstoup;",
                "&marker;",
                "&mcomma;",
                "&Mcy;",
                "&mcy;",
                "&mdash;",
                "&mDDot;",
                "&measuredangle;",
                "&MediumSpace;",
                "&Mellintrf;",
                "&Mfr;",
                "&mfr;",
                "&mho;",
                "&micro",
                "&micro;",
                "&mid;",
                "&midast;",
                "&midcir;",
                "&middot",
                "&middot;",
                "&minus;",
                "&minusb;",
                "&minusd;",
                "&minusdu;",
                "&MinusPlus;",
                "&mlcp;",
                "&mldr;",
                "&mnplus;",
                "&models;",
                "&Mopf;",
                "&mopf;",
                "&mp;",
                "&Mscr;",
                "&mscr;",
                "&mstpos;",
                "&Mu;",
                "&mu;",
                "&multimap;",
                "&mumap;",
                "&nabla;",
                "&Nacute;",
                "&nacute;",
                "&nang;",
                "&nap;",
                "&napE;",
                "&napid;",
                "&napos;",
                "&napprox;",
                "&natur;",
                "&natural;",
                "&naturals;",
                "&nbsp",
                "&nbsp;",
                "&nbump;",
                "&nbumpe;",
                "&ncap;",
                "&Ncaron;",
                "&ncaron;",
                "&Ncedil;",
                "&ncedil;",
                "&ncong;",
                "&ncongdot;",
                "&ncup;",
                "&Ncy;",
                "&ncy;",
                "&ndash;",
                "&ne;",
                "&nearhk;",
                "&neArr;",
                "&nearr;",
                "&nearrow;",
                "&nedot;",
                "&NegativeMediumSpace;",
                "&NegativeThickSpace;",
                "&NegativeThinSpace;",
                "&NegativeVeryThinSpace;",
                "&nequiv;",
                "&nesear;",
                "&nesim;",
                "&NestedGreaterGreater;",
                "&NestedLessLess;",
                "&NewLine;",
                "&nexist;",
                "&nexists;",
                "&Nfr;",
                "&nfr;",
                "&ngE;",
                "&nge;",
                "&ngeq;",
                "&ngeqq;",
                "&ngeqslant;",
                "&nges;",
                "&nGg;",
                "&ngsim;",
                "&nGt;",
                "&ngt;",
                "&ngtr;",
                "&nGtv;",
                "&nhArr;",
                "&nharr;",
                "&nhpar;",
                "&ni;",
                "&nis;",
                "&nisd;",
                "&niv;",
                "&NJcy;",
                "&njcy;",
                "&nlArr;",
                "&nlarr;",
                "&nldr;",
                "&nlE;",
                "&nle;",
                "&nLeftarrow;",
                "&nleftarrow;",
                "&nLeftrightarrow;",
                "&nleftrightarrow;",
                "&nleq;",
                "&nleqq;",
                "&nleqslant;",
                "&nles;",
                "&nless;",
                "&nLl;",
                "&nlsim;",
                "&nLt;",
                "&nlt;",
                "&nltri;",
                "&nltrie;",
                "&nLtv;",
                "&nmid;",
                "&NoBreak;",
                "&NonBreakingSpace;",
                "&Nopf;",
                "&nopf;",
                "&not",
                "&Not;",
                "&not;",
                "&NotCongruent;",
                "&NotCupCap;",
                "&NotDoubleVerticalBar;",
                "&NotElement;",
                "&NotEqual;",
                "&NotEqualTilde;",
                "&NotExists;",
                "&NotGreater;",
                "&NotGreaterEqual;",
                "&NotGreaterFullEqual;",
                "&NotGreaterGreater;",
                "&NotGreaterLess;",
                "&NotGreaterSlantEqual;",
                "&NotGreaterTilde;",
                "&NotHumpDownHump;",
                "&NotHumpEqual;",
                "&notin;",
                "&notindot;",
                "&notinE;",
                "&notinva;",
                "&notinvb;",
                "&notinvc;",
                "&NotLeftTriangle;",
                "&NotLeftTriangleBar;",
                "&NotLeftTriangleEqual;",
                "&NotLess;",
                "&NotLessEqual;",
                "&NotLessGreater;",
                "&NotLessLess;",
                "&NotLessSlantEqual;",
                "&NotLessTilde;",
                "&NotNestedGreaterGreater;",
                "&NotNestedLessLess;",
                "&notni;",
                "&notniva;",
                "&notnivb;",
                "&notnivc;",
                "&NotPrecedes;",
                "&NotPrecedesEqual;",
                "&NotPrecedesSlantEqual;",
                "&NotReverseElement;",
                "&NotRightTriangle;",
                "&NotRightTriangleBar;",
                "&NotRightTriangleEqual;",
                "&NotSquareSubset;",
                "&NotSquareSubsetEqual;",
                "&NotSquareSuperset;",
                "&NotSquareSupersetEqual;",
                "&NotSubset;",
                "&NotSubsetEqual;",
                "&NotSucceeds;",
                "&NotSucceedsEqual;",
                "&NotSucceedsSlantEqual;",
                "&NotSucceedsTilde;",
                "&NotSuperset;",
                "&NotSupersetEqual;",
                "&NotTilde;",
                "&NotTildeEqual;",
                "&NotTildeFullEqual;",
                "&NotTildeTilde;",
                "&NotVerticalBar;",
                "&npar;",
                "&nparallel;",
                "&nparsl;",
                "&npart;",
                "&npolint;",
                "&npr;",
                "&nprcue;",
                "&npre;",
                "&nprec;",
                "&npreceq;",
                "&nrArr;",
                "&nrarr;",
                "&nrarrc;",
                "&nrarrw;",
                "&nRightarrow;",
                "&nrightarrow;",
                "&nrtri;",
                "&nrtrie;",
                "&nsc;",
                "&nsccue;",
                "&nsce;",
                "&Nscr;",
                "&nscr;",
                "&nshortmid;",
                "&nshortparallel;",
                "&nsim;",
                "&nsime;",
                "&nsimeq;",
                "&nsmid;",
                "&nspar;",
                "&nsqsube;",
                "&nsqsupe;",
                "&nsub;",
                "&nsubE;",
                "&nsube;",
                "&nsubset;",
                "&nsubseteq;",
                "&nsubseteqq;",
                "&nsucc;",
                "&nsucceq;",
                "&nsup;",
                "&nsupE;",
                "&nsupe;",
                "&nsupset;",
                "&nsupseteq;",
                "&nsupseteqq;",
                "&ntgl;",
                "&Ntilde",
                "&ntilde",
                "&Ntilde;",
                "&ntilde;",
                "&ntlg;",
                "&ntriangleleft;",
                "&ntrianglelefteq;",
                "&ntriangleright;",
                "&ntrianglerighteq;",
                "&Nu;",
                "&nu;",
                "&num;",
                "&numero;",
                "&numsp;",
                "&nvap;",
                "&nVDash;",
                "&nVdash;",
                "&nvDash;",
                "&nvdash;",
                "&nvge;",
                "&nvgt;",
                "&nvHarr;",
                "&nvinfin;",
                "&nvlArr;",
                "&nvle;",
                "&nvlt;",
                "&nvltrie;",
                "&nvrArr;",
                "&nvrtrie;",
                "&nvsim;",
                "&nwarhk;",
                "&nwArr;",
                "&nwarr;",
                "&nwarrow;",
                "&nwnear;",
                "&Oacute",
                "&oacute",
                "&Oacute;",
                "&oacute;",
                "&oast;",
                "&ocir;",
                "&Ocirc",
                "&ocirc",
                "&Ocirc;",
                "&ocirc;",
                "&Ocy;",
                "&ocy;",
                "&odash;",
                "&Odblac;",
                "&odblac;",
                "&odiv;",
                "&odot;",
                "&odsold;",
                "&OElig;",
                "&oelig;",
                "&ofcir;",
                "&Ofr;",
                "&ofr;",
                "&ogon;",
                "&Ograve",
                "&ograve",
                "&Ograve;",
                "&ograve;",
                "&ogt;",
                "&ohbar;",
                "&ohm;",
                "&oint;",
                "&olarr;",
                "&olcir;",
                "&olcross;",
                "&oline;",
                "&olt;",
                "&Omacr;",
                "&omacr;",
                "&Omega;",
                "&omega;",
                "&Omicron;",
                "&omicron;",
                "&omid;",
                "&ominus;",
                "&Oopf;",
                "&oopf;",
                "&opar;",
                "&OpenCurlyDoubleQuote;",
                "&OpenCurlyQuote;",
                "&operp;",
                "&oplus;",
                "&Or;",
                "&or;",
                "&orarr;",
                "&ord;",
                "&order;",
                "&orderof;",
                "&ordf",
                "&ordf;",
                "&ordm",
                "&ordm;",
                "&origof;",
                "&oror;",
                "&orslope;",
                "&orv;",
                "&oS;",
                "&Oscr;",
                "&oscr;",
                "&Oslash",
                "&oslash",
                "&Oslash;",
                "&oslash;",
                "&osol;",
                "&Otilde",
                "&otilde",
                "&Otilde;",
                "&otilde;",
                "&Otimes;",
                "&otimes;",
                "&otimesas;",
                "&Ouml",
                "&ouml",
                "&Ouml;",
                "&ouml;",
                "&ovbar;",
                "&OverBar;",
                "&OverBrace;",
                "&OverBracket;",
                "&OverParenthesis;",
                "&par;",
                "&para",
                "&para;",
                "&parallel;",
                "&parsim;",
                "&parsl;",
                "&part;",
                "&PartialD;",
                "&Pcy;",
                "&pcy;",
                "&percnt;",
                "&period;",
                "&permil;",
                "&perp;",
                "&pertenk;",
                "&Pfr;",
                "&pfr;",
                "&Phi;",
                "&phi;",
                "&phiv;",
                "&phmmat;",
                "&phone;",
                "&Pi;",
                "&pi;",
                "&pitchfork;",
                "&piv;",
                "&planck;",
                "&planckh;",
                "&plankv;",
                "&plus;",
                "&plusacir;",
                "&plusb;",
                "&pluscir;",
                "&plusdo;",
                "&plusdu;",
                "&pluse;",
                "&PlusMinus;",
                "&plusmn",
                "&plusmn;",
                "&plussim;",
                "&plustwo;",
                "&pm;",
                "&Poincareplane;",
                "&pointint;",
                "&Popf;",
                "&popf;",
                "&pound",
                "&pound;",
                "&Pr;",
                "&pr;",
                "&prap;",
                "&prcue;",
                "&prE;",
                "&pre;",
                "&prec;",
                "&precapprox;",
                "&preccurlyeq;",
                "&Precedes;",
                "&PrecedesEqual;",
                "&PrecedesSlantEqual;",
                "&PrecedesTilde;",
                "&preceq;",
                "&precnapprox;",
                "&precneqq;",
                "&precnsim;",
                "&precsim;",
                "&Prime;",
                "&prime;",
                "&primes;",
                "&prnap;",
                "&prnE;",
                "&prnsim;",
                "&prod;",
                "&Product;",
                "&profalar;",
                "&profline;",
                "&profsurf;",
                "&prop;",
                "&Proportion;",
                "&Proportional;",
                "&propto;",
                "&prsim;",
                "&prurel;",
                "&Pscr;",
                "&pscr;",
                "&Psi;",
                "&psi;",
                "&puncsp;",
                "&Qfr;",
                "&qfr;",
                "&qint;",
                "&Qopf;",
                "&qopf;",
                "&qprime;",
                "&Qscr;",
                "&qscr;",
                "&quaternions;",
                "&quatint;",
                "&quest;",
                "&questeq;",
                "&QUOT",
                "&quot",
                "&QUOT;",
                "&quot;",
                "&rAarr;",
                "&race;",
                "&Racute;",
                "&racute;",
                "&radic;",
                "&raemptyv;",
                "&Rang;",
                "&rang;",
                "&rangd;",
                "&range;",
                "&rangle;",
                "&raquo",
                "&raquo;",
                "&Rarr;",
                "&rArr;",
                "&rarr;",
                "&rarrap;",
                "&rarrb;",
                "&rarrbfs;",
                "&rarrc;",
                "&rarrfs;",
                "&rarrhk;",
                "&rarrlp;",
                "&rarrpl;",
                "&rarrsim;",
                "&Rarrtl;",
                "&rarrtl;",
                "&rarrw;",
                "&rAtail;",
                "&ratail;",
                "&ratio;",
                "&rationals;",
                "&RBarr;",
                "&rBarr;",
                "&rbarr;",
                "&rbbrk;",
                "&rbrace;",
                "&rbrack;",
                "&rbrke;",
                "&rbrksld;",
                "&rbrkslu;",
                "&Rcaron;",
                "&rcaron;",
                "&Rcedil;",
                "&rcedil;",
                "&rceil;",
                "&rcub;",
                "&Rcy;",
                "&rcy;",
                "&rdca;",
                "&rdldhar;",
                "&rdquo;",
                "&rdquor;",
                "&rdsh;",
                "&Re;",
                "&real;",
                "&realine;",
                "&realpart;",
                "&reals;",
                "&rect;",
                "&REG",
                "&reg",
                "&REG;",
                "&reg;",
                "&ReverseElement;",
                "&ReverseEquilibrium;",
                "&ReverseUpEquilibrium;",
                "&rfisht;",
                "&rfloor;",
                "&Rfr;",
                "&rfr;",
                "&rHar;",
                "&rhard;",
                "&rharu;",
                "&rharul;",
                "&Rho;",
                "&rho;",
                "&rhov;",
                "&RightAngleBracket;",
                "&RightArrow;",
                "&Rightarrow;",
                "&rightarrow;",
                "&RightArrowBar;",
                "&RightArrowLeftArrow;",
                "&rightarrowtail;",
                "&RightCeiling;",
                "&RightDoubleBracket;",
                "&RightDownTeeVector;",
                "&RightDownVector;",
                "&RightDownVectorBar;",
                "&RightFloor;",
                "&rightharpoondown;",
                "&rightharpoonup;",
                "&rightleftarrows;",
                "&rightleftharpoons;",
                "&rightrightarrows;",
                "&rightsquigarrow;",
                "&RightTee;",
                "&RightTeeArrow;",
                "&RightTeeVector;",
                "&rightthreetimes;",
                "&RightTriangle;",
                "&RightTriangleBar;",
                "&RightTriangleEqual;",
                "&RightUpDownVector;",
                "&RightUpTeeVector;",
                "&RightUpVector;",
                "&RightUpVectorBar;",
                "&RightVector;",
                "&RightVectorBar;",
                "&ring;",
                "&risingdotseq;",
                "&rlarr;",
                "&rlhar;",
                "&rlm;",
                "&rmoust;",
                "&rmoustache;",
                "&rnmid;",
                "&roang;",
                "&roarr;",
                "&robrk;",
                "&ropar;",
                "&Ropf;",
                "&ropf;",
                "&roplus;",
                "&rotimes;",
                "&RoundImplies;",
                "&rpar;",
                "&rpargt;",
                "&rppolint;",
                "&rrarr;",
                "&Rrightarrow;",
                "&rsaquo;",
                "&Rscr;",
                "&rscr;",
                "&Rsh;",
                "&rsh;",
                "&rsqb;",
                "&rsquo;",
                "&rsquor;",
                "&rthree;",
                "&rtimes;",
                "&rtri;",
                "&rtrie;",
                "&rtrif;",
                "&rtriltri;",
                "&RuleDelayed;",
                "&ruluhar;",
                "&rx;",
                "&Sacute;",
                "&sacute;",
                "&sbquo;",
                "&Sc;",
                "&sc;",
                "&scap;",
                "&Scaron;",
                "&scaron;",
                "&sccue;",
                "&scE;",
                "&sce;",
                "&Scedil;",
                "&scedil;",
                "&Scirc;",
                "&scirc;",
                "&scnap;",
                "&scnE;",
                "&scnsim;",
                "&scpolint;",
                "&scsim;",
                "&Scy;",
                "&scy;",
                "&sdot;",
                "&sdotb;",
                "&sdote;",
                "&searhk;",
                "&seArr;",
                "&searr;",
                "&searrow;",
                "&sect",
                "&sect;",
                "&semi;",
                "&seswar;",
                "&setminus;",
                "&setmn;",
                "&sext;",
                "&Sfr;",
                "&sfr;",
                "&sfrown;",
                "&sharp;",
                "&SHCHcy;",
                "&shchcy;",
                "&SHcy;",
                "&shcy;",
                "&ShortDownArrow;",
                "&ShortLeftArrow;",
                "&shortmid;",
                "&shortparallel;",
                "&ShortRightArrow;",
                "&ShortUpArrow;",
                "&shy",
                "&shy;",
                "&Sigma;",
                "&sigma;",
                "&sigmaf;",
                "&sigmav;",
                "&sim;",
                "&simdot;",
                "&sime;",
                "&simeq;",
                "&simg;",
                "&simgE;",
                "&siml;",
                "&simlE;",
                "&simne;",
                "&simplus;",
                "&simrarr;",
                "&slarr;",
                "&SmallCircle;",
                "&smallsetminus;",
                "&smashp;",
                "&smeparsl;",
                "&smid;",
                "&smile;",
                "&smt;",
                "&smte;",
                "&smtes;",
                "&SOFTcy;",
                "&softcy;",
                "&sol;",
                "&solb;",
                "&solbar;",
                "&Sopf;",
                "&sopf;",
                "&spades;",
                "&spadesuit;",
                "&spar;",
                "&sqcap;",
                "&sqcaps;",
                "&sqcup;",
                "&sqcups;",
                "&Sqrt;",
                "&sqsub;",
                "&sqsube;",
                "&sqsubset;",
                "&sqsubseteq;",
                "&sqsup;",
                "&sqsupe;",
                "&sqsupset;",
                "&sqsupseteq;",
                "&squ;",
                "&Square;",
                "&square;",
                "&SquareIntersection;",
                "&SquareSubset;",
                "&SquareSubsetEqual;",
                "&SquareSuperset;",
                "&SquareSupersetEqual;",
                "&SquareUnion;",
                "&squarf;",
                "&squf;",
                "&srarr;",
                "&Sscr;",
                "&sscr;",
                "&ssetmn;",
                "&ssmile;",
                "&sstarf;",
                "&Star;",
                "&star;",
                "&starf;",
                "&straightepsilon;",
                "&straightphi;",
                "&strns;",
                "&Sub;",
                "&sub;",
                "&subdot;",
                "&subE;",
                "&sube;",
                "&subedot;",
                "&submult;",
                "&subnE;",
                "&subne;",
                "&subplus;",
                "&subrarr;",
                "&Subset;",
                "&subset;",
                "&subseteq;",
                "&subseteqq;",
                "&SubsetEqual;",
                "&subsetneq;",
                "&subsetneqq;",
                "&subsim;",
                "&subsub;",
                "&subsup;",
                "&succ;",
                "&succapprox;",
                "&succcurlyeq;",
                "&Succeeds;",
                "&SucceedsEqual;",
                "&SucceedsSlantEqual;",
                "&SucceedsTilde;",
                "&succeq;",
                "&succnapprox;",
                "&succneqq;",
                "&succnsim;",
                "&succsim;",
                "&SuchThat;",
                "&Sum;",
                "&sum;",
                "&sung;",
                "&sup1",
                "&sup1;",
                "&sup2",
                "&sup2;",
                "&sup3",
                "&sup3;",
                "&Sup;",
                "&sup;",
                "&supdot;",
                "&supdsub;",
                "&supE;",
                "&supe;",
                "&supedot;",
                "&Superset;",
                "&SupersetEqual;",
                "&suphsol;",
                "&suphsub;",
                "&suplarr;",
                "&supmult;",
                "&supnE;",
                "&supne;",
                "&supplus;",
                "&Supset;",
                "&supset;",
                "&supseteq;",
                "&supseteqq;",
                "&supsetneq;",
                "&supsetneqq;",
                "&supsim;",
                "&supsub;",
                "&supsup;",
                "&swarhk;",
                "&swArr;",
                "&swarr;",
                "&swarrow;",
                "&swnwar;",
                "&szlig",
                "&szlig;",
                "&Tab;",
                "&target;",
                "&Tau;",
                "&tau;",
                "&tbrk;",
                "&Tcaron;",
                "&tcaron;",
                "&Tcedil;",
                "&tcedil;",
                "&Tcy;",
                "&tcy;",
                "&tdot;",
                "&telrec;",
                "&Tfr;",
                "&tfr;",
                "&there4;",
                "&Therefore;",
                "&therefore;",
                "&Theta;",
                "&theta;",
                "&thetasym;",
                "&thetav;",
                "&thickapprox;",
                "&thicksim;",
                "&ThickSpace;",
                "&thinsp;",
                "&ThinSpace;",
                "&thkap;",
                "&thksim;",
                "&THORN",
                "&thorn",
                "&THORN;",
                "&thorn;",
                "&Tilde;",
                "&tilde;",
                "&TildeEqual;",
                "&TildeFullEqual;",
                "&TildeTilde;",
                "&times",
                "&times;",
                "&timesb;",
                "&timesbar;",
                "&timesd;",
                "&tint;",
                "&toea;",
                "&top;",
                "&topbot;",
                "&topcir;",
                "&Topf;",
                "&topf;",
                "&topfork;",
                "&tosa;",
                "&tprime;",
                "&TRADE;",
                "&trade;",
                "&triangle;",
                "&triangledown;",
                "&triangleleft;",
                "&trianglelefteq;",
                "&triangleq;",
                "&triangleright;",
                "&trianglerighteq;",
                "&tridot;",
                "&trie;",
                "&triminus;",
                "&TripleDot;",
                "&triplus;",
                "&trisb;",
                "&tritime;",
                "&trpezium;",
                "&Tscr;",
                "&tscr;",
                "&TScy;",
                "&tscy;",
                "&TSHcy;",
                "&tshcy;",
                "&Tstrok;",
                "&tstrok;",
                "&twixt;",
                "&twoheadleftarrow;",
                "&twoheadrightarrow;",
                "&Uacute",
                "&uacute",
                "&Uacute;",
                "&uacute;",
                "&Uarr;",
                "&uArr;",
                "&uarr;",
                "&Uarrocir;",
                "&Ubrcy;",
                "&ubrcy;",
                "&Ubreve;",
                "&ubreve;",
                "&Ucirc",
                "&ucirc",
                "&Ucirc;",
                "&ucirc;",
                "&Ucy;",
                "&ucy;",
                "&udarr;",
                "&Udblac;",
                "&udblac;",
                "&udhar;",
                "&ufisht;",
                "&Ufr;",
                "&ufr;",
                "&Ugrave",
                "&ugrave",
                "&Ugrave;",
                "&ugrave;",
                "&uHar;",
                "&uharl;",
                "&uharr;",
                "&uhblk;",
                "&ulcorn;",
                "&ulcorner;",
                "&ulcrop;",
                "&ultri;",
                "&Umacr;",
                "&umacr;",
                "&uml",
                "&uml;",
                "&UnderBar;",
                "&UnderBrace;",
                "&UnderBracket;",
                "&UnderParenthesis;",
                "&Union;",
                "&UnionPlus;",
                "&Uogon;",
                "&uogon;",
                "&Uopf;",
                "&uopf;",
                "&UpArrow;",
                "&Uparrow;",
                "&uparrow;",
                "&UpArrowBar;",
                "&UpArrowDownArrow;",
                "&UpDownArrow;",
                "&Updownarrow;",
                "&updownarrow;",
                "&UpEquilibrium;",
                "&upharpoonleft;",
                "&upharpoonright;",
                "&uplus;",
                "&UpperLeftArrow;",
                "&UpperRightArrow;",
                "&Upsi;",
                "&upsi;",
                "&upsih;",
                "&Upsilon;",
                "&upsilon;",
                "&UpTee;",
                "&UpTeeArrow;",
                "&upuparrows;",
                "&urcorn;",
                "&urcorner;",
                "&urcrop;",
                "&Uring;",
                "&uring;",
                "&urtri;",
                "&Uscr;",
                "&uscr;",
                "&utdot;",
                "&Utilde;",
                "&utilde;",
                "&utri;",
                "&utrif;",
                "&uuarr;",
                "&Uuml",
                "&uuml",
                "&Uuml;",
                "&uuml;",
                "&uwangle;",
                "&vangrt;",
                "&varepsilon;",
                "&varkappa;",
                "&varnothing;",
                "&varphi;",
                "&varpi;",
                "&varpropto;",
                "&vArr;",
                "&varr;",
                "&varrho;",
                "&varsigma;",
                "&varsubsetneq;",
                "&varsubsetneqq;",
                "&varsupsetneq;",
                "&varsupsetneqq;",
                "&vartheta;",
                "&vartriangleleft;",
                "&vartriangleright;",
                "&Vbar;",
                "&vBar;",
                "&vBarv;",
                "&Vcy;",
                "&vcy;",
                "&VDash;",
                "&Vdash;",
                "&vDash;",
                "&vdash;",
                "&Vdashl;",
                "&Vee;",
                "&vee;",
                "&veebar;",
                "&veeeq;",
                "&vellip;",
                "&Verbar;",
                "&verbar;",
                "&Vert;",
                "&vert;",
                "&VerticalBar;",
                "&VerticalLine;",
                "&VerticalSeparator;",
                "&VerticalTilde;",
                "&VeryThinSpace;",
                "&Vfr;",
                "&vfr;",
                "&vltri;",
                "&vnsub;",
                "&vnsup;",
                "&Vopf;",
                "&vopf;",
                "&vprop;",
                "&vrtri;",
                "&Vscr;",
                "&vscr;",
                "&vsubnE;",
                "&vsubne;",
                "&vsupnE;",
                "&vsupne;",
                "&Vvdash;",
                "&vzigzag;",
                "&Wcirc;",
                "&wcirc;",
                "&wedbar;",
                "&Wedge;",
                "&wedge;",
                "&wedgeq;",
                "&weierp;",
                "&Wfr;",
                "&wfr;",
                "&Wopf;",
                "&wopf;",
                "&wp;",
                "&wr;",
                "&wreath;",
                "&Wscr;",
                "&wscr;",
                "&xcap;",
                "&xcirc;",
                "&xcup;",
                "&xdtri;",
                "&Xfr;",
                "&xfr;",
                "&xhArr;",
                "&xharr;",
                "&Xi;",
                "&xi;",
                "&xlArr;",
                "&xlarr;",
                "&xmap;",
                "&xnis;",
                "&xodot;",
                "&Xopf;",
                "&xopf;",
                "&xoplus;",
                "&xotime;",
                "&xrArr;",
                "&xrarr;",
                "&Xscr;",
                "&xscr;",
                "&xsqcup;",
                "&xuplus;",
                "&xutri;",
                "&xvee;",
                "&xwedge;",
                "&Yacute",
                "&yacute",
                "&Yacute;",
                "&yacute;",
                "&YAcy;",
                "&yacy;",
                "&Ycirc;",
                "&ycirc;",
                "&Ycy;",
                "&ycy;",
                "&yen",
                "&yen;",
                "&Yfr;",
                "&yfr;",
                "&YIcy;",
                "&yicy;",
                "&Yopf;",
                "&yopf;",
                "&Yscr;",
                "&yscr;",
                "&YUcy;",
                "&yucy;",
                "&yuml",
                "&Yuml;",
                "&yuml;",
                "&Zacute;",
                "&zacute;",
                "&Zcaron;",
                "&zcaron;",
                "&Zcy;",
                "&zcy;",
                "&Zdot;",
                "&zdot;",
                "&zeetrf;",
                "&ZeroWidthSpace;",
                "&Zeta;",
                "&zeta;",
                "&Zfr;",
                "&zfr;",
                "&ZHcy;",
                "&zhcy;",
                "&zigrarr;",
                "&Zopf;",
                "&zopf;",
                "&Zscr;",
                "&zscr;",
                "&zwj;",
                "&zwnj;"
            ];
            exports.bundledElements = bundledElements;
            exports.entities = entities;
            exports.html5 = html5;
            //# sourceMappingURL=elements.js.map
            /***/ 
        }),
        /***/ 9886: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var coreNodejs = __nccwpck_require__(2687);
            var core = __nccwpck_require__(2110);
            var cli = __nccwpck_require__(937);
            var metaHelper = __nccwpck_require__(9800);
            __nccwpck_require__(7561);
            __nccwpck_require__(9411);
            __nccwpck_require__(5215);
            __nccwpck_require__(2426);
            __nccwpck_require__(6323);
            __nccwpck_require__(6420);
            __nccwpck_require__(7147);
            __nccwpck_require__(7963);
            __nccwpck_require__(8902);
            __nccwpck_require__(1322);
            __nccwpck_require__(6962);
            __nccwpck_require__(1383);
            __nccwpck_require__(8211);
            __nccwpck_require__(1230);
            __nccwpck_require__(9646);
            exports.FileSystemConfigLoader = coreNodejs.FileSystemConfigLoader;
            exports.compatibilityCheck = coreNodejs.compatibilityCheck;
            exports.nodejsResolver = coreNodejs.nodejsResolver;
            exports.Attribute = core.Attribute;
            exports.Config = core.Config;
            exports.ConfigError = core.ConfigError;
            exports.ConfigLoader = core.ConfigLoader;
            exports.DOMNode = core.DOMNode;
            exports.DOMTokenList = core.DOMTokenList;
            exports.DOMTree = core.DOMTree;
            exports.DynamicValue = core.DynamicValue;
            exports.EventHandler = core.EventHandler;
            exports.HtmlElement = core.HtmlElement;
            exports.HtmlValidate = core.HtmlValidate;
            exports.MetaCopyableProperty = core.MetaCopyableProperty;
            exports.MetaTable = core.MetaTable;
            exports.NestedError = core.NestedError;
            Object.defineProperty(exports, "NodeClosed", ({
                enumerable: true,
                get: function () { return core.NodeClosed; }
            }));
            Object.defineProperty(exports, "NodeType", ({
                enumerable: true,
                get: function () { return core.NodeType; }
            }));
            exports.Parser = core.Parser;
            exports.Reporter = core.Reporter;
            exports.ResolvedConfig = core.ResolvedConfig;
            exports.Rule = core.Rule;
            exports.SchemaValidationError = core.SchemaValidationError;
            Object.defineProperty(exports, "Severity", ({
                enumerable: true,
                get: function () { return core.Severity; }
            }));
            exports.StaticConfigLoader = core.StaticConfigLoader;
            Object.defineProperty(exports, "TextClassification", ({
                enumerable: true,
                get: function () { return core.TextClassification; }
            }));
            Object.defineProperty(exports, "TextContent", ({
                enumerable: true,
                get: function () { return core.TextContent; }
            }));
            exports.TextNode = core.TextNode;
            exports.UserError = core.UserError;
            exports.Validator = core.Validator;
            exports.WrappedError = core.WrappedError;
            exports.classifyNodeText = core.classifyNodeText;
            exports.configPresets = core.Presets;
            exports.definePlugin = core.definePlugin;
            exports.formatterFactory = core.getFormatter;
            exports.keywordPatternMatcher = core.keywordPatternMatcher;
            exports.ruleExists = core.ruleExists;
            exports.sliceLocation = core.sliceLocation;
            exports.staticResolver = core.staticResolver;
            exports.version = core.version;
            exports.CLI = cli.CLI;
            exports.defineMetadata = metaHelper.defineMetadata;
            exports.metadataHelper = metaHelper.metadataHelper;
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 9800: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var utils_naturalJoin = __nccwpck_require__(8902);
            /**
             * Helper function to assist IDE with completion and type-checking.
             *
             * @public
             */
            function defineMetadata(metatable) {
                return metatable;
            }
            /**
             * @internal
             */
            function allowedIfAttributeIsPresent() {
                var attr = [];
                for (var _1 = 0; _1 < arguments.length; _1++) {
                    attr[_1] = arguments[_1];
                }
                return function (node) {
                    if (attr.some(function (it) { return node.hasAttribute(it); })) {
                        return null;
                    }
                    var expected = utils_naturalJoin.naturalJoin(attr.map(function (it) { return "\"".concat(it, "\""); }));
                    return "requires ".concat(expected, " attribute to be present");
                };
            }
            /**
             * @internal
             */
            function allowedIfAttributeIsAbsent() {
                var attr = [];
                for (var _1 = 0; _1 < arguments.length; _1++) {
                    attr[_1] = arguments[_1];
                }
                return function (node) {
                    var present = attr.filter(function (it) { return node.hasAttribute(it); });
                    if (present.length === 0) {
                        return null;
                    }
                    var expected = utils_naturalJoin.naturalJoin(present.map(function (it) { return "\"".concat(it, "\""); }));
                    return "cannot be used at the same time as ".concat(expected);
                };
            }
            /**
             * @internal
             */
            function allowedIfAttributeHasValue(key, expectedValue, _1) {
                var _2 = _1 === void 0 ? {} : _1, defaultValue = _2.defaultValue;
                return function (node) {
                    var attr = node.getAttribute(key);
                    if (attr && typeof attr !== "string") {
                        return null;
                    }
                    var actualValue = attr ? attr : defaultValue;
                    if (actualValue && expectedValue.includes(actualValue.toLocaleLowerCase())) {
                        return null;
                    }
                    var expected = utils_naturalJoin.naturalJoin(expectedValue.map(function (it) { return "\"".concat(it, "\""); }));
                    return "\"".concat(key, "\" attribute must be ").concat(expected);
                };
            }
            /**
             * @internal
             */
            function allowedIfParentIsPresent() {
                var tags = [];
                for (var _1 = 0; _1 < arguments.length; _1++) {
                    tags[_1] = arguments[_1];
                }
                return function (node) {
                    var match = tags.some(function (it) { return node.closest(it); });
                    if (match) {
                        return null;
                    }
                    var expected = utils_naturalJoin.naturalJoin(tags.map(function (it) { return "<".concat(it, ">"); }));
                    return "requires ".concat(expected, " as parent");
                };
            }
            /**
             * @public
             */
            var metadataHelper = {
                allowedIfAttributeIsPresent: allowedIfAttributeIsPresent,
                allowedIfAttributeIsAbsent: allowedIfAttributeIsAbsent,
                allowedIfAttributeHasValue: allowedIfAttributeHasValue,
                allowedIfParentIsPresent: allowedIfParentIsPresent
            };
            exports.defineMetadata = defineMetadata;
            exports.metadataHelper = metadataHelper;
            //# sourceMappingURL=meta-helper.js.map
            /***/ 
        }),
        /***/ 8902: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            /**
             * Joins a list of words into natural language.
             *
             * - `["foo"]` becomes `"foo"`
             * - `["foo", "bar"]` becomes `"foo or bar"`
             * - `["foo", "bar", "baz"]` becomes `"foo, bar or baz"`
             * - and so on...
             *
             * @internal
             * @param values - List of words to join
             * @param conjunction - Conjunction for the last element.
             * @returns String with the words naturally joined with a conjunction.
             */
            function naturalJoin(values, conjunction) {
                if (conjunction === void 0) { conjunction = "or"; }
                switch (values.length) {
                    case 0:
                        return "";
                    case 1:
                        return values[0];
                    case 2:
                        return "".concat(values[0], " ").concat(conjunction, " ").concat(values[1]);
                    default:
                        return "".concat(values.slice(0, -1).join(", "), " ").concat(conjunction, " ").concat(values.slice(-1)[0]);
                }
            }
            exports.naturalJoin = naturalJoin;
            //# sourceMappingURL=natural-join.js.map
            /***/ 
        }),
        /***/ 903: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.assertValidPattern = void 0;
            var MAX_PATTERN_LENGTH = 1024 * 64;
            var assertValidPattern = function (pattern) {
                if (typeof pattern !== 'string') {
                    throw new TypeError('invalid pattern');
                }
                if (pattern.length > MAX_PATTERN_LENGTH) {
                    throw new TypeError('pattern is too long');
                }
            };
            exports.assertValidPattern = assertValidPattern;
            //# sourceMappingURL=assert-valid-pattern.js.map
            /***/ 
        }),
        /***/ 3839: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var _AST_instances, _1, _AST_root, _AST_hasMagic, _AST_uflag, _AST_parts, _AST_parent, _AST_parentIndex, _AST_negs, _AST_filledNegs, _AST_options, _AST_toString, _AST_emptyExt, _AST_fillNegs, _AST_parseAST, _AST_partsToRegExp, _AST_parseGlob;
            // parse a single path portion
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.AST = void 0;
            var brace_expressions_js_1 = __nccwpck_require__(5822);
            var unescape_js_1 = __nccwpck_require__(7305);
            var types = new Set(['!', '?', '+', '*', '@']);
            var isExtglobType = function (c) { return types.has(c); };
            // Patterns that get prepended to bind to the start of either the
            // entire string, or just a single path portion, to prevent dots
            // and/or traversal patterns, when needed.
            // Exts don't need the ^ or / bit, because the root binds that already.
            var startNoTraversal = '(?!(?:^|/)\\.\\.?(?:$|/))';
            var startNoDot = '(?!\\.)';
            // characters that indicate a start of pattern needs the "no dots" bit,
            // because a dot *might* be matched. ( is not in the list, because in
            // the case of a child extglob, it will handle the prevention itself.
            var addPatternStart = new Set(['[', '.']);
            // cases where traversal is A-OK, no dot prevention needed
            var justDots = new Set(['..', '.']);
            var reSpecials = new Set('().*{}+?[]^$\\!');
            var regExpEscape = function (s) { return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&'); };
            // any single thing other than /
            var qmark = '[^/]';
            // * => any number of characters
            var star = qmark + '*?';
            // use + when we need to ensure that *something* matches, because the * is
            // the only thing in the path portion.
            var starNoEmpty = qmark + '+?';
            // remove the \ chars that we added if we end up doing a nonmagic compare
            // const deslash = (s: string) => s.replace(/\\(.)/g, '$1')
            var AST = /** @class */ (function () {
                function AST(type, parent, options) {
                    if (options === void 0) { options = {}; }
                    _AST_instances.add(this);
                    _AST_root.set(this, void 0);
                    _AST_hasMagic.set(this, void 0);
                    _AST_uflag.set(this, false);
                    _AST_parts.set(this, []);
                    _AST_parent.set(this, void 0);
                    _AST_parentIndex.set(this, void 0);
                    _AST_negs.set(this, void 0);
                    _AST_filledNegs.set(this, false);
                    _AST_options.set(this, void 0);
                    _AST_toString.set(this, void 0);
                    // set to true if it's an extglob with no children
                    // (which really means one child of '')
                    _AST_emptyExt.set(this, false);
                    this.type = type;
                    // extglobs are inherently magical
                    if (type)
                        __classPrivateFieldSet(this, _AST_hasMagic, true, "f");
                    __classPrivateFieldSet(this, _AST_parent, parent, "f");
                    __classPrivateFieldSet(this, _AST_root, __classPrivateFieldGet(this, _AST_parent, "f") ? __classPrivateFieldGet(__classPrivateFieldGet(this, _AST_parent, "f"), _AST_root, "f") : this, "f");
                    __classPrivateFieldSet(this, _AST_options, __classPrivateFieldGet(this, _AST_root, "f") === this ? options : __classPrivateFieldGet(__classPrivateFieldGet(this, _AST_root, "f"), _AST_options, "f"), "f");
                    __classPrivateFieldSet(this, _AST_negs, __classPrivateFieldGet(this, _AST_root, "f") === this ? [] : __classPrivateFieldGet(__classPrivateFieldGet(this, _AST_root, "f"), _AST_negs, "f"), "f");
                    if (type === '!' && !__classPrivateFieldGet(__classPrivateFieldGet(this, _AST_root, "f"), _AST_filledNegs, "f"))
                        __classPrivateFieldGet(this, _AST_negs, "f").push(this);
                    __classPrivateFieldSet(this, _AST_parentIndex, __classPrivateFieldGet(this, _AST_parent, "f") ? __classPrivateFieldGet(__classPrivateFieldGet(this, _AST_parent, "f"), _AST_parts, "f").length : 0, "f");
                }
                Object.defineProperty(AST.prototype, "hasMagic", {
                    get: function () {
                        /* c8 ignore start */
                        if (__classPrivateFieldGet(this, _AST_hasMagic, "f") !== undefined)
                            return __classPrivateFieldGet(this, _AST_hasMagic, "f");
                        /* c8 ignore stop */
                        for (var _2 = 0, _3 = __classPrivateFieldGet(this, _AST_parts, "f"); _2 < _3.length; _2++) {
                            var p = _3[_2];
                            if (typeof p === 'string')
                                continue;
                            if (p.type || p.hasMagic)
                                return (__classPrivateFieldSet(this, _AST_hasMagic, true, "f"));
                        }
                        // note: will be undefined until we generate the regexp src and find out
                        return __classPrivateFieldGet(this, _AST_hasMagic, "f");
                    },
                    enumerable: false,
                    configurable: true
                });
                // reconstructs the pattern
                AST.prototype.toString = function () {
                    if (__classPrivateFieldGet(this, _AST_toString, "f") !== undefined)
                        return __classPrivateFieldGet(this, _AST_toString, "f");
                    if (!this.type) {
                        return (__classPrivateFieldSet(this, _AST_toString, __classPrivateFieldGet(this, _AST_parts, "f").map(function (p) { return String(p); }).join(''), "f"));
                    }
                    else {
                        return (__classPrivateFieldSet(this, _AST_toString, this.type + '(' + __classPrivateFieldGet(this, _AST_parts, "f").map(function (p) { return String(p); }).join('|') + ')', "f"));
                    }
                };
                AST.prototype.push = function () {
                    var parts = [];
                    for (var _2 = 0; _2 < arguments.length; _2++) {
                        parts[_2] = arguments[_2];
                    }
                    for (var _3 = 0, parts_2 = parts; _3 < parts_2.length; _3++) {
                        var p = parts_2[_3];
                        if (p === '')
                            continue;
                        /* c8 ignore start */
                        if (typeof p !== 'string' && !(p instanceof AST && __classPrivateFieldGet(p, _AST_parent, "f") === this)) {
                            throw new Error('invalid part: ' + p);
                        }
                        /* c8 ignore stop */
                        __classPrivateFieldGet(this, _AST_parts, "f").push(p);
                    }
                };
                AST.prototype.toJSON = function () {
                    var _2;
                    var ret = this.type === null
                        ? __classPrivateFieldGet(this, _AST_parts, "f").slice().map(function (p) { return (typeof p === 'string' ? p : p.toJSON()); })
                        : __spreadArray([this.type], __classPrivateFieldGet(this, _AST_parts, "f").map(function (p) { return p.toJSON(); }), true);
                    if (this.isStart() && !this.type)
                        ret.unshift([]);
                    if (this.isEnd() &&
                        (this === __classPrivateFieldGet(this, _AST_root, "f") ||
                            (__classPrivateFieldGet(__classPrivateFieldGet(this, _AST_root, "f"), _AST_filledNegs, "f") && ((_2 = __classPrivateFieldGet(this, _AST_parent, "f")) === null || _2 === void 0 ? void 0 : _2.type) === '!'))) {
                        ret.push({});
                    }
                    return ret;
                };
                AST.prototype.isStart = function () {
                    var _2;
                    if (__classPrivateFieldGet(this, _AST_root, "f") === this)
                        return true;
                    // if (this.type) return !!this.#parent?.isStart()
                    if (!((_2 = __classPrivateFieldGet(this, _AST_parent, "f")) === null || _2 === void 0 ? void 0 : _2.isStart()))
                        return false;
                    if (__classPrivateFieldGet(this, _AST_parentIndex, "f") === 0)
                        return true;
                    // if everything AHEAD of this is a negation, then it's still the "start"
                    var p = __classPrivateFieldGet(this, _AST_parent, "f");
                    for (var i = 0; i < __classPrivateFieldGet(this, _AST_parentIndex, "f"); i++) {
                        var pp = __classPrivateFieldGet(p, _AST_parts, "f")[i];
                        if (!(pp instanceof AST && pp.type === '!')) {
                            return false;
                        }
                    }
                    return true;
                };
                AST.prototype.isEnd = function () {
                    var _2, _3, _4;
                    if (__classPrivateFieldGet(this, _AST_root, "f") === this)
                        return true;
                    if (((_2 = __classPrivateFieldGet(this, _AST_parent, "f")) === null || _2 === void 0 ? void 0 : _2.type) === '!')
                        return true;
                    if (!((_3 = __classPrivateFieldGet(this, _AST_parent, "f")) === null || _3 === void 0 ? void 0 : _3.isEnd()))
                        return false;
                    if (!this.type)
                        return (_4 = __classPrivateFieldGet(this, _AST_parent, "f")) === null || _4 === void 0 ? void 0 : _4.isEnd();
                    // if not root, it'll always have a parent
                    /* c8 ignore start */
                    var pl = __classPrivateFieldGet(this, _AST_parent, "f") ? __classPrivateFieldGet(__classPrivateFieldGet(this, _AST_parent, "f"), _AST_parts, "f").length : 0;
                    /* c8 ignore stop */
                    return __classPrivateFieldGet(this, _AST_parentIndex, "f") === pl - 1;
                };
                AST.prototype.copyIn = function (part) {
                    if (typeof part === 'string')
                        this.push(part);
                    else
                        this.push(part.clone(this));
                };
                AST.prototype.clone = function (parent) {
                    var c = new AST(this.type, parent);
                    for (var _2 = 0, _3 = __classPrivateFieldGet(this, _AST_parts, "f"); _2 < _3.length; _2++) {
                        var p = _3[_2];
                        c.copyIn(p);
                    }
                    return c;
                };
                AST.fromGlob = function (pattern, options) {
                    if (options === void 0) { options = {}; }
                    var ast = new AST(null, undefined, options);
                    __classPrivateFieldGet(AST, _1, "m", _AST_parseAST).call(AST, pattern, ast, 0, options);
                    return ast;
                };
                // returns the regular expression if there's magic, or the unescaped
                // string if not.
                AST.prototype.toMMPattern = function () {
                    // should only be called on root
                    /* c8 ignore start */
                    if (this !== __classPrivateFieldGet(this, _AST_root, "f"))
                        return __classPrivateFieldGet(this, _AST_root, "f").toMMPattern();
                    /* c8 ignore stop */
                    var glob = this.toString();
                    var _2 = this.toRegExpSource(), re = _2[0], body = _2[1], hasMagic = _2[2], uflag = _2[3];
                    // if we're in nocase mode, and not nocaseMagicOnly, then we do
                    // still need a regular expression if we have to case-insensitively
                    // match capital/lowercase characters.
                    var anyMagic = hasMagic ||
                        __classPrivateFieldGet(this, _AST_hasMagic, "f") ||
                        (__classPrivateFieldGet(this, _AST_options, "f").nocase &&
                            !__classPrivateFieldGet(this, _AST_options, "f").nocaseMagicOnly &&
                            glob.toUpperCase() !== glob.toLowerCase());
                    if (!anyMagic) {
                        return body;
                    }
                    var flags = (__classPrivateFieldGet(this, _AST_options, "f").nocase ? 'i' : '') + (uflag ? 'u' : '');
                    return Object.assign(new RegExp("^".concat(re, "$"), flags), {
                        _src: re,
                        _glob: glob
                    });
                };
                // returns the string match, the regexp source, whether there's magic
                // in the regexp (so a regular expression is required) and whether or
                // not the uflag is needed for the regular expression (for posix classes)
                // TODO: instead of injecting the start/end at this point, just return
                // the BODY of the regexp, along with the start/end portions suitable
                // for binding the start/end in either a joined full-path makeRe context
                // (where we bind to (^|/), or a standalone matchPart context (where
                // we bind to ^, and not /).  Otherwise slashes get duped!
                //
                // In part-matching mode, the start is:
                // - if not isStart: nothing
                // - if traversal possible, but not allowed: ^(?!\.\.?$)
                // - if dots allowed or not possible: ^
                // - if dots possible and not allowed: ^(?!\.)
                // end is:
                // - if not isEnd(): nothing
                // - else: $
                //
                // In full-path matching mode, we put the slash at the START of the
                // pattern, so start is:
                // - if first pattern: same as part-matching mode
                // - if not isStart(): nothing
                // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
                // - if dots allowed or not possible: /
                // - if dots possible and not allowed: /(?!\.)
                // end is:
                // - if last pattern, same as part-matching mode
                // - else nothing
                //
                // Always put the (?:$|/) on negated tails, though, because that has to be
                // there to bind the end of the negated pattern portion, and it's easier to
                // just stick it in now rather than try to inject it later in the middle of
                // the pattern.
                //
                // We can just always return the same end, and leave it up to the caller
                // to know whether it's going to be used joined or in parts.
                // And, if the start is adjusted slightly, can do the same there:
                // - if not isStart: nothing
                // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
                // - if dots allowed or not possible: (?:/|^)
                // - if dots possible and not allowed: (?:/|^)(?!\.)
                //
                // But it's better to have a simpler binding without a conditional, for
                // performance, so probably better to return both start options.
                //
                // Then the caller just ignores the end if it's not the first pattern,
                // and the start always gets applied.
                //
                // But that's always going to be $ if it's the ending pattern, or nothing,
                // so the caller can just attach $ at the end of the pattern when building.
                //
                // So the todo is:
                // - better detect what kind of start is needed
                // - return both flavors of starting pattern
                // - attach $ at the end of the pattern when creating the actual RegExp
                //
                // Ah, but wait, no, that all only applies to the root when the first pattern
                // is not an extglob. If the first pattern IS an extglob, then we need all
                // that dot prevention biz to live in the extglob portions, because eg
                // +(*|.x*) can match .xy but not .yx.
                //
                // So, return the two flavors if it's #root and the first child is not an
                // AST, otherwise leave it to the child AST to handle it, and there,
                // use the (?:^|/) style of start binding.
                //
                // Even simplified further:
                // - Since the start for a join is eg /(?!\.) and the start for a part
                // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
                // or start or whatever) and prepend ^ or / at the Regexp construction.
                AST.prototype.toRegExpSource = function (allowDot) {
                    var _this_1 = this;
                    var _2;
                    var dot = allowDot !== null && allowDot !== void 0 ? allowDot : !!__classPrivateFieldGet(this, _AST_options, "f").dot;
                    if (__classPrivateFieldGet(this, _AST_root, "f") === this)
                        __classPrivateFieldGet(this, _AST_instances, "m", _AST_fillNegs).call(this);
                    if (!this.type) {
                        var noEmpty_1 = this.isStart() && this.isEnd();
                        var src = __classPrivateFieldGet(this, _AST_parts, "f")
                            .map(function (p) {
                            var _2 = typeof p === 'string'
                                ? __classPrivateFieldGet(AST, _1, "m", _AST_parseGlob).call(AST, p, __classPrivateFieldGet(_this_1, _AST_hasMagic, "f"), noEmpty_1)
                                : p.toRegExpSource(allowDot), re = _2[0], _ = _2[1], hasMagic = _2[2], uflag = _2[3];
                            __classPrivateFieldSet(_this_1, _AST_hasMagic, __classPrivateFieldGet(_this_1, _AST_hasMagic, "f") || hasMagic, "f");
                            __classPrivateFieldSet(_this_1, _AST_uflag, __classPrivateFieldGet(_this_1, _AST_uflag, "f") || uflag, "f");
                            return re;
                        })
                            .join('');
                        var start_1 = '';
                        if (this.isStart()) {
                            if (typeof __classPrivateFieldGet(this, _AST_parts, "f")[0] === 'string') {
                                // this is the string that will match the start of the pattern,
                                // so we need to protect against dots and such.
                                // '.' and '..' cannot match unless the pattern is that exactly,
                                // even if it starts with . or dot:true is set.
                                var dotTravAllowed = __classPrivateFieldGet(this, _AST_parts, "f").length === 1 && justDots.has(__classPrivateFieldGet(this, _AST_parts, "f")[0]);
                                if (!dotTravAllowed) {
                                    var aps = addPatternStart;
                                    // check if we have a possibility of matching . or ..,
                                    // and prevent that.
                                    var needNoTrav = 
                                    // dots are allowed, and the pattern starts with [ or .
                                    (dot && aps.has(src.charAt(0))) ||
                                        // the pattern starts with \., and then [ or .
                                        (src.startsWith('\\.') && aps.has(src.charAt(2))) ||
                                        // the pattern starts with \.\., and then [ or .
                                        (src.startsWith('\\.\\.') && aps.has(src.charAt(4)));
                                    // no need to prevent dots if it can't match a dot, or if a
                                    // sub-pattern will be preventing it anyway.
                                    var needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
                                    start_1 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';
                                }
                            }
                        }
                        // append the "end of path portion" pattern to negation tails
                        var end = '';
                        if (this.isEnd() &&
                            __classPrivateFieldGet(__classPrivateFieldGet(this, _AST_root, "f"), _AST_filledNegs, "f") &&
                            ((_2 = __classPrivateFieldGet(this, _AST_parent, "f")) === null || _2 === void 0 ? void 0 : _2.type) === '!') {
                            end = '(?:$|\\/)';
                        }
                        var final_1 = start_1 + src + end;
                        return [
                            final_1,
                            (0, unescape_js_1.unescape)(src),
                            (__classPrivateFieldSet(this, _AST_hasMagic, !!__classPrivateFieldGet(this, _AST_hasMagic, "f"), "f")),
                            __classPrivateFieldGet(this, _AST_uflag, "f"),
                        ];
                    }
                    // We need to calculate the body *twice* if it's a repeat pattern
                    // at the start, once in nodot mode, then again in dot mode, so a
                    // pattern like *(?) can match 'x.y'
                    var repeated = this.type === '*' || this.type === '+';
                    // some kind of extglob
                    var start = this.type === '!' ? '(?:(?!(?:' : '(?:';
                    var body = __classPrivateFieldGet(this, _AST_instances, "m", _AST_partsToRegExp).call(this, dot);
                    if (this.isStart() && this.isEnd() && !body && this.type !== '!') {
                        // invalid extglob, has to at least be *something* present, if it's
                        // the entire path portion.
                        var s = this.toString();
                        __classPrivateFieldSet(this, _AST_parts, [s], "f");
                        this.type = null;
                        __classPrivateFieldSet(this, _AST_hasMagic, undefined, "f");
                        return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];
                    }
                    // XXX abstract out this map method
                    var bodyDotAllowed = !repeated || allowDot || dot || !startNoDot
                        ? ''
                        : __classPrivateFieldGet(this, _AST_instances, "m", _AST_partsToRegExp).call(this, true);
                    if (bodyDotAllowed === body) {
                        bodyDotAllowed = '';
                    }
                    if (bodyDotAllowed) {
                        body = "(?:".concat(body, ")(?:").concat(bodyDotAllowed, ")*?");
                    }
                    // an empty !() is exactly equivalent to a starNoEmpty
                    var final = '';
                    if (this.type === '!' && __classPrivateFieldGet(this, _AST_emptyExt, "f")) {
                        final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;
                    }
                    else {
                        var close_2 = this.type === '!'
                            ? // !() must match something,but !(x) can match ''
                                '))' +
                                    (this.isStart() && !dot && !allowDot ? startNoDot : '') +
                                    star +
                                    ')'
                            : this.type === '@'
                                ? ')'
                                : this.type === '?'
                                    ? ')?'
                                    : this.type === '+' && bodyDotAllowed
                                        ? ')'
                                        : this.type === '*' && bodyDotAllowed
                                            ? ")?"
                                            : ")".concat(this.type);
                        final = start + body + close_2;
                    }
                    return [
                        final,
                        (0, unescape_js_1.unescape)(body),
                        (__classPrivateFieldSet(this, _AST_hasMagic, !!__classPrivateFieldGet(this, _AST_hasMagic, "f"), "f")),
                        __classPrivateFieldGet(this, _AST_uflag, "f"),
                    ];
                };
                return AST;
            }());
            _1 = AST, _AST_root = new WeakMap(), _AST_hasMagic = new WeakMap(), _AST_uflag = new WeakMap(), _AST_parts = new WeakMap(), _AST_parent = new WeakMap(), _AST_parentIndex = new WeakMap(), _AST_negs = new WeakMap(), _AST_filledNegs = new WeakMap(), _AST_options = new WeakMap(), _AST_toString = new WeakMap(), _AST_emptyExt = new WeakMap(), _AST_instances = new WeakSet(), _AST_fillNegs = function _AST_fillNegs() {
                /* c8 ignore start */
                if (this !== __classPrivateFieldGet(this, _AST_root, "f"))
                    throw new Error('should only call on root');
                if (__classPrivateFieldGet(this, _AST_filledNegs, "f"))
                    return this;
                /* c8 ignore stop */
                // call toString() once to fill this out
                this.toString();
                __classPrivateFieldSet(this, _AST_filledNegs, true, "f");
                var n;
                while ((n = __classPrivateFieldGet(this, _AST_negs, "f").pop())) {
                    if (n.type !== '!')
                        continue;
                    // walk up the tree, appending everthing that comes AFTER parentIndex
                    var p = n;
                    var pp = __classPrivateFieldGet(p, _AST_parent, "f");
                    while (pp) {
                        for (var i = __classPrivateFieldGet(p, _AST_parentIndex, "f") + 1; !pp.type && i < __classPrivateFieldGet(pp, _AST_parts, "f").length; i++) {
                            for (var _2 = 0, _3 = __classPrivateFieldGet(n, _AST_parts, "f"); _2 < _3.length; _2++) {
                                var part = _3[_2];
                                /* c8 ignore start */
                                if (typeof part === 'string') {
                                    throw new Error('string part in extglob AST??');
                                }
                                /* c8 ignore stop */
                                part.copyIn(__classPrivateFieldGet(pp, _AST_parts, "f")[i]);
                            }
                        }
                        p = pp;
                        pp = __classPrivateFieldGet(p, _AST_parent, "f");
                    }
                }
                return this;
            }, _AST_parseAST = function _AST_parseAST(str, ast, pos, opt) {
                var escaping = false;
                var inBrace = false;
                var braceStart = -1;
                var braceNeg = false;
                if (ast.type === null) {
                    // outside of a extglob, append until we find a start
                    var i_1 = pos;
                    var acc_1 = '';
                    while (i_1 < str.length) {
                        var c = str.charAt(i_1++);
                        // still accumulate escapes at this point, but we do ignore
                        // starts that are escaped
                        if (escaping || c === '\\') {
                            escaping = !escaping;
                            acc_1 += c;
                            continue;
                        }
                        if (inBrace) {
                            if (i_1 === braceStart + 1) {
                                if (c === '^' || c === '!') {
                                    braceNeg = true;
                                }
                            }
                            else if (c === ']' && !(i_1 === braceStart + 2 && braceNeg)) {
                                inBrace = false;
                            }
                            acc_1 += c;
                            continue;
                        }
                        else if (c === '[') {
                            inBrace = true;
                            braceStart = i_1;
                            braceNeg = false;
                            acc_1 += c;
                            continue;
                        }
                        if (!opt.noext && isExtglobType(c) && str.charAt(i_1) === '(') {
                            ast.push(acc_1);
                            acc_1 = '';
                            var ext = new AST(c, ast);
                            i_1 = __classPrivateFieldGet(AST, _1, "m", _AST_parseAST).call(AST, str, ext, i_1, opt);
                            ast.push(ext);
                            continue;
                        }
                        acc_1 += c;
                    }
                    ast.push(acc_1);
                    return i_1;
                }
                // some kind of extglob, pos is at the (
                // find the next | or )
                var i = pos + 1;
                var part = new AST(null, ast);
                var parts = [];
                var acc = '';
                while (i < str.length) {
                    var c = str.charAt(i++);
                    // still accumulate escapes at this point, but we do ignore
                    // starts that are escaped
                    if (escaping || c === '\\') {
                        escaping = !escaping;
                        acc += c;
                        continue;
                    }
                    if (inBrace) {
                        if (i === braceStart + 1) {
                            if (c === '^' || c === '!') {
                                braceNeg = true;
                            }
                        }
                        else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                            inBrace = false;
                        }
                        acc += c;
                        continue;
                    }
                    else if (c === '[') {
                        inBrace = true;
                        braceStart = i;
                        braceNeg = false;
                        acc += c;
                        continue;
                    }
                    if (isExtglobType(c) && str.charAt(i) === '(') {
                        part.push(acc);
                        acc = '';
                        var ext = new AST(c, part);
                        part.push(ext);
                        i = __classPrivateFieldGet(AST, _1, "m", _AST_parseAST).call(AST, str, ext, i, opt);
                        continue;
                    }
                    if (c === '|') {
                        part.push(acc);
                        acc = '';
                        parts.push(part);
                        part = new AST(null, ast);
                        continue;
                    }
                    if (c === ')') {
                        if (acc === '' && __classPrivateFieldGet(ast, _AST_parts, "f").length === 0) {
                            __classPrivateFieldSet(ast, _AST_emptyExt, true, "f");
                        }
                        part.push(acc);
                        acc = '';
                        ast.push.apply(ast, __spreadArray(__spreadArray([], parts, false), [part], false));
                        return i;
                    }
                    acc += c;
                }
                // unfinished extglob
                // if we got here, it was a malformed extglob! not an extglob, but
                // maybe something else in there.
                ast.type = null;
                __classPrivateFieldSet(ast, _AST_hasMagic, undefined, "f");
                __classPrivateFieldSet(ast, _AST_parts, [str.substring(pos - 1)], "f");
                return i;
            }, _AST_partsToRegExp = function _AST_partsToRegExp(dot) {
                var _this_1 = this;
                return __classPrivateFieldGet(this, _AST_parts, "f")
                    .map(function (p) {
                    // extglob ASTs should only contain parent ASTs
                    /* c8 ignore start */
                    if (typeof p === 'string') {
                        throw new Error('string type in extglob ast??');
                    }
                    /* c8 ignore stop */
                    // can ignore hasMagic, because extglobs are already always magic
                    var _2 = p.toRegExpSource(dot), re = _2[0], _ = _2[1], _hasMagic = _2[2], uflag = _2[3];
                    __classPrivateFieldSet(_this_1, _AST_uflag, __classPrivateFieldGet(_this_1, _AST_uflag, "f") || uflag, "f");
                    return re;
                })
                    .filter(function (p) { return !(_this_1.isStart() && _this_1.isEnd()) || !!p; })
                    .join('|');
            }, _AST_parseGlob = function _AST_parseGlob(glob, hasMagic, noEmpty) {
                if (noEmpty === void 0) { noEmpty = false; }
                var escaping = false;
                var re = '';
                var uflag = false;
                for (var i = 0; i < glob.length; i++) {
                    var c = glob.charAt(i);
                    if (escaping) {
                        escaping = false;
                        re += (reSpecials.has(c) ? '\\' : '') + c;
                        continue;
                    }
                    if (c === '\\') {
                        if (i === glob.length - 1) {
                            re += '\\\\';
                        }
                        else {
                            escaping = true;
                        }
                        continue;
                    }
                    if (c === '[') {
                        var _2 = (0, brace_expressions_js_1.parseClass)(glob, i), src = _2[0], needUflag = _2[1], consumed = _2[2], magic = _2[3];
                        if (consumed) {
                            re += src;
                            uflag = uflag || needUflag;
                            i += consumed - 1;
                            hasMagic = hasMagic || magic;
                            continue;
                        }
                    }
                    if (c === '*') {
                        if (noEmpty && glob === '*')
                            re += starNoEmpty;
                        else
                            re += star;
                        hasMagic = true;
                        continue;
                    }
                    if (c === '?') {
                        re += qmark;
                        hasMagic = true;
                        continue;
                    }
                    re += regExpEscape(c);
                }
                return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];
            };
            exports.AST = AST;
            //# sourceMappingURL=ast.js.map
            /***/ 
        }),
        /***/ 5822: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            // translate the various posix character classes into unicode properties
            // this works across all unicode locales
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.parseClass = void 0;
            // { <posix class>: [<translation>, /u flag required, negated]
            var posixClasses = {
                '[:alnum:]': ['\\p{L}\\p{Nl}\\p{Nd}', true],
                '[:alpha:]': ['\\p{L}\\p{Nl}', true],
                '[:ascii:]': ['\\x' + '00-\\x' + '7f', false],
                '[:blank:]': ['\\p{Zs}\\t', true],
                '[:cntrl:]': ['\\p{Cc}', true],
                '[:digit:]': ['\\p{Nd}', true],
                '[:graph:]': ['\\p{Z}\\p{C}', true, true],
                '[:lower:]': ['\\p{Ll}', true],
                '[:print:]': ['\\p{C}', true],
                '[:punct:]': ['\\p{P}', true],
                '[:space:]': ['\\p{Z}\\t\\r\\n\\v\\f', true],
                '[:upper:]': ['\\p{Lu}', true],
                '[:word:]': ['\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}', true],
                '[:xdigit:]': ['A-Fa-f0-9', false]
            };
            // only need to escape a few things inside of brace expressions
            // escapes: [ \ ] -
            var braceEscape = function (s) { return s.replace(/[[\]\\-]/g, '\\$&'); };
            // escape all regexp magic characters
            var regexpEscape = function (s) { return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&'); };
            // everything has already been escaped, we just have to join
            var rangesToString = function (ranges) { return ranges.join(''); };
            // takes a glob string at a posix brace expression, and returns
            // an equivalent regular expression source, and boolean indicating
            // whether the /u flag needs to be applied, and the number of chars
            // consumed to parse the character class.
            // This also removes out of order ranges, and returns ($.) if the
            // entire class just no good.
            var parseClass = function (glob, position) {
                var pos = position;
                /* c8 ignore start */
                if (glob.charAt(pos) !== '[') {
                    throw new Error('not in a brace expression');
                }
                /* c8 ignore stop */
                var ranges = [];
                var negs = [];
                var i = pos + 1;
                var sawStart = false;
                var uflag = false;
                var escaping = false;
                var negate = false;
                var endPos = pos;
                var rangeStart = '';
                WHILE: while (i < glob.length) {
                    var c = glob.charAt(i);
                    if ((c === '!' || c === '^') && i === pos + 1) {
                        negate = true;
                        i++;
                        continue;
                    }
                    if (c === ']' && sawStart && !escaping) {
                        endPos = i + 1;
                        break;
                    }
                    sawStart = true;
                    if (c === '\\') {
                        if (!escaping) {
                            escaping = true;
                            i++;
                            continue;
                        }
                        // escaped \ char, fall through and treat like normal char
                    }
                    if (c === '[' && !escaping) {
                        // either a posix class, a collation equivalent, or just a [
                        for (var _1 = 0, _2 = Object.entries(posixClasses); _1 < _2.length; _1++) {
                            var _3 = _2[_1], cls = _3[0], _4 = _3[1], unip = _4[0], u = _4[1], neg = _4[2];
                            if (glob.startsWith(cls, i)) {
                                // invalid, [a-[] is fine, but not [a-[:alpha]]
                                if (rangeStart) {
                                    return ['$.', false, glob.length - pos, true];
                                }
                                i += cls.length;
                                if (neg)
                                    negs.push(unip);
                                else
                                    ranges.push(unip);
                                uflag = uflag || u;
                                continue WHILE;
                            }
                        }
                    }
                    // now it's just a normal character, effectively
                    escaping = false;
                    if (rangeStart) {
                        // throw this range away if it's not valid, but others
                        // can still match.
                        if (c > rangeStart) {
                            ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));
                        }
                        else if (c === rangeStart) {
                            ranges.push(braceEscape(c));
                        }
                        rangeStart = '';
                        i++;
                        continue;
                    }
                    // now might be the start of a range.
                    // can be either c-d or c-] or c<more...>] or c] at this point
                    if (glob.startsWith('-]', i + 1)) {
                        ranges.push(braceEscape(c + '-'));
                        i += 2;
                        continue;
                    }
                    if (glob.startsWith('-', i + 1)) {
                        rangeStart = c;
                        i += 2;
                        continue;
                    }
                    // not the start of a range, just a single character
                    ranges.push(braceEscape(c));
                    i++;
                }
                if (endPos < i) {
                    // didn't see the end of the class, not a valid class,
                    // but might still be valid as a literal match.
                    return ['', false, 0, false];
                }
                // if we got no ranges and no negates, then we have a range that
                // cannot possibly match anything, and that poisons the whole glob
                if (!ranges.length && !negs.length) {
                    return ['$.', false, glob.length - pos, true];
                }
                // if we got one positive range, and it's a single character, then that's
                // not actually a magic pattern, it's just that one literal character.
                // we should not treat that as "magic", we should just return the literal
                // character. [_] is a perfectly valid way to escape glob magic chars.
                if (negs.length === 0 &&
                    ranges.length === 1 &&
                    /^\\?.$/.test(ranges[0]) &&
                    !negate) {
                    var r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
                    return [regexpEscape(r), false, endPos - pos, false];
                }
                var sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';
                var snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';
                var comb = ranges.length && negs.length
                    ? '(' + sranges + '|' + snegs + ')'
                    : ranges.length
                        ? sranges
                        : snegs;
                return [comb, uflag, endPos - pos, true];
            };
            exports.parseClass = parseClass;
            //# sourceMappingURL=brace-expressions.js.map
            /***/ 
        }),
        /***/ 9004: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.escape = void 0;
            /**
             * Escape all magic characters in a glob pattern.
             *
             * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}
             * option is used, then characters are escaped by wrapping in `[]`, because
             * a magic character wrapped in a character class can only be satisfied by
             * that exact character.  In this mode, `\` is _not_ escaped, because it is
             * not interpreted as a magic character, but instead as a path separator.
             */
            var escape = function (s, _1) {
                var _2 = _1 === void 0 ? {} : _1, _3 = _2.windowsPathsNoEscape, windowsPathsNoEscape = _3 === void 0 ? false : _3;
                // don't need to escape +@! because we escape the parens
                // that make those magic, and escaping ! as [!] isn't valid,
                // because [!]] is a valid glob class meaning not ']'.
                return windowsPathsNoEscape
                    ? s.replace(/[?*()[\]]/g, '[$&]')
                    : s.replace(/[?*()[\]\\]/g, '\\$&');
            };
            exports.escape = escape;
            //# sourceMappingURL=escape.js.map
            /***/ 
        }),
        /***/ 1953: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var __importDefault = (this && this.__importDefault) || function (mod) {
                return (mod && mod.__esModule) ? mod : { "default": mod };
            };
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;
            var brace_expansion_1 = __importDefault(__nccwpck_require__(3717));
            var assert_valid_pattern_js_1 = __nccwpck_require__(903);
            var ast_js_1 = __nccwpck_require__(3839);
            var escape_js_1 = __nccwpck_require__(9004);
            var unescape_js_1 = __nccwpck_require__(7305);
            var minimatch = function (p, pattern, options) {
                if (options === void 0) { options = {}; }
                (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
                // shortcut: comments match nothing.
                if (!options.nocomment && pattern.charAt(0) === '#') {
                    return false;
                }
                return new Minimatch(pattern, options).match(p);
            };
            exports.minimatch = minimatch;
            // Optimized checking for the most common glob patterns.
            var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
            var starDotExtTest = function (ext) { return function (f) { return !f.startsWith('.') && f.endsWith(ext); }; };
            var starDotExtTestDot = function (ext) { return function (f) { return f.endsWith(ext); }; };
            var starDotExtTestNocase = function (ext) {
                ext = ext.toLowerCase();
                return function (f) { return !f.startsWith('.') && f.toLowerCase().endsWith(ext); };
            };
            var starDotExtTestNocaseDot = function (ext) {
                ext = ext.toLowerCase();
                return function (f) { return f.toLowerCase().endsWith(ext); };
            };
            var starDotStarRE = /^\*+\.\*+$/;
            var starDotStarTest = function (f) { return !f.startsWith('.') && f.includes('.'); };
            var starDotStarTestDot = function (f) { return f !== '.' && f !== '..' && f.includes('.'); };
            var dotStarRE = /^\.\*+$/;
            var dotStarTest = function (f) { return f !== '.' && f !== '..' && f.startsWith('.'); };
            var starRE = /^\*+$/;
            var starTest = function (f) { return f.length !== 0 && !f.startsWith('.'); };
            var starTestDot = function (f) { return f.length !== 0 && f !== '.' && f !== '..'; };
            var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
            var qmarksTestNocase = function (_1) {
                var $0 = _1[0], _2 = _1[1], ext = _2 === void 0 ? '' : _2;
                var noext = qmarksTestNoExt([$0]);
                if (!ext)
                    return noext;
                ext = ext.toLowerCase();
                return function (f) { return noext(f) && f.toLowerCase().endsWith(ext); };
            };
            var qmarksTestNocaseDot = function (_1) {
                var $0 = _1[0], _2 = _1[1], ext = _2 === void 0 ? '' : _2;
                var noext = qmarksTestNoExtDot([$0]);
                if (!ext)
                    return noext;
                ext = ext.toLowerCase();
                return function (f) { return noext(f) && f.toLowerCase().endsWith(ext); };
            };
            var qmarksTestDot = function (_1) {
                var $0 = _1[0], _2 = _1[1], ext = _2 === void 0 ? '' : _2;
                var noext = qmarksTestNoExtDot([$0]);
                return !ext ? noext : function (f) { return noext(f) && f.endsWith(ext); };
            };
            var qmarksTest = function (_1) {
                var $0 = _1[0], _2 = _1[1], ext = _2 === void 0 ? '' : _2;
                var noext = qmarksTestNoExt([$0]);
                return !ext ? noext : function (f) { return noext(f) && f.endsWith(ext); };
            };
            var qmarksTestNoExt = function (_1) {
                var $0 = _1[0];
                var len = $0.length;
                return function (f) { return f.length === len && !f.startsWith('.'); };
            };
            var qmarksTestNoExtDot = function (_1) {
                var $0 = _1[0];
                var len = $0.length;
                return function (f) { return f.length === len && f !== '.' && f !== '..'; };
            };
            /* c8 ignore start */
            var defaultPlatform = (typeof process === 'object' && process
                ? (typeof process.env === 'object' &&
                    process.env &&
                    process.env.__MINIMATCH_TESTING_PLATFORM__) ||
                    process.platform
                : 'posix');
            var path = {
                win32: { sep: '\\' },
                posix: { sep: '/' }
            };
            /* c8 ignore stop */
            exports.sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;
            exports.minimatch.sep = exports.sep;
            exports.GLOBSTAR = Symbol('globstar **');
            exports.minimatch.GLOBSTAR = exports.GLOBSTAR;
            // any single thing other than /
            // don't need to escape / when using new RegExp()
            var qmark = '[^/]';
            // * => any number of characters
            var star = qmark + '*?';
            // ** when dots are allowed.  Anything goes, except .. and .
            // not (^ or / followed by one or two dots followed by $ or /),
            // followed by anything, any number of times.
            var twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?';
            // not a ^ or / followed by a dot,
            // followed by anything, any number of times.
            var twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?';
            var filter = function (pattern, options) {
                if (options === void 0) { options = {}; }
                return function (p) { return (0, exports.minimatch)(p, pattern, options); };
            };
            exports.filter = filter;
            exports.minimatch.filter = exports.filter;
            var ext = function (a, b) {
                if (b === void 0) { b = {}; }
                return Object.assign({}, a, b);
            };
            var defaults = function (def) {
                if (!def || typeof def !== 'object' || !Object.keys(def).length) {
                    return exports.minimatch;
                }
                var orig = exports.minimatch;
                var m = function (p, pattern, options) {
                    if (options === void 0) { options = {}; }
                    return orig(p, pattern, ext(def, options));
                };
                return Object.assign(m, {
                    Minimatch: /** @class */ (function (_super) {
                        __extends(Minimatch, _super);
                        function Minimatch(pattern, options) {
                            if (options === void 0) { options = {}; }
                            return _super.call(this, pattern, ext(def, options)) || this;
                        }
                        Minimatch.defaults = function (options) {
                            return orig.defaults(ext(def, options)).Minimatch;
                        };
                        return Minimatch;
                    }(orig.Minimatch)),
                    AST: /** @class */ (function (_super) {
                        __extends(AST, _super);
                        /* c8 ignore start */
                        function AST(type, parent, options) {
                            if (options === void 0) { options = {}; }
                            return _super.call(this, type, parent, ext(def, options)) || this;
                        }
                        /* c8 ignore stop */
                        AST.fromGlob = function (pattern, options) {
                            if (options === void 0) { options = {}; }
                            return orig.AST.fromGlob(pattern, ext(def, options));
                        };
                        return AST;
                    }(orig.AST)),
                    unescape: function (s, options) {
                        if (options === void 0) { options = {}; }
                        return orig.unescape(s, ext(def, options));
                    },
                    escape: function (s, options) {
                        if (options === void 0) { options = {}; }
                        return orig.escape(s, ext(def, options));
                    },
                    filter: function (pattern, options) {
                        if (options === void 0) { options = {}; }
                        return orig.filter(pattern, ext(def, options));
                    },
                    defaults: function (options) { return orig.defaults(ext(def, options)); },
                    makeRe: function (pattern, options) {
                        if (options === void 0) { options = {}; }
                        return orig.makeRe(pattern, ext(def, options));
                    },
                    braceExpand: function (pattern, options) {
                        if (options === void 0) { options = {}; }
                        return orig.braceExpand(pattern, ext(def, options));
                    },
                    match: function (list, pattern, options) {
                        if (options === void 0) { options = {}; }
                        return orig.match(list, pattern, ext(def, options));
                    },
                    sep: orig.sep,
                    GLOBSTAR: exports.GLOBSTAR
                });
            };
            exports.defaults = defaults;
            exports.minimatch.defaults = exports.defaults;
            // Brace expansion:
            // a{b,c}d -> abd acd
            // a{b,}c -> abc ac
            // a{0..3}d -> a0d a1d a2d a3d
            // a{b,c{d,e}f}g -> abg acdfg acefg
            // a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
            //
            // Invalid sets are not expanded.
            // a{2..}b -> a{2..}b
            // a{b}c -> a{b}c
            var braceExpand = function (pattern, options) {
                if (options === void 0) { options = {}; }
                (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
                // Thanks to Yeting Li <https://github.com/yetingli> for
                // improving this regexp to avoid a ReDOS vulnerability.
                if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
                    // shortcut. no need to expand.
                    return [pattern];
                }
                return (0, brace_expansion_1["default"])(pattern);
            };
            exports.braceExpand = braceExpand;
            exports.minimatch.braceExpand = exports.braceExpand;
            // parse a component of the expanded set.
            // At this point, no pattern may contain "/" in it
            // so we're going to return a 2d array, where each entry is the full
            // pattern, split on '/', and then turned into a regular expression.
            // A regexp is made at the end which joins each array with an
            // escaped /, and another full one which joins each regexp with |.
            //
            // Following the lead of Bash 4.1, note that "**" only has special meaning
            // when it is the *only* thing in a path portion.  Otherwise, any series
            // of * is equivalent to a single *.  Globstar behavior is enabled by
            // default, and can be disabled by setting options.noglobstar.
            var makeRe = function (pattern, options) {
                if (options === void 0) { options = {}; }
                return new Minimatch(pattern, options).makeRe();
            };
            exports.makeRe = makeRe;
            exports.minimatch.makeRe = exports.makeRe;
            var match = function (list, pattern, options) {
                if (options === void 0) { options = {}; }
                var mm = new Minimatch(pattern, options);
                list = list.filter(function (f) { return mm.match(f); });
                if (mm.options.nonull && !list.length) {
                    list.push(pattern);
                }
                return list;
            };
            exports.match = match;
            exports.minimatch.match = exports.match;
            // replace stuff like \* with *
            var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
            var regExpEscape = function (s) { return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&'); };
            var Minimatch = /** @class */ (function () {
                function Minimatch(pattern, options) {
                    if (options === void 0) { options = {}; }
                    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
                    options = options || {};
                    this.options = options;
                    this.pattern = pattern;
                    this.platform = options.platform || defaultPlatform;
                    this.isWindows = this.platform === 'win32';
                    this.windowsPathsNoEscape =
                        !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
                    if (this.windowsPathsNoEscape) {
                        this.pattern = this.pattern.replace(/\\/g, '/');
                    }
                    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
                    this.regexp = null;
                    this.negate = false;
                    this.nonegate = !!options.nonegate;
                    this.comment = false;
                    this.empty = false;
                    this.partial = !!options.partial;
                    this.nocase = !!this.options.nocase;
                    this.windowsNoMagicRoot =
                        options.windowsNoMagicRoot !== undefined
                            ? options.windowsNoMagicRoot
                            : !!(this.isWindows && this.nocase);
                    this.globSet = [];
                    this.globParts = [];
                    this.set = [];
                    // make the set of regexps etc.
                    this.make();
                }
                Minimatch.prototype.hasMagic = function () {
                    if (this.options.magicalBraces && this.set.length > 1) {
                        return true;
                    }
                    for (var _1 = 0, _2 = this.set; _1 < _2.length; _1++) {
                        var pattern = _2[_1];
                        for (var _3 = 0, pattern_3 = pattern; _3 < pattern_3.length; _3++) {
                            var part = pattern_3[_3];
                            if (typeof part !== 'string')
                                return true;
                        }
                    }
                    return false;
                };
                Minimatch.prototype.debug = function () {
                    var _ = [];
                    for (var _1 = 0; _1 < arguments.length; _1++) {
                        _[_1] = arguments[_1];
                    }
                };
                Minimatch.prototype.make = function () {
                    var _this_1 = this;
                    var pattern = this.pattern;
                    var options = this.options;
                    // empty patterns and comments match nothing.
                    if (!options.nocomment && pattern.charAt(0) === '#') {
                        this.comment = true;
                        return;
                    }
                    if (!pattern) {
                        this.empty = true;
                        return;
                    }
                    // step 1: figure out negation, etc.
                    this.parseNegate();
                    // step 2: expand braces
                    this.globSet = __spreadArray([], new Set(this.braceExpand()), true);
                    if (options.debug) {
                        this.debug = function () {
                            var args = [];
                            for (var _1 = 0; _1 < arguments.length; _1++) {
                                args[_1] = arguments[_1];
                            }
                            return console.error.apply(console, args);
                        };
                    }
                    this.debug(this.pattern, this.globSet);
                    // step 3: now we have a set, so turn each one into a series of
                    // path-portion matching patterns.
                    // These will be regexps, except in the case of "**", which is
                    // set to the GLOBSTAR object for globstar behavior,
                    // and will not contain any / characters
                    //
                    // First, we preprocess to make the glob pattern sets a bit simpler
                    // and deduped.  There are some perf-killing patterns that can cause
                    // problems with a glob walk, but we can simplify them down a bit.
                    var rawGlobParts = this.globSet.map(function (s) { return _this_1.slashSplit(s); });
                    this.globParts = this.preprocess(rawGlobParts);
                    this.debug(this.pattern, this.globParts);
                    // glob --> regexps
                    var set = this.globParts.map(function (s, _, __) {
                        if (_this_1.isWindows && _this_1.windowsNoMagicRoot) {
                            // check if it's a drive or unc path.
                            var isUNC = s[0] === '' &&
                                s[1] === '' &&
                                (s[2] === '?' || !globMagic.test(s[2])) &&
                                !globMagic.test(s[3]);
                            var isDrive = /^[a-z]:/i.test(s[0]);
                            if (isUNC) {
                                return __spreadArray(__spreadArray([], s.slice(0, 4), true), s.slice(4).map(function (ss) { return _this_1.parse(ss); }), true);
                            }
                            else if (isDrive) {
                                return __spreadArray([s[0]], s.slice(1).map(function (ss) { return _this_1.parse(ss); }), true);
                            }
                        }
                        return s.map(function (ss) { return _this_1.parse(ss); });
                    });
                    this.debug(this.pattern, set);
                    // filter out everything that didn't compile properly.
                    this.set = set.filter(function (s) { return s.indexOf(false) === -1; });
                    // do not treat the ? in UNC paths as magic
                    if (this.isWindows) {
                        for (var i = 0; i < this.set.length; i++) {
                            var p = this.set[i];
                            if (p[0] === '' &&
                                p[1] === '' &&
                                this.globParts[i][2] === '?' &&
                                typeof p[3] === 'string' &&
                                /^[a-z]:$/i.test(p[3])) {
                                p[2] = '?';
                            }
                        }
                    }
                    this.debug(this.pattern, this.set);
                };
                // various transforms to equivalent pattern sets that are
                // faster to process in a filesystem walk.  The goal is to
                // eliminate what we can, and push all ** patterns as far
                // to the right as possible, even if it increases the number
                // of patterns that we have to process.
                Minimatch.prototype.preprocess = function (globParts) {
                    // if we're not in globstar mode, then turn all ** into *
                    if (this.options.noglobstar) {
                        for (var i = 0; i < globParts.length; i++) {
                            for (var j = 0; j < globParts[i].length; j++) {
                                if (globParts[i][j] === '**') {
                                    globParts[i][j] = '*';
                                }
                            }
                        }
                    }
                    var _1 = this.options.optimizationLevel, optimizationLevel = _1 === void 0 ? 1 : _1;
                    if (optimizationLevel >= 2) {
                        // aggressive optimization for the purpose of fs walking
                        globParts = this.firstPhasePreProcess(globParts);
                        globParts = this.secondPhasePreProcess(globParts);
                    }
                    else if (optimizationLevel >= 1) {
                        // just basic optimizations to remove some .. parts
                        globParts = this.levelOneOptimize(globParts);
                    }
                    else {
                        globParts = this.adjascentGlobstarOptimize(globParts);
                    }
                    return globParts;
                };
                // just get rid of adjascent ** portions
                Minimatch.prototype.adjascentGlobstarOptimize = function (globParts) {
                    return globParts.map(function (parts) {
                        var gs = -1;
                        while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                            var i = gs;
                            while (parts[i + 1] === '**') {
                                i++;
                            }
                            if (i !== gs) {
                                parts.splice(gs, i - gs);
                            }
                        }
                        return parts;
                    });
                };
                // get rid of adjascent ** and resolve .. portions
                Minimatch.prototype.levelOneOptimize = function (globParts) {
                    return globParts.map(function (parts) {
                        parts = parts.reduce(function (set, part) {
                            var prev = set[set.length - 1];
                            if (part === '**' && prev === '**') {
                                return set;
                            }
                            if (part === '..') {
                                if (prev && prev !== '..' && prev !== '.' && prev !== '**') {
                                    set.pop();
                                    return set;
                                }
                            }
                            set.push(part);
                            return set;
                        }, []);
                        return parts.length === 0 ? [''] : parts;
                    });
                };
                Minimatch.prototype.levelTwoFileOptimize = function (parts) {
                    if (!Array.isArray(parts)) {
                        parts = this.slashSplit(parts);
                    }
                    var didSomething = false;
                    do {
                        didSomething = false;
                        // <pre>/<e>/<rest> -> <pre>/<rest>
                        if (!this.preserveMultipleSlashes) {
                            for (var i = 1; i < parts.length - 1; i++) {
                                var p = parts[i];
                                // don't squeeze out UNC patterns
                                if (i === 1 && p === '' && parts[0] === '')
                                    continue;
                                if (p === '.' || p === '') {
                                    didSomething = true;
                                    parts.splice(i, 1);
                                    i--;
                                }
                            }
                            if (parts[0] === '.' &&
                                parts.length === 2 &&
                                (parts[1] === '.' || parts[1] === '')) {
                                didSomething = true;
                                parts.pop();
                            }
                        }
                        // <pre>/<p>/../<rest> -> <pre>/<rest>
                        var dd = 0;
                        while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
                            var p = parts[dd - 1];
                            if (p && p !== '.' && p !== '..' && p !== '**') {
                                didSomething = true;
                                parts.splice(dd - 1, 2);
                                dd -= 2;
                            }
                        }
                    } while (didSomething);
                    return parts.length === 0 ? [''] : parts;
                };
                // First phase: single-pattern processing
                // <pre> is 1 or more portions
                // <rest> is 1 or more portions
                // <p> is any portion other than ., .., '', or **
                // <e> is . or ''
                //
                // **/.. is *brutal* for filesystem walking performance, because
                // it effectively resets the recursive walk each time it occurs,
                // and ** cannot be reduced out by a .. pattern part like a regexp
                // or most strings (other than .., ., and '') can be.
                //
                // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
                // <pre>/<e>/<rest> -> <pre>/<rest>
                // <pre>/<p>/../<rest> -> <pre>/<rest>
                // **/**/<rest> -> **/<rest>
                //
                // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
                // this WOULD be allowed if ** did follow symlinks, or * didn't
                Minimatch.prototype.firstPhasePreProcess = function (globParts) {
                    var didSomething = false;
                    do {
                        didSomething = false;
                        // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
                        for (var _1 = 0, globParts_1 = globParts; _1 < globParts_1.length; _1++) {
                            var parts = globParts_1[_1];
                            var gs = -1;
                            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                                var gss = gs;
                                while (parts[gss + 1] === '**') {
                                    // <pre>/**/**/<rest> -> <pre>/**/<rest>
                                    gss++;
                                }
                                // eg, if gs is 2 and gss is 4, that means we have 3 **
                                // parts, and can remove 2 of them.
                                if (gss > gs) {
                                    parts.splice(gs + 1, gss - gs);
                                }
                                var next = parts[gs + 1];
                                var p = parts[gs + 2];
                                var p2 = parts[gs + 3];
                                if (next !== '..')
                                    continue;
                                if (!p ||
                                    p === '.' ||
                                    p === '..' ||
                                    !p2 ||
                                    p2 === '.' ||
                                    p2 === '..') {
                                    continue;
                                }
                                didSomething = true;
                                // edit parts in place, and push the new one
                                parts.splice(gs, 1);
                                var other = parts.slice(0);
                                other[gs] = '**';
                                globParts.push(other);
                                gs--;
                            }
                            // <pre>/<e>/<rest> -> <pre>/<rest>
                            if (!this.preserveMultipleSlashes) {
                                for (var i = 1; i < parts.length - 1; i++) {
                                    var p = parts[i];
                                    // don't squeeze out UNC patterns
                                    if (i === 1 && p === '' && parts[0] === '')
                                        continue;
                                    if (p === '.' || p === '') {
                                        didSomething = true;
                                        parts.splice(i, 1);
                                        i--;
                                    }
                                }
                                if (parts[0] === '.' &&
                                    parts.length === 2 &&
                                    (parts[1] === '.' || parts[1] === '')) {
                                    didSomething = true;
                                    parts.pop();
                                }
                            }
                            // <pre>/<p>/../<rest> -> <pre>/<rest>
                            var dd = 0;
                            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
                                var p = parts[dd - 1];
                                if (p && p !== '.' && p !== '..' && p !== '**') {
                                    didSomething = true;
                                    var needDot = dd === 1 && parts[dd + 1] === '**';
                                    var splin = needDot ? ['.'] : [];
                                    parts.splice.apply(parts, __spreadArray([dd - 1, 2], splin, false));
                                    if (parts.length === 0)
                                        parts.push('');
                                    dd -= 2;
                                }
                            }
                        }
                    } while (didSomething);
                    return globParts;
                };
                // second phase: multi-pattern dedupes
                // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
                // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
                // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
                //
                // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
                // ^-- not valid because ** doens't follow symlinks
                Minimatch.prototype.secondPhasePreProcess = function (globParts) {
                    for (var i = 0; i < globParts.length - 1; i++) {
                        for (var j = i + 1; j < globParts.length; j++) {
                            var matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
                            if (!matched)
                                continue;
                            globParts[i] = matched;
                            globParts[j] = [];
                        }
                    }
                    return globParts.filter(function (gs) { return gs.length; });
                };
                Minimatch.prototype.partsMatch = function (a, b, emptyGSMatch) {
                    if (emptyGSMatch === void 0) { emptyGSMatch = false; }
                    var ai = 0;
                    var bi = 0;
                    var result = [];
                    var which = '';
                    while (ai < a.length && bi < b.length) {
                        if (a[ai] === b[bi]) {
                            result.push(which === 'b' ? b[bi] : a[ai]);
                            ai++;
                            bi++;
                        }
                        else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {
                            result.push(a[ai]);
                            ai++;
                        }
                        else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {
                            result.push(b[bi]);
                            bi++;
                        }
                        else if (a[ai] === '*' &&
                            b[bi] &&
                            (this.options.dot || !b[bi].startsWith('.')) &&
                            b[bi] !== '**') {
                            if (which === 'b')
                                return false;
                            which = 'a';
                            result.push(a[ai]);
                            ai++;
                            bi++;
                        }
                        else if (b[bi] === '*' &&
                            a[ai] &&
                            (this.options.dot || !a[ai].startsWith('.')) &&
                            a[ai] !== '**') {
                            if (which === 'a')
                                return false;
                            which = 'b';
                            result.push(b[bi]);
                            ai++;
                            bi++;
                        }
                        else {
                            return false;
                        }
                    }
                    // if we fall out of the loop, it means they two are identical
                    // as long as their lengths match
                    return a.length === b.length && result;
                };
                Minimatch.prototype.parseNegate = function () {
                    if (this.nonegate)
                        return;
                    var pattern = this.pattern;
                    var negate = false;
                    var negateOffset = 0;
                    for (var i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {
                        negate = !negate;
                        negateOffset++;
                    }
                    if (negateOffset)
                        this.pattern = pattern.slice(negateOffset);
                    this.negate = negate;
                };
                // set partial to true to test if, for example,
                // "/a/b" matches the start of "/*/b/*/d"
                // Partial means, if you run out of file before you run
                // out of pattern, then that's fine, as long as all
                // the parts match.
                Minimatch.prototype.matchOne = function (file, pattern, partial) {
                    if (partial === void 0) { partial = false; }
                    var options = this.options;
                    // UNC paths like //?/X:/... can match X:/... and vice versa
                    // Drive letters in absolute drive or unc paths are always compared
                    // case-insensitively.
                    if (this.isWindows) {
                        var fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);
                        var fileUNC = !fileDrive &&
                            file[0] === '' &&
                            file[1] === '' &&
                            file[2] === '?' &&
                            /^[a-z]:$/i.test(file[3]);
                        var patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);
                        var patternUNC = !patternDrive &&
                            pattern[0] === '' &&
                            pattern[1] === '' &&
                            pattern[2] === '?' &&
                            typeof pattern[3] === 'string' &&
                            /^[a-z]:$/i.test(pattern[3]);
                        var fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;
                        var pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;
                        if (typeof fdi === 'number' && typeof pdi === 'number') {
                            var _1 = [file[fdi], pattern[pdi]], fd = _1[0], pd = _1[1];
                            if (fd.toLowerCase() === pd.toLowerCase()) {
                                pattern[pdi] = fd;
                                if (pdi > fdi) {
                                    pattern = pattern.slice(pdi);
                                }
                                else if (fdi > pdi) {
                                    file = file.slice(fdi);
                                }
                            }
                        }
                    }
                    // resolve and reduce . and .. portions in the file as well.
                    // dont' need to do the second phase, because it's only one string[]
                    var _2 = this.options.optimizationLevel, optimizationLevel = _2 === void 0 ? 1 : _2;
                    if (optimizationLevel >= 2) {
                        file = this.levelTwoFileOptimize(file);
                    }
                    this.debug('matchOne', this, { file: file, pattern: pattern });
                    this.debug('matchOne', file.length, pattern.length);
                    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
                        this.debug('matchOne loop');
                        var p = pattern[pi];
                        var f = file[fi];
                        this.debug(pattern, p, f);
                        // should be impossible.
                        // some invalid regexp stuff in the set.
                        /* c8 ignore start */
                        if (p === false) {
                            return false;
                        }
                        /* c8 ignore stop */
                        if (p === exports.GLOBSTAR) {
                            this.debug('GLOBSTAR', [pattern, p, f]);
                            // "**"
                            // a/**/b/**/c would match the following:
                            // a/b/x/y/z/c
                            // a/x/y/z/b/c
                            // a/b/x/b/x/c
                            // a/b/c
                            // To do this, take the rest of the pattern after
                            // the **, and see if it would match the file remainder.
                            // If so, return success.
                            // If not, the ** "swallows" a segment, and try again.
                            // This is recursively awful.
                            //
                            // a/**/b/**/c matching a/b/x/y/z/c
                            // - a matches a
                            // - doublestar
                            //   - matchOne(b/x/y/z/c, b/**/c)
                            //     - b matches b
                            //     - doublestar
                            //       - matchOne(x/y/z/c, c) -> no
                            //       - matchOne(y/z/c, c) -> no
                            //       - matchOne(z/c, c) -> no
                            //       - matchOne(c, c) yes, hit
                            var fr = fi;
                            var pr = pi + 1;
                            if (pr === pl) {
                                this.debug('** at the end');
                                // a ** at the end will just swallow the rest.
                                // We have found a match.
                                // however, it will not swallow /.x, unless
                                // options.dot is set.
                                // . and .. are *never* matched by **, for explosively
                                // exponential reasons.
                                for (; fi < fl; fi++) {
                                    if (file[fi] === '.' ||
                                        file[fi] === '..' ||
                                        (!options.dot && file[fi].charAt(0) === '.'))
                                        return false;
                                }
                                return true;
                            }
                            // ok, let's see if we can swallow whatever we can.
                            while (fr < fl) {
                                var swallowee = file[fr];
                                this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);
                                // XXX remove this slice.  Just pass the start index.
                                if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                                    this.debug('globstar found match!', fr, fl, swallowee);
                                    // found a match.
                                    return true;
                                }
                                else {
                                    // can't swallow "." or ".." ever.
                                    // can only swallow ".foo" when explicitly asked.
                                    if (swallowee === '.' ||
                                        swallowee === '..' ||
                                        (!options.dot && swallowee.charAt(0) === '.')) {
                                        this.debug('dot detected!', file, fr, pattern, pr);
                                        break;
                                    }
                                    // ** swallows a segment, and continue.
                                    this.debug('globstar swallow a segment, and continue');
                                    fr++;
                                }
                            }
                            // no match was found.
                            // However, in partial mode, we can't say this is necessarily over.
                            /* c8 ignore start */
                            if (partial) {
                                // ran out of file
                                this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
                                if (fr === fl) {
                                    return true;
                                }
                            }
                            /* c8 ignore stop */
                            return false;
                        }
                        // something other than **
                        // non-magic patterns just have to match exactly
                        // patterns with magic have been turned into regexps.
                        var hit = void 0;
                        if (typeof p === 'string') {
                            hit = f === p;
                            this.debug('string match', p, f, hit);
                        }
                        else {
                            hit = p.test(f);
                            this.debug('pattern match', p, f, hit);
                        }
                        if (!hit)
                            return false;
                    }
                    // Note: ending in / means that we'll get a final ""
                    // at the end of the pattern.  This can only match a
                    // corresponding "" at the end of the file.
                    // If the file ends in /, then it can only match a
                    // a pattern that ends in /, unless the pattern just
                    // doesn't have any more for it. But, a/b/ should *not*
                    // match "a/b/*", even though "" matches against the
                    // [^/]*? pattern, except in partial mode, where it might
                    // simply not be reached yet.
                    // However, a/b/ should still satisfy a/*
                    // now either we fell off the end of the pattern, or we're done.
                    if (fi === fl && pi === pl) {
                        // ran out of pattern and filename at the same time.
                        // an exact hit!
                        return true;
                    }
                    else if (fi === fl) {
                        // ran out of file, but still had pattern left.
                        // this is ok if we're doing the match as part of
                        // a glob fs traversal.
                        return partial;
                    }
                    else if (pi === pl) {
                        // ran out of pattern, still have file left.
                        // this is only acceptable if we're on the very last
                        // empty segment of a file with a trailing slash.
                        // a/* should match a/b/
                        return fi === fl - 1 && file[fi] === '';
                        /* c8 ignore start */
                    }
                    else {
                        // should be unreachable.
                        throw new Error('wtf?');
                    }
                    /* c8 ignore stop */
                };
                Minimatch.prototype.braceExpand = function () {
                    return (0, exports.braceExpand)(this.pattern, this.options);
                };
                Minimatch.prototype.parse = function (pattern) {
                    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
                    var options = this.options;
                    // shortcuts
                    if (pattern === '**')
                        return exports.GLOBSTAR;
                    if (pattern === '')
                        return '';
                    // far and away, the most common glob pattern parts are
                    // *, *.*, and *.<ext>  Add a fast check method for those.
                    var m;
                    var fastTest = null;
                    if ((m = pattern.match(starRE))) {
                        fastTest = options.dot ? starTestDot : starTest;
                    }
                    else if ((m = pattern.match(starDotExtRE))) {
                        fastTest = (options.nocase
                            ? options.dot
                                ? starDotExtTestNocaseDot
                                : starDotExtTestNocase
                            : options.dot
                                ? starDotExtTestDot
                                : starDotExtTest)(m[1]);
                    }
                    else if ((m = pattern.match(qmarksRE))) {
                        fastTest = (options.nocase
                            ? options.dot
                                ? qmarksTestNocaseDot
                                : qmarksTestNocase
                            : options.dot
                                ? qmarksTestDot
                                : qmarksTest)(m);
                    }
                    else if ((m = pattern.match(starDotStarRE))) {
                        fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
                    }
                    else if ((m = pattern.match(dotStarRE))) {
                        fastTest = dotStarTest;
                    }
                    var re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();
                    return fastTest ? Object.assign(re, { test: fastTest }) : re;
                };
                Minimatch.prototype.makeRe = function () {
                    if (this.regexp || this.regexp === false)
                        return this.regexp;
                    // at this point, this.set is a 2d array of partial
                    // pattern strings, or "**".
                    //
                    // It's better to use .match().  This function shouldn't
                    // be used, really, but it's pretty convenient sometimes,
                    // when you just want to work with a regex.
                    var set = this.set;
                    if (!set.length) {
                        this.regexp = false;
                        return this.regexp;
                    }
                    var options = this.options;
                    var twoStar = options.noglobstar
                        ? star
                        : options.dot
                            ? twoStarDot
                            : twoStarNoDot;
                    var flags = new Set(options.nocase ? ['i'] : []);
                    // regexpify non-globstar patterns
                    // if ** is only item, then we just do one twoStar
                    // if ** is first, and there are more, prepend (\/|twoStar\/)? to next
                    // if ** is last, append (\/twoStar|) to previous
                    // if ** is in the middle, append (\/|\/twoStar\/) to previous
                    // then filter out GLOBSTAR symbols
                    var re = set
                        .map(function (pattern) {
                        var pp = pattern.map(function (p) {
                            if (p instanceof RegExp) {
                                for (var _1 = 0, _2 = p.flags.split(''); _1 < _2.length; _1++) {
                                    var f = _2[_1];
                                    flags.add(f);
                                }
                            }
                            return typeof p === 'string'
                                ? regExpEscape(p)
                                : p === exports.GLOBSTAR
                                    ? exports.GLOBSTAR
                                    : p._src;
                        });
                        pp.forEach(function (p, i) {
                            var next = pp[i + 1];
                            var prev = pp[i - 1];
                            if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {
                                return;
                            }
                            if (prev === undefined) {
                                if (next !== undefined && next !== exports.GLOBSTAR) {
                                    pp[i + 1] = '(?:\\/|' + twoStar + '\\/)?' + next;
                                }
                                else {
                                    pp[i] = twoStar;
                                }
                            }
                            else if (next === undefined) {
                                pp[i - 1] = prev + '(?:\\/|' + twoStar + ')?';
                            }
                            else if (next !== exports.GLOBSTAR) {
                                pp[i - 1] = prev + '(?:\\/|\\/' + twoStar + '\\/)' + next;
                                pp[i + 1] = exports.GLOBSTAR;
                            }
                        });
                        return pp.filter(function (p) { return p !== exports.GLOBSTAR; }).join('/');
                    })
                        .join('|');
                    // need to wrap in parens if we had more than one thing with |,
                    // otherwise only the first will be anchored to ^ and the last to $
                    var _1 = set.length > 1 ? ['(?:', ')'] : ['', ''], open = _1[0], close = _1[1];
                    // must match entire pattern
                    // ending in a * or ** will make it less strict.
                    re = '^' + open + re + close + '$';
                    // can match anything, as long as it's not this.
                    if (this.negate)
                        re = '^(?!' + re + ').+$';
                    try {
                        this.regexp = new RegExp(re, __spreadArray([], flags, true).join(''));
                        /* c8 ignore start */
                    }
                    catch (ex) {
                        // should be impossible
                        this.regexp = false;
                    }
                    /* c8 ignore stop */
                    return this.regexp;
                };
                Minimatch.prototype.slashSplit = function (p) {
                    // if p starts with // on windows, we preserve that
                    // so that UNC paths aren't broken.  Otherwise, any number of
                    // / characters are coalesced into one, unless
                    // preserveMultipleSlashes is set to true.
                    if (this.preserveMultipleSlashes) {
                        return p.split('/');
                    }
                    else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
                        // add an extra '' for the one we lose
                        return __spreadArray([''], p.split(/\/+/), true);
                    }
                    else {
                        return p.split(/\/+/);
                    }
                };
                Minimatch.prototype.match = function (f, partial) {
                    if (partial === void 0) { partial = this.partial; }
                    this.debug('match', f, this.pattern);
                    // short-circuit in the case of busted things.
                    // comments, etc.
                    if (this.comment) {
                        return false;
                    }
                    if (this.empty) {
                        return f === '';
                    }
                    if (f === '/' && partial) {
                        return true;
                    }
                    var options = this.options;
                    // windows: need to use /, not \
                    if (this.isWindows) {
                        f = f.split('\\').join('/');
                    }
                    // treat the test path as a set of pathparts.
                    var ff = this.slashSplit(f);
                    this.debug(this.pattern, 'split', ff);
                    // just ONE of the pattern sets in this.set needs to match
                    // in order for it to be valid.  If negating, then just one
                    // match means that we have failed.
                    // Either way, return on the first hit.
                    var set = this.set;
                    this.debug(this.pattern, 'set', set);
                    // Find the basename of the path by looking for the last non-empty segment
                    var filename = ff[ff.length - 1];
                    if (!filename) {
                        for (var i = ff.length - 2; !filename && i >= 0; i--) {
                            filename = ff[i];
                        }
                    }
                    for (var i = 0; i < set.length; i++) {
                        var pattern = set[i];
                        var file = ff;
                        if (options.matchBase && pattern.length === 1) {
                            file = [filename];
                        }
                        var hit = this.matchOne(file, pattern, partial);
                        if (hit) {
                            if (options.flipNegate) {
                                return true;
                            }
                            return !this.negate;
                        }
                    }
                    // didn't get any hits.  this is success if it's a negative
                    // pattern, failure otherwise.
                    if (options.flipNegate) {
                        return false;
                    }
                    return this.negate;
                };
                Minimatch.defaults = function (def) {
                    return exports.minimatch.defaults(def).Minimatch;
                };
                return Minimatch;
            }());
            exports.Minimatch = Minimatch;
            /* c8 ignore start */
            var ast_js_2 = __nccwpck_require__(3839);
            Object.defineProperty(exports, "AST", ({ enumerable: true, get: function () { return ast_js_2.AST; } }));
            var escape_js_2 = __nccwpck_require__(9004);
            Object.defineProperty(exports, "escape", ({ enumerable: true, get: function () { return escape_js_2.escape; } }));
            var unescape_js_2 = __nccwpck_require__(7305);
            Object.defineProperty(exports, "unescape", ({ enumerable: true, get: function () { return unescape_js_2.unescape; } }));
            /* c8 ignore stop */
            exports.minimatch.AST = ast_js_1.AST;
            exports.minimatch.Minimatch = Minimatch;
            exports.minimatch.escape = escape_js_1.escape;
            exports.minimatch.unescape = unescape_js_1.unescape;
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 7305: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.unescape = void 0;
            /**
             * Un-escape a string that has been escaped with {@link escape}.
             *
             * If the {@link windowsPathsNoEscape} option is used, then square-brace
             * escapes are removed, but not backslash escapes.  For example, it will turn
             * the string `'[*]'` into `*`, but it will not turn `'\\*'` into `'*'`,
             * becuase `\` is a path separator in `windowsPathsNoEscape` mode.
             *
             * When `windowsPathsNoEscape` is not set, then both brace escapes and
             * backslash escapes are removed.
             *
             * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped
             * or unescaped.
             */
            var unescape = function (s, _1) {
                var _2 = _1 === void 0 ? {} : _1, _3 = _2.windowsPathsNoEscape, windowsPathsNoEscape = _3 === void 0 ? false : _3;
                return windowsPathsNoEscape
                    ? s.replace(/\[([^\/\\])\]/g, '$1')
                    : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, '$1$2').replace(/\\([^\/])/g, '$1');
            };
            exports.unescape = unescape;
            //# sourceMappingURL=unescape.js.map
            /***/ 
        }),
        /***/ 8865: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14;
            var __importDefault = (this && this.__importDefault) || function (mod) {
                return (mod && mod.__esModule) ? mod : { "default": mod };
            };
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.Minipass = exports.isWritable = exports.isReadable = exports.isStream = void 0;
            var proc = typeof process === 'object' && process
                ? process
                : {
                    stdout: null,
                    stderr: null
                };
            var events_1 = __nccwpck_require__(2361);
            var stream_1 = __importDefault(__nccwpck_require__(2781));
            var string_decoder_1 = __nccwpck_require__(1576);
            /**
             * Return true if the argument is a Minipass stream, Node stream, or something
             * else that Minipass can interact with.
             */
            var isStream = function (s) { return !!s &&
                typeof s === 'object' &&
                (s instanceof Minipass ||
                    s instanceof stream_1["default"] ||
                    (0, exports.isReadable)(s) ||
                    (0, exports.isWritable)(s)); };
            exports.isStream = isStream;
            /**
             * Return true if the argument is a valid {@link Minipass.Readable}
             */
            var isReadable = function (s) { return !!s &&
                typeof s === 'object' &&
                s instanceof events_1.EventEmitter &&
                typeof s.pipe === 'function' &&
                // node core Writable streams have a pipe() method, but it throws
                s.pipe !== stream_1["default"].Writable.prototype.pipe; };
            exports.isReadable = isReadable;
            /**
             * Return true if the argument is a valid {@link Minipass.Writable}
             */
            var isWritable = function (s) { return !!s &&
                typeof s === 'object' &&
                s instanceof events_1.EventEmitter &&
                typeof s.write === 'function' &&
                typeof s.end === 'function'; };
            exports.isWritable = isWritable;
            var EOF = Symbol('EOF');
            var MAYBE_EMIT_END = Symbol('maybeEmitEnd');
            var EMITTED_END = Symbol('emittedEnd');
            var EMITTING_END = Symbol('emittingEnd');
            var EMITTED_ERROR = Symbol('emittedError');
            var CLOSED = Symbol('closed');
            var READ = Symbol('read');
            var FLUSH = Symbol('flush');
            var FLUSHCHUNK = Symbol('flushChunk');
            var ENCODING = Symbol('encoding');
            var DECODER = Symbol('decoder');
            var FLOWING = Symbol('flowing');
            var PAUSED = Symbol('paused');
            var RESUME = Symbol('resume');
            var BUFFER = Symbol('buffer');
            var PIPES = Symbol('pipes');
            var BUFFERLENGTH = Symbol('bufferLength');
            var BUFFERPUSH = Symbol('bufferPush');
            var BUFFERSHIFT = Symbol('bufferShift');
            var OBJECTMODE = Symbol('objectMode');
            // internal event when stream is destroyed
            var DESTROYED = Symbol('destroyed');
            // internal event when stream has an error
            var ERROR = Symbol('error');
            var EMITDATA = Symbol('emitData');
            var EMITEND = Symbol('emitEnd');
            var EMITEND2 = Symbol('emitEnd2');
            var ASYNC = Symbol('async');
            var ABORT = Symbol('abort');
            var ABORTED = Symbol('aborted');
            var SIGNAL = Symbol('signal');
            var DATALISTENERS = Symbol('dataListeners');
            var DISCARDED = Symbol('discarded');
            var defer = function (fn) { return Promise.resolve().then(fn); };
            var nodefer = function (fn) { return fn(); };
            var isEndish = function (ev) { return ev === 'end' || ev === 'finish' || ev === 'prefinish'; };
            var isArrayBufferLike = function (b) { return b instanceof ArrayBuffer ||
                (!!b &&
                    typeof b === 'object' &&
                    b.constructor &&
                    b.constructor.name === 'ArrayBuffer' &&
                    b.byteLength >= 0); };
            var isArrayBufferView = function (b) { return !Buffer.isBuffer(b) && ArrayBuffer.isView(b); };
            /**
             * Internal class representing a pipe to a destination stream.
             *
             * @internal
             */
            var Pipe = /** @class */ (function () {
                function Pipe(src, dest, opts) {
                    this.src = src;
                    this.dest = dest;
                    this.opts = opts;
                    this.ondrain = function () { return src[RESUME](); };
                    this.dest.on('drain', this.ondrain);
                }
                Pipe.prototype.unpipe = function () {
                    this.dest.removeListener('drain', this.ondrain);
                };
                // only here for the prototype
                /* c8 ignore start */
                Pipe.prototype.proxyErrors = function (_er) { };
                /* c8 ignore stop */
                Pipe.prototype.end = function () {
                    this.unpipe();
                    if (this.opts.end)
                        this.dest.end();
                };
                return Pipe;
            }());
            /**
             * Internal class representing a pipe to a destination stream where
             * errors are proxied.
             *
             * @internal
             */
            var PipeProxyErrors = /** @class */ (function (_super) {
                __extends(PipeProxyErrors, _super);
                function PipeProxyErrors(src, dest, opts) {
                    var _this_1 = _super.call(this, src, dest, opts) || this;
                    _this_1.proxyErrors = function (er) { return dest.emit('error', er); };
                    src.on('error', _this_1.proxyErrors);
                    return _this_1;
                }
                PipeProxyErrors.prototype.unpipe = function () {
                    this.src.removeListener('error', this.proxyErrors);
                    _super.prototype.unpipe.call(this);
                };
                return PipeProxyErrors;
            }(Pipe));
            var isObjectModeOptions = function (o) { return !!o.objectMode; };
            var isEncodingOptions = function (o) { return !o.objectMode && !!o.encoding && o.encoding !== 'buffer'; };
            /**
             * Main export, the Minipass class
             *
             * `RType` is the type of data emitted, defaults to Buffer
             *
             * `WType` is the type of data to be written, if RType is buffer or string,
             * then any {@link Minipass.ContiguousData} is allowed.
             *
             * `Events` is the set of event handler signatures that this object
             * will emit, see {@link Minipass.Events}
             */
            var Minipass = /** @class */ (function (_super) {
                __extends(Minipass, _super);
                /**
                 * If `RType` is Buffer, then options do not need to be provided.
                 * Otherwise, an options object must be provided to specify either
                 * {@link Minipass.SharedOptions.objectMode} or
                 * {@link Minipass.SharedOptions.encoding}, as appropriate.
                 */
                function Minipass() {
                    var args = [];
                    for (var _15 = 0; _15 < arguments.length; _15++) {
                        args[_15] = arguments[_15];
                    }
                    var _this_1 = this;
                    var options = (args[0] ||
                        {});
                    _this_1 = _super.call(this) || this;
                    _this_1[_1] = false;
                    _this_1[_2] = false;
                    _this_1[_3] = [];
                    _this_1[_4] = [];
                    _this_1[_5] = false;
                    _this_1[_6] = false;
                    _this_1[_7] = false;
                    _this_1[_8] = false;
                    _this_1[_9] = null;
                    _this_1[_10] = 0;
                    _this_1[_11] = false;
                    _this_1[_12] = false;
                    _this_1[_13] = 0;
                    _this_1[_14] = false;
                    /**
                     * true if the stream can be written
                     */
                    _this_1.writable = true;
                    /**
                     * true if the stream can be read
                     */
                    _this_1.readable = true;
                    if (options.objectMode && typeof options.encoding === 'string') {
                        throw new TypeError('Encoding and objectMode may not be used together');
                    }
                    if (isObjectModeOptions(options)) {
                        _this_1[OBJECTMODE] = true;
                        _this_1[ENCODING] = null;
                    }
                    else if (isEncodingOptions(options)) {
                        _this_1[ENCODING] = options.encoding;
                        _this_1[OBJECTMODE] = false;
                    }
                    else {
                        _this_1[OBJECTMODE] = false;
                        _this_1[ENCODING] = null;
                    }
                    _this_1[ASYNC] = !!options.async;
                    _this_1[DECODER] = _this_1[ENCODING]
                        ? new string_decoder_1.StringDecoder(_this_1[ENCODING])
                        : null;
                    //@ts-ignore - private option for debugging and testing
                    if (options && options.debugExposeBuffer === true) {
                        Object.defineProperty(_this_1, 'buffer', { get: function () { return _this_1[BUFFER]; } });
                    }
                    //@ts-ignore - private option for debugging and testing
                    if (options && options.debugExposePipes === true) {
                        Object.defineProperty(_this_1, 'pipes', { get: function () { return _this_1[PIPES]; } });
                    }
                    var signal = options.signal;
                    if (signal) {
                        _this_1[SIGNAL] = signal;
                        if (signal.aborted) {
                            _this_1[ABORT]();
                        }
                        else {
                            signal.addEventListener('abort', function () { return _this_1[ABORT](); });
                        }
                    }
                    return _this_1;
                }
                Object.defineProperty(Minipass.prototype, "bufferLength", {
                    /**
                     * The amount of data stored in the buffer waiting to be read.
                     *
                     * For Buffer strings, this will be the total byte length.
                     * For string encoding streams, this will be the string character length,
                     * according to JavaScript's `string.length` logic.
                     * For objectMode streams, this is a count of the items waiting to be
                     * emitted.
                     */
                    get: function () {
                        return this[BUFFERLENGTH];
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(Minipass.prototype, "encoding", {
                    /**
                     * The `BufferEncoding` currently in use, or `null`
                     */
                    get: function () {
                        return this[ENCODING];
                    },
                    /**
                     * @deprecated - This is a read only property
                     */
                    set: function (_enc) {
                        throw new Error('Encoding must be set at instantiation time');
                    },
                    enumerable: false,
                    configurable: true
                });
                /**
                 * @deprecated - Encoding may only be set at instantiation time
                 */
                Minipass.prototype.setEncoding = function (_enc) {
                    throw new Error('Encoding must be set at instantiation time');
                };
                Object.defineProperty(Minipass.prototype, "objectMode", {
                    /**
                     * True if this is an objectMode stream
                     */
                    get: function () {
                        return this[OBJECTMODE];
                    },
                    /**
                     * @deprecated - This is a read-only property
                     */
                    set: function (_om) {
                        throw new Error('objectMode must be set at instantiation time');
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(Minipass.prototype, (_1 = FLOWING, _2 = PAUSED, _3 = PIPES, _4 = BUFFER, _5 = EOF, _6 = EMITTED_END, _7 = EMITTING_END, _8 = CLOSED, _9 = EMITTED_ERROR, _10 = BUFFERLENGTH, _11 = DESTROYED, _12 = ABORTED, _13 = DATALISTENERS, _14 = DISCARDED, 'async'), {
                    /**
                     * true if this is an async stream
                     */
                    get: function () {
                        return this[ASYNC];
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(Minipass.prototype, 'async', {
                    /**
                     * Set to true to make this stream async.
                     *
                     * Once set, it cannot be unset, as this would potentially cause incorrect
                     * behavior.  Ie, a sync stream can be made async, but an async stream
                     * cannot be safely made sync.
                     */
                    set: function (a) {
                        this[ASYNC] = this[ASYNC] || !!a;
                    },
                    enumerable: false,
                    configurable: true
                });
                // drop everything and get out of the flow completely
                Minipass.prototype[ABORT] = function () {
                    var _15, _16;
                    this[ABORTED] = true;
                    this.emit('abort', (_15 = this[SIGNAL]) === null || _15 === void 0 ? void 0 : _15.reason);
                    this.destroy((_16 = this[SIGNAL]) === null || _16 === void 0 ? void 0 : _16.reason);
                };
                Object.defineProperty(Minipass.prototype, "aborted", {
                    /**
                     * True if the stream has been aborted.
                     */
                    get: function () {
                        return this[ABORTED];
                    },
                    /**
                     * No-op setter. Stream aborted status is set via the AbortSignal provided
                     * in the constructor options.
                     */
                    set: function (_) { },
                    enumerable: false,
                    configurable: true
                });
                Minipass.prototype.write = function (chunk, encoding, cb) {
                    var _15;
                    if (this[ABORTED])
                        return false;
                    if (this[EOF])
                        throw new Error('write after end');
                    if (this[DESTROYED]) {
                        this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), { code: 'ERR_STREAM_DESTROYED' }));
                        return true;
                    }
                    if (typeof encoding === 'function') {
                        cb = encoding;
                        encoding = 'utf8';
                    }
                    if (!encoding)
                        encoding = 'utf8';
                    var fn = this[ASYNC] ? defer : nodefer;
                    // convert array buffers and typed array views into buffers
                    // at some point in the future, we may want to do the opposite!
                    // leave strings and buffers as-is
                    // anything is only allowed if in object mode, so throw
                    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
                        if (isArrayBufferView(chunk)) {
                            //@ts-ignore - sinful unsafe type changing
                            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
                        }
                        else if (isArrayBufferLike(chunk)) {
                            //@ts-ignore - sinful unsafe type changing
                            chunk = Buffer.from(chunk);
                        }
                        else if (typeof chunk !== 'string') {
                            throw new Error('Non-contiguous data written to non-objectMode stream');
                        }
                    }
                    // handle object mode up front, since it's simpler
                    // this yields better performance, fewer checks later.
                    if (this[OBJECTMODE]) {
                        // maybe impossible?
                        /* c8 ignore start */
                        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
                            this[FLUSH](true);
                        /* c8 ignore stop */
                        if (this[FLOWING])
                            this.emit('data', chunk);
                        else
                            this[BUFFERPUSH](chunk);
                        if (this[BUFFERLENGTH] !== 0)
                            this.emit('readable');
                        if (cb)
                            fn(cb);
                        return this[FLOWING];
                    }
                    // at this point the chunk is a buffer or string
                    // don't buffer it up or send it to the decoder
                    if (!chunk.length) {
                        if (this[BUFFERLENGTH] !== 0)
                            this.emit('readable');
                        if (cb)
                            fn(cb);
                        return this[FLOWING];
                    }
                    // fast-path writing strings of same encoding to a stream with
                    // an empty buffer, skipping the buffer/decoder dance
                    if (typeof chunk === 'string' &&
                        // unless it is a string already ready for us to use
                        !(encoding === this[ENCODING] && !((_15 = this[DECODER]) === null || _15 === void 0 ? void 0 : _15.lastNeed))) {
                        //@ts-ignore - sinful unsafe type change
                        chunk = Buffer.from(chunk, encoding);
                    }
                    if (Buffer.isBuffer(chunk) && this[ENCODING]) {
                        //@ts-ignore - sinful unsafe type change
                        chunk = this[DECODER].write(chunk);
                    }
                    // Note: flushing CAN potentially switch us into not-flowing mode
                    if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
                        this[FLUSH](true);
                    if (this[FLOWING])
                        this.emit('data', chunk);
                    else
                        this[BUFFERPUSH](chunk);
                    if (this[BUFFERLENGTH] !== 0)
                        this.emit('readable');
                    if (cb)
                        fn(cb);
                    return this[FLOWING];
                };
                /**
                 * Low-level explicit read method.
                 *
                 * In objectMode, the argument is ignored, and one item is returned if
                 * available.
                 *
                 * `n` is the number of bytes (or in the case of encoding streams,
                 * characters) to consume. If `n` is not provided, then the entire buffer
                 * is returned, or `null` is returned if no data is available.
                 *
                 * If `n` is greater that the amount of data in the internal buffer,
                 * then `null` is returned.
                 */
                Minipass.prototype.read = function (n) {
                    if (this[DESTROYED])
                        return null;
                    this[DISCARDED] = false;
                    if (this[BUFFERLENGTH] === 0 ||
                        n === 0 ||
                        (n && n > this[BUFFERLENGTH])) {
                        this[MAYBE_EMIT_END]();
                        return null;
                    }
                    if (this[OBJECTMODE])
                        n = null;
                    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
                        // not object mode, so if we have an encoding, then RType is string
                        // otherwise, must be Buffer
                        this[BUFFER] = [
                            (this[ENCODING]
                                ? this[BUFFER].join('')
                                : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])),
                        ];
                    }
                    var ret = this[READ](n || null, this[BUFFER][0]);
                    this[MAYBE_EMIT_END]();
                    return ret;
                };
                Minipass.prototype[READ] = function (n, chunk) {
                    if (this[OBJECTMODE])
                        this[BUFFERSHIFT]();
                    else {
                        var c = chunk;
                        if (n === c.length || n === null)
                            this[BUFFERSHIFT]();
                        else if (typeof c === 'string') {
                            this[BUFFER][0] = c.slice(n);
                            chunk = c.slice(0, n);
                            this[BUFFERLENGTH] -= n;
                        }
                        else {
                            this[BUFFER][0] = c.subarray(n);
                            chunk = c.subarray(0, n);
                            this[BUFFERLENGTH] -= n;
                        }
                    }
                    this.emit('data', chunk);
                    if (!this[BUFFER].length && !this[EOF])
                        this.emit('drain');
                    return chunk;
                };
                Minipass.prototype.end = function (chunk, encoding, cb) {
                    if (typeof chunk === 'function') {
                        cb = chunk;
                        chunk = undefined;
                    }
                    if (typeof encoding === 'function') {
                        cb = encoding;
                        encoding = 'utf8';
                    }
                    if (chunk !== undefined)
                        this.write(chunk, encoding);
                    if (cb)
                        this.once('end', cb);
                    this[EOF] = true;
                    this.writable = false;
                    // if we haven't written anything, then go ahead and emit,
                    // even if we're not reading.
                    // we'll re-emit if a new 'end' listener is added anyway.
                    // This makes MP more suitable to write-only use cases.
                    if (this[FLOWING] || !this[PAUSED])
                        this[MAYBE_EMIT_END]();
                    return this;
                };
                // don't let the internal resume be overwritten
                Minipass.prototype[RESUME] = function () {
                    if (this[DESTROYED])
                        return;
                    if (!this[DATALISTENERS] && !this[PIPES].length) {
                        this[DISCARDED] = true;
                    }
                    this[PAUSED] = false;
                    this[FLOWING] = true;
                    this.emit('resume');
                    if (this[BUFFER].length)
                        this[FLUSH]();
                    else if (this[EOF])
                        this[MAYBE_EMIT_END]();
                    else
                        this.emit('drain');
                };
                /**
                 * Resume the stream if it is currently in a paused state
                 *
                 * If called when there are no pipe destinations or `data` event listeners,
                 * this will place the stream in a "discarded" state, where all data will
                 * be thrown away. The discarded state is removed if a pipe destination or
                 * data handler is added, if pause() is called, or if any synchronous or
                 * asynchronous iteration is started.
                 */
                Minipass.prototype.resume = function () {
                    return this[RESUME]();
                };
                /**
                 * Pause the stream
                 */
                Minipass.prototype.pause = function () {
                    this[FLOWING] = false;
                    this[PAUSED] = true;
                    this[DISCARDED] = false;
                };
                Object.defineProperty(Minipass.prototype, "destroyed", {
                    /**
                     * true if the stream has been forcibly destroyed
                     */
                    get: function () {
                        return this[DESTROYED];
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(Minipass.prototype, "flowing", {
                    /**
                     * true if the stream is currently in a flowing state, meaning that
                     * any writes will be immediately emitted.
                     */
                    get: function () {
                        return this[FLOWING];
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(Minipass.prototype, "paused", {
                    /**
                     * true if the stream is currently in a paused state
                     */
                    get: function () {
                        return this[PAUSED];
                    },
                    enumerable: false,
                    configurable: true
                });
                Minipass.prototype[BUFFERPUSH] = function (chunk) {
                    if (this[OBJECTMODE])
                        this[BUFFERLENGTH] += 1;
                    else
                        this[BUFFERLENGTH] += chunk.length;
                    this[BUFFER].push(chunk);
                };
                Minipass.prototype[BUFFERSHIFT] = function () {
                    if (this[OBJECTMODE])
                        this[BUFFERLENGTH] -= 1;
                    else
                        this[BUFFERLENGTH] -= this[BUFFER][0].length;
                    return this[BUFFER].shift();
                };
                Minipass.prototype[FLUSH] = function (noDrain) {
                    if (noDrain === void 0) { noDrain = false; }
                    do { } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&
                        this[BUFFER].length);
                    if (!noDrain && !this[BUFFER].length && !this[EOF])
                        this.emit('drain');
                };
                Minipass.prototype[FLUSHCHUNK] = function (chunk) {
                    this.emit('data', chunk);
                    return this[FLOWING];
                };
                /**
                 * Pipe all data emitted by this stream into the destination provided.
                 *
                 * Triggers the flow of data.
                 */
                Minipass.prototype.pipe = function (dest, opts) {
                    var _this_1 = this;
                    if (this[DESTROYED])
                        return dest;
                    this[DISCARDED] = false;
                    var ended = this[EMITTED_END];
                    opts = opts || {};
                    if (dest === proc.stdout || dest === proc.stderr)
                        opts.end = false;
                    else
                        opts.end = opts.end !== false;
                    opts.proxyErrors = !!opts.proxyErrors;
                    // piping an ended stream ends immediately
                    if (ended) {
                        if (opts.end)
                            dest.end();
                    }
                    else {
                        // "as" here just ignores the WType, which pipes don't care about,
                        // since they're only consuming from us, and writing to the dest
                        this[PIPES].push(!opts.proxyErrors
                            ? new Pipe(this, dest, opts)
                            : new PipeProxyErrors(this, dest, opts));
                        if (this[ASYNC])
                            defer(function () { return _this_1[RESUME](); });
                        else
                            this[RESUME]();
                    }
                    return dest;
                };
                /**
                 * Fully unhook a piped destination stream.
                 *
                 * If the destination stream was the only consumer of this stream (ie,
                 * there are no other piped destinations or `'data'` event listeners)
                 * then the flow of data will stop until there is another consumer or
                 * {@link Minipass#resume} is explicitly called.
                 */
                Minipass.prototype.unpipe = function (dest) {
                    var p = this[PIPES].find(function (p) { return p.dest === dest; });
                    if (p) {
                        if (this[PIPES].length === 1) {
                            if (this[FLOWING] && this[DATALISTENERS] === 0) {
                                this[FLOWING] = false;
                            }
                            this[PIPES] = [];
                        }
                        else
                            this[PIPES].splice(this[PIPES].indexOf(p), 1);
                        p.unpipe();
                    }
                };
                /**
                 * Alias for {@link Minipass#on}
                 */
                Minipass.prototype.addListener = function (ev, handler) {
                    return this.on(ev, handler);
                };
                /**
                 * Mostly identical to `EventEmitter.on`, with the following
                 * behavior differences to prevent data loss and unnecessary hangs:
                 *
                 * - Adding a 'data' event handler will trigger the flow of data
                 *
                 * - Adding a 'readable' event handler when there is data waiting to be read
                 *   will cause 'readable' to be emitted immediately.
                 *
                 * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
                 *   already passed will cause the event to be emitted immediately and all
                 *   handlers removed.
                 *
                 * - Adding an 'error' event handler after an error has been emitted will
                 *   cause the event to be re-emitted immediately with the error previously
                 *   raised.
                 */
                Minipass.prototype.on = function (ev, handler) {
                    var _this_1 = this;
                    var ret = _super.prototype.on.call(this, ev, handler);
                    if (ev === 'data') {
                        this[DISCARDED] = false;
                        this[DATALISTENERS]++;
                        if (!this[PIPES].length && !this[FLOWING]) {
                            this[RESUME]();
                        }
                    }
                    else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {
                        _super.prototype.emit.call(this, 'readable');
                    }
                    else if (isEndish(ev) && this[EMITTED_END]) {
                        _super.prototype.emit.call(this, ev);
                        this.removeAllListeners(ev);
                    }
                    else if (ev === 'error' && this[EMITTED_ERROR]) {
                        var h_1 = handler;
                        if (this[ASYNC])
                            defer(function () { return h_1.call(_this_1, _this_1[EMITTED_ERROR]); });
                        else
                            h_1.call(this, this[EMITTED_ERROR]);
                    }
                    return ret;
                };
                /**
                 * Alias for {@link Minipass#off}
                 */
                Minipass.prototype.removeListener = function (ev, handler) {
                    return this.off(ev, handler);
                };
                /**
                 * Mostly identical to `EventEmitter.off`
                 *
                 * If a 'data' event handler is removed, and it was the last consumer
                 * (ie, there are no pipe destinations or other 'data' event listeners),
                 * then the flow of data will stop until there is another consumer or
                 * {@link Minipass#resume} is explicitly called.
                 */
                Minipass.prototype.off = function (ev, handler) {
                    var ret = _super.prototype.off.call(this, ev, handler);
                    // if we previously had listeners, and now we don't, and we don't
                    // have any pipes, then stop the flow, unless it's been explicitly
                    // put in a discarded flowing state via stream.resume().
                    if (ev === 'data') {
                        this[DATALISTENERS] = this.listeners('data').length;
                        if (this[DATALISTENERS] === 0 &&
                            !this[DISCARDED] &&
                            !this[PIPES].length) {
                            this[FLOWING] = false;
                        }
                    }
                    return ret;
                };
                /**
                 * Mostly identical to `EventEmitter.removeAllListeners`
                 *
                 * If all 'data' event handlers are removed, and they were the last consumer
                 * (ie, there are no pipe destinations), then the flow of data will stop
                 * until there is another consumer or {@link Minipass#resume} is explicitly
                 * called.
                 */
                Minipass.prototype.removeAllListeners = function (ev) {
                    var ret = _super.prototype.removeAllListeners.call(this, ev);
                    if (ev === 'data' || ev === undefined) {
                        this[DATALISTENERS] = 0;
                        if (!this[DISCARDED] && !this[PIPES].length) {
                            this[FLOWING] = false;
                        }
                    }
                    return ret;
                };
                Object.defineProperty(Minipass.prototype, "emittedEnd", {
                    /**
                     * true if the 'end' event has been emitted
                     */
                    get: function () {
                        return this[EMITTED_END];
                    },
                    enumerable: false,
                    configurable: true
                });
                Minipass.prototype[MAYBE_EMIT_END] = function () {
                    if (!this[EMITTING_END] &&
                        !this[EMITTED_END] &&
                        !this[DESTROYED] &&
                        this[BUFFER].length === 0 &&
                        this[EOF]) {
                        this[EMITTING_END] = true;
                        this.emit('end');
                        this.emit('prefinish');
                        this.emit('finish');
                        if (this[CLOSED])
                            this.emit('close');
                        this[EMITTING_END] = false;
                    }
                };
                /**
                 * Mostly identical to `EventEmitter.emit`, with the following
                 * behavior differences to prevent data loss and unnecessary hangs:
                 *
                 * If the stream has been destroyed, and the event is something other
                 * than 'close' or 'error', then `false` is returned and no handlers
                 * are called.
                 *
                 * If the event is 'end', and has already been emitted, then the event
                 * is ignored. If the stream is in a paused or non-flowing state, then
                 * the event will be deferred until data flow resumes. If the stream is
                 * async, then handlers will be called on the next tick rather than
                 * immediately.
                 *
                 * If the event is 'close', and 'end' has not yet been emitted, then
                 * the event will be deferred until after 'end' is emitted.
                 *
                 * If the event is 'error', and an AbortSignal was provided for the stream,
                 * and there are no listeners, then the event is ignored, matching the
                 * behavior of node core streams in the presense of an AbortSignal.
                 *
                 * If the event is 'finish' or 'prefinish', then all listeners will be
                 * removed after emitting the event, to prevent double-firing.
                 */
                Minipass.prototype.emit = function (ev) {
                    var _this_1 = this;
                    var args = [];
                    for (var _15 = 1; _15 < arguments.length; _15++) {
                        args[_15 - 1] = arguments[_15];
                    }
                    var data = args[0];
                    // error and close are only events allowed after calling destroy()
                    if (ev !== 'error' &&
                        ev !== 'close' &&
                        ev !== DESTROYED &&
                        this[DESTROYED]) {
                        return false;
                    }
                    else if (ev === 'data') {
                        return !this[OBJECTMODE] && !data
                            ? false
                            : this[ASYNC]
                                ? (defer(function () { return _this_1[EMITDATA](data); }), true)
                                : this[EMITDATA](data);
                    }
                    else if (ev === 'end') {
                        return this[EMITEND]();
                    }
                    else if (ev === 'close') {
                        this[CLOSED] = true;
                        // don't emit close before 'end' and 'finish'
                        if (!this[EMITTED_END] && !this[DESTROYED])
                            return false;
                        var ret_1 = _super.prototype.emit.call(this, 'close');
                        this.removeAllListeners('close');
                        return ret_1;
                    }
                    else if (ev === 'error') {
                        this[EMITTED_ERROR] = data;
                        _super.prototype.emit.call(this, ERROR, data);
                        var ret_2 = !this[SIGNAL] || this.listeners('error').length
                            ? _super.prototype.emit.call(this, 'error', data)
                            : false;
                        this[MAYBE_EMIT_END]();
                        return ret_2;
                    }
                    else if (ev === 'resume') {
                        var ret_3 = _super.prototype.emit.call(this, 'resume');
                        this[MAYBE_EMIT_END]();
                        return ret_3;
                    }
                    else if (ev === 'finish' || ev === 'prefinish') {
                        var ret_4 = _super.prototype.emit.call(this, ev);
                        this.removeAllListeners(ev);
                        return ret_4;
                    }
                    // Some other unknown event
                    var ret = _super.prototype.emit.apply(this, __spreadArray([ev], args, false));
                    this[MAYBE_EMIT_END]();
                    return ret;
                };
                Minipass.prototype[EMITDATA] = function (data) {
                    for (var _15 = 0, _16 = this[PIPES]; _15 < _16.length; _15++) {
                        var p = _16[_15];
                        if (p.dest.write(data) === false)
                            this.pause();
                    }
                    var ret = this[DISCARDED] ? false : _super.prototype.emit.call(this, 'data', data);
                    this[MAYBE_EMIT_END]();
                    return ret;
                };
                Minipass.prototype[EMITEND] = function () {
                    var _this_1 = this;
                    if (this[EMITTED_END])
                        return false;
                    this[EMITTED_END] = true;
                    this.readable = false;
                    return this[ASYNC]
                        ? (defer(function () { return _this_1[EMITEND2](); }), true)
                        : this[EMITEND2]();
                };
                Minipass.prototype[EMITEND2] = function () {
                    if (this[DECODER]) {
                        var data = this[DECODER].end();
                        if (data) {
                            for (var _15 = 0, _16 = this[PIPES]; _15 < _16.length; _15++) {
                                var p = _16[_15];
                                p.dest.write(data);
                            }
                            if (!this[DISCARDED])
                                _super.prototype.emit.call(this, 'data', data);
                        }
                    }
                    for (var _17 = 0, _18 = this[PIPES]; _17 < _18.length; _17++) {
                        var p = _18[_17];
                        p.end();
                    }
                    var ret = _super.prototype.emit.call(this, 'end');
                    this.removeAllListeners('end');
                    return ret;
                };
                /**
                 * Return a Promise that resolves to an array of all emitted data once
                 * the stream ends.
                 */
                Minipass.prototype.collect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var buf, p;
                        var _this_1 = this;
                        return __generator(this, function (_15) {
                            switch (_15.label) {
                                case 0:
                                    buf = Object.assign([], {
                                        dataLength: 0
                                    });
                                    if (!this[OBJECTMODE])
                                        buf.dataLength = 0;
                                    p = this.promise();
                                    this.on('data', function (c) {
                                        buf.push(c);
                                        if (!_this_1[OBJECTMODE])
                                            buf.dataLength += c.length;
                                    });
                                    return [4 /*yield*/, p];
                                case 1:
                                    _15.sent();
                                    return [2 /*return*/, buf];
                            }
                        });
                    });
                };
                /**
                 * Return a Promise that resolves to the concatenation of all emitted data
                 * once the stream ends.
                 *
                 * Not allowed on objectMode streams.
                 */
                Minipass.prototype.concat = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var buf;
                        return __generator(this, function (_15) {
                            switch (_15.label) {
                                case 0:
                                    if (this[OBJECTMODE]) {
                                        throw new Error('cannot concat in objectMode');
                                    }
                                    return [4 /*yield*/, this.collect()];
                                case 1:
                                    buf = _15.sent();
                                    return [2 /*return*/, (this[ENCODING]
                                            ? buf.join('')
                                            : Buffer.concat(buf, buf.dataLength))];
                            }
                        });
                    });
                };
                /**
                 * Return a void Promise that resolves once the stream ends.
                 */
                Minipass.prototype.promise = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this_1 = this;
                        return __generator(this, function (_15) {
                            return [2 /*return*/, new Promise(function (resolve, reject) {
                                    _this_1.on(DESTROYED, function () { return reject(new Error('stream destroyed')); });
                                    _this_1.on('error', function (er) { return reject(er); });
                                    _this_1.on('end', function () { return resolve(); });
                                })];
                        });
                    });
                };
                /**
                 * Asynchronous `for await of` iteration.
                 *
                 * This will continue emitting all chunks until the stream terminates.
                 */
                Minipass.prototype[Symbol.asyncIterator] = function () {
                    var _15;
                    var _this_1 = this;
                    // set this up front, in case the consumer doesn't call next()
                    // right away.
                    this[DISCARDED] = false;
                    var stopped = false;
                    var stop = function () { return __awaiter(_this_1, void 0, void 0, function () {
                        return __generator(this, function (_15) {
                            this.pause();
                            stopped = true;
                            return [2 /*return*/, { value: undefined, done: true }];
                        });
                    }); };
                    var next = function () {
                        if (stopped)
                            return stop();
                        var res = _this_1.read();
                        if (res !== null)
                            return Promise.resolve({ done: false, value: res });
                        if (_this_1[EOF])
                            return stop();
                        var resolve;
                        var reject;
                        var onerr = function (er) {
                            _this_1.off('data', ondata);
                            _this_1.off('end', onend);
                            _this_1.off(DESTROYED, ondestroy);
                            stop();
                            reject(er);
                        };
                        var ondata = function (value) {
                            _this_1.off('error', onerr);
                            _this_1.off('end', onend);
                            _this_1.off(DESTROYED, ondestroy);
                            _this_1.pause();
                            resolve({ value: value, done: !!_this_1[EOF] });
                        };
                        var onend = function () {
                            _this_1.off('error', onerr);
                            _this_1.off('data', ondata);
                            _this_1.off(DESTROYED, ondestroy);
                            stop();
                            resolve({ done: true, value: undefined });
                        };
                        var ondestroy = function () { return onerr(new Error('stream destroyed')); };
                        return new Promise(function (res, rej) {
                            reject = rej;
                            resolve = res;
                            _this_1.once(DESTROYED, ondestroy);
                            _this_1.once('error', onerr);
                            _this_1.once('end', onend);
                            _this_1.once('data', ondata);
                        });
                    };
                    return _15 = {
                            next: next,
                            "throw": stop,
                            "return": stop
                        },
                        _15[Symbol.asyncIterator] = function () {
                            return this;
                        },
                        _15;
                };
                /**
                 * Synchronous `for of` iteration.
                 *
                 * The iteration will terminate when the internal buffer runs out, even
                 * if the stream has not yet terminated.
                 */
                Minipass.prototype[Symbol.iterator] = function () {
                    var _15;
                    var _this_1 = this;
                    // set this up front, in case the consumer doesn't call next()
                    // right away.
                    this[DISCARDED] = false;
                    var stopped = false;
                    var stop = function () {
                        _this_1.pause();
                        _this_1.off(ERROR, stop);
                        _this_1.off(DESTROYED, stop);
                        _this_1.off('end', stop);
                        stopped = true;
                        return { done: true, value: undefined };
                    };
                    var next = function () {
                        if (stopped)
                            return stop();
                        var value = _this_1.read();
                        return value === null ? stop() : { done: false, value: value };
                    };
                    this.once('end', stop);
                    this.once(ERROR, stop);
                    this.once(DESTROYED, stop);
                    return _15 = {
                            next: next,
                            "throw": stop,
                            "return": stop
                        },
                        _15[Symbol.iterator] = function () {
                            return this;
                        },
                        _15;
                };
                /**
                 * Destroy a stream, preventing it from being used for any further purpose.
                 *
                 * If the stream has a `close()` method, then it will be called on
                 * destruction.
                 *
                 * After destruction, any attempt to write data, read data, or emit most
                 * events will be ignored.
                 *
                 * If an error argument is provided, then it will be emitted in an
                 * 'error' event.
                 */
                Minipass.prototype.destroy = function (er) {
                    if (this[DESTROYED]) {
                        if (er)
                            this.emit('error', er);
                        else
                            this.emit(DESTROYED);
                        return this;
                    }
                    this[DESTROYED] = true;
                    this[DISCARDED] = true;
                    // throw away all buffered data, it's never coming out
                    this[BUFFER].length = 0;
                    this[BUFFERLENGTH] = 0;
                    var wc = this;
                    if (typeof wc.close === 'function' && !this[CLOSED])
                        wc.close();
                    if (er)
                        this.emit('error', er);
                    // if no error to emit, still reject pending promises
                    else
                        this.emit(DESTROYED);
                    return this;
                };
                Object.defineProperty(Minipass, "isStream", {
                    /**
                     * Alias for {@link isStream}
                     *
                     * Former export location, maintained for backwards compatibility.
                     *
                     * @deprecated
                     */
                    get: function () {
                        return exports.isStream;
                    },
                    enumerable: false,
                    configurable: true
                });
                return Minipass;
            }(events_1.EventEmitter));
            exports.Minipass = Minipass;
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 9569: 
        /***/ (function (__unused_webpack_module, exports, __nccwpck_require__) {
            "use strict";
            var _PathBase_instances, _PathBase_fs, _PathBase_dev, _PathBase_mode, _PathBase_nlink, _PathBase_uid, _PathBase_gid, _PathBase_rdev, _PathBase_blksize, _PathBase_ino, _PathBase_size, _PathBase_blocks, _PathBase_atimeMs, _PathBase_mtimeMs, _PathBase_ctimeMs, _PathBase_birthtimeMs, _PathBase_atime, _PathBase_mtime, _PathBase_ctime, _PathBase_birthtime, _PathBase_matchName, _PathBase_depth, _PathBase_fullpath, _PathBase_fullpathPosix, _PathBase_relative, _PathBase_relativePosix, _PathBase_type, _PathBase_children, _PathBase_linkTarget, _PathBase_realpath, _PathBase_resolveParts, _PathBase_readdirSuccess, _PathBase_markENOENT, _PathBase_markChildrenENOENT, _PathBase_markENOREALPATH, _PathBase_markENOTDIR, _PathBase_readdirFail, _PathBase_lstatFail, _PathBase_readlinkFail, _PathBase_readdirAddChild, _PathBase_readdirAddNewChild, _PathBase_readdirMaybePromoteChild, _PathBase_readdirPromoteChild, _PathBase_applyStat, _PathBase_onReaddirCB, _PathBase_readdirCBInFlight, _PathBase_callOnReaddirCB, _PathBase_asyncReaddirInFlight, _PathScurryBase_resolveCache, _PathScurryBase_resolvePosixCache, _PathScurryBase_children, _PathScurryBase_fs;
            var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
                if (k2 === undefined)
                    k2 = k;
                var desc = Object.getOwnPropertyDescriptor(m, k);
                if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                    desc = { enumerable: true, get: function () { return m[k]; } };
                }
                Object.defineProperty(o, k2, desc);
            }) : (function (o, m, k, k2) {
                if (k2 === undefined)
                    k2 = k;
                o[k2] = m[k];
            }));
            var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {
                Object.defineProperty(o, "default", { enumerable: true, value: v });
            }) : function (o, v) {
                o["default"] = v;
            });
            var __importStar = (this && this.__importStar) || function (mod) {
                if (mod && mod.__esModule)
                    return mod;
                var result = {};
                if (mod != null)
                    for (var k in mod)
                        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                            __createBinding(result, mod, k);
                __setModuleDefault(result, mod);
                return result;
            };
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.PathScurry = exports.Path = exports.PathScurryDarwin = exports.PathScurryPosix = exports.PathScurryWin32 = exports.PathScurryBase = exports.PathPosix = exports.PathWin32 = exports.PathBase = exports.ChildrenCache = exports.ResolveCache = void 0;
            var lru_cache_1 = __nccwpck_require__(7433);
            var path_1 = __nccwpck_require__(1017);
            var url_1 = __nccwpck_require__(7310);
            var actualFS = __importStar(__nccwpck_require__(7147));
            var fs_1 = __nccwpck_require__(7147);
            var realpathSync = fs_1.realpathSync.native;
            // TODO: test perf of fs/promises realpath vs realpathCB,
            // since the promises one uses realpath.native
            var promises_1 = __nccwpck_require__(3292);
            var minipass_1 = __nccwpck_require__(8865);
            var defaultFS = {
                lstatSync: fs_1.lstatSync,
                readdir: fs_1.readdir,
                readdirSync: fs_1.readdirSync,
                readlinkSync: fs_1.readlinkSync,
                realpathSync: realpathSync,
                promises: {
                    lstat: promises_1.lstat,
                    readdir: promises_1.readdir,
                    readlink: promises_1.readlink,
                    realpath: promises_1.realpath
                }
            };
            // if they just gave us require('fs') then use our default
            var fsFromOption = function (fsOption) { return !fsOption || fsOption === defaultFS || fsOption === actualFS
                ? defaultFS
                : __assign(__assign(__assign({}, defaultFS), fsOption), { promises: __assign(__assign({}, defaultFS.promises), (fsOption.promises || {})) }); };
            // turn something like //?/c:/ into c:\
            var uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
            var uncToDrive = function (rootPath) { return rootPath.replace(/\//g, '\\').replace(uncDriveRegexp, '$1\\'); };
            // windows paths are separated by either / or \
            var eitherSep = /[\\\/]/;
            var UNKNOWN = 0; // may not even exist, for all we know
            var IFIFO = 1;
            var IFCHR = 2;
            var IFDIR = 4;
            var IFBLK = 6;
            var IFREG = 8;
            var IFLNK = 10;
            var IFSOCK = 12;
            var IFMT = 15;
            // mask to unset low 4 bits
            var IFMT_UNKNOWN = ~IFMT;
            // set after successfully calling readdir() and getting entries.
            var READDIR_CALLED = 16;
            // set after a successful lstat()
            var LSTAT_CALLED = 32;
            // set if an entry (or one of its parents) is definitely not a dir
            var ENOTDIR = 64;
            // set if an entry (or one of its parents) does not exist
            // (can also be set on lstat errors like EACCES or ENAMETOOLONG)
            var ENOENT = 128;
            // cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK
            // set if we fail to readlink
            var ENOREADLINK = 256;
            // set if we know realpath() will fail
            var ENOREALPATH = 512;
            var ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
            var TYPEMASK = 1023;
            var entToType = function (s) { return s.isFile()
                ? IFREG
                : s.isDirectory()
                    ? IFDIR
                    : s.isSymbolicLink()
                        ? IFLNK
                        : s.isCharacterDevice()
                            ? IFCHR
                            : s.isBlockDevice()
                                ? IFBLK
                                : s.isSocket()
                                    ? IFSOCK
                                    : s.isFIFO()
                                        ? IFIFO
                                        : UNKNOWN; };
            // normalize unicode path names
            var normalizeCache = new Map();
            var normalize = function (s) {
                var c = normalizeCache.get(s);
                if (c)
                    return c;
                var n = s.normalize('NFKD');
                normalizeCache.set(s, n);
                return n;
            };
            var normalizeNocaseCache = new Map();
            var normalizeNocase = function (s) {
                var c = normalizeNocaseCache.get(s);
                if (c)
                    return c;
                var n = normalize(s.toLowerCase());
                normalizeNocaseCache.set(s, n);
                return n;
            };
            /**
             * An LRUCache for storing resolved path strings or Path objects.
             * @internal
             */
            var ResolveCache = /** @class */ (function (_super) {
                __extends(ResolveCache, _super);
                function ResolveCache() {
                    return _super.call(this, { max: 256 }) || this;
                }
                return ResolveCache;
            }(lru_cache_1.LRUCache));
            exports.ResolveCache = ResolveCache;
            // In order to prevent blowing out the js heap by allocating hundreds of
            // thousands of Path entries when walking extremely large trees, the "children"
            // in this tree are represented by storing an array of Path entries in an
            // LRUCache, indexed by the parent.  At any time, Path.children() may return an
            // empty array, indicating that it doesn't know about any of its children, and
            // thus has to rebuild that cache.  This is fine, it just means that we don't
            // benefit as much from having the cached entries, but huge directory walks
            // don't blow out the stack, and smaller ones are still as fast as possible.
            //
            //It does impose some complexity when building up the readdir data, because we
            //need to pass a reference to the children array that we started with.
            /**
             * an LRUCache for storing child entries.
             * @internal
             */
            var ChildrenCache = /** @class */ (function (_super) {
                __extends(ChildrenCache, _super);
                function ChildrenCache(maxSize) {
                    if (maxSize === void 0) { maxSize = 16 * 1024; }
                    return _super.call(this, {
                        maxSize: maxSize,
                        // parent + children
                        sizeCalculation: function (a) { return a.length + 1; }
                    }) || this;
                }
                return ChildrenCache;
            }(lru_cache_1.LRUCache));
            exports.ChildrenCache = ChildrenCache;
            var setAsCwd = Symbol('PathScurry setAsCwd');
            /**
             * Path objects are sort of like a super-powered
             * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}
             *
             * Each one represents a single filesystem entry on disk, which may or may not
             * exist. It includes methods for reading various types of information via
             * lstat, readlink, and readdir, and caches all information to the greatest
             * degree possible.
             *
             * Note that fs operations that would normally throw will instead return an
             * "empty" value. This is in order to prevent excessive overhead from error
             * stack traces.
             */
            var PathBase = /** @class */ (function () {
                /**
                 * Do not create new Path objects directly.  They should always be accessed
                 * via the PathScurry class or other methods on the Path class.
                 *
                 * @internal
                 */
                function PathBase(name, type, root, roots, nocase, children, opts) {
                    if (type === void 0) { type = UNKNOWN; }
                    _PathBase_instances.add(this);
                    // potential default fs override
                    _PathBase_fs.set(this, void 0);
                    // Stats fields
                    _PathBase_dev.set(this, void 0);
                    _PathBase_mode.set(this, void 0);
                    _PathBase_nlink.set(this, void 0);
                    _PathBase_uid.set(this, void 0);
                    _PathBase_gid.set(this, void 0);
                    _PathBase_rdev.set(this, void 0);
                    _PathBase_blksize.set(this, void 0);
                    _PathBase_ino.set(this, void 0);
                    _PathBase_size.set(this, void 0);
                    _PathBase_blocks.set(this, void 0);
                    _PathBase_atimeMs.set(this, void 0);
                    _PathBase_mtimeMs.set(this, void 0);
                    _PathBase_ctimeMs.set(this, void 0);
                    _PathBase_birthtimeMs.set(this, void 0);
                    _PathBase_atime.set(this, void 0);
                    _PathBase_mtime.set(this, void 0);
                    _PathBase_ctime.set(this, void 0);
                    _PathBase_birthtime.set(this, void 0);
                    _PathBase_matchName.set(this, void 0);
                    _PathBase_depth.set(this, void 0);
                    _PathBase_fullpath.set(this, void 0);
                    _PathBase_fullpathPosix.set(this, void 0);
                    _PathBase_relative.set(this, void 0);
                    _PathBase_relativePosix.set(this, void 0);
                    _PathBase_type.set(this, void 0);
                    _PathBase_children.set(this, void 0);
                    _PathBase_linkTarget.set(this, void 0);
                    _PathBase_realpath.set(this, void 0);
                    _PathBase_onReaddirCB.set(this, []);
                    _PathBase_readdirCBInFlight.set(this, false);
                    _PathBase_asyncReaddirInFlight.set(this, void 0);
                    this.name = name;
                    __classPrivateFieldSet(this, _PathBase_matchName, nocase ? normalizeNocase(name) : normalize(name), "f");
                    __classPrivateFieldSet(this, _PathBase_type, type & TYPEMASK, "f");
                    this.nocase = nocase;
                    this.roots = roots;
                    this.root = root || this;
                    __classPrivateFieldSet(this, _PathBase_children, children, "f");
                    __classPrivateFieldSet(this, _PathBase_fullpath, opts.fullpath, "f");
                    __classPrivateFieldSet(this, _PathBase_relative, opts.relative, "f");
                    __classPrivateFieldSet(this, _PathBase_relativePosix, opts.relativePosix, "f");
                    this.parent = opts.parent;
                    if (this.parent) {
                        __classPrivateFieldSet(this, _PathBase_fs, __classPrivateFieldGet(this.parent, _PathBase_fs, "f"), "f");
                    }
                    else {
                        __classPrivateFieldSet(this, _PathBase_fs, fsFromOption(opts.fs), "f");
                    }
                }
                Object.defineProperty(PathBase.prototype, "dev", {
                    get: function () {
                        return __classPrivateFieldGet(this, _PathBase_dev, "f");
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(PathBase.prototype, "mode", {
                    get: function () {
                        return __classPrivateFieldGet(this, _PathBase_mode, "f");
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(PathBase.prototype, "nlink", {
                    get: function () {
                        return __classPrivateFieldGet(this, _PathBase_nlink, "f");
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(PathBase.prototype, "uid", {
                    get: function () {
                        return __classPrivateFieldGet(this, _PathBase_uid, "f");
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(PathBase.prototype, "gid", {
                    get: function () {
                        return __classPrivateFieldGet(this, _PathBase_gid, "f");
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(PathBase.prototype, "rdev", {
                    get: function () {
                        return __classPrivateFieldGet(this, _PathBase_rdev, "f");
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(PathBase.prototype, "blksize", {
                    get: function () {
                        return __classPrivateFieldGet(this, _PathBase_blksize, "f");
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(PathBase.prototype, "ino", {
                    get: function () {
                        return __classPrivateFieldGet(this, _PathBase_ino, "f");
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(PathBase.prototype, "size", {
                    get: function () {
                        return __classPrivateFieldGet(this, _PathBase_size, "f");
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(PathBase.prototype, "blocks", {
                    get: function () {
                        return __classPrivateFieldGet(this, _PathBase_blocks, "f");
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(PathBase.prototype, "atimeMs", {
                    get: function () {
                        return __classPrivateFieldGet(this, _PathBase_atimeMs, "f");
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(PathBase.prototype, "mtimeMs", {
                    get: function () {
                        return __classPrivateFieldGet(this, _PathBase_mtimeMs, "f");
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(PathBase.prototype, "ctimeMs", {
                    get: function () {
                        return __classPrivateFieldGet(this, _PathBase_ctimeMs, "f");
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(PathBase.prototype, "birthtimeMs", {
                    get: function () {
                        return __classPrivateFieldGet(this, _PathBase_birthtimeMs, "f");
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(PathBase.prototype, "atime", {
                    get: function () {
                        return __classPrivateFieldGet(this, _PathBase_atime, "f");
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(PathBase.prototype, "mtime", {
                    get: function () {
                        return __classPrivateFieldGet(this, _PathBase_mtime, "f");
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(PathBase.prototype, "ctime", {
                    get: function () {
                        return __classPrivateFieldGet(this, _PathBase_ctime, "f");
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(PathBase.prototype, "birthtime", {
                    get: function () {
                        return __classPrivateFieldGet(this, _PathBase_birthtime, "f");
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(PathBase.prototype, "path", {
                    /**
                     * This property is for compatibility with the Dirent class as of
                     * Node v20, where Dirent['path'] refers to the path of the directory
                     * that was passed to readdir.  So, somewhat counterintuitively, this
                     * property refers to the *parent* path, not the path object itself.
                     * For root entries, it's the path to the entry itself.
                     */
                    get: function () {
                        return (this.parent || this).fullpath();
                    },
                    enumerable: false,
                    configurable: true
                });
                /**
                 * Returns the depth of the Path object from its root.
                 *
                 * For example, a path at `/foo/bar` would have a depth of 2.
                 */
                PathBase.prototype.depth = function () {
                    if (__classPrivateFieldGet(this, _PathBase_depth, "f") !== undefined)
                        return __classPrivateFieldGet(this, _PathBase_depth, "f");
                    if (!this.parent)
                        return (__classPrivateFieldSet(this, _PathBase_depth, 0, "f"));
                    return (__classPrivateFieldSet(this, _PathBase_depth, this.parent.depth() + 1, "f"));
                };
                /**
                 * @internal
                 */
                PathBase.prototype.childrenCache = function () {
                    return __classPrivateFieldGet(this, _PathBase_children, "f");
                };
                /**
                 * Get the Path object referenced by the string path, resolved from this Path
                 */
                PathBase.prototype.resolve = function (path) {
                    var _1;
                    if (!path) {
                        return this;
                    }
                    var rootPath = this.getRootString(path);
                    var dir = path.substring(rootPath.length);
                    var dirParts = dir.split(this.splitSep);
                    var result = rootPath
                        ? __classPrivateFieldGet((_1 = this.getRoot(rootPath)), _PathBase_instances, "m", _PathBase_resolveParts).call(_1, dirParts)
                        : __classPrivateFieldGet(this, _PathBase_instances, "m", _PathBase_resolveParts).call(this, dirParts);
                    return result;
                };
                /**
                 * Returns the cached children Path objects, if still available.  If they
                 * have fallen out of the cache, then returns an empty array, and resets the
                 * READDIR_CALLED bit, so that future calls to readdir() will require an fs
                 * lookup.
                 *
                 * @internal
                 */
                PathBase.prototype.children = function () {
                    var cached = __classPrivateFieldGet(this, _PathBase_children, "f").get(this);
                    if (cached) {
                        return cached;
                    }
                    var children = Object.assign([], { provisional: 0 });
                    __classPrivateFieldGet(this, _PathBase_children, "f").set(this, children);
                    __classPrivateFieldSet(this, _PathBase_type, __classPrivateFieldGet(this, _PathBase_type, "f") & ~READDIR_CALLED, "f");
                    return children;
                };
                /**
                 * Resolves a path portion and returns or creates the child Path.
                 *
                 * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
                 * `'..'`.
                 *
                 * This should not be called directly.  If `pathPart` contains any path
                 * separators, it will lead to unsafe undefined behavior.
                 *
                 * Use `Path.resolve()` instead.
                 *
                 * @internal
                 */
                PathBase.prototype.child = function (pathPart, opts) {
                    var _1;
                    if (pathPart === '' || pathPart === '.') {
                        return this;
                    }
                    if (pathPart === '..') {
                        return this.parent || this;
                    }
                    // find the child
                    var children = this.children();
                    var name = this.nocase
                        ? normalizeNocase(pathPart)
                        : normalize(pathPart);
                    for (var _2 = 0, children_2 = children; _2 < children_2.length; _2++) {
                        var p = children_2[_2];
                        if (__classPrivateFieldGet(p, _PathBase_matchName, "f") === name) {
                            return p;
                        }
                    }
                    // didn't find it, create provisional child, since it might not
                    // actually exist.  If we know the parent isn't a dir, then
                    // in fact it CAN'T exist.
                    var s = this.parent ? this.sep : '';
                    var fullpath = __classPrivateFieldGet(this, _PathBase_fullpath, "f")
                        ? __classPrivateFieldGet(this, _PathBase_fullpath, "f") + s + pathPart
                        : undefined;
                    var pchild = this.newChild(pathPart, UNKNOWN, __assign(__assign({}, opts), { parent: this, fullpath: fullpath }));
                    if (!this.canReaddir()) {
                        __classPrivateFieldSet(_1 = pchild, _PathBase_type, __classPrivateFieldGet(_1, _PathBase_type, "f") | ENOENT, "f");
                    }
                    // don't have to update provisional, because if we have real children,
                    // then provisional is set to children.length, otherwise a lower number
                    children.push(pchild);
                    return pchild;
                };
                /**
                 * The relative path from the cwd. If it does not share an ancestor with
                 * the cwd, then this ends up being equivalent to the fullpath()
                 */
                PathBase.prototype.relative = function () {
                    if (__classPrivateFieldGet(this, _PathBase_relative, "f") !== undefined) {
                        return __classPrivateFieldGet(this, _PathBase_relative, "f");
                    }
                    var name = this.name;
                    var p = this.parent;
                    if (!p) {
                        return (__classPrivateFieldSet(this, _PathBase_relative, this.name, "f"));
                    }
                    var pv = p.relative();
                    return pv + (!pv || !p.parent ? '' : this.sep) + name;
                };
                /**
                 * The relative path from the cwd, using / as the path separator.
                 * If it does not share an ancestor with
                 * the cwd, then this ends up being equivalent to the fullpathPosix()
                 * On posix systems, this is identical to relative().
                 */
                PathBase.prototype.relativePosix = function () {
                    if (this.sep === '/')
                        return this.relative();
                    if (__classPrivateFieldGet(this, _PathBase_relativePosix, "f") !== undefined)
                        return __classPrivateFieldGet(this, _PathBase_relativePosix, "f");
                    var name = this.name;
                    var p = this.parent;
                    if (!p) {
                        return (__classPrivateFieldSet(this, _PathBase_relativePosix, this.fullpathPosix(), "f"));
                    }
                    var pv = p.relativePosix();
                    return pv + (!pv || !p.parent ? '' : '/') + name;
                };
                /**
                 * The fully resolved path string for this Path entry
                 */
                PathBase.prototype.fullpath = function () {
                    if (__classPrivateFieldGet(this, _PathBase_fullpath, "f") !== undefined) {
                        return __classPrivateFieldGet(this, _PathBase_fullpath, "f");
                    }
                    var name = this.name;
                    var p = this.parent;
                    if (!p) {
                        return (__classPrivateFieldSet(this, _PathBase_fullpath, this.name, "f"));
                    }
                    var pv = p.fullpath();
                    var fp = pv + (!p.parent ? '' : this.sep) + name;
                    return (__classPrivateFieldSet(this, _PathBase_fullpath, fp, "f"));
                };
                /**
                 * On platforms other than windows, this is identical to fullpath.
                 *
                 * On windows, this is overridden to return the forward-slash form of the
                 * full UNC path.
                 */
                PathBase.prototype.fullpathPosix = function () {
                    if (__classPrivateFieldGet(this, _PathBase_fullpathPosix, "f") !== undefined)
                        return __classPrivateFieldGet(this, _PathBase_fullpathPosix, "f");
                    if (this.sep === '/')
                        return (__classPrivateFieldSet(this, _PathBase_fullpathPosix, this.fullpath(), "f"));
                    if (!this.parent) {
                        var p_1 = this.fullpath().replace(/\\/g, '/');
                        if (/^[a-z]:\//i.test(p_1)) {
                            return (__classPrivateFieldSet(this, _PathBase_fullpathPosix, "//?/".concat(p_1), "f"));
                        }
                        else {
                            return (__classPrivateFieldSet(this, _PathBase_fullpathPosix, p_1, "f"));
                        }
                    }
                    var p = this.parent;
                    var pfpp = p.fullpathPosix();
                    var fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name;
                    return (__classPrivateFieldSet(this, _PathBase_fullpathPosix, fpp, "f"));
                };
                /**
                 * Is the Path of an unknown type?
                 *
                 * Note that we might know *something* about it if there has been a previous
                 * filesystem operation, for example that it does not exist, or is not a
                 * link, or whether it has child entries.
                 */
                PathBase.prototype.isUnknown = function () {
                    return (__classPrivateFieldGet(this, _PathBase_type, "f") & IFMT) === UNKNOWN;
                };
                PathBase.prototype.isType = function (type) {
                    return this["is".concat(type)]();
                };
                PathBase.prototype.getType = function () {
                    return this.isUnknown()
                        ? 'Unknown'
                        : this.isDirectory()
                            ? 'Directory'
                            : this.isFile()
                                ? 'File'
                                : this.isSymbolicLink()
                                    ? 'SymbolicLink'
                                    : this.isFIFO()
                                        ? 'FIFO'
                                        : this.isCharacterDevice()
                                            ? 'CharacterDevice'
                                            : this.isBlockDevice()
                                                ? 'BlockDevice'
                                                : /* c8 ignore start */ this.isSocket()
                                                    ? 'Socket'
                                                    : 'Unknown';
                    /* c8 ignore stop */
                };
                /**
                 * Is the Path a regular file?
                 */
                PathBase.prototype.isFile = function () {
                    return (__classPrivateFieldGet(this, _PathBase_type, "f") & IFMT) === IFREG;
                };
                /**
                 * Is the Path a directory?
                 */
                PathBase.prototype.isDirectory = function () {
                    return (__classPrivateFieldGet(this, _PathBase_type, "f") & IFMT) === IFDIR;
                };
                /**
                 * Is the path a character device?
                 */
                PathBase.prototype.isCharacterDevice = function () {
                    return (__classPrivateFieldGet(this, _PathBase_type, "f") & IFMT) === IFCHR;
                };
                /**
                 * Is the path a block device?
                 */
                PathBase.prototype.isBlockDevice = function () {
                    return (__classPrivateFieldGet(this, _PathBase_type, "f") & IFMT) === IFBLK;
                };
                /**
                 * Is the path a FIFO pipe?
                 */
                PathBase.prototype.isFIFO = function () {
                    return (__classPrivateFieldGet(this, _PathBase_type, "f") & IFMT) === IFIFO;
                };
                /**
                 * Is the path a socket?
                 */
                PathBase.prototype.isSocket = function () {
                    return (__classPrivateFieldGet(this, _PathBase_type, "f") & IFMT) === IFSOCK;
                };
                /**
                 * Is the path a symbolic link?
                 */
                PathBase.prototype.isSymbolicLink = function () {
                    return (__classPrivateFieldGet(this, _PathBase_type, "f") & IFLNK) === IFLNK;
                };
                /**
                 * Return the entry if it has been subject of a successful lstat, or
                 * undefined otherwise.
                 *
                 * Does not read the filesystem, so an undefined result *could* simply
                 * mean that we haven't called lstat on it.
                 */
                PathBase.prototype.lstatCached = function () {
                    return __classPrivateFieldGet(this, _PathBase_type, "f") & LSTAT_CALLED ? this : undefined;
                };
                /**
                 * Return the cached link target if the entry has been the subject of a
                 * successful readlink, or undefined otherwise.
                 *
                 * Does not read the filesystem, so an undefined result *could* just mean we
                 * don't have any cached data. Only use it if you are very sure that a
                 * readlink() has been called at some point.
                 */
                PathBase.prototype.readlinkCached = function () {
                    return __classPrivateFieldGet(this, _PathBase_linkTarget, "f");
                };
                /**
                 * Returns the cached realpath target if the entry has been the subject
                 * of a successful realpath, or undefined otherwise.
                 *
                 * Does not read the filesystem, so an undefined result *could* just mean we
                 * don't have any cached data. Only use it if you are very sure that a
                 * realpath() has been called at some point.
                 */
                PathBase.prototype.realpathCached = function () {
                    return __classPrivateFieldGet(this, _PathBase_realpath, "f");
                };
                /**
                 * Returns the cached child Path entries array if the entry has been the
                 * subject of a successful readdir(), or [] otherwise.
                 *
                 * Does not read the filesystem, so an empty array *could* just mean we
                 * don't have any cached data. Only use it if you are very sure that a
                 * readdir() has been called recently enough to still be valid.
                 */
                PathBase.prototype.readdirCached = function () {
                    var children = this.children();
                    return children.slice(0, children.provisional);
                };
                /**
                 * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
                 * any indication that readlink will definitely fail.
                 *
                 * Returns false if the path is known to not be a symlink, if a previous
                 * readlink failed, or if the entry does not exist.
                 */
                PathBase.prototype.canReadlink = function () {
                    if (__classPrivateFieldGet(this, _PathBase_linkTarget, "f"))
                        return true;
                    if (!this.parent)
                        return false;
                    // cases where it cannot possibly succeed
                    var ifmt = __classPrivateFieldGet(this, _PathBase_type, "f") & IFMT;
                    return !((ifmt !== UNKNOWN && ifmt !== IFLNK) ||
                        __classPrivateFieldGet(this, _PathBase_type, "f") & ENOREADLINK ||
                        __classPrivateFieldGet(this, _PathBase_type, "f") & ENOENT);
                };
                /**
                 * Return true if readdir has previously been successfully called on this
                 * path, indicating that cachedReaddir() is likely valid.
                 */
                PathBase.prototype.calledReaddir = function () {
                    return !!(__classPrivateFieldGet(this, _PathBase_type, "f") & READDIR_CALLED);
                };
                /**
                 * Returns true if the path is known to not exist. That is, a previous lstat
                 * or readdir failed to verify its existence when that would have been
                 * expected, or a parent entry was marked either enoent or enotdir.
                 */
                PathBase.prototype.isENOENT = function () {
                    return !!(__classPrivateFieldGet(this, _PathBase_type, "f") & ENOENT);
                };
                /**
                 * Return true if the path is a match for the given path name.  This handles
                 * case sensitivity and unicode normalization.
                 *
                 * Note: even on case-sensitive systems, it is **not** safe to test the
                 * equality of the `.name` property to determine whether a given pathname
                 * matches, due to unicode normalization mismatches.
                 *
                 * Always use this method instead of testing the `path.name` property
                 * directly.
                 */
                PathBase.prototype.isNamed = function (n) {
                    return !this.nocase
                        ? __classPrivateFieldGet(this, _PathBase_matchName, "f") === normalize(n)
                        : __classPrivateFieldGet(this, _PathBase_matchName, "f") === normalizeNocase(n);
                };
                /**
                 * Return the Path object corresponding to the target of a symbolic link.
                 *
                 * If the Path is not a symbolic link, or if the readlink call fails for any
                 * reason, `undefined` is returned.
                 *
                 * Result is cached, and thus may be outdated if the filesystem is mutated.
                 */
                PathBase.prototype.readlink = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var target, read, linkTarget, er_1;
                        return __generator(this, function (_1) {
                            switch (_1.label) {
                                case 0:
                                    target = __classPrivateFieldGet(this, _PathBase_linkTarget, "f");
                                    if (target) {
                                        return [2 /*return*/, target];
                                    }
                                    if (!this.canReadlink()) {
                                        return [2 /*return*/, undefined];
                                    }
                                    /* c8 ignore start */
                                    // already covered by the canReadlink test, here for ts grumples
                                    if (!this.parent) {
                                        return [2 /*return*/, undefined];
                                    }
                                    _1.label = 1;
                                case 1:
                                    _1.trys.push([1, 3, , 4]);
                                    return [4 /*yield*/, __classPrivateFieldGet(this, _PathBase_fs, "f").promises.readlink(this.fullpath())];
                                case 2:
                                    read = _1.sent();
                                    linkTarget = this.parent.resolve(read);
                                    if (linkTarget) {
                                        return [2 /*return*/, (__classPrivateFieldSet(this, _PathBase_linkTarget, linkTarget, "f"))];
                                    }
                                    return [3 /*break*/, 4];
                                case 3:
                                    er_1 = _1.sent();
                                    __classPrivateFieldGet(this, _PathBase_instances, "m", _PathBase_readlinkFail).call(this, er_1.code);
                                    return [2 /*return*/, undefined];
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Synchronous {@link PathBase.readlink}
                 */
                PathBase.prototype.readlinkSync = function () {
                    var target = __classPrivateFieldGet(this, _PathBase_linkTarget, "f");
                    if (target) {
                        return target;
                    }
                    if (!this.canReadlink()) {
                        return undefined;
                    }
                    /* c8 ignore start */
                    // already covered by the canReadlink test, here for ts grumples
                    if (!this.parent) {
                        return undefined;
                    }
                    /* c8 ignore stop */
                    try {
                        var read = __classPrivateFieldGet(this, _PathBase_fs, "f").readlinkSync(this.fullpath());
                        var linkTarget = this.parent.resolve(read);
                        if (linkTarget) {
                            return (__classPrivateFieldSet(this, _PathBase_linkTarget, linkTarget, "f"));
                        }
                    }
                    catch (er) {
                        __classPrivateFieldGet(this, _PathBase_instances, "m", _PathBase_readlinkFail).call(this, er.code);
                        return undefined;
                    }
                };
                /**
                 * Call lstat() on this Path, and update all known information that can be
                 * determined.
                 *
                 * Note that unlike `fs.lstat()`, the returned value does not contain some
                 * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
                 * information is required, you will need to call `fs.lstat` yourself.
                 *
                 * If the Path refers to a nonexistent file, or if the lstat call fails for
                 * any reason, `undefined` is returned.  Otherwise the updated Path object is
                 * returned.
                 *
                 * Results are cached, and thus may be out of date if the filesystem is
                 * mutated.
                 */
                PathBase.prototype.lstat = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _1, _2, _3, er_2;
                        return __generator(this, function (_4) {
                            switch (_4.label) {
                                case 0:
                                    if (!((__classPrivateFieldGet(this, _PathBase_type, "f") & ENOENT) === 0)) return [3 /*break*/, 4];
                                    _4.label = 1;
                                case 1:
                                    _4.trys.push([1, 3, , 4]);
                                    _2 = (_1 = __classPrivateFieldGet(this, _PathBase_instances, "m", _PathBase_applyStat)).call;
                                    _3 = [this];
                                    return [4 /*yield*/, __classPrivateFieldGet(this, _PathBase_fs, "f").promises.lstat(this.fullpath())];
                                case 2:
                                    _2.apply(_1, _3.concat([_4.sent()]));
                                    return [2 /*return*/, this];
                                case 3:
                                    er_2 = _4.sent();
                                    __classPrivateFieldGet(this, _PathBase_instances, "m", _PathBase_lstatFail).call(this, er_2.code);
                                    return [3 /*break*/, 4];
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * synchronous {@link PathBase.lstat}
                 */
                PathBase.prototype.lstatSync = function () {
                    if ((__classPrivateFieldGet(this, _PathBase_type, "f") & ENOENT) === 0) {
                        try {
                            __classPrivateFieldGet(this, _PathBase_instances, "m", _PathBase_applyStat).call(this, __classPrivateFieldGet(this, _PathBase_fs, "f").lstatSync(this.fullpath()));
                            return this;
                        }
                        catch (er) {
                            __classPrivateFieldGet(this, _PathBase_instances, "m", _PathBase_lstatFail).call(this, er.code);
                        }
                    }
                };
                /**
                 * Standard node-style callback interface to get list of directory entries.
                 *
                 * If the Path cannot or does not contain any children, then an empty array
                 * is returned.
                 *
                 * Results are cached, and thus may be out of date if the filesystem is
                 * mutated.
                 *
                 * @param cb The callback called with (er, entries).  Note that the `er`
                 * param is somewhat extraneous, as all readdir() errors are handled and
                 * simply result in an empty set of entries being returned.
                 * @param allowZalgo Boolean indicating that immediately known results should
                 * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
                 * zalgo at your peril, the dark pony lord is devious and unforgiving.
                 */
                PathBase.prototype.readdirCB = function (cb, allowZalgo) {
                    var _this_1 = this;
                    if (allowZalgo === void 0) { allowZalgo = false; }
                    if (!this.canReaddir()) {
                        if (allowZalgo)
                            cb(null, []);
                        else
                            queueMicrotask(function () { return cb(null, []); });
                        return;
                    }
                    var children = this.children();
                    if (this.calledReaddir()) {
                        var c_1 = children.slice(0, children.provisional);
                        if (allowZalgo)
                            cb(null, c_1);
                        else
                            queueMicrotask(function () { return cb(null, c_1); });
                        return;
                    }
                    // don't have to worry about zalgo at this point.
                    __classPrivateFieldGet(this, _PathBase_onReaddirCB, "f").push(cb);
                    if (__classPrivateFieldGet(this, _PathBase_readdirCBInFlight, "f")) {
                        return;
                    }
                    __classPrivateFieldSet(this, _PathBase_readdirCBInFlight, true, "f");
                    // else read the directory, fill up children
                    // de-provisionalize any provisional children.
                    var fullpath = this.fullpath();
                    __classPrivateFieldGet(this, _PathBase_fs, "f").readdir(fullpath, { withFileTypes: true }, function (er, entries) {
                        if (er) {
                            __classPrivateFieldGet(_this_1, _PathBase_instances, "m", _PathBase_readdirFail).call(_this_1, er.code);
                            children.provisional = 0;
                        }
                        else {
                            // if we didn't get an error, we always get entries.
                            //@ts-ignore
                            for (var _1 = 0, entries_3 = entries; _1 < entries_3.length; _1++) {
                                var e = entries_3[_1];
                                __classPrivateFieldGet(_this_1, _PathBase_instances, "m", _PathBase_readdirAddChild).call(_this_1, e, children);
                            }
                            __classPrivateFieldGet(_this_1, _PathBase_instances, "m", _PathBase_readdirSuccess).call(_this_1, children);
                        }
                        __classPrivateFieldGet(_this_1, _PathBase_instances, "m", _PathBase_callOnReaddirCB).call(_this_1, children.slice(0, children.provisional));
                        return;
                    });
                };
                /**
                 * Return an array of known child entries.
                 *
                 * If the Path cannot or does not contain any children, then an empty array
                 * is returned.
                 *
                 * Results are cached, and thus may be out of date if the filesystem is
                 * mutated.
                 */
                PathBase.prototype.readdir = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var children, fullpath, resolve_2, _1, _2, e, er_3;
                        return __generator(this, function (_3) {
                            switch (_3.label) {
                                case 0:
                                    if (!this.canReaddir()) {
                                        return [2 /*return*/, []];
                                    }
                                    children = this.children();
                                    if (this.calledReaddir()) {
                                        return [2 /*return*/, children.slice(0, children.provisional)];
                                    }
                                    fullpath = this.fullpath();
                                    if (!__classPrivateFieldGet(this, _PathBase_asyncReaddirInFlight, "f")) return [3 /*break*/, 2];
                                    return [4 /*yield*/, __classPrivateFieldGet(this, _PathBase_asyncReaddirInFlight, "f")];
                                case 1:
                                    _3.sent();
                                    return [3 /*break*/, 10];
                                case 2:
                                    resolve_2 = function () { };
                                    /* c8 ignore stop */
                                    __classPrivateFieldSet(this, _PathBase_asyncReaddirInFlight, new Promise(function (res) { return (resolve_2 = res); }), "f");
                                    _3.label = 3;
                                case 3:
                                    _3.trys.push([3, 8, , 9]);
                                    _1 = 0;
                                    return [4 /*yield*/, __classPrivateFieldGet(this, _PathBase_fs, "f").promises.readdir(fullpath, {
                                            withFileTypes: true
                                        })];
                                case 4:
                                    _2 = _3.sent();
                                    _3.label = 5;
                                case 5:
                                    if (!(_1 < _2.length)) return [3 /*break*/, 7];
                                    e = _2[_1];
                                    __classPrivateFieldGet(this, _PathBase_instances, "m", _PathBase_readdirAddChild).call(this, e, children);
                                    _3.label = 6;
                                case 6:
                                    _1++;
                                    return [3 /*break*/, 5];
                                case 7:
                                    __classPrivateFieldGet(this, _PathBase_instances, "m", _PathBase_readdirSuccess).call(this, children);
                                    return [3 /*break*/, 9];
                                case 8:
                                    er_3 = _3.sent();
                                    __classPrivateFieldGet(this, _PathBase_instances, "m", _PathBase_readdirFail).call(this, er_3.code);
                                    children.provisional = 0;
                                    return [3 /*break*/, 9];
                                case 9:
                                    __classPrivateFieldSet(this, _PathBase_asyncReaddirInFlight, undefined, "f");
                                    resolve_2();
                                    _3.label = 10;
                                case 10: return [2 /*return*/, children.slice(0, children.provisional)];
                            }
                        });
                    });
                };
                /**
                 * synchronous {@link PathBase.readdir}
                 */
                PathBase.prototype.readdirSync = function () {
                    if (!this.canReaddir()) {
                        return [];
                    }
                    var children = this.children();
                    if (this.calledReaddir()) {
                        return children.slice(0, children.provisional);
                    }
                    // else read the directory, fill up children
                    // de-provisionalize any provisional children.
                    var fullpath = this.fullpath();
                    try {
                        for (var _1 = 0, _2 = __classPrivateFieldGet(this, _PathBase_fs, "f").readdirSync(fullpath, {
                            withFileTypes: true
                        }); _1 < _2.length; _1++) {
                            var e = _2[_1];
                            __classPrivateFieldGet(this, _PathBase_instances, "m", _PathBase_readdirAddChild).call(this, e, children);
                        }
                        __classPrivateFieldGet(this, _PathBase_instances, "m", _PathBase_readdirSuccess).call(this, children);
                    }
                    catch (er) {
                        __classPrivateFieldGet(this, _PathBase_instances, "m", _PathBase_readdirFail).call(this, er.code);
                        children.provisional = 0;
                    }
                    return children.slice(0, children.provisional);
                };
                PathBase.prototype.canReaddir = function () {
                    if (__classPrivateFieldGet(this, _PathBase_type, "f") & ENOCHILD)
                        return false;
                    var ifmt = IFMT & __classPrivateFieldGet(this, _PathBase_type, "f");
                    // we always set ENOTDIR when setting IFMT, so should be impossible
                    /* c8 ignore start */
                    if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
                        return false;
                    }
                    /* c8 ignore stop */
                    return true;
                };
                PathBase.prototype.shouldWalk = function (dirs, walkFilter) {
                    return ((__classPrivateFieldGet(this, _PathBase_type, "f") & IFDIR) === IFDIR &&
                        !(__classPrivateFieldGet(this, _PathBase_type, "f") & ENOCHILD) &&
                        !dirs.has(this) &&
                        (!walkFilter || walkFilter(this)));
                };
                /**
                 * Return the Path object corresponding to path as resolved
                 * by realpath(3).
                 *
                 * If the realpath call fails for any reason, `undefined` is returned.
                 *
                 * Result is cached, and thus may be outdated if the filesystem is mutated.
                 * On success, returns a Path object.
                 */
                PathBase.prototype.realpath = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var rp, _1;
                        return __generator(this, function (_2) {
                            switch (_2.label) {
                                case 0:
                                    if (__classPrivateFieldGet(this, _PathBase_realpath, "f"))
                                        return [2 /*return*/, __classPrivateFieldGet(this, _PathBase_realpath, "f")];
                                    if ((ENOREALPATH | ENOREADLINK | ENOENT) & __classPrivateFieldGet(this, _PathBase_type, "f"))
                                        return [2 /*return*/, undefined];
                                    _2.label = 1;
                                case 1:
                                    _2.trys.push([1, 3, , 4]);
                                    return [4 /*yield*/, __classPrivateFieldGet(this, _PathBase_fs, "f").promises.realpath(this.fullpath())];
                                case 2:
                                    rp = _2.sent();
                                    return [2 /*return*/, (__classPrivateFieldSet(this, _PathBase_realpath, this.resolve(rp), "f"))];
                                case 3:
                                    _1 = _2.sent();
                                    __classPrivateFieldGet(this, _PathBase_instances, "m", _PathBase_markENOREALPATH).call(this);
                                    return [3 /*break*/, 4];
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Synchronous {@link realpath}
                 */
                PathBase.prototype.realpathSync = function () {
                    if (__classPrivateFieldGet(this, _PathBase_realpath, "f"))
                        return __classPrivateFieldGet(this, _PathBase_realpath, "f");
                    if ((ENOREALPATH | ENOREADLINK | ENOENT) & __classPrivateFieldGet(this, _PathBase_type, "f"))
                        return undefined;
                    try {
                        var rp = __classPrivateFieldGet(this, _PathBase_fs, "f").realpathSync(this.fullpath());
                        return (__classPrivateFieldSet(this, _PathBase_realpath, this.resolve(rp), "f"));
                    }
                    catch (_) {
                        __classPrivateFieldGet(this, _PathBase_instances, "m", _PathBase_markENOREALPATH).call(this);
                    }
                };
                /**
                 * Internal method to mark this Path object as the scurry cwd,
                 * called by {@link PathScurry#chdir}
                 *
                 * @internal
                 */
                PathBase.prototype[(_PathBase_fs = new WeakMap(), _PathBase_dev = new WeakMap(), _PathBase_mode = new WeakMap(), _PathBase_nlink = new WeakMap(), _PathBase_uid = new WeakMap(), _PathBase_gid = new WeakMap(), _PathBase_rdev = new WeakMap(), _PathBase_blksize = new WeakMap(), _PathBase_ino = new WeakMap(), _PathBase_size = new WeakMap(), _PathBase_blocks = new WeakMap(), _PathBase_atimeMs = new WeakMap(), _PathBase_mtimeMs = new WeakMap(), _PathBase_ctimeMs = new WeakMap(), _PathBase_birthtimeMs = new WeakMap(), _PathBase_atime = new WeakMap(), _PathBase_mtime = new WeakMap(), _PathBase_ctime = new WeakMap(), _PathBase_birthtime = new WeakMap(), _PathBase_matchName = new WeakMap(), _PathBase_depth = new WeakMap(), _PathBase_fullpath = new WeakMap(), _PathBase_fullpathPosix = new WeakMap(), _PathBase_relative = new WeakMap(), _PathBase_relativePosix = new WeakMap(), _PathBase_type = new WeakMap(), _PathBase_children = new WeakMap(), _PathBase_linkTarget = new WeakMap(), _PathBase_realpath = new WeakMap(), _PathBase_onReaddirCB = new WeakMap(), _PathBase_readdirCBInFlight = new WeakMap(), _PathBase_asyncReaddirInFlight = new WeakMap(), _PathBase_instances = new WeakSet(), _PathBase_resolveParts = function _PathBase_resolveParts(dirParts) {
                    var p = this;
                    for (var _2 = 0, dirParts_1 = dirParts; _2 < dirParts_1.length; _2++) {
                        var part = dirParts_1[_2];
                        p = p.child(part);
                    }
                    return p;
                }, _PathBase_readdirSuccess = function _PathBase_readdirSuccess(children) {
                    var _2;
                    // succeeded, mark readdir called bit
                    __classPrivateFieldSet(this, _PathBase_type, __classPrivateFieldGet(this, _PathBase_type, "f") | READDIR_CALLED, "f");
                    // mark all remaining provisional children as ENOENT
                    for (var p = children.provisional; p < children.length; p++) {
                        __classPrivateFieldGet((_2 = children[p]), _PathBase_instances, "m", _PathBase_markENOENT).call(_2);
                    }
                }, _PathBase_markENOENT = function _PathBase_markENOENT() {
                    // mark as UNKNOWN and ENOENT
                    if (__classPrivateFieldGet(this, _PathBase_type, "f") & ENOENT)
                        return;
                    __classPrivateFieldSet(this, _PathBase_type, (__classPrivateFieldGet(this, _PathBase_type, "f") | ENOENT) & IFMT_UNKNOWN, "f");
                    __classPrivateFieldGet(this, _PathBase_instances, "m", _PathBase_markChildrenENOENT).call(this);
                }, _PathBase_markChildrenENOENT = function _PathBase_markChildrenENOENT() {
                    // all children are provisional and do not exist
                    var children = this.children();
                    children.provisional = 0;
                    for (var _2 = 0, children_3 = children; _2 < children_3.length; _2++) {
                        var p = children_3[_2];
                        __classPrivateFieldGet(p, _PathBase_instances, "m", _PathBase_markENOENT).call(p);
                    }
                }, _PathBase_markENOREALPATH = function _PathBase_markENOREALPATH() {
                    __classPrivateFieldSet(this, _PathBase_type, __classPrivateFieldGet(this, _PathBase_type, "f") | ENOREALPATH, "f");
                    __classPrivateFieldGet(this, _PathBase_instances, "m", _PathBase_markENOTDIR).call(this);
                }, _PathBase_markENOTDIR = function _PathBase_markENOTDIR() {
                    // entry is not a directory, so any children can't exist.
                    // this *should* be impossible, since any children created
                    // after it's been marked ENOTDIR should be marked ENOENT,
                    // so it won't even get to this point.
                    /* c8 ignore start */
                    if (__classPrivateFieldGet(this, _PathBase_type, "f") & ENOTDIR)
                        return;
                    /* c8 ignore stop */
                    var t = __classPrivateFieldGet(this, _PathBase_type, "f");
                    // this could happen if we stat a dir, then delete it,
                    // then try to read it or one of its children.
                    if ((t & IFMT) === IFDIR)
                        t &= IFMT_UNKNOWN;
                    __classPrivateFieldSet(this, _PathBase_type, t | ENOTDIR, "f");
                    __classPrivateFieldGet(this, _PathBase_instances, "m", _PathBase_markChildrenENOENT).call(this);
                }, _PathBase_readdirFail = function _PathBase_readdirFail(code) {
                    if (code === void 0) { code = ''; }
                    // markENOTDIR and markENOENT also set provisional=0
                    if (code === 'ENOTDIR' || code === 'EPERM') {
                        __classPrivateFieldGet(this, _PathBase_instances, "m", _PathBase_markENOTDIR).call(this);
                    }
                    else if (code === 'ENOENT') {
                        __classPrivateFieldGet(this, _PathBase_instances, "m", _PathBase_markENOENT).call(this);
                    }
                    else {
                        this.children().provisional = 0;
                    }
                }, _PathBase_lstatFail = function _PathBase_lstatFail(code) {
                    if (code === void 0) { code = ''; }
                    // Windows just raises ENOENT in this case, disable for win CI
                    /* c8 ignore start */
                    if (code === 'ENOTDIR') {
                        // already know it has a parent by this point
                        var p = this.parent;
                        __classPrivateFieldGet(p, _PathBase_instances, "m", _PathBase_markENOTDIR).call(p);
                    }
                    else if (code === 'ENOENT') {
                        /* c8 ignore stop */
                        __classPrivateFieldGet(this, _PathBase_instances, "m", _PathBase_markENOENT).call(this);
                    }
                }, _PathBase_readlinkFail = function _PathBase_readlinkFail(code) {
                    var _2;
                    if (code === void 0) { code = ''; }
                    var ter = __classPrivateFieldGet(this, _PathBase_type, "f");
                    ter |= ENOREADLINK;
                    if (code === 'ENOENT')
                        ter |= ENOENT;
                    // windows gets a weird error when you try to readlink a file
                    if (code === 'EINVAL' || code === 'UNKNOWN') {
                        // exists, but not a symlink, we don't know WHAT it is, so remove
                        // all IFMT bits.
                        ter &= IFMT_UNKNOWN;
                    }
                    __classPrivateFieldSet(this, _PathBase_type, ter, "f");
                    // windows just gets ENOENT in this case.  We do cover the case,
                    // just disabled because it's impossible on Windows CI
                    /* c8 ignore start */
                    if (code === 'ENOTDIR' && this.parent) {
                        __classPrivateFieldGet((_2 = this.parent), _PathBase_instances, "m", _PathBase_markENOTDIR).call(_2);
                    }
                    /* c8 ignore stop */
                }, _PathBase_readdirAddChild = function _PathBase_readdirAddChild(e, c) {
                    return (__classPrivateFieldGet(this, _PathBase_instances, "m", _PathBase_readdirMaybePromoteChild).call(this, e, c) ||
                        __classPrivateFieldGet(this, _PathBase_instances, "m", _PathBase_readdirAddNewChild).call(this, e, c));
                }, _PathBase_readdirAddNewChild = function _PathBase_readdirAddNewChild(e, c) {
                    var _2;
                    // alloc new entry at head, so it's never provisional
                    var type = entToType(e);
                    var child = this.newChild(e.name, type, { parent: this });
                    var ifmt = __classPrivateFieldGet(child, _PathBase_type, "f") & IFMT;
                    if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
                        __classPrivateFieldSet(_2 = child, _PathBase_type, __classPrivateFieldGet(_2, _PathBase_type, "f") | ENOTDIR, "f");
                    }
                    c.unshift(child);
                    c.provisional++;
                    return child;
                }, _PathBase_readdirMaybePromoteChild = function _PathBase_readdirMaybePromoteChild(e, c) {
                    for (var p = c.provisional; p < c.length; p++) {
                        var pchild = c[p];
                        var name_22 = this.nocase
                            ? normalizeNocase(e.name)
                            : normalize(e.name);
                        if (name_22 !== __classPrivateFieldGet(pchild, _PathBase_matchName, "f")) {
                            continue;
                        }
                        return __classPrivateFieldGet(this, _PathBase_instances, "m", _PathBase_readdirPromoteChild).call(this, e, pchild, p, c);
                    }
                }, _PathBase_readdirPromoteChild = function _PathBase_readdirPromoteChild(e, p, index, c) {
                    var v = p.name;
                    // retain any other flags, but set ifmt from dirent
                    __classPrivateFieldSet(p, _PathBase_type, (__classPrivateFieldGet(p, _PathBase_type, "f") & IFMT_UNKNOWN) | entToType(e), "f");
                    // case sensitivity fixing when we learn the true name.
                    if (v !== e.name)
                        p.name = e.name;
                    // just advance provisional index (potentially off the list),
                    // otherwise we have to splice/pop it out and re-insert at head
                    if (index !== c.provisional) {
                        if (index === c.length - 1)
                            c.pop();
                        else
                            c.splice(index, 1);
                        c.unshift(p);
                    }
                    c.provisional++;
                    return p;
                }, _PathBase_applyStat = function _PathBase_applyStat(st) {
                    var atime = st.atime, atimeMs = st.atimeMs, birthtime = st.birthtime, birthtimeMs = st.birthtimeMs, blksize = st.blksize, blocks = st.blocks, ctime = st.ctime, ctimeMs = st.ctimeMs, dev = st.dev, gid = st.gid, ino = st.ino, mode = st.mode, mtime = st.mtime, mtimeMs = st.mtimeMs, nlink = st.nlink, rdev = st.rdev, size = st.size, uid = st.uid;
                    __classPrivateFieldSet(this, _PathBase_atime, atime, "f");
                    __classPrivateFieldSet(this, _PathBase_atimeMs, atimeMs, "f");
                    __classPrivateFieldSet(this, _PathBase_birthtime, birthtime, "f");
                    __classPrivateFieldSet(this, _PathBase_birthtimeMs, birthtimeMs, "f");
                    __classPrivateFieldSet(this, _PathBase_blksize, blksize, "f");
                    __classPrivateFieldSet(this, _PathBase_blocks, blocks, "f");
                    __classPrivateFieldSet(this, _PathBase_ctime, ctime, "f");
                    __classPrivateFieldSet(this, _PathBase_ctimeMs, ctimeMs, "f");
                    __classPrivateFieldSet(this, _PathBase_dev, dev, "f");
                    __classPrivateFieldSet(this, _PathBase_gid, gid, "f");
                    __classPrivateFieldSet(this, _PathBase_ino, ino, "f");
                    __classPrivateFieldSet(this, _PathBase_mode, mode, "f");
                    __classPrivateFieldSet(this, _PathBase_mtime, mtime, "f");
                    __classPrivateFieldSet(this, _PathBase_mtimeMs, mtimeMs, "f");
                    __classPrivateFieldSet(this, _PathBase_nlink, nlink, "f");
                    __classPrivateFieldSet(this, _PathBase_rdev, rdev, "f");
                    __classPrivateFieldSet(this, _PathBase_size, size, "f");
                    __classPrivateFieldSet(this, _PathBase_uid, uid, "f");
                    var ifmt = entToType(st);
                    // retain any other flags, but set the ifmt
                    __classPrivateFieldSet(this, _PathBase_type, (__classPrivateFieldGet(this, _PathBase_type, "f") & IFMT_UNKNOWN) | ifmt | LSTAT_CALLED, "f");
                    if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
                        __classPrivateFieldSet(this, _PathBase_type, __classPrivateFieldGet(this, _PathBase_type, "f") | ENOTDIR, "f");
                    }
                }, _PathBase_callOnReaddirCB = function _PathBase_callOnReaddirCB(children) {
                    __classPrivateFieldSet(this, _PathBase_readdirCBInFlight, false, "f");
                    var cbs = __classPrivateFieldGet(this, _PathBase_onReaddirCB, "f").slice();
                    __classPrivateFieldGet(this, _PathBase_onReaddirCB, "f").length = 0;
                    cbs.forEach(function (cb) { return cb(null, children); });
                }, setAsCwd)] = function (oldCwd) {
                    if (oldCwd === this)
                        return;
                    var changed = new Set([]);
                    var rp = [];
                    var p = this;
                    while (p && p.parent) {
                        changed.add(p);
                        __classPrivateFieldSet(p, _PathBase_relative, rp.join(this.sep), "f");
                        __classPrivateFieldSet(p, _PathBase_relativePosix, rp.join('/'), "f");
                        p = p.parent;
                        rp.push('..');
                    }
                    // now un-memoize parents of old cwd
                    p = oldCwd;
                    while (p && p.parent && !changed.has(p)) {
                        __classPrivateFieldSet(p, _PathBase_relative, undefined, "f");
                        __classPrivateFieldSet(p, _PathBase_relativePosix, undefined, "f");
                        p = p.parent;
                    }
                };
                return PathBase;
            }());
            exports.PathBase = PathBase;
            /**
             * Path class used on win32 systems
             *
             * Uses `'\\'` as the path separator for returned paths, either `'\\'` or `'/'`
             * as the path separator for parsing paths.
             */
            var PathWin32 = /** @class */ (function (_super) {
                __extends(PathWin32, _super);
                /**
                 * Do not create new Path objects directly.  They should always be accessed
                 * via the PathScurry class or other methods on the Path class.
                 *
                 * @internal
                 */
                function PathWin32(name, type, root, roots, nocase, children, opts) {
                    if (type === void 0) { type = UNKNOWN; }
                    var _this_1 = _super.call(this, name, type, root, roots, nocase, children, opts) || this;
                    /**
                     * Separator for generating path strings.
                     */
                    _this_1.sep = '\\';
                    /**
                     * Separator for parsing path strings.
                     */
                    _this_1.splitSep = eitherSep;
                    return _this_1;
                }
                /**
                 * @internal
                 */
                PathWin32.prototype.newChild = function (name, type, opts) {
                    if (type === void 0) { type = UNKNOWN; }
                    if (opts === void 0) { opts = {}; }
                    return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
                };
                /**
                 * @internal
                 */
                PathWin32.prototype.getRootString = function (path) {
                    return path_1.win32.parse(path).root;
                };
                /**
                 * @internal
                 */
                PathWin32.prototype.getRoot = function (rootPath) {
                    rootPath = uncToDrive(rootPath.toUpperCase());
                    if (rootPath === this.root.name) {
                        return this.root;
                    }
                    // ok, not that one, check if it matches another we know about
                    for (var _2 = 0, _3 = Object.entries(this.roots); _2 < _3.length; _2++) {
                        var _4 = _3[_2], compare = _4[0], root = _4[1];
                        if (this.sameRoot(rootPath, compare)) {
                            return (this.roots[rootPath] = root);
                        }
                    }
                    // otherwise, have to create a new one.
                    return (this.roots[rootPath] = new PathScurryWin32(rootPath, this).root);
                };
                /**
                 * @internal
                 */
                PathWin32.prototype.sameRoot = function (rootPath, compare) {
                    if (compare === void 0) { compare = this.root.name; }
                    // windows can (rarely) have case-sensitive filesystem, but
                    // UNC and drive letters are always case-insensitive, and canonically
                    // represented uppercase.
                    rootPath = rootPath
                        .toUpperCase()
                        .replace(/\//g, '\\')
                        .replace(uncDriveRegexp, '$1\\');
                    return rootPath === compare;
                };
                return PathWin32;
            }(PathBase));
            exports.PathWin32 = PathWin32;
            /**
             * Path class used on all posix systems.
             *
             * Uses `'/'` as the path separator.
             */
            var PathPosix = /** @class */ (function (_super) {
                __extends(PathPosix, _super);
                /**
                 * Do not create new Path objects directly.  They should always be accessed
                 * via the PathScurry class or other methods on the Path class.
                 *
                 * @internal
                 */
                function PathPosix(name, type, root, roots, nocase, children, opts) {
                    if (type === void 0) { type = UNKNOWN; }
                    var _this_1 = _super.call(this, name, type, root, roots, nocase, children, opts) || this;
                    /**
                     * separator for parsing path strings
                     */
                    _this_1.splitSep = '/';
                    /**
                     * separator for generating path strings
                     */
                    _this_1.sep = '/';
                    return _this_1;
                }
                /**
                 * @internal
                 */
                PathPosix.prototype.getRootString = function (path) {
                    return path.startsWith('/') ? '/' : '';
                };
                /**
                 * @internal
                 */
                PathPosix.prototype.getRoot = function (_rootPath) {
                    return this.root;
                };
                /**
                 * @internal
                 */
                PathPosix.prototype.newChild = function (name, type, opts) {
                    if (type === void 0) { type = UNKNOWN; }
                    if (opts === void 0) { opts = {}; }
                    return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
                };
                return PathPosix;
            }(PathBase));
            exports.PathPosix = PathPosix;
            /**
             * The base class for all PathScurry classes, providing the interface for path
             * resolution and filesystem operations.
             *
             * Typically, you should *not* instantiate this class directly, but rather one
             * of the platform-specific classes, or the exported {@link PathScurry} which
             * defaults to the current platform.
             */
            var PathScurryBase = /** @class */ (function () {
                /**
                 * This class should not be instantiated directly.
                 *
                 * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
                 *
                 * @internal
                 */
                function PathScurryBase(cwd, pathImpl, sep, _2) {
                    if (cwd === void 0) { cwd = process.cwd(); }
                    var _3 = _2 === void 0 ? {} : _2, nocase = _3.nocase, _4 = _3.childrenCacheSize, childrenCacheSize = _4 === void 0 ? 16 * 1024 : _4, _5 = _3.fs, fs = _5 === void 0 ? defaultFS : _5;
                    _PathScurryBase_resolveCache.set(this, void 0);
                    _PathScurryBase_resolvePosixCache.set(this, void 0);
                    _PathScurryBase_children.set(this, void 0);
                    _PathScurryBase_fs.set(this, void 0);
                    __classPrivateFieldSet(this, _PathScurryBase_fs, fsFromOption(fs), "f");
                    if (cwd instanceof URL || cwd.startsWith('file://')) {
                        cwd = (0, url_1.fileURLToPath)(cwd);
                    }
                    // resolve and split root, and then add to the store.
                    // this is the only time we call path.resolve()
                    var cwdPath = pathImpl.resolve(cwd);
                    this.roots = Object.create(null);
                    this.rootPath = this.parseRootPath(cwdPath);
                    __classPrivateFieldSet(this, _PathScurryBase_resolveCache, new ResolveCache(), "f");
                    __classPrivateFieldSet(this, _PathScurryBase_resolvePosixCache, new ResolveCache(), "f");
                    __classPrivateFieldSet(this, _PathScurryBase_children, new ChildrenCache(childrenCacheSize), "f");
                    var split = cwdPath.substring(this.rootPath.length).split(sep);
                    // resolve('/') leaves '', splits to [''], we don't want that.
                    if (split.length === 1 && !split[0]) {
                        split.pop();
                    }
                    /* c8 ignore start */
                    if (nocase === undefined) {
                        throw new TypeError('must provide nocase setting to PathScurryBase ctor');
                    }
                    /* c8 ignore stop */
                    this.nocase = nocase;
                    this.root = this.newRoot(__classPrivateFieldGet(this, _PathScurryBase_fs, "f"));
                    this.roots[this.rootPath] = this.root;
                    var prev = this.root;
                    var len = split.length - 1;
                    var joinSep = pathImpl.sep;
                    var abs = this.rootPath;
                    var sawFirst = false;
                    for (var _6 = 0, split_1 = split; _6 < split_1.length; _6++) {
                        var part = split_1[_6];
                        var l = len--;
                        prev = prev.child(part, {
                            relative: new Array(l).fill('..').join(joinSep),
                            relativePosix: new Array(l).fill('..').join('/'),
                            fullpath: (abs += (sawFirst ? '' : joinSep) + part)
                        });
                        sawFirst = true;
                    }
                    this.cwd = prev;
                }
                /**
                 * Get the depth of a provided path, string, or the cwd
                 */
                PathScurryBase.prototype.depth = function (path) {
                    if (path === void 0) { path = this.cwd; }
                    if (typeof path === 'string') {
                        path = this.cwd.resolve(path);
                    }
                    return path.depth();
                };
                /**
                 * Return the cache of child entries.  Exposed so subclasses can create
                 * child Path objects in a platform-specific way.
                 *
                 * @internal
                 */
                PathScurryBase.prototype.childrenCache = function () {
                    return __classPrivateFieldGet(this, _PathScurryBase_children, "f");
                };
                /**
                 * Resolve one or more path strings to a resolved string
                 *
                 * Same interface as require('path').resolve.
                 *
                 * Much faster than path.resolve() when called multiple times for the same
                 * path, because the resolved Path objects are cached.  Much slower
                 * otherwise.
                 */
                PathScurryBase.prototype.resolve = function () {
                    var paths = [];
                    for (var _2 = 0; _2 < arguments.length; _2++) {
                        paths[_2] = arguments[_2];
                    }
                    // first figure out the minimum number of paths we have to test
                    // we always start at cwd, but any absolutes will bump the start
                    var r = '';
                    for (var i = paths.length - 1; i >= 0; i--) {
                        var p = paths[i];
                        if (!p || p === '.')
                            continue;
                        r = r ? "".concat(p, "/").concat(r) : p;
                        if (this.isAbsolute(p)) {
                            break;
                        }
                    }
                    var cached = __classPrivateFieldGet(this, _PathScurryBase_resolveCache, "f").get(r);
                    if (cached !== undefined) {
                        return cached;
                    }
                    var result = this.cwd.resolve(r).fullpath();
                    __classPrivateFieldGet(this, _PathScurryBase_resolveCache, "f").set(r, result);
                    return result;
                };
                /**
                 * Resolve one or more path strings to a resolved string, returning
                 * the posix path.  Identical to .resolve() on posix systems, but on
                 * windows will return a forward-slash separated UNC path.
                 *
                 * Same interface as require('path').resolve.
                 *
                 * Much faster than path.resolve() when called multiple times for the same
                 * path, because the resolved Path objects are cached.  Much slower
                 * otherwise.
                 */
                PathScurryBase.prototype.resolvePosix = function () {
                    var paths = [];
                    for (var _2 = 0; _2 < arguments.length; _2++) {
                        paths[_2] = arguments[_2];
                    }
                    // first figure out the minimum number of paths we have to test
                    // we always start at cwd, but any absolutes will bump the start
                    var r = '';
                    for (var i = paths.length - 1; i >= 0; i--) {
                        var p = paths[i];
                        if (!p || p === '.')
                            continue;
                        r = r ? "".concat(p, "/").concat(r) : p;
                        if (this.isAbsolute(p)) {
                            break;
                        }
                    }
                    var cached = __classPrivateFieldGet(this, _PathScurryBase_resolvePosixCache, "f").get(r);
                    if (cached !== undefined) {
                        return cached;
                    }
                    var result = this.cwd.resolve(r).fullpathPosix();
                    __classPrivateFieldGet(this, _PathScurryBase_resolvePosixCache, "f").set(r, result);
                    return result;
                };
                /**
                 * find the relative path from the cwd to the supplied path string or entry
                 */
                PathScurryBase.prototype.relative = function (entry) {
                    if (entry === void 0) { entry = this.cwd; }
                    if (typeof entry === 'string') {
                        entry = this.cwd.resolve(entry);
                    }
                    return entry.relative();
                };
                /**
                 * find the relative path from the cwd to the supplied path string or
                 * entry, using / as the path delimiter, even on Windows.
                 */
                PathScurryBase.prototype.relativePosix = function (entry) {
                    if (entry === void 0) { entry = this.cwd; }
                    if (typeof entry === 'string') {
                        entry = this.cwd.resolve(entry);
                    }
                    return entry.relativePosix();
                };
                /**
                 * Return the basename for the provided string or Path object
                 */
                PathScurryBase.prototype.basename = function (entry) {
                    if (entry === void 0) { entry = this.cwd; }
                    if (typeof entry === 'string') {
                        entry = this.cwd.resolve(entry);
                    }
                    return entry.name;
                };
                /**
                 * Return the dirname for the provided string or Path object
                 */
                PathScurryBase.prototype.dirname = function (entry) {
                    if (entry === void 0) { entry = this.cwd; }
                    if (typeof entry === 'string') {
                        entry = this.cwd.resolve(entry);
                    }
                    return (entry.parent || entry).fullpath();
                };
                PathScurryBase.prototype.readdir = function (entry, opts) {
                    if (entry === void 0) { entry = this.cwd; }
                    if (opts === void 0) { opts = {
                        withFileTypes: true
                    }; }
                    return __awaiter(this, void 0, void 0, function () {
                        var withFileTypes, p;
                        return __generator(this, function (_2) {
                            switch (_2.label) {
                                case 0:
                                    if (typeof entry === 'string') {
                                        entry = this.cwd.resolve(entry);
                                    }
                                    else if (!(entry instanceof PathBase)) {
                                        opts = entry;
                                        entry = this.cwd;
                                    }
                                    withFileTypes = opts.withFileTypes;
                                    if (!!entry.canReaddir()) return [3 /*break*/, 1];
                                    return [2 /*return*/, []];
                                case 1: return [4 /*yield*/, entry.readdir()];
                                case 2:
                                    p = _2.sent();
                                    return [2 /*return*/, withFileTypes ? p : p.map(function (e) { return e.name; })];
                            }
                        });
                    });
                };
                PathScurryBase.prototype.readdirSync = function (entry, opts) {
                    if (entry === void 0) { entry = this.cwd; }
                    if (opts === void 0) { opts = {
                        withFileTypes: true
                    }; }
                    if (typeof entry === 'string') {
                        entry = this.cwd.resolve(entry);
                    }
                    else if (!(entry instanceof PathBase)) {
                        opts = entry;
                        entry = this.cwd;
                    }
                    var _2 = opts.withFileTypes, withFileTypes = _2 === void 0 ? true : _2;
                    if (!entry.canReaddir()) {
                        return [];
                    }
                    else if (withFileTypes) {
                        return entry.readdirSync();
                    }
                    else {
                        return entry.readdirSync().map(function (e) { return e.name; });
                    }
                };
                /**
                 * Call lstat() on the string or Path object, and update all known
                 * information that can be determined.
                 *
                 * Note that unlike `fs.lstat()`, the returned value does not contain some
                 * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
                 * information is required, you will need to call `fs.lstat` yourself.
                 *
                 * If the Path refers to a nonexistent file, or if the lstat call fails for
                 * any reason, `undefined` is returned.  Otherwise the updated Path object is
                 * returned.
                 *
                 * Results are cached, and thus may be out of date if the filesystem is
                 * mutated.
                 */
                PathScurryBase.prototype.lstat = function (entry) {
                    if (entry === void 0) { entry = this.cwd; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_2) {
                            if (typeof entry === 'string') {
                                entry = this.cwd.resolve(entry);
                            }
                            return [2 /*return*/, entry.lstat()];
                        });
                    });
                };
                /**
                 * synchronous {@link PathScurryBase.lstat}
                 */
                PathScurryBase.prototype.lstatSync = function (entry) {
                    if (entry === void 0) { entry = this.cwd; }
                    if (typeof entry === 'string') {
                        entry = this.cwd.resolve(entry);
                    }
                    return entry.lstatSync();
                };
                PathScurryBase.prototype.readlink = function (entry, _2) {
                    if (entry === void 0) { entry = this.cwd; }
                    var _3 = _2 === void 0 ? {
                        withFileTypes: false
                    } : _2, withFileTypes = _3.withFileTypes;
                    return __awaiter(this, void 0, void 0, function () {
                        var e;
                        return __generator(this, function (_4) {
                            switch (_4.label) {
                                case 0:
                                    if (typeof entry === 'string') {
                                        entry = this.cwd.resolve(entry);
                                    }
                                    else if (!(entry instanceof PathBase)) {
                                        withFileTypes = entry.withFileTypes;
                                        entry = this.cwd;
                                    }
                                    return [4 /*yield*/, entry.readlink()];
                                case 1:
                                    e = _4.sent();
                                    return [2 /*return*/, withFileTypes ? e : e === null || e === void 0 ? void 0 : e.fullpath()];
                            }
                        });
                    });
                };
                PathScurryBase.prototype.readlinkSync = function (entry, _2) {
                    if (entry === void 0) { entry = this.cwd; }
                    var _3 = _2 === void 0 ? {
                        withFileTypes: false
                    } : _2, withFileTypes = _3.withFileTypes;
                    if (typeof entry === 'string') {
                        entry = this.cwd.resolve(entry);
                    }
                    else if (!(entry instanceof PathBase)) {
                        withFileTypes = entry.withFileTypes;
                        entry = this.cwd;
                    }
                    var e = entry.readlinkSync();
                    return withFileTypes ? e : e === null || e === void 0 ? void 0 : e.fullpath();
                };
                PathScurryBase.prototype.realpath = function (entry, _2) {
                    if (entry === void 0) { entry = this.cwd; }
                    var _3 = _2 === void 0 ? {
                        withFileTypes: false
                    } : _2, withFileTypes = _3.withFileTypes;
                    return __awaiter(this, void 0, void 0, function () {
                        var e;
                        return __generator(this, function (_4) {
                            switch (_4.label) {
                                case 0:
                                    if (typeof entry === 'string') {
                                        entry = this.cwd.resolve(entry);
                                    }
                                    else if (!(entry instanceof PathBase)) {
                                        withFileTypes = entry.withFileTypes;
                                        entry = this.cwd;
                                    }
                                    return [4 /*yield*/, entry.realpath()];
                                case 1:
                                    e = _4.sent();
                                    return [2 /*return*/, withFileTypes ? e : e === null || e === void 0 ? void 0 : e.fullpath()];
                            }
                        });
                    });
                };
                PathScurryBase.prototype.realpathSync = function (entry, _2) {
                    if (entry === void 0) { entry = this.cwd; }
                    var _3 = _2 === void 0 ? {
                        withFileTypes: false
                    } : _2, withFileTypes = _3.withFileTypes;
                    if (typeof entry === 'string') {
                        entry = this.cwd.resolve(entry);
                    }
                    else if (!(entry instanceof PathBase)) {
                        withFileTypes = entry.withFileTypes;
                        entry = this.cwd;
                    }
                    var e = entry.realpathSync();
                    return withFileTypes ? e : e === null || e === void 0 ? void 0 : e.fullpath();
                };
                PathScurryBase.prototype.walk = function (entry, opts) {
                    if (entry === void 0) { entry = this.cwd; }
                    if (opts === void 0) { opts = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var _2, withFileTypes, _3, follow, filter, walkFilter, results, dirs, walk, start;
                        return __generator(this, function (_4) {
                            if (typeof entry === 'string') {
                                entry = this.cwd.resolve(entry);
                            }
                            else if (!(entry instanceof PathBase)) {
                                opts = entry;
                                entry = this.cwd;
                            }
                            _2 = opts.withFileTypes, withFileTypes = _2 === void 0 ? true : _2, _3 = opts.follow, follow = _3 === void 0 ? false : _3, filter = opts.filter, walkFilter = opts.walkFilter;
                            results = [];
                            if (!filter || filter(entry)) {
                                results.push(withFileTypes ? entry : entry.fullpath());
                            }
                            dirs = new Set();
                            walk = function (dir, cb) {
                                dirs.add(dir);
                                dir.readdirCB(function (er, entries) {
                                    /* c8 ignore start */
                                    if (er) {
                                        return cb(er);
                                    }
                                    /* c8 ignore stop */
                                    var len = entries.length;
                                    if (!len)
                                        return cb();
                                    var next = function () {
                                        if (--len === 0) {
                                            cb();
                                        }
                                    };
                                    for (var _2 = 0, entries_4 = entries; _2 < entries_4.length; _2++) {
                                        var e = entries_4[_2];
                                        if (!filter || filter(e)) {
                                            results.push(withFileTypes ? e : e.fullpath());
                                        }
                                        if (follow && e.isSymbolicLink()) {
                                            e.realpath()
                                                .then(function (r) { return ((r === null || r === void 0 ? void 0 : r.isUnknown()) ? r.lstat() : r); })
                                                .then(function (r) { return (r === null || r === void 0 ? void 0 : r.shouldWalk(dirs, walkFilter)) ? walk(r, next) : next(); });
                                        }
                                        else {
                                            if (e.shouldWalk(dirs, walkFilter)) {
                                                walk(e, next);
                                            }
                                            else {
                                                next();
                                            }
                                        }
                                    }
                                }, true); // zalgooooooo
                            };
                            start = entry;
                            return [2 /*return*/, new Promise(function (res, rej) {
                                    walk(start, function (er) {
                                        /* c8 ignore start */
                                        if (er)
                                            return rej(er);
                                        /* c8 ignore stop */
                                        res(results);
                                    });
                                })];
                        });
                    });
                };
                PathScurryBase.prototype.walkSync = function (entry, opts) {
                    if (entry === void 0) { entry = this.cwd; }
                    if (opts === void 0) { opts = {}; }
                    if (typeof entry === 'string') {
                        entry = this.cwd.resolve(entry);
                    }
                    else if (!(entry instanceof PathBase)) {
                        opts = entry;
                        entry = this.cwd;
                    }
                    var _2 = opts.withFileTypes, withFileTypes = _2 === void 0 ? true : _2, _3 = opts.follow, follow = _3 === void 0 ? false : _3, filter = opts.filter, walkFilter = opts.walkFilter;
                    var results = [];
                    if (!filter || filter(entry)) {
                        results.push(withFileTypes ? entry : entry.fullpath());
                    }
                    var dirs = new Set([entry]);
                    for (var _4 = 0, dirs_1 = dirs; _4 < dirs_1.length; _4++) {
                        var dir = dirs_1[_4];
                        var entries = dir.readdirSync();
                        for (var _5 = 0, entries_5 = entries; _5 < entries_5.length; _5++) {
                            var e = entries_5[_5];
                            if (!filter || filter(e)) {
                                results.push(withFileTypes ? e : e.fullpath());
                            }
                            var r = e;
                            if (e.isSymbolicLink()) {
                                if (!(follow && (r = e.realpathSync())))
                                    continue;
                                if (r.isUnknown())
                                    r.lstatSync();
                            }
                            if (r.shouldWalk(dirs, walkFilter)) {
                                dirs.add(r);
                            }
                        }
                    }
                    return results;
                };
                /**
                 * Support for `for await`
                 *
                 * Alias for {@link PathScurryBase.iterate}
                 *
                 * Note: As of Node 19, this is very slow, compared to other methods of
                 * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
                 * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
                 */
                PathScurryBase.prototype[(_PathScurryBase_resolveCache = new WeakMap(), _PathScurryBase_resolvePosixCache = new WeakMap(), _PathScurryBase_children = new WeakMap(), _PathScurryBase_fs = new WeakMap(), Symbol.asyncIterator)] = function () {
                    return this.iterate();
                };
                PathScurryBase.prototype.iterate = function (entry, options) {
                    if (entry === void 0) { entry = this.cwd; }
                    if (options === void 0) { options = {}; }
                    // iterating async over the stream is significantly more performant,
                    // especially in the warm-cache scenario, because it buffers up directory
                    // entries in the background instead of waiting for a yield for each one.
                    if (typeof entry === 'string') {
                        entry = this.cwd.resolve(entry);
                    }
                    else if (!(entry instanceof PathBase)) {
                        options = entry;
                        entry = this.cwd;
                    }
                    return this.stream(entry, options)[Symbol.asyncIterator]();
                };
                /**
                 * Iterating over a PathScurry performs a synchronous walk.
                 *
                 * Alias for {@link PathScurryBase.iterateSync}
                 */
                PathScurryBase.prototype[Symbol.iterator] = function () {
                    return this.iterateSync();
                };
                PathScurryBase.prototype.iterateSync = function (entry, opts) {
                    var _2, withFileTypes, _3, follow, filter, walkFilter, dirs, _4, dirs_2, dir, entries, _5, entries_6, e, r;
                    if (entry === void 0) { entry = this.cwd; }
                    if (opts === void 0) { opts = {}; }
                    return __generator(this, function (_6) {
                        switch (_6.label) {
                            case 0:
                                if (typeof entry === 'string') {
                                    entry = this.cwd.resolve(entry);
                                }
                                else if (!(entry instanceof PathBase)) {
                                    opts = entry;
                                    entry = this.cwd;
                                }
                                _2 = opts.withFileTypes, withFileTypes = _2 === void 0 ? true : _2, _3 = opts.follow, follow = _3 === void 0 ? false : _3, filter = opts.filter, walkFilter = opts.walkFilter;
                                if (!(!filter || filter(entry))) return [3 /*break*/, 2];
                                return [4 /*yield*/, withFileTypes ? entry : entry.fullpath()];
                            case 1:
                                _6.sent();
                                _6.label = 2;
                            case 2:
                                dirs = new Set([entry]);
                                _4 = 0, dirs_2 = dirs;
                                _6.label = 3;
                            case 3:
                                if (!(_4 < dirs_2.length)) return [3 /*break*/, 9];
                                dir = dirs_2[_4];
                                entries = dir.readdirSync();
                                _5 = 0, entries_6 = entries;
                                _6.label = 4;
                            case 4:
                                if (!(_5 < entries_6.length)) return [3 /*break*/, 8];
                                e = entries_6[_5];
                                if (!(!filter || filter(e))) return [3 /*break*/, 6];
                                return [4 /*yield*/, withFileTypes ? e : e.fullpath()];
                            case 5:
                                _6.sent();
                                _6.label = 6;
                            case 6:
                                r = e;
                                if (e.isSymbolicLink()) {
                                    if (!(follow && (r = e.realpathSync())))
                                        return [3 /*break*/, 7];
                                    if (r.isUnknown())
                                        r.lstatSync();
                                }
                                if (r.shouldWalk(dirs, walkFilter)) {
                                    dirs.add(r);
                                }
                                _6.label = 7;
                            case 7:
                                _5++;
                                return [3 /*break*/, 4];
                            case 8:
                                _4++;
                                return [3 /*break*/, 3];
                            case 9: return [2 /*return*/];
                        }
                    });
                };
                PathScurryBase.prototype.stream = function (entry, opts) {
                    if (entry === void 0) { entry = this.cwd; }
                    if (opts === void 0) { opts = {}; }
                    if (typeof entry === 'string') {
                        entry = this.cwd.resolve(entry);
                    }
                    else if (!(entry instanceof PathBase)) {
                        opts = entry;
                        entry = this.cwd;
                    }
                    var _2 = opts.withFileTypes, withFileTypes = _2 === void 0 ? true : _2, _3 = opts.follow, follow = _3 === void 0 ? false : _3, filter = opts.filter, walkFilter = opts.walkFilter;
                    var results = new minipass_1.Minipass({ objectMode: true });
                    if (!filter || filter(entry)) {
                        results.write(withFileTypes ? entry : entry.fullpath());
                    }
                    var dirs = new Set();
                    var queue = [entry];
                    var processing = 0;
                    var process = function () {
                        var paused = false;
                        var _loop_23 = function () {
                            var dir = queue.shift();
                            if (!dir) {
                                if (processing === 0)
                                    results.end();
                                return { value: void 0 };
                            }
                            processing++;
                            dirs.add(dir);
                            var onReaddir = function (er, entries, didRealpaths) {
                                if (didRealpaths === void 0) { didRealpaths = false; }
                                /* c8 ignore start */
                                if (er)
                                    return results.emit('error', er);
                                /* c8 ignore stop */
                                if (follow && !didRealpaths) {
                                    var promises = [];
                                    for (var _2 = 0, entries_7 = entries; _2 < entries_7.length; _2++) {
                                        var e = entries_7[_2];
                                        if (e.isSymbolicLink()) {
                                            promises.push(e
                                                .realpath()
                                                .then(function (r) { return (r === null || r === void 0 ? void 0 : r.isUnknown()) ? r.lstat() : r; }));
                                        }
                                    }
                                    if (promises.length) {
                                        Promise.all(promises).then(function () { return onReaddir(null, entries, true); });
                                        return;
                                    }
                                }
                                for (var _3 = 0, entries_8 = entries; _3 < entries_8.length; _3++) {
                                    var e = entries_8[_3];
                                    if (e && (!filter || filter(e))) {
                                        if (!results.write(withFileTypes ? e : e.fullpath())) {
                                            paused = true;
                                        }
                                    }
                                }
                                processing--;
                                for (var _4 = 0, entries_9 = entries; _4 < entries_9.length; _4++) {
                                    var e = entries_9[_4];
                                    var r = e.realpathCached() || e;
                                    if (r.shouldWalk(dirs, walkFilter)) {
                                        queue.push(r);
                                    }
                                }
                                if (paused && !results.flowing) {
                                    results.once('drain', process);
                                }
                                else if (!sync) {
                                    process();
                                }
                            };
                            // zalgo containment
                            var sync = true;
                            dir.readdirCB(onReaddir, true);
                            sync = false;
                        };
                        while (!paused) {
                            var state_6 = _loop_23();
                            if (typeof state_6 === "object")
                                return state_6.value;
                        }
                    };
                    process();
                    return results;
                };
                PathScurryBase.prototype.streamSync = function (entry, opts) {
                    if (entry === void 0) { entry = this.cwd; }
                    if (opts === void 0) { opts = {}; }
                    if (typeof entry === 'string') {
                        entry = this.cwd.resolve(entry);
                    }
                    else if (!(entry instanceof PathBase)) {
                        opts = entry;
                        entry = this.cwd;
                    }
                    var _2 = opts.withFileTypes, withFileTypes = _2 === void 0 ? true : _2, _3 = opts.follow, follow = _3 === void 0 ? false : _3, filter = opts.filter, walkFilter = opts.walkFilter;
                    var results = new minipass_1.Minipass({ objectMode: true });
                    var dirs = new Set();
                    if (!filter || filter(entry)) {
                        results.write(withFileTypes ? entry : entry.fullpath());
                    }
                    var queue = [entry];
                    var processing = 0;
                    var process = function () {
                        var paused = false;
                        while (!paused) {
                            var dir = queue.shift();
                            if (!dir) {
                                if (processing === 0)
                                    results.end();
                                return;
                            }
                            processing++;
                            dirs.add(dir);
                            var entries = dir.readdirSync();
                            for (var _2 = 0, entries_10 = entries; _2 < entries_10.length; _2++) {
                                var e = entries_10[_2];
                                if (!filter || filter(e)) {
                                    if (!results.write(withFileTypes ? e : e.fullpath())) {
                                        paused = true;
                                    }
                                }
                            }
                            processing--;
                            for (var _3 = 0, entries_11 = entries; _3 < entries_11.length; _3++) {
                                var e = entries_11[_3];
                                var r = e;
                                if (e.isSymbolicLink()) {
                                    if (!(follow && (r = e.realpathSync())))
                                        continue;
                                    if (r.isUnknown())
                                        r.lstatSync();
                                }
                                if (r.shouldWalk(dirs, walkFilter)) {
                                    queue.push(r);
                                }
                            }
                        }
                        if (paused && !results.flowing)
                            results.once('drain', process);
                    };
                    process();
                    return results;
                };
                PathScurryBase.prototype.chdir = function (path) {
                    if (path === void 0) { path = this.cwd; }
                    var oldCwd = this.cwd;
                    this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path;
                    this.cwd[setAsCwd](oldCwd);
                };
                return PathScurryBase;
            }());
            exports.PathScurryBase = PathScurryBase;
            /**
             * Windows implementation of {@link PathScurryBase}
             *
             * Defaults to case insensitve, uses `'\\'` to generate path strings.  Uses
             * {@link PathWin32} for Path objects.
             */
            var PathScurryWin32 = /** @class */ (function (_super) {
                __extends(PathScurryWin32, _super);
                function PathScurryWin32(cwd, opts) {
                    if (cwd === void 0) { cwd = process.cwd(); }
                    if (opts === void 0) { opts = {}; }
                    var _this_1 = this;
                    var _2 = opts.nocase, nocase = _2 === void 0 ? true : _2;
                    _this_1 = _super.call(this, cwd, path_1.win32, '\\', __assign(__assign({}, opts), { nocase: nocase })) || this;
                    /**
                     * separator for generating path strings
                     */
                    _this_1.sep = '\\';
                    _this_1.nocase = nocase;
                    for (var p = _this_1.cwd; p; p = p.parent) {
                        p.nocase = _this_1.nocase;
                    }
                    return _this_1;
                }
                /**
                 * @internal
                 */
                PathScurryWin32.prototype.parseRootPath = function (dir) {
                    // if the path starts with a single separator, it's not a UNC, and we'll
                    // just get separator as the root, and driveFromUNC will return \
                    // In that case, mount \ on the root from the cwd.
                    return path_1.win32.parse(dir).root.toUpperCase();
                };
                /**
                 * @internal
                 */
                PathScurryWin32.prototype.newRoot = function (fs) {
                    return new PathWin32(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs: fs });
                };
                /**
                 * Return true if the provided path string is an absolute path
                 */
                PathScurryWin32.prototype.isAbsolute = function (p) {
                    return (p.startsWith('/') || p.startsWith('\\') || /^[a-z]:(\/|\\)/i.test(p));
                };
                return PathScurryWin32;
            }(PathScurryBase));
            exports.PathScurryWin32 = PathScurryWin32;
            /**
             * {@link PathScurryBase} implementation for all posix systems other than Darwin.
             *
             * Defaults to case-sensitive matching, uses `'/'` to generate path strings.
             *
             * Uses {@link PathPosix} for Path objects.
             */
            var PathScurryPosix = /** @class */ (function (_super) {
                __extends(PathScurryPosix, _super);
                function PathScurryPosix(cwd, opts) {
                    if (cwd === void 0) { cwd = process.cwd(); }
                    if (opts === void 0) { opts = {}; }
                    var _this_1 = this;
                    var _2 = opts.nocase, nocase = _2 === void 0 ? false : _2;
                    _this_1 = _super.call(this, cwd, path_1.posix, '/', __assign(__assign({}, opts), { nocase: nocase })) || this;
                    /**
                     * separator for generating path strings
                     */
                    _this_1.sep = '/';
                    _this_1.nocase = nocase;
                    return _this_1;
                }
                /**
                 * @internal
                 */
                PathScurryPosix.prototype.parseRootPath = function (_dir) {
                    return '/';
                };
                /**
                 * @internal
                 */
                PathScurryPosix.prototype.newRoot = function (fs) {
                    return new PathPosix(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs: fs });
                };
                /**
                 * Return true if the provided path string is an absolute path
                 */
                PathScurryPosix.prototype.isAbsolute = function (p) {
                    return p.startsWith('/');
                };
                return PathScurryPosix;
            }(PathScurryBase));
            exports.PathScurryPosix = PathScurryPosix;
            /**
             * {@link PathScurryBase} implementation for Darwin (macOS) systems.
             *
             * Defaults to case-insensitive matching, uses `'/'` for generating path
             * strings.
             *
             * Uses {@link PathPosix} for Path objects.
             */
            var PathScurryDarwin = /** @class */ (function (_super) {
                __extends(PathScurryDarwin, _super);
                function PathScurryDarwin(cwd, opts) {
                    if (cwd === void 0) { cwd = process.cwd(); }
                    if (opts === void 0) { opts = {}; }
                    var _2 = opts.nocase, nocase = _2 === void 0 ? true : _2;
                    return _super.call(this, cwd, __assign(__assign({}, opts), { nocase: nocase })) || this;
                }
                return PathScurryDarwin;
            }(PathScurryPosix));
            exports.PathScurryDarwin = PathScurryDarwin;
            /**
             * Default {@link PathBase} implementation for the current platform.
             *
             * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.
             */
            exports.Path = process.platform === 'win32' ? PathWin32 : PathPosix;
            /**
             * Default {@link PathScurryBase} implementation for the current platform.
             *
             * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on
             * Darwin (macOS) systems, {@link PathScurryPosix} on all others.
             */
            exports.PathScurry = process.platform === 'win32'
                ? PathScurryWin32
                : process.platform === 'darwin'
                    ? PathScurryDarwin
                    : PathScurryPosix;
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 7433: 
        /***/ (function (__unused_webpack_module, exports) {
            "use strict";
            var _2;
            var _LRUCache_instances, _LRUCache_max, _LRUCache_maxSize, _LRUCache_dispose, _LRUCache_disposeAfter, _LRUCache_fetchMethod, _LRUCache_size, _LRUCache_calculatedSize, _LRUCache_keyMap, _LRUCache_keyList, _LRUCache_valList, _LRUCache_next, _LRUCache_prev, _LRUCache_head, _LRUCache_tail, _LRUCache_free, _LRUCache_disposed, _LRUCache_sizes, _LRUCache_starts, _LRUCache_ttls, _LRUCache_hasDispose, _LRUCache_hasFetchMethod, _LRUCache_hasDisposeAfter, _LRUCache_initializeTTLTracking, _LRUCache_updateItemAge, _LRUCache_statusTTL, _LRUCache_setItemTTL, _LRUCache_isStale, _LRUCache_initializeSizeTracking, _LRUCache_removeItemSize, _LRUCache_addItemSize, _LRUCache_requireSize, _LRUCache_indexes, _LRUCache_rindexes, _LRUCache_isValidIndex, _LRUCache_evict, _LRUCache_backgroundFetch, _LRUCache_isBackgroundFetch, _LRUCache_connect, _LRUCache_moveToTail;
            /**
             * @module LRUCache
             */
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.LRUCache = void 0;
            var perf = typeof performance === 'object' &&
                performance &&
                typeof performance.now === 'function'
                ? performance
                : Date;
            var warned = new Set();
            /* c8 ignore start */
            var PROCESS = (typeof process === 'object' && !!process ? process : {});
            /* c8 ignore start */
            var emitWarning = function (msg, type, code, fn) {
                typeof PROCESS.emitWarning === 'function'
                    ? PROCESS.emitWarning(msg, type, code, fn)
                    : console.error("[".concat(code, "] ").concat(type, ": ").concat(msg));
            };
            var AC = globalThis.AbortController;
            var AS = globalThis.AbortSignal;
            /* c8 ignore start */
            if (typeof AC === 'undefined') {
                //@ts-ignore
                AS = /** @class */ (function () {
                    function AbortSignal() {
                        this._onabort = [];
                        this.aborted = false;
                    }
                    AbortSignal.prototype.addEventListener = function (_, fn) {
                        this._onabort.push(fn);
                    };
                    return AbortSignal;
                }());
                //@ts-ignore
                AC = /** @class */ (function () {
                    function AbortController() {
                        this.signal = new AS();
                        warnACPolyfill_1();
                    }
                    AbortController.prototype.abort = function (reason) {
                        var _2, _3;
                        if (this.signal.aborted)
                            return;
                        //@ts-ignore
                        this.signal.reason = reason;
                        //@ts-ignore
                        this.signal.aborted = true;
                        //@ts-ignore
                        for (var _4 = 0, _5 = this.signal._onabort; _4 < _5.length; _4++) {
                            var fn = _5[_4];
                            fn(reason);
                        }
                        (_3 = (_2 = this.signal).onabort) === null || _3 === void 0 ? void 0 : _3.call(_2, reason);
                    };
                    return AbortController;
                }());
                var printACPolyfillWarning_1 = ((_2 = PROCESS.env) === null || _2 === void 0 ? void 0 : _2.LRU_CACHE_IGNORE_AC_WARNING) !== '1';
                var warnACPolyfill_1 = function () {
                    if (!printACPolyfillWarning_1)
                        return;
                    printACPolyfillWarning_1 = false;
                    emitWarning('AbortController is not defined. If using lru-cache in ' +
                        'node 14, load an AbortController polyfill from the ' +
                        '`node-abort-controller` package. A minimal polyfill is ' +
                        'provided for use by LRUCache.fetch(), but it should not be ' +
                        'relied upon in other contexts (eg, passing it to other APIs that ' +
                        'use AbortController/AbortSignal might have undesirable effects). ' +
                        'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill_1);
                };
            }
            /* c8 ignore stop */
            var shouldWarn = function (code) { return !warned.has(code); };
            var TYPE = Symbol('type');
            var isPosInt = function (n) { return n && n === Math.floor(n) && n > 0 && isFinite(n); };
            /* c8 ignore start */
            // This is a little bit ridiculous, tbh.
            // The maximum array length is 2^32-1 or thereabouts on most JS impls.
            // And well before that point, you're caching the entire world, I mean,
            // that's ~32GB of just integers for the next/prev links, plus whatever
            // else to hold that many keys and values.  Just filling the memory with
            // zeroes at init time is brutal when you get that big.
            // But why not be complete?
            // Maybe in the future, these limits will have expanded.
            var getUintArray = function (max) { return !isPosInt(max)
                ? null
                : max <= Math.pow(2, 8)
                    ? Uint8Array
                    : max <= Math.pow(2, 16)
                        ? Uint16Array
                        : max <= Math.pow(2, 32)
                            ? Uint32Array
                            : max <= Number.MAX_SAFE_INTEGER
                                ? ZeroArray
                                : null; };
            /* c8 ignore stop */
            var ZeroArray = /** @class */ (function (_super) {
                __extends(ZeroArray, _super);
                function ZeroArray(size) {
                    var _this_1 = _super.call(this, size) || this;
                    _this_1.fill(0);
                    return _this_1;
                }
                return ZeroArray;
            }(Array));
            var Stack = /** @class */ (function () {
                function Stack(max, HeapCls) {
                    /* c8 ignore start */
                    if (!__classPrivateFieldGet(Stack, _3, "f", _Stack_constructing)) {
                        throw new TypeError('instantiate Stack using Stack.create(n)');
                    }
                    /* c8 ignore stop */
                    this.heap = new HeapCls(max);
                    this.length = 0;
                }
                Stack.create = function (max) {
                    var HeapCls = getUintArray(max);
                    if (!HeapCls)
                        return [];
                    __classPrivateFieldSet(Stack, _3, true, "f", _Stack_constructing);
                    var s = new Stack(max, HeapCls);
                    __classPrivateFieldSet(Stack, _3, false, "f", _Stack_constructing);
                    return s;
                };
                Stack.prototype.push = function (n) {
                    this.heap[this.length++] = n;
                };
                Stack.prototype.pop = function () {
                    return this.heap[--this.length];
                };
                var _3, _Stack_constructing;
                _3 = Stack;
                // private constructor
                _Stack_constructing = { value: false };
                return Stack;
            }());
            /**
             * Default export, the thing you're using this module to get.
             *
             * All properties from the options object (with the exception of
             * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as
             * normal public members. (`max` and `maxBase` are read-only getters.)
             * Changing any of these will alter the defaults for subsequent method calls,
             * but is otherwise safe.
             */
            var LRUCache = /** @class */ (function () {
                function LRUCache(options) {
                    _LRUCache_instances.add(this);
                    // properties coming in from the options of these, only max and maxSize
                    // really *need* to be protected. The rest can be modified, as they just
                    // set defaults for various methods.
                    _LRUCache_max.set(this, void 0);
                    _LRUCache_maxSize.set(this, void 0);
                    _LRUCache_dispose.set(this, void 0);
                    _LRUCache_disposeAfter.set(this, void 0);
                    _LRUCache_fetchMethod.set(this, void 0);
                    // computed properties
                    _LRUCache_size.set(this, void 0);
                    _LRUCache_calculatedSize.set(this, void 0);
                    _LRUCache_keyMap.set(this, void 0);
                    _LRUCache_keyList.set(this, void 0);
                    _LRUCache_valList.set(this, void 0);
                    _LRUCache_next.set(this, void 0);
                    _LRUCache_prev.set(this, void 0);
                    _LRUCache_head.set(this, void 0);
                    _LRUCache_tail.set(this, void 0);
                    _LRUCache_free.set(this, void 0);
                    _LRUCache_disposed.set(this, void 0);
                    _LRUCache_sizes.set(this, void 0);
                    _LRUCache_starts.set(this, void 0);
                    _LRUCache_ttls.set(this, void 0);
                    _LRUCache_hasDispose.set(this, void 0);
                    _LRUCache_hasFetchMethod.set(this, void 0);
                    _LRUCache_hasDisposeAfter.set(this, void 0);
                    // conditionally set private methods related to TTL
                    _LRUCache_updateItemAge.set(this, function () { });
                    _LRUCache_statusTTL.set(this, function () { });
                    _LRUCache_setItemTTL.set(this, function () { });
                    /* c8 ignore stop */
                    _LRUCache_isStale.set(this, function () { return false; });
                    _LRUCache_removeItemSize.set(this, function (_i) { });
                    _LRUCache_addItemSize.set(this, function (_i, _s, _st) { });
                    _LRUCache_requireSize.set(this, function (_k, _v, size, sizeCalculation) {
                        if (size || sizeCalculation) {
                            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');
                        }
                        return 0;
                    });
                    var _2 = options.max, max = _2 === void 0 ? 0 : _2, ttl = options.ttl, _4 = options.ttlResolution, ttlResolution = _4 === void 0 ? 1 : _4, ttlAutopurge = options.ttlAutopurge, updateAgeOnGet = options.updateAgeOnGet, updateAgeOnHas = options.updateAgeOnHas, allowStale = options.allowStale, dispose = options.dispose, disposeAfter = options.disposeAfter, noDisposeOnSet = options.noDisposeOnSet, noUpdateTTL = options.noUpdateTTL, _5 = options.maxSize, maxSize = _5 === void 0 ? 0 : _5, _6 = options.maxEntrySize, maxEntrySize = _6 === void 0 ? 0 : _6, sizeCalculation = options.sizeCalculation, fetchMethod = options.fetchMethod, noDeleteOnFetchRejection = options.noDeleteOnFetchRejection, noDeleteOnStaleGet = options.noDeleteOnStaleGet, allowStaleOnFetchRejection = options.allowStaleOnFetchRejection, allowStaleOnFetchAbort = options.allowStaleOnFetchAbort, ignoreFetchAbort = options.ignoreFetchAbort;
                    if (max !== 0 && !isPosInt(max)) {
                        throw new TypeError('max option must be a nonnegative integer');
                    }
                    var UintArray = max ? getUintArray(max) : Array;
                    if (!UintArray) {
                        throw new Error('invalid max value: ' + max);
                    }
                    __classPrivateFieldSet(this, _LRUCache_max, max, "f");
                    __classPrivateFieldSet(this, _LRUCache_maxSize, maxSize, "f");
                    this.maxEntrySize = maxEntrySize || __classPrivateFieldGet(this, _LRUCache_maxSize, "f");
                    this.sizeCalculation = sizeCalculation;
                    if (this.sizeCalculation) {
                        if (!__classPrivateFieldGet(this, _LRUCache_maxSize, "f") && !this.maxEntrySize) {
                            throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');
                        }
                        if (typeof this.sizeCalculation !== 'function') {
                            throw new TypeError('sizeCalculation set to non-function');
                        }
                    }
                    if (fetchMethod !== undefined &&
                        typeof fetchMethod !== 'function') {
                        throw new TypeError('fetchMethod must be a function if specified');
                    }
                    __classPrivateFieldSet(this, _LRUCache_fetchMethod, fetchMethod, "f");
                    __classPrivateFieldSet(this, _LRUCache_hasFetchMethod, !!fetchMethod, "f");
                    __classPrivateFieldSet(this, _LRUCache_keyMap, new Map(), "f");
                    __classPrivateFieldSet(this, _LRUCache_keyList, new Array(max).fill(undefined), "f");
                    __classPrivateFieldSet(this, _LRUCache_valList, new Array(max).fill(undefined), "f");
                    __classPrivateFieldSet(this, _LRUCache_next, new UintArray(max), "f");
                    __classPrivateFieldSet(this, _LRUCache_prev, new UintArray(max), "f");
                    __classPrivateFieldSet(this, _LRUCache_head, 0, "f");
                    __classPrivateFieldSet(this, _LRUCache_tail, 0, "f");
                    __classPrivateFieldSet(this, _LRUCache_free, Stack.create(max), "f");
                    __classPrivateFieldSet(this, _LRUCache_size, 0, "f");
                    __classPrivateFieldSet(this, _LRUCache_calculatedSize, 0, "f");
                    if (typeof dispose === 'function') {
                        __classPrivateFieldSet(this, _LRUCache_dispose, dispose, "f");
                    }
                    if (typeof disposeAfter === 'function') {
                        __classPrivateFieldSet(this, _LRUCache_disposeAfter, disposeAfter, "f");
                        __classPrivateFieldSet(this, _LRUCache_disposed, [], "f");
                    }
                    else {
                        __classPrivateFieldSet(this, _LRUCache_disposeAfter, undefined, "f");
                        __classPrivateFieldSet(this, _LRUCache_disposed, undefined, "f");
                    }
                    __classPrivateFieldSet(this, _LRUCache_hasDispose, !!__classPrivateFieldGet(this, _LRUCache_dispose, "f"), "f");
                    __classPrivateFieldSet(this, _LRUCache_hasDisposeAfter, !!__classPrivateFieldGet(this, _LRUCache_disposeAfter, "f"), "f");
                    this.noDisposeOnSet = !!noDisposeOnSet;
                    this.noUpdateTTL = !!noUpdateTTL;
                    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
                    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
                    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
                    this.ignoreFetchAbort = !!ignoreFetchAbort;
                    // NB: maxEntrySize is set to maxSize if it's set
                    if (this.maxEntrySize !== 0) {
                        if (__classPrivateFieldGet(this, _LRUCache_maxSize, "f") !== 0) {
                            if (!isPosInt(__classPrivateFieldGet(this, _LRUCache_maxSize, "f"))) {
                                throw new TypeError('maxSize must be a positive integer if specified');
                            }
                        }
                        if (!isPosInt(this.maxEntrySize)) {
                            throw new TypeError('maxEntrySize must be a positive integer if specified');
                        }
                        __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_initializeSizeTracking).call(this);
                    }
                    this.allowStale = !!allowStale;
                    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
                    this.updateAgeOnGet = !!updateAgeOnGet;
                    this.updateAgeOnHas = !!updateAgeOnHas;
                    this.ttlResolution =
                        isPosInt(ttlResolution) || ttlResolution === 0
                            ? ttlResolution
                            : 1;
                    this.ttlAutopurge = !!ttlAutopurge;
                    this.ttl = ttl || 0;
                    if (this.ttl) {
                        if (!isPosInt(this.ttl)) {
                            throw new TypeError('ttl must be a positive integer if specified');
                        }
                        __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_initializeTTLTracking).call(this);
                    }
                    // do not allow completely unbounded caches
                    if (__classPrivateFieldGet(this, _LRUCache_max, "f") === 0 && this.ttl === 0 && __classPrivateFieldGet(this, _LRUCache_maxSize, "f") === 0) {
                        throw new TypeError('At least one of max, maxSize, or ttl is required');
                    }
                    if (!this.ttlAutopurge && !__classPrivateFieldGet(this, _LRUCache_max, "f") && !__classPrivateFieldGet(this, _LRUCache_maxSize, "f")) {
                        var code = 'LRU_CACHE_UNBOUNDED';
                        if (shouldWarn(code)) {
                            warned.add(code);
                            var msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +
                                'result in unbounded memory consumption.';
                            emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);
                        }
                    }
                }
                /**
                 * Do not call this method unless you need to inspect the
                 * inner workings of the cache.  If anything returned by this
                 * object is modified in any way, strange breakage may occur.
                 *
                 * These fields are private for a reason!
                 *
                 * @internal
                 */
                LRUCache.unsafeExposeInternals = function (c) {
                    return {
                        // properties
                        starts: __classPrivateFieldGet(c, _LRUCache_starts, "f"),
                        ttls: __classPrivateFieldGet(c, _LRUCache_ttls, "f"),
                        sizes: __classPrivateFieldGet(c, _LRUCache_sizes, "f"),
                        keyMap: __classPrivateFieldGet(c, _LRUCache_keyMap, "f"),
                        keyList: __classPrivateFieldGet(c, _LRUCache_keyList, "f"),
                        valList: __classPrivateFieldGet(c, _LRUCache_valList, "f"),
                        next: __classPrivateFieldGet(c, _LRUCache_next, "f"),
                        prev: __classPrivateFieldGet(c, _LRUCache_prev, "f"),
                        get head() {
                            return __classPrivateFieldGet(c, _LRUCache_head, "f");
                        },
                        get tail() {
                            return __classPrivateFieldGet(c, _LRUCache_tail, "f");
                        },
                        free: __classPrivateFieldGet(c, _LRUCache_free, "f"),
                        // methods
                        isBackgroundFetch: function (p) { return __classPrivateFieldGet(c, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(c, p); },
                        backgroundFetch: function (k, index, options, context) { return __classPrivateFieldGet(c, _LRUCache_instances, "m", _LRUCache_backgroundFetch).call(c, k, index, options, context); },
                        moveToTail: function (index) { return __classPrivateFieldGet(c, _LRUCache_instances, "m", _LRUCache_moveToTail).call(c, index); },
                        indexes: function (options) { return __classPrivateFieldGet(c, _LRUCache_instances, "m", _LRUCache_indexes).call(c, options); },
                        rindexes: function (options) { return __classPrivateFieldGet(c, _LRUCache_instances, "m", _LRUCache_rindexes).call(c, options); },
                        isStale: function (index) { return __classPrivateFieldGet(c, _LRUCache_isStale, "f").call(c, index); }
                    };
                };
                Object.defineProperty(LRUCache.prototype, "max", {
                    // Protected read-only members
                    /**
                     * {@link LRUCache.OptionsBase.max} (read-only)
                     */
                    get: function () {
                        return __classPrivateFieldGet(this, _LRUCache_max, "f");
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(LRUCache.prototype, "maxSize", {
                    /**
                     * {@link LRUCache.OptionsBase.maxSize} (read-only)
                     */
                    get: function () {
                        return __classPrivateFieldGet(this, _LRUCache_maxSize, "f");
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(LRUCache.prototype, "calculatedSize", {
                    /**
                     * The total computed size of items in the cache (read-only)
                     */
                    get: function () {
                        return __classPrivateFieldGet(this, _LRUCache_calculatedSize, "f");
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(LRUCache.prototype, "size", {
                    /**
                     * The number of items stored in the cache (read-only)
                     */
                    get: function () {
                        return __classPrivateFieldGet(this, _LRUCache_size, "f");
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(LRUCache.prototype, "fetchMethod", {
                    /**
                     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
                     */
                    get: function () {
                        return __classPrivateFieldGet(this, _LRUCache_fetchMethod, "f");
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(LRUCache.prototype, "dispose", {
                    /**
                     * {@link LRUCache.OptionsBase.dispose} (read-only)
                     */
                    get: function () {
                        return __classPrivateFieldGet(this, _LRUCache_dispose, "f");
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(LRUCache.prototype, "disposeAfter", {
                    /**
                     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
                     */
                    get: function () {
                        return __classPrivateFieldGet(this, _LRUCache_disposeAfter, "f");
                    },
                    enumerable: false,
                    configurable: true
                });
                /**
                 * Return the remaining TTL time for a given entry key
                 */
                LRUCache.prototype.getRemainingTTL = function (key) {
                    return __classPrivateFieldGet(this, _LRUCache_keyMap, "f").has(key) ? Infinity : 0;
                };
                /**
                 * Return a generator yielding `[key, value]` pairs,
                 * in order from most recently used to least recently used.
                 */
                LRUCache.prototype.entries = function () {
                    var _2, _4, i;
                    return __generator(this, function (_5) {
                        switch (_5.label) {
                            case 0:
                                _2 = 0, _4 = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_indexes).call(this);
                                _5.label = 1;
                            case 1:
                                if (!(_2 < _4.length)) return [3 /*break*/, 4];
                                i = _4[_2];
                                if (!(__classPrivateFieldGet(this, _LRUCache_valList, "f")[i] !== undefined &&
                                    __classPrivateFieldGet(this, _LRUCache_keyList, "f")[i] !== undefined &&
                                    !__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, __classPrivateFieldGet(this, _LRUCache_valList, "f")[i]))) return [3 /*break*/, 3];
                                return [4 /*yield*/, [__classPrivateFieldGet(this, _LRUCache_keyList, "f")[i], __classPrivateFieldGet(this, _LRUCache_valList, "f")[i]]];
                            case 2:
                                _5.sent();
                                _5.label = 3;
                            case 3:
                                _2++;
                                return [3 /*break*/, 1];
                            case 4: return [2 /*return*/];
                        }
                    });
                };
                /**
                 * Inverse order version of {@link LRUCache.entries}
                 *
                 * Return a generator yielding `[key, value]` pairs,
                 * in order from least recently used to most recently used.
                 */
                LRUCache.prototype.rentries = function () {
                    var _2, _4, i;
                    return __generator(this, function (_5) {
                        switch (_5.label) {
                            case 0:
                                _2 = 0, _4 = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_rindexes).call(this);
                                _5.label = 1;
                            case 1:
                                if (!(_2 < _4.length)) return [3 /*break*/, 4];
                                i = _4[_2];
                                if (!(__classPrivateFieldGet(this, _LRUCache_valList, "f")[i] !== undefined &&
                                    __classPrivateFieldGet(this, _LRUCache_keyList, "f")[i] !== undefined &&
                                    !__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, __classPrivateFieldGet(this, _LRUCache_valList, "f")[i]))) return [3 /*break*/, 3];
                                return [4 /*yield*/, [__classPrivateFieldGet(this, _LRUCache_keyList, "f")[i], __classPrivateFieldGet(this, _LRUCache_valList, "f")[i]]];
                            case 2:
                                _5.sent();
                                _5.label = 3;
                            case 3:
                                _2++;
                                return [3 /*break*/, 1];
                            case 4: return [2 /*return*/];
                        }
                    });
                };
                /**
                 * Return a generator yielding the keys in the cache,
                 * in order from most recently used to least recently used.
                 */
                LRUCache.prototype.keys = function () {
                    var _2, _4, i, k;
                    return __generator(this, function (_5) {
                        switch (_5.label) {
                            case 0:
                                _2 = 0, _4 = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_indexes).call(this);
                                _5.label = 1;
                            case 1:
                                if (!(_2 < _4.length)) return [3 /*break*/, 4];
                                i = _4[_2];
                                k = __classPrivateFieldGet(this, _LRUCache_keyList, "f")[i];
                                if (!(k !== undefined &&
                                    !__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, __classPrivateFieldGet(this, _LRUCache_valList, "f")[i]))) return [3 /*break*/, 3];
                                return [4 /*yield*/, k];
                            case 2:
                                _5.sent();
                                _5.label = 3;
                            case 3:
                                _2++;
                                return [3 /*break*/, 1];
                            case 4: return [2 /*return*/];
                        }
                    });
                };
                /**
                 * Inverse order version of {@link LRUCache.keys}
                 *
                 * Return a generator yielding the keys in the cache,
                 * in order from least recently used to most recently used.
                 */
                LRUCache.prototype.rkeys = function () {
                    var _2, _4, i, k;
                    return __generator(this, function (_5) {
                        switch (_5.label) {
                            case 0:
                                _2 = 0, _4 = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_rindexes).call(this);
                                _5.label = 1;
                            case 1:
                                if (!(_2 < _4.length)) return [3 /*break*/, 4];
                                i = _4[_2];
                                k = __classPrivateFieldGet(this, _LRUCache_keyList, "f")[i];
                                if (!(k !== undefined &&
                                    !__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, __classPrivateFieldGet(this, _LRUCache_valList, "f")[i]))) return [3 /*break*/, 3];
                                return [4 /*yield*/, k];
                            case 2:
                                _5.sent();
                                _5.label = 3;
                            case 3:
                                _2++;
                                return [3 /*break*/, 1];
                            case 4: return [2 /*return*/];
                        }
                    });
                };
                /**
                 * Return a generator yielding the values in the cache,
                 * in order from most recently used to least recently used.
                 */
                LRUCache.prototype.values = function () {
                    var _2, _4, i, v;
                    return __generator(this, function (_5) {
                        switch (_5.label) {
                            case 0:
                                _2 = 0, _4 = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_indexes).call(this);
                                _5.label = 1;
                            case 1:
                                if (!(_2 < _4.length)) return [3 /*break*/, 4];
                                i = _4[_2];
                                v = __classPrivateFieldGet(this, _LRUCache_valList, "f")[i];
                                if (!(v !== undefined &&
                                    !__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, __classPrivateFieldGet(this, _LRUCache_valList, "f")[i]))) return [3 /*break*/, 3];
                                return [4 /*yield*/, __classPrivateFieldGet(this, _LRUCache_valList, "f")[i]];
                            case 2:
                                _5.sent();
                                _5.label = 3;
                            case 3:
                                _2++;
                                return [3 /*break*/, 1];
                            case 4: return [2 /*return*/];
                        }
                    });
                };
                /**
                 * Inverse order version of {@link LRUCache.values}
                 *
                 * Return a generator yielding the values in the cache,
                 * in order from least recently used to most recently used.
                 */
                LRUCache.prototype.rvalues = function () {
                    var _2, _4, i, v;
                    return __generator(this, function (_5) {
                        switch (_5.label) {
                            case 0:
                                _2 = 0, _4 = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_rindexes).call(this);
                                _5.label = 1;
                            case 1:
                                if (!(_2 < _4.length)) return [3 /*break*/, 4];
                                i = _4[_2];
                                v = __classPrivateFieldGet(this, _LRUCache_valList, "f")[i];
                                if (!(v !== undefined &&
                                    !__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, __classPrivateFieldGet(this, _LRUCache_valList, "f")[i]))) return [3 /*break*/, 3];
                                return [4 /*yield*/, __classPrivateFieldGet(this, _LRUCache_valList, "f")[i]];
                            case 2:
                                _5.sent();
                                _5.label = 3;
                            case 3:
                                _2++;
                                return [3 /*break*/, 1];
                            case 4: return [2 /*return*/];
                        }
                    });
                };
                /**
                 * Iterating over the cache itself yields the same results as
                 * {@link LRUCache.entries}
                 */
                LRUCache.prototype[(_LRUCache_max = new WeakMap(), _LRUCache_maxSize = new WeakMap(), _LRUCache_dispose = new WeakMap(), _LRUCache_disposeAfter = new WeakMap(), _LRUCache_fetchMethod = new WeakMap(), _LRUCache_size = new WeakMap(), _LRUCache_calculatedSize = new WeakMap(), _LRUCache_keyMap = new WeakMap(), _LRUCache_keyList = new WeakMap(), _LRUCache_valList = new WeakMap(), _LRUCache_next = new WeakMap(), _LRUCache_prev = new WeakMap(), _LRUCache_head = new WeakMap(), _LRUCache_tail = new WeakMap(), _LRUCache_free = new WeakMap(), _LRUCache_disposed = new WeakMap(), _LRUCache_sizes = new WeakMap(), _LRUCache_starts = new WeakMap(), _LRUCache_ttls = new WeakMap(), _LRUCache_hasDispose = new WeakMap(), _LRUCache_hasFetchMethod = new WeakMap(), _LRUCache_hasDisposeAfter = new WeakMap(), _LRUCache_updateItemAge = new WeakMap(), _LRUCache_statusTTL = new WeakMap(), _LRUCache_setItemTTL = new WeakMap(), _LRUCache_isStale = new WeakMap(), _LRUCache_removeItemSize = new WeakMap(), _LRUCache_addItemSize = new WeakMap(), _LRUCache_requireSize = new WeakMap(), _LRUCache_instances = new WeakSet(), _LRUCache_initializeTTLTracking = function _LRUCache_initializeTTLTracking() {
                    var _this_1 = this;
                    var ttls = new ZeroArray(__classPrivateFieldGet(this, _LRUCache_max, "f"));
                    var starts = new ZeroArray(__classPrivateFieldGet(this, _LRUCache_max, "f"));
                    __classPrivateFieldSet(this, _LRUCache_ttls, ttls, "f");
                    __classPrivateFieldSet(this, _LRUCache_starts, starts, "f");
                    __classPrivateFieldSet(this, _LRUCache_setItemTTL, function (index, ttl, start) {
                        if (start === void 0) { start = perf.now(); }
                        starts[index] = ttl !== 0 ? start : 0;
                        ttls[index] = ttl;
                        if (ttl !== 0 && _this_1.ttlAutopurge) {
                            var t = setTimeout(function () {
                                if (__classPrivateFieldGet(_this_1, _LRUCache_isStale, "f").call(_this_1, index)) {
                                    _this_1["delete"](__classPrivateFieldGet(_this_1, _LRUCache_keyList, "f")[index]);
                                }
                            }, ttl + 1);
                            // unref() not supported on all platforms
                            /* c8 ignore start */
                            if (t.unref) {
                                t.unref();
                            }
                            /* c8 ignore stop */
                        }
                    }, "f");
                    __classPrivateFieldSet(this, _LRUCache_updateItemAge, function (index) {
                        starts[index] = ttls[index] !== 0 ? perf.now() : 0;
                    }, "f");
                    __classPrivateFieldSet(this, _LRUCache_statusTTL, function (status, index) {
                        if (ttls[index]) {
                            var ttl = ttls[index];
                            var start = starts[index];
                            status.ttl = ttl;
                            status.start = start;
                            status.now = cachedNow || getNow();
                            var age = status.now - start;
                            status.remainingTTL = ttl - age;
                        }
                    }, "f");
                    // debounce calls to perf.now() to 1s so we're not hitting
                    // that costly call repeatedly.
                    var cachedNow = 0;
                    var getNow = function () {
                        var n = perf.now();
                        if (_this_1.ttlResolution > 0) {
                            cachedNow = n;
                            var t = setTimeout(function () { return (cachedNow = 0); }, _this_1.ttlResolution);
                            // not available on all platforms
                            /* c8 ignore start */
                            if (t.unref) {
                                t.unref();
                            }
                            /* c8 ignore stop */
                        }
                        return n;
                    };
                    this.getRemainingTTL = function (key) {
                        var index = __classPrivateFieldGet(_this_1, _LRUCache_keyMap, "f").get(key);
                        if (index === undefined) {
                            return 0;
                        }
                        var ttl = ttls[index];
                        var start = starts[index];
                        if (ttl === 0 || start === 0) {
                            return Infinity;
                        }
                        var age = (cachedNow || getNow()) - start;
                        return ttl - age;
                    };
                    __classPrivateFieldSet(this, _LRUCache_isStale, function (index) {
                        return (ttls[index] !== 0 &&
                            starts[index] !== 0 &&
                            (cachedNow || getNow()) - starts[index] > ttls[index]);
                    }, "f");
                }, _LRUCache_initializeSizeTracking = function _LRUCache_initializeSizeTracking() {
                    var _this_1 = this;
                    var sizes = new ZeroArray(__classPrivateFieldGet(this, _LRUCache_max, "f"));
                    __classPrivateFieldSet(this, _LRUCache_calculatedSize, 0, "f");
                    __classPrivateFieldSet(this, _LRUCache_sizes, sizes, "f");
                    __classPrivateFieldSet(this, _LRUCache_removeItemSize, function (index) {
                        __classPrivateFieldSet(_this_1, _LRUCache_calculatedSize, __classPrivateFieldGet(_this_1, _LRUCache_calculatedSize, "f") - sizes[index], "f");
                        sizes[index] = 0;
                    }, "f");
                    __classPrivateFieldSet(this, _LRUCache_requireSize, function (k, v, size, sizeCalculation) {
                        // provisionally accept background fetches.
                        // actual value size will be checked when they return.
                        if (__classPrivateFieldGet(_this_1, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(_this_1, v)) {
                            return 0;
                        }
                        if (!isPosInt(size)) {
                            if (sizeCalculation) {
                                if (typeof sizeCalculation !== 'function') {
                                    throw new TypeError('sizeCalculation must be a function');
                                }
                                size = sizeCalculation(v, k);
                                if (!isPosInt(size)) {
                                    throw new TypeError('sizeCalculation return invalid (expect positive integer)');
                                }
                            }
                            else {
                                throw new TypeError('invalid size value (must be positive integer). ' +
                                    'When maxSize or maxEntrySize is used, sizeCalculation ' +
                                    'or size must be set.');
                            }
                        }
                        return size;
                    }, "f");
                    __classPrivateFieldSet(this, _LRUCache_addItemSize, function (index, size, status) {
                        sizes[index] = size;
                        if (__classPrivateFieldGet(_this_1, _LRUCache_maxSize, "f")) {
                            var maxSize = __classPrivateFieldGet(_this_1, _LRUCache_maxSize, "f") - sizes[index];
                            while (__classPrivateFieldGet(_this_1, _LRUCache_calculatedSize, "f") > maxSize) {
                                __classPrivateFieldGet(_this_1, _LRUCache_instances, "m", _LRUCache_evict).call(_this_1, true);
                            }
                        }
                        __classPrivateFieldSet(_this_1, _LRUCache_calculatedSize, __classPrivateFieldGet(_this_1, _LRUCache_calculatedSize, "f") + sizes[index], "f");
                        if (status) {
                            status.entrySize = size;
                            status.totalCalculatedSize = __classPrivateFieldGet(_this_1, _LRUCache_calculatedSize, "f");
                        }
                    }, "f");
                }, _LRUCache_indexes = function _LRUCache_indexes(_2) {
                    var i;
                    var _4 = _2 === void 0 ? {} : _2, _5 = _4.allowStale, allowStale = _5 === void 0 ? this.allowStale : _5;
                    return __generator(this, function (_6) {
                        switch (_6.label) {
                            case 0:
                                if (!__classPrivateFieldGet(this, _LRUCache_size, "f")) return [3 /*break*/, 5];
                                i = __classPrivateFieldGet(this, _LRUCache_tail, "f");
                                _6.label = 1;
                            case 1:
                                if (!true) return [3 /*break*/, 5];
                                if (!__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isValidIndex).call(this, i)) {
                                    return [3 /*break*/, 5];
                                }
                                if (!(allowStale || !__classPrivateFieldGet(this, _LRUCache_isStale, "f").call(this, i))) return [3 /*break*/, 3];
                                return [4 /*yield*/, i];
                            case 2:
                                _6.sent();
                                _6.label = 3;
                            case 3:
                                if (i === __classPrivateFieldGet(this, _LRUCache_head, "f")) {
                                    return [3 /*break*/, 5];
                                }
                                else {
                                    i = __classPrivateFieldGet(this, _LRUCache_prev, "f")[i];
                                }
                                _6.label = 4;
                            case 4: return [3 /*break*/, 1];
                            case 5: return [2 /*return*/];
                        }
                    });
                }, _LRUCache_rindexes = function _LRUCache_rindexes(_2) {
                    var i;
                    var _4 = _2 === void 0 ? {} : _2, _5 = _4.allowStale, allowStale = _5 === void 0 ? this.allowStale : _5;
                    return __generator(this, function (_6) {
                        switch (_6.label) {
                            case 0:
                                if (!__classPrivateFieldGet(this, _LRUCache_size, "f")) return [3 /*break*/, 5];
                                i = __classPrivateFieldGet(this, _LRUCache_head, "f");
                                _6.label = 1;
                            case 1:
                                if (!true) return [3 /*break*/, 5];
                                if (!__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isValidIndex).call(this, i)) {
                                    return [3 /*break*/, 5];
                                }
                                if (!(allowStale || !__classPrivateFieldGet(this, _LRUCache_isStale, "f").call(this, i))) return [3 /*break*/, 3];
                                return [4 /*yield*/, i];
                            case 2:
                                _6.sent();
                                _6.label = 3;
                            case 3:
                                if (i === __classPrivateFieldGet(this, _LRUCache_tail, "f")) {
                                    return [3 /*break*/, 5];
                                }
                                else {
                                    i = __classPrivateFieldGet(this, _LRUCache_next, "f")[i];
                                }
                                _6.label = 4;
                            case 4: return [3 /*break*/, 1];
                            case 5: return [2 /*return*/];
                        }
                    });
                }, _LRUCache_isValidIndex = function _LRUCache_isValidIndex(index) {
                    return (index !== undefined &&
                        __classPrivateFieldGet(this, _LRUCache_keyMap, "f").get(__classPrivateFieldGet(this, _LRUCache_keyList, "f")[index]) === index);
                }, Symbol.iterator)] = function () {
                    return this.entries();
                };
                /**
                 * Find a value for which the supplied fn method returns a truthy value,
                 * similar to Array.find().  fn is called as fn(value, key, cache).
                 */
                LRUCache.prototype.find = function (fn, getOptions) {
                    if (getOptions === void 0) { getOptions = {}; }
                    for (var _2 = 0, _4 = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_indexes).call(this); _2 < _4.length; _2++) {
                        var i = _4[_2];
                        var v = __classPrivateFieldGet(this, _LRUCache_valList, "f")[i];
                        var value = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, v)
                            ? v.__staleWhileFetching
                            : v;
                        if (value === undefined)
                            continue;
                        if (fn(value, __classPrivateFieldGet(this, _LRUCache_keyList, "f")[i], this)) {
                            return this.get(__classPrivateFieldGet(this, _LRUCache_keyList, "f")[i], getOptions);
                        }
                    }
                };
                /**
                 * Call the supplied function on each item in the cache, in order from
                 * most recently used to least recently used.  fn is called as
                 * fn(value, key, cache).  Does not update age or recenty of use.
                 * Does not iterate over stale values.
                 */
                LRUCache.prototype.forEach = function (fn, thisp) {
                    if (thisp === void 0) { thisp = this; }
                    for (var _2 = 0, _4 = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_indexes).call(this); _2 < _4.length; _2++) {
                        var i = _4[_2];
                        var v = __classPrivateFieldGet(this, _LRUCache_valList, "f")[i];
                        var value = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, v)
                            ? v.__staleWhileFetching
                            : v;
                        if (value === undefined)
                            continue;
                        fn.call(thisp, value, __classPrivateFieldGet(this, _LRUCache_keyList, "f")[i], this);
                    }
                };
                /**
                 * The same as {@link LRUCache.forEach} but items are iterated over in
                 * reverse order.  (ie, less recently used items are iterated over first.)
                 */
                LRUCache.prototype.rforEach = function (fn, thisp) {
                    if (thisp === void 0) { thisp = this; }
                    for (var _2 = 0, _4 = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_rindexes).call(this); _2 < _4.length; _2++) {
                        var i = _4[_2];
                        var v = __classPrivateFieldGet(this, _LRUCache_valList, "f")[i];
                        var value = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, v)
                            ? v.__staleWhileFetching
                            : v;
                        if (value === undefined)
                            continue;
                        fn.call(thisp, value, __classPrivateFieldGet(this, _LRUCache_keyList, "f")[i], this);
                    }
                };
                /**
                 * Delete any stale entries. Returns true if anything was removed,
                 * false otherwise.
                 */
                LRUCache.prototype.purgeStale = function () {
                    var deleted = false;
                    for (var _2 = 0, _4 = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_rindexes).call(this, { allowStale: true }); _2 < _4.length; _2++) {
                        var i = _4[_2];
                        if (__classPrivateFieldGet(this, _LRUCache_isStale, "f").call(this, i)) {
                            this["delete"](__classPrivateFieldGet(this, _LRUCache_keyList, "f")[i]);
                            deleted = true;
                        }
                    }
                    return deleted;
                };
                /**
                 * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
                 * passed to cache.load()
                 */
                LRUCache.prototype.dump = function () {
                    var arr = [];
                    for (var _2 = 0, _4 = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_indexes).call(this, { allowStale: true }); _2 < _4.length; _2++) {
                        var i = _4[_2];
                        var key = __classPrivateFieldGet(this, _LRUCache_keyList, "f")[i];
                        var v = __classPrivateFieldGet(this, _LRUCache_valList, "f")[i];
                        var value = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, v)
                            ? v.__staleWhileFetching
                            : v;
                        if (value === undefined || key === undefined)
                            continue;
                        var entry = { value: value };
                        if (__classPrivateFieldGet(this, _LRUCache_ttls, "f") && __classPrivateFieldGet(this, _LRUCache_starts, "f")) {
                            entry.ttl = __classPrivateFieldGet(this, _LRUCache_ttls, "f")[i];
                            // always dump the start relative to a portable timestamp
                            // it's ok for this to be a bit slow, it's a rare operation.
                            var age = perf.now() - __classPrivateFieldGet(this, _LRUCache_starts, "f")[i];
                            entry.start = Math.floor(Date.now() - age);
                        }
                        if (__classPrivateFieldGet(this, _LRUCache_sizes, "f")) {
                            entry.size = __classPrivateFieldGet(this, _LRUCache_sizes, "f")[i];
                        }
                        arr.unshift([key, entry]);
                    }
                    return arr;
                };
                /**
                 * Reset the cache and load in the items in entries in the order listed.
                 * Note that the shape of the resulting cache may be different if the
                 * same options are not used in both caches.
                 */
                LRUCache.prototype.load = function (arr) {
                    this.clear();
                    for (var _2 = 0, arr_3 = arr; _2 < arr_3.length; _2++) {
                        var _4 = arr_3[_2], key = _4[0], entry = _4[1];
                        if (entry.start) {
                            // entry.start is a portable timestamp, but we may be using
                            // node's performance.now(), so calculate the offset, so that
                            // we get the intended remaining TTL, no matter how long it's
                            // been on ice.
                            //
                            // it's ok for this to be a bit slow, it's a rare operation.
                            var age = Date.now() - entry.start;
                            entry.start = perf.now() - age;
                        }
                        this.set(key, entry.value, entry);
                    }
                };
                /**
                 * Add a value to the cache.
                 *
                 * Note: if `undefined` is specified as a value, this is an alias for
                 * {@link LRUCache#delete}
                 */
                LRUCache.prototype.set = function (k, v, setOptions) {
                    var _2, _4, _5, _6, _7;
                    var _8;
                    if (setOptions === void 0) { setOptions = {}; }
                    if (v === undefined) {
                        this["delete"](k);
                        return this;
                    }
                    var _9 = setOptions.ttl, ttl = _9 === void 0 ? this.ttl : _9, start = setOptions.start, _10 = setOptions.noDisposeOnSet, noDisposeOnSet = _10 === void 0 ? this.noDisposeOnSet : _10, _11 = setOptions.sizeCalculation, sizeCalculation = _11 === void 0 ? this.sizeCalculation : _11, status = setOptions.status;
                    var _12 = setOptions.noUpdateTTL, noUpdateTTL = _12 === void 0 ? this.noUpdateTTL : _12;
                    var size = __classPrivateFieldGet(this, _LRUCache_requireSize, "f").call(this, k, v, setOptions.size || 0, sizeCalculation);
                    // if the item doesn't fit, don't do anything
                    // NB: maxEntrySize set to maxSize by default
                    if (this.maxEntrySize && size > this.maxEntrySize) {
                        if (status) {
                            status.set = 'miss';
                            status.maxEntrySizeExceeded = true;
                        }
                        // have to delete, in case something is there already.
                        this["delete"](k);
                        return this;
                    }
                    var index = __classPrivateFieldGet(this, _LRUCache_size, "f") === 0 ? undefined : __classPrivateFieldGet(this, _LRUCache_keyMap, "f").get(k);
                    if (index === undefined) {
                        // addition
                        index = (__classPrivateFieldGet(this, _LRUCache_size, "f") === 0
                            ? __classPrivateFieldGet(this, _LRUCache_tail, "f")
                            : __classPrivateFieldGet(this, _LRUCache_free, "f").length !== 0
                                ? __classPrivateFieldGet(this, _LRUCache_free, "f").pop()
                                : __classPrivateFieldGet(this, _LRUCache_size, "f") === __classPrivateFieldGet(this, _LRUCache_max, "f")
                                    ? __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_evict).call(this, false)
                                    : __classPrivateFieldGet(this, _LRUCache_size, "f"));
                        __classPrivateFieldGet(this, _LRUCache_keyList, "f")[index] = k;
                        __classPrivateFieldGet(this, _LRUCache_valList, "f")[index] = v;
                        __classPrivateFieldGet(this, _LRUCache_keyMap, "f").set(k, index);
                        __classPrivateFieldGet(this, _LRUCache_next, "f")[__classPrivateFieldGet(this, _LRUCache_tail, "f")] = index;
                        __classPrivateFieldGet(this, _LRUCache_prev, "f")[index] = __classPrivateFieldGet(this, _LRUCache_tail, "f");
                        __classPrivateFieldSet(this, _LRUCache_tail, index, "f");
                        __classPrivateFieldSet(this, _LRUCache_size, (_8 = __classPrivateFieldGet(this, _LRUCache_size, "f"), _8++, _8), "f");
                        __classPrivateFieldGet(this, _LRUCache_addItemSize, "f").call(this, index, size, status);
                        if (status)
                            status.set = 'add';
                        noUpdateTTL = false;
                    }
                    else {
                        // update
                        __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_moveToTail).call(this, index);
                        var oldVal = __classPrivateFieldGet(this, _LRUCache_valList, "f")[index];
                        if (v !== oldVal) {
                            if (__classPrivateFieldGet(this, _LRUCache_hasFetchMethod, "f") && __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, oldVal)) {
                                oldVal.__abortController.abort(new Error('replaced'));
                                var s = oldVal.__staleWhileFetching;
                                if (s !== undefined && !noDisposeOnSet) {
                                    if (__classPrivateFieldGet(this, _LRUCache_hasDispose, "f")) {
                                        (_2 = __classPrivateFieldGet(this, _LRUCache_dispose, "f")) === null || _2 === void 0 ? void 0 : _2.call(this, s, k, 'set');
                                    }
                                    if (__classPrivateFieldGet(this, _LRUCache_hasDisposeAfter, "f")) {
                                        (_4 = __classPrivateFieldGet(this, _LRUCache_disposed, "f")) === null || _4 === void 0 ? void 0 : _4.push([s, k, 'set']);
                                    }
                                }
                            }
                            else if (!noDisposeOnSet) {
                                if (__classPrivateFieldGet(this, _LRUCache_hasDispose, "f")) {
                                    (_5 = __classPrivateFieldGet(this, _LRUCache_dispose, "f")) === null || _5 === void 0 ? void 0 : _5.call(this, oldVal, k, 'set');
                                }
                                if (__classPrivateFieldGet(this, _LRUCache_hasDisposeAfter, "f")) {
                                    (_6 = __classPrivateFieldGet(this, _LRUCache_disposed, "f")) === null || _6 === void 0 ? void 0 : _6.push([oldVal, k, 'set']);
                                }
                            }
                            __classPrivateFieldGet(this, _LRUCache_removeItemSize, "f").call(this, index);
                            __classPrivateFieldGet(this, _LRUCache_addItemSize, "f").call(this, index, size, status);
                            __classPrivateFieldGet(this, _LRUCache_valList, "f")[index] = v;
                            if (status) {
                                status.set = 'replace';
                                var oldValue = oldVal && __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, oldVal)
                                    ? oldVal.__staleWhileFetching
                                    : oldVal;
                                if (oldValue !== undefined)
                                    status.oldValue = oldValue;
                            }
                        }
                        else if (status) {
                            status.set = 'update';
                        }
                    }
                    if (ttl !== 0 && !__classPrivateFieldGet(this, _LRUCache_ttls, "f")) {
                        __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_initializeTTLTracking).call(this);
                    }
                    if (__classPrivateFieldGet(this, _LRUCache_ttls, "f")) {
                        if (!noUpdateTTL) {
                            __classPrivateFieldGet(this, _LRUCache_setItemTTL, "f").call(this, index, ttl, start);
                        }
                        if (status)
                            __classPrivateFieldGet(this, _LRUCache_statusTTL, "f").call(this, status, index);
                    }
                    if (!noDisposeOnSet && __classPrivateFieldGet(this, _LRUCache_hasDisposeAfter, "f") && __classPrivateFieldGet(this, _LRUCache_disposed, "f")) {
                        var dt = __classPrivateFieldGet(this, _LRUCache_disposed, "f");
                        var task = void 0;
                        while ((task = dt === null || dt === void 0 ? void 0 : dt.shift())) {
                            (_7 = __classPrivateFieldGet(this, _LRUCache_disposeAfter, "f")) === null || _7 === void 0 ? void 0 : _7.call.apply(_7, __spreadArray([this], task, false));
                        }
                    }
                    return this;
                };
                /**
                 * Evict the least recently used item, returning its value or
                 * `undefined` if cache is empty.
                 */
                LRUCache.prototype.pop = function () {
                    var _2;
                    try {
                        while (__classPrivateFieldGet(this, _LRUCache_size, "f")) {
                            var val = __classPrivateFieldGet(this, _LRUCache_valList, "f")[__classPrivateFieldGet(this, _LRUCache_head, "f")];
                            __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_evict).call(this, true);
                            if (__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, val)) {
                                if (val.__staleWhileFetching) {
                                    return val.__staleWhileFetching;
                                }
                            }
                            else if (val !== undefined) {
                                return val;
                            }
                        }
                    }
                    finally {
                        if (__classPrivateFieldGet(this, _LRUCache_hasDisposeAfter, "f") && __classPrivateFieldGet(this, _LRUCache_disposed, "f")) {
                            var dt = __classPrivateFieldGet(this, _LRUCache_disposed, "f");
                            var task = void 0;
                            while ((task = dt === null || dt === void 0 ? void 0 : dt.shift())) {
                                (_2 = __classPrivateFieldGet(this, _LRUCache_disposeAfter, "f")) === null || _2 === void 0 ? void 0 : _2.call.apply(_2, __spreadArray([this], task, false));
                            }
                        }
                    }
                };
                /**
                 * Check if a key is in the cache, without updating the recency of use.
                 * Will return false if the item is stale, even though it is technically
                 * in the cache.
                 *
                 * Will not update item age unless
                 * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
                 */
                LRUCache.prototype.has = function (k, hasOptions) {
                    if (hasOptions === void 0) { hasOptions = {}; }
                    var _2 = hasOptions.updateAgeOnHas, updateAgeOnHas = _2 === void 0 ? this.updateAgeOnHas : _2, status = hasOptions.status;
                    var index = __classPrivateFieldGet(this, _LRUCache_keyMap, "f").get(k);
                    if (index !== undefined) {
                        var v = __classPrivateFieldGet(this, _LRUCache_valList, "f")[index];
                        if (__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, v) &&
                            v.__staleWhileFetching === undefined) {
                            return false;
                        }
                        if (!__classPrivateFieldGet(this, _LRUCache_isStale, "f").call(this, index)) {
                            if (updateAgeOnHas) {
                                __classPrivateFieldGet(this, _LRUCache_updateItemAge, "f").call(this, index);
                            }
                            if (status) {
                                status.has = 'hit';
                                __classPrivateFieldGet(this, _LRUCache_statusTTL, "f").call(this, status, index);
                            }
                            return true;
                        }
                        else if (status) {
                            status.has = 'stale';
                            __classPrivateFieldGet(this, _LRUCache_statusTTL, "f").call(this, status, index);
                        }
                    }
                    else if (status) {
                        status.has = 'miss';
                    }
                    return false;
                };
                /**
                 * Like {@link LRUCache#get} but doesn't update recency or delete stale
                 * items.
                 *
                 * Returns `undefined` if the item is stale, unless
                 * {@link LRUCache.OptionsBase.allowStale} is set.
                 */
                LRUCache.prototype.peek = function (k, peekOptions) {
                    if (peekOptions === void 0) { peekOptions = {}; }
                    var _2 = peekOptions.allowStale, allowStale = _2 === void 0 ? this.allowStale : _2;
                    var index = __classPrivateFieldGet(this, _LRUCache_keyMap, "f").get(k);
                    if (index !== undefined &&
                        (allowStale || !__classPrivateFieldGet(this, _LRUCache_isStale, "f").call(this, index))) {
                        var v = __classPrivateFieldGet(this, _LRUCache_valList, "f")[index];
                        // either stale and allowed, or forcing a refresh of non-stale value
                        return __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, v) ? v.__staleWhileFetching : v;
                    }
                };
                LRUCache.prototype.fetch = function (k, fetchOptions) {
                    if (fetchOptions === void 0) { fetchOptions = {}; }
                    return __awaiter(this, void 0, void 0, function () {
                        var _2, 
                        // get options
                        allowStale, _4, updateAgeOnGet, _5, noDeleteOnStaleGet, _6, 
                        // set options
                        ttl, _7, noDisposeOnSet, _8, size, _9, sizeCalculation, _10, noUpdateTTL, _11, 
                        // fetch exclusive options
                        noDeleteOnFetchRejection, _12, allowStaleOnFetchRejection, _13, ignoreFetchAbort, _14, allowStaleOnFetchAbort, context, _15, forceRefresh, status, signal, options, index, p, v, stale, isStale, p, hasStale, staleVal;
                        return __generator(this, function (_16) {
                            _2 = fetchOptions.allowStale, allowStale = _2 === void 0 ? this.allowStale : _2, _4 = fetchOptions.updateAgeOnGet, updateAgeOnGet = _4 === void 0 ? this.updateAgeOnGet : _4, _5 = fetchOptions.noDeleteOnStaleGet, noDeleteOnStaleGet = _5 === void 0 ? this.noDeleteOnStaleGet : _5, _6 = fetchOptions.ttl, ttl = _6 === void 0 ? this.ttl : _6, _7 = fetchOptions.noDisposeOnSet, noDisposeOnSet = _7 === void 0 ? this.noDisposeOnSet : _7, _8 = fetchOptions.size, size = _8 === void 0 ? 0 : _8, _9 = fetchOptions.sizeCalculation, sizeCalculation = _9 === void 0 ? this.sizeCalculation : _9, _10 = fetchOptions.noUpdateTTL, noUpdateTTL = _10 === void 0 ? this.noUpdateTTL : _10, _11 = fetchOptions.noDeleteOnFetchRejection, noDeleteOnFetchRejection = _11 === void 0 ? this.noDeleteOnFetchRejection : _11, _12 = fetchOptions.allowStaleOnFetchRejection, allowStaleOnFetchRejection = _12 === void 0 ? this.allowStaleOnFetchRejection : _12, _13 = fetchOptions.ignoreFetchAbort, ignoreFetchAbort = _13 === void 0 ? this.ignoreFetchAbort : _13, _14 = fetchOptions.allowStaleOnFetchAbort, allowStaleOnFetchAbort = _14 === void 0 ? this.allowStaleOnFetchAbort : _14, context = fetchOptions.context, _15 = fetchOptions.forceRefresh, forceRefresh = _15 === void 0 ? false : _15, status = fetchOptions.status, signal = fetchOptions.signal;
                            if (!__classPrivateFieldGet(this, _LRUCache_hasFetchMethod, "f")) {
                                if (status)
                                    status.fetch = 'get';
                                return [2 /*return*/, this.get(k, {
                                        allowStale: allowStale,
                                        updateAgeOnGet: updateAgeOnGet,
                                        noDeleteOnStaleGet: noDeleteOnStaleGet,
                                        status: status
                                    })];
                            }
                            options = {
                                allowStale: allowStale,
                                updateAgeOnGet: updateAgeOnGet,
                                noDeleteOnStaleGet: noDeleteOnStaleGet,
                                ttl: ttl,
                                noDisposeOnSet: noDisposeOnSet,
                                size: size,
                                sizeCalculation: sizeCalculation,
                                noUpdateTTL: noUpdateTTL,
                                noDeleteOnFetchRejection: noDeleteOnFetchRejection,
                                allowStaleOnFetchRejection: allowStaleOnFetchRejection,
                                allowStaleOnFetchAbort: allowStaleOnFetchAbort,
                                ignoreFetchAbort: ignoreFetchAbort,
                                status: status,
                                signal: signal
                            };
                            index = __classPrivateFieldGet(this, _LRUCache_keyMap, "f").get(k);
                            if (index === undefined) {
                                if (status)
                                    status.fetch = 'miss';
                                p = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_backgroundFetch).call(this, k, index, options, context);
                                return [2 /*return*/, (p.__returned = p)];
                            }
                            else {
                                v = __classPrivateFieldGet(this, _LRUCache_valList, "f")[index];
                                if (__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, v)) {
                                    stale = allowStale && v.__staleWhileFetching !== undefined;
                                    if (status) {
                                        status.fetch = 'inflight';
                                        if (stale)
                                            status.returnedStale = true;
                                    }
                                    return [2 /*return*/, stale ? v.__staleWhileFetching : (v.__returned = v)];
                                }
                                isStale = __classPrivateFieldGet(this, _LRUCache_isStale, "f").call(this, index);
                                if (!forceRefresh && !isStale) {
                                    if (status)
                                        status.fetch = 'hit';
                                    __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_moveToTail).call(this, index);
                                    if (updateAgeOnGet) {
                                        __classPrivateFieldGet(this, _LRUCache_updateItemAge, "f").call(this, index);
                                    }
                                    if (status)
                                        __classPrivateFieldGet(this, _LRUCache_statusTTL, "f").call(this, status, index);
                                    return [2 /*return*/, v];
                                }
                                p = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_backgroundFetch).call(this, k, index, options, context);
                                hasStale = p.__staleWhileFetching !== undefined;
                                staleVal = hasStale && allowStale;
                                if (status) {
                                    status.fetch = isStale ? 'stale' : 'refresh';
                                    if (staleVal && isStale)
                                        status.returnedStale = true;
                                }
                                return [2 /*return*/, staleVal ? p.__staleWhileFetching : (p.__returned = p)];
                            }
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Return a value from the cache. Will update the recency of the cache
                 * entry found.
                 *
                 * If the key is not found, get() will return `undefined`.
                 */
                LRUCache.prototype.get = function (k, getOptions) {
                    if (getOptions === void 0) { getOptions = {}; }
                    var _2 = getOptions.allowStale, allowStale = _2 === void 0 ? this.allowStale : _2, _4 = getOptions.updateAgeOnGet, updateAgeOnGet = _4 === void 0 ? this.updateAgeOnGet : _4, _5 = getOptions.noDeleteOnStaleGet, noDeleteOnStaleGet = _5 === void 0 ? this.noDeleteOnStaleGet : _5, status = getOptions.status;
                    var index = __classPrivateFieldGet(this, _LRUCache_keyMap, "f").get(k);
                    if (index !== undefined) {
                        var value = __classPrivateFieldGet(this, _LRUCache_valList, "f")[index];
                        var fetching = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, value);
                        if (status)
                            __classPrivateFieldGet(this, _LRUCache_statusTTL, "f").call(this, status, index);
                        if (__classPrivateFieldGet(this, _LRUCache_isStale, "f").call(this, index)) {
                            if (status)
                                status.get = 'stale';
                            // delete only if not an in-flight background fetch
                            if (!fetching) {
                                if (!noDeleteOnStaleGet) {
                                    this["delete"](k);
                                }
                                if (status && allowStale)
                                    status.returnedStale = true;
                                return allowStale ? value : undefined;
                            }
                            else {
                                if (status &&
                                    allowStale &&
                                    value.__staleWhileFetching !== undefined) {
                                    status.returnedStale = true;
                                }
                                return allowStale ? value.__staleWhileFetching : undefined;
                            }
                        }
                        else {
                            if (status)
                                status.get = 'hit';
                            // if we're currently fetching it, we don't actually have it yet
                            // it's not stale, which means this isn't a staleWhileRefetching.
                            // If it's not stale, and fetching, AND has a __staleWhileFetching
                            // value, then that means the user fetched with {forceRefresh:true},
                            // so it's safe to return that value.
                            if (fetching) {
                                return value.__staleWhileFetching;
                            }
                            __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_moveToTail).call(this, index);
                            if (updateAgeOnGet) {
                                __classPrivateFieldGet(this, _LRUCache_updateItemAge, "f").call(this, index);
                            }
                            return value;
                        }
                    }
                    else if (status) {
                        status.get = 'miss';
                    }
                };
                /**
                 * Deletes a key out of the cache.
                 * Returns true if the key was deleted, false otherwise.
                 */
                LRUCache.prototype["delete"] = function (k) {
                    var _2, _4, _5, _6;
                    var _7;
                    var deleted = false;
                    if (__classPrivateFieldGet(this, _LRUCache_size, "f") !== 0) {
                        var index = __classPrivateFieldGet(this, _LRUCache_keyMap, "f").get(k);
                        if (index !== undefined) {
                            deleted = true;
                            if (__classPrivateFieldGet(this, _LRUCache_size, "f") === 1) {
                                this.clear();
                            }
                            else {
                                __classPrivateFieldGet(this, _LRUCache_removeItemSize, "f").call(this, index);
                                var v = __classPrivateFieldGet(this, _LRUCache_valList, "f")[index];
                                if (__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, v)) {
                                    v.__abortController.abort(new Error('deleted'));
                                }
                                else if (__classPrivateFieldGet(this, _LRUCache_hasDispose, "f") || __classPrivateFieldGet(this, _LRUCache_hasDisposeAfter, "f")) {
                                    if (__classPrivateFieldGet(this, _LRUCache_hasDispose, "f")) {
                                        (_2 = __classPrivateFieldGet(this, _LRUCache_dispose, "f")) === null || _2 === void 0 ? void 0 : _2.call(this, v, k, 'delete');
                                    }
                                    if (__classPrivateFieldGet(this, _LRUCache_hasDisposeAfter, "f")) {
                                        (_4 = __classPrivateFieldGet(this, _LRUCache_disposed, "f")) === null || _4 === void 0 ? void 0 : _4.push([v, k, 'delete']);
                                    }
                                }
                                __classPrivateFieldGet(this, _LRUCache_keyMap, "f")["delete"](k);
                                __classPrivateFieldGet(this, _LRUCache_keyList, "f")[index] = undefined;
                                __classPrivateFieldGet(this, _LRUCache_valList, "f")[index] = undefined;
                                if (index === __classPrivateFieldGet(this, _LRUCache_tail, "f")) {
                                    __classPrivateFieldSet(this, _LRUCache_tail, __classPrivateFieldGet(this, _LRUCache_prev, "f")[index], "f");
                                }
                                else if (index === __classPrivateFieldGet(this, _LRUCache_head, "f")) {
                                    __classPrivateFieldSet(this, _LRUCache_head, __classPrivateFieldGet(this, _LRUCache_next, "f")[index], "f");
                                }
                                else {
                                    __classPrivateFieldGet(this, _LRUCache_next, "f")[__classPrivateFieldGet(this, _LRUCache_prev, "f")[index]] = __classPrivateFieldGet(this, _LRUCache_next, "f")[index];
                                    __classPrivateFieldGet(this, _LRUCache_prev, "f")[__classPrivateFieldGet(this, _LRUCache_next, "f")[index]] = __classPrivateFieldGet(this, _LRUCache_prev, "f")[index];
                                }
                                __classPrivateFieldSet(this, _LRUCache_size, (_7 = __classPrivateFieldGet(this, _LRUCache_size, "f"), _7--, _7), "f");
                                __classPrivateFieldGet(this, _LRUCache_free, "f").push(index);
                            }
                        }
                    }
                    if (__classPrivateFieldGet(this, _LRUCache_hasDisposeAfter, "f") && ((_5 = __classPrivateFieldGet(this, _LRUCache_disposed, "f")) === null || _5 === void 0 ? void 0 : _5.length)) {
                        var dt = __classPrivateFieldGet(this, _LRUCache_disposed, "f");
                        var task = void 0;
                        while ((task = dt === null || dt === void 0 ? void 0 : dt.shift())) {
                            (_6 = __classPrivateFieldGet(this, _LRUCache_disposeAfter, "f")) === null || _6 === void 0 ? void 0 : _6.call.apply(_6, __spreadArray([this], task, false));
                        }
                    }
                    return deleted;
                };
                /**
                 * Clear the cache entirely, throwing away all values.
                 */
                LRUCache.prototype.clear = function () {
                    var _2, _4, _5;
                    for (var _6 = 0, _7 = __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_rindexes).call(this, { allowStale: true }); _6 < _7.length; _6++) {
                        var index = _7[_6];
                        var v = __classPrivateFieldGet(this, _LRUCache_valList, "f")[index];
                        if (__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, v)) {
                            v.__abortController.abort(new Error('deleted'));
                        }
                        else {
                            var k = __classPrivateFieldGet(this, _LRUCache_keyList, "f")[index];
                            if (__classPrivateFieldGet(this, _LRUCache_hasDispose, "f")) {
                                (_2 = __classPrivateFieldGet(this, _LRUCache_dispose, "f")) === null || _2 === void 0 ? void 0 : _2.call(this, v, k, 'delete');
                            }
                            if (__classPrivateFieldGet(this, _LRUCache_hasDisposeAfter, "f")) {
                                (_4 = __classPrivateFieldGet(this, _LRUCache_disposed, "f")) === null || _4 === void 0 ? void 0 : _4.push([v, k, 'delete']);
                            }
                        }
                    }
                    __classPrivateFieldGet(this, _LRUCache_keyMap, "f").clear();
                    __classPrivateFieldGet(this, _LRUCache_valList, "f").fill(undefined);
                    __classPrivateFieldGet(this, _LRUCache_keyList, "f").fill(undefined);
                    if (__classPrivateFieldGet(this, _LRUCache_ttls, "f") && __classPrivateFieldGet(this, _LRUCache_starts, "f")) {
                        __classPrivateFieldGet(this, _LRUCache_ttls, "f").fill(0);
                        __classPrivateFieldGet(this, _LRUCache_starts, "f").fill(0);
                    }
                    if (__classPrivateFieldGet(this, _LRUCache_sizes, "f")) {
                        __classPrivateFieldGet(this, _LRUCache_sizes, "f").fill(0);
                    }
                    __classPrivateFieldSet(this, _LRUCache_head, 0, "f");
                    __classPrivateFieldSet(this, _LRUCache_tail, 0, "f");
                    __classPrivateFieldGet(this, _LRUCache_free, "f").length = 0;
                    __classPrivateFieldSet(this, _LRUCache_calculatedSize, 0, "f");
                    __classPrivateFieldSet(this, _LRUCache_size, 0, "f");
                    if (__classPrivateFieldGet(this, _LRUCache_hasDisposeAfter, "f") && __classPrivateFieldGet(this, _LRUCache_disposed, "f")) {
                        var dt = __classPrivateFieldGet(this, _LRUCache_disposed, "f");
                        var task = void 0;
                        while ((task = dt === null || dt === void 0 ? void 0 : dt.shift())) {
                            (_5 = __classPrivateFieldGet(this, _LRUCache_disposeAfter, "f")) === null || _5 === void 0 ? void 0 : _5.call.apply(_5, __spreadArray([this], task, false));
                        }
                    }
                };
                return LRUCache;
            }());
            _LRUCache_evict = function _LRUCache_evict(free) {
                var _2, _4;
                var _5;
                var head = __classPrivateFieldGet(this, _LRUCache_head, "f");
                var k = __classPrivateFieldGet(this, _LRUCache_keyList, "f")[head];
                var v = __classPrivateFieldGet(this, _LRUCache_valList, "f")[head];
                if (__classPrivateFieldGet(this, _LRUCache_hasFetchMethod, "f") && __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, v)) {
                    v.__abortController.abort(new Error('evicted'));
                }
                else if (__classPrivateFieldGet(this, _LRUCache_hasDispose, "f") || __classPrivateFieldGet(this, _LRUCache_hasDisposeAfter, "f")) {
                    if (__classPrivateFieldGet(this, _LRUCache_hasDispose, "f")) {
                        (_2 = __classPrivateFieldGet(this, _LRUCache_dispose, "f")) === null || _2 === void 0 ? void 0 : _2.call(this, v, k, 'evict');
                    }
                    if (__classPrivateFieldGet(this, _LRUCache_hasDisposeAfter, "f")) {
                        (_4 = __classPrivateFieldGet(this, _LRUCache_disposed, "f")) === null || _4 === void 0 ? void 0 : _4.push([v, k, 'evict']);
                    }
                }
                __classPrivateFieldGet(this, _LRUCache_removeItemSize, "f").call(this, head);
                // if we aren't about to use the index, then null these out
                if (free) {
                    __classPrivateFieldGet(this, _LRUCache_keyList, "f")[head] = undefined;
                    __classPrivateFieldGet(this, _LRUCache_valList, "f")[head] = undefined;
                    __classPrivateFieldGet(this, _LRUCache_free, "f").push(head);
                }
                if (__classPrivateFieldGet(this, _LRUCache_size, "f") === 1) {
                    __classPrivateFieldSet(this, _LRUCache_head, __classPrivateFieldSet(this, _LRUCache_tail, 0, "f"), "f");
                    __classPrivateFieldGet(this, _LRUCache_free, "f").length = 0;
                }
                else {
                    __classPrivateFieldSet(this, _LRUCache_head, __classPrivateFieldGet(this, _LRUCache_next, "f")[head], "f");
                }
                __classPrivateFieldGet(this, _LRUCache_keyMap, "f")["delete"](k);
                __classPrivateFieldSet(this, _LRUCache_size, (_5 = __classPrivateFieldGet(this, _LRUCache_size, "f"), _5--, _5), "f");
                return head;
            }, _LRUCache_backgroundFetch = function _LRUCache_backgroundFetch(k, index, options, context) {
                var _this_1 = this;
                var v = index === undefined ? undefined : __classPrivateFieldGet(this, _LRUCache_valList, "f")[index];
                if (__classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_isBackgroundFetch).call(this, v)) {
                    return v;
                }
                var ac = new AC();
                var signal = options.signal;
                // when/if our AC signals, then stop listening to theirs.
                signal === null || signal === void 0 ? void 0 : signal.addEventListener('abort', function () { return ac.abort(signal.reason); }, {
                    signal: ac.signal
                });
                var fetchOpts = {
                    signal: ac.signal,
                    options: options,
                    context: context
                };
                var cb = function (v, updateCache) {
                    if (updateCache === void 0) { updateCache = false; }
                    var aborted = ac.signal.aborted;
                    var ignoreAbort = options.ignoreFetchAbort && v !== undefined;
                    if (options.status) {
                        if (aborted && !updateCache) {
                            options.status.fetchAborted = true;
                            options.status.fetchError = ac.signal.reason;
                            if (ignoreAbort)
                                options.status.fetchAbortIgnored = true;
                        }
                        else {
                            options.status.fetchResolved = true;
                        }
                    }
                    if (aborted && !ignoreAbort && !updateCache) {
                        return fetchFail(ac.signal.reason);
                    }
                    // either we didn't abort, and are still here, or we did, and ignored
                    var bf = p;
                    if (__classPrivateFieldGet(_this_1, _LRUCache_valList, "f")[index] === p) {
                        if (v === undefined) {
                            if (bf.__staleWhileFetching) {
                                __classPrivateFieldGet(_this_1, _LRUCache_valList, "f")[index] = bf.__staleWhileFetching;
                            }
                            else {
                                _this_1["delete"](k);
                            }
                        }
                        else {
                            if (options.status)
                                options.status.fetchUpdated = true;
                            _this_1.set(k, v, fetchOpts.options);
                        }
                    }
                    return v;
                };
                var eb = function (er) {
                    if (options.status) {
                        options.status.fetchRejected = true;
                        options.status.fetchError = er;
                    }
                    return fetchFail(er);
                };
                var fetchFail = function (er) {
                    var aborted = ac.signal.aborted;
                    var allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
                    var allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
                    var noDelete = allowStale || options.noDeleteOnFetchRejection;
                    var bf = p;
                    if (__classPrivateFieldGet(_this_1, _LRUCache_valList, "f")[index] === p) {
                        // if we allow stale on fetch rejections, then we need to ensure that
                        // the stale value is not removed from the cache when the fetch fails.
                        var del = !noDelete || bf.__staleWhileFetching === undefined;
                        if (del) {
                            _this_1["delete"](k);
                        }
                        else if (!allowStaleAborted) {
                            // still replace the *promise* with the stale value,
                            // since we are done with the promise at this point.
                            // leave it untouched if we're still waiting for an
                            // aborted background fetch that hasn't yet returned.
                            __classPrivateFieldGet(_this_1, _LRUCache_valList, "f")[index] = bf.__staleWhileFetching;
                        }
                    }
                    if (allowStale) {
                        if (options.status && bf.__staleWhileFetching !== undefined) {
                            options.status.returnedStale = true;
                        }
                        return bf.__staleWhileFetching;
                    }
                    else if (bf.__returned === bf) {
                        throw er;
                    }
                };
                var pcall = function (res, rej) {
                    var _2;
                    var fmp = (_2 = __classPrivateFieldGet(_this_1, _LRUCache_fetchMethod, "f")) === null || _2 === void 0 ? void 0 : _2.call(_this_1, k, v, fetchOpts);
                    if (fmp && fmp instanceof Promise) {
                        fmp.then(function (v) { return res(v === undefined ? undefined : v); }, rej);
                    }
                    // ignored, we go until we finish, regardless.
                    // defer check until we are actually aborting,
                    // so fetchMethod can override.
                    ac.signal.addEventListener('abort', function () {
                        if (!options.ignoreFetchAbort ||
                            options.allowStaleOnFetchAbort) {
                            res(undefined);
                            // when it eventually resolves, update the cache.
                            if (options.allowStaleOnFetchAbort) {
                                res = function (v) { return cb(v, true); };
                            }
                        }
                    });
                };
                if (options.status)
                    options.status.fetchDispatched = true;
                var p = new Promise(pcall).then(cb, eb);
                var bf = Object.assign(p, {
                    __abortController: ac,
                    __staleWhileFetching: v,
                    __returned: undefined
                });
                if (index === undefined) {
                    // internal, don't expose status.
                    this.set(k, bf, __assign(__assign({}, fetchOpts.options), { status: undefined }));
                    index = __classPrivateFieldGet(this, _LRUCache_keyMap, "f").get(k);
                }
                else {
                    __classPrivateFieldGet(this, _LRUCache_valList, "f")[index] = bf;
                }
                return bf;
            }, _LRUCache_isBackgroundFetch = function _LRUCache_isBackgroundFetch(p) {
                if (!__classPrivateFieldGet(this, _LRUCache_hasFetchMethod, "f"))
                    return false;
                var b = p;
                return (!!b &&
                    b instanceof Promise &&
                    b.hasOwnProperty('__staleWhileFetching') &&
                    b.__abortController instanceof AC);
            }, _LRUCache_connect = function _LRUCache_connect(p, n) {
                __classPrivateFieldGet(this, _LRUCache_prev, "f")[n] = p;
                __classPrivateFieldGet(this, _LRUCache_next, "f")[p] = n;
            }, _LRUCache_moveToTail = function _LRUCache_moveToTail(index) {
                // if tail already, nothing to do
                // if head, move head to next[index]
                // else
                //   move next[prev[index]] to next[index] (head has no prev)
                //   move prev[next[index]] to prev[index]
                // prev[index] = tail
                // next[tail] = index
                // tail = index
                if (index !== __classPrivateFieldGet(this, _LRUCache_tail, "f")) {
                    if (index === __classPrivateFieldGet(this, _LRUCache_head, "f")) {
                        __classPrivateFieldSet(this, _LRUCache_head, __classPrivateFieldGet(this, _LRUCache_next, "f")[index], "f");
                    }
                    else {
                        __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_connect).call(this, __classPrivateFieldGet(this, _LRUCache_prev, "f")[index], __classPrivateFieldGet(this, _LRUCache_next, "f")[index]);
                    }
                    __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_connect).call(this, __classPrivateFieldGet(this, _LRUCache_tail, "f"), index);
                    __classPrivateFieldSet(this, _LRUCache_tail, index, "f");
                }
            };
            exports.LRUCache = LRUCache;
            //# sourceMappingURL=index.js.map
            /***/ 
        }),
        /***/ 4775: 
        /***/ (function (module) {
            "use strict";
            module.exports = JSON.parse('{"$id":"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#","description":"Meta-schema for $data reference (JSON AnySchema extension proposal)","type":"object","required":["$data"],"properties":{"$data":{"type":"string","anyOf":[{"format":"relative-json-pointer"},{"format":"json-pointer"}]}},"additionalProperties":false}');
            /***/ 
        }),
        /***/ 98: 
        /***/ (function (module) {
            "use strict";
            module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-07/schema#","$id":"http://json-schema.org/draft-07/schema#","title":"Core schema meta-schema","definitions":{"schemaArray":{"type":"array","minItems":1,"items":{"$ref":"#"}},"nonNegativeInteger":{"type":"integer","minimum":0},"nonNegativeIntegerDefault0":{"allOf":[{"$ref":"#/definitions/nonNegativeInteger"},{"default":0}]},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"uniqueItems":true,"default":[]}},"type":["object","boolean"],"properties":{"$id":{"type":"string","format":"uri-reference"},"$schema":{"type":"string","format":"uri"},"$ref":{"type":"string","format":"uri-reference"},"$comment":{"type":"string"},"title":{"type":"string"},"description":{"type":"string"},"default":true,"readOnly":{"type":"boolean","default":false},"examples":{"type":"array","items":true},"multipleOf":{"type":"number","exclusiveMinimum":0},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"number"},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"number"},"maxLength":{"$ref":"#/definitions/nonNegativeInteger"},"minLength":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"additionalItems":{"$ref":"#"},"items":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/schemaArray"}],"default":true},"maxItems":{"$ref":"#/definitions/nonNegativeInteger"},"minItems":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"contains":{"$ref":"#"},"maxProperties":{"$ref":"#/definitions/nonNegativeInteger"},"minProperties":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"required":{"$ref":"#/definitions/stringArray"},"additionalProperties":{"$ref":"#"},"definitions":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"properties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$ref":"#"},"propertyNames":{"format":"regex"},"default":{}},"dependencies":{"type":"object","additionalProperties":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/stringArray"}]}},"propertyNames":{"$ref":"#"},"const":true,"enum":{"type":"array","items":true,"minItems":1,"uniqueItems":true},"type":{"anyOf":[{"$ref":"#/definitions/simpleTypes"},{"type":"array","items":{"$ref":"#/definitions/simpleTypes"},"minItems":1,"uniqueItems":true}]},"format":{"type":"string"},"contentMediaType":{"type":"string"},"contentEncoding":{"type":"string"},"if":{"$ref":"#"},"then":{"$ref":"#"},"else":{"$ref":"#"},"allOf":{"$ref":"#/definitions/schemaArray"},"anyOf":{"$ref":"#/definitions/schemaArray"},"oneOf":{"$ref":"#/definitions/schemaArray"},"not":{"$ref":"#"}},"default":true}');
            /***/ 
        }),
        /***/ 2020: 
        /***/ (function (module) {
            "use strict";
            module.exports = JSON.parse('[[[0,44],"disallowed_STD3_valid"],[[45,46],"valid"],[[47,47],"disallowed_STD3_valid"],[[48,57],"valid"],[[58,64],"disallowed_STD3_valid"],[[65,65],"mapped",[97]],[[66,66],"mapped",[98]],[[67,67],"mapped",[99]],[[68,68],"mapped",[100]],[[69,69],"mapped",[101]],[[70,70],"mapped",[102]],[[71,71],"mapped",[103]],[[72,72],"mapped",[104]],[[73,73],"mapped",[105]],[[74,74],"mapped",[106]],[[75,75],"mapped",[107]],[[76,76],"mapped",[108]],[[77,77],"mapped",[109]],[[78,78],"mapped",[110]],[[79,79],"mapped",[111]],[[80,80],"mapped",[112]],[[81,81],"mapped",[113]],[[82,82],"mapped",[114]],[[83,83],"mapped",[115]],[[84,84],"mapped",[116]],[[85,85],"mapped",[117]],[[86,86],"mapped",[118]],[[87,87],"mapped",[119]],[[88,88],"mapped",[120]],[[89,89],"mapped",[121]],[[90,90],"mapped",[122]],[[91,96],"disallowed_STD3_valid"],[[97,122],"valid"],[[123,127],"disallowed_STD3_valid"],[[128,159],"disallowed"],[[160,160],"disallowed_STD3_mapped",[32]],[[161,167],"valid",[],"NV8"],[[168,168],"disallowed_STD3_mapped",[32,776]],[[169,169],"valid",[],"NV8"],[[170,170],"mapped",[97]],[[171,172],"valid",[],"NV8"],[[173,173],"ignored"],[[174,174],"valid",[],"NV8"],[[175,175],"disallowed_STD3_mapped",[32,772]],[[176,177],"valid",[],"NV8"],[[178,178],"mapped",[50]],[[179,179],"mapped",[51]],[[180,180],"disallowed_STD3_mapped",[32,769]],[[181,181],"mapped",[956]],[[182,182],"valid",[],"NV8"],[[183,183],"valid"],[[184,184],"disallowed_STD3_mapped",[32,807]],[[185,185],"mapped",[49]],[[186,186],"mapped",[111]],[[187,187],"valid",[],"NV8"],[[188,188],"mapped",[49,8260,52]],[[189,189],"mapped",[49,8260,50]],[[190,190],"mapped",[51,8260,52]],[[191,191],"valid",[],"NV8"],[[192,192],"mapped",[224]],[[193,193],"mapped",[225]],[[194,194],"mapped",[226]],[[195,195],"mapped",[227]],[[196,196],"mapped",[228]],[[197,197],"mapped",[229]],[[198,198],"mapped",[230]],[[199,199],"mapped",[231]],[[200,200],"mapped",[232]],[[201,201],"mapped",[233]],[[202,202],"mapped",[234]],[[203,203],"mapped",[235]],[[204,204],"mapped",[236]],[[205,205],"mapped",[237]],[[206,206],"mapped",[238]],[[207,207],"mapped",[239]],[[208,208],"mapped",[240]],[[209,209],"mapped",[241]],[[210,210],"mapped",[242]],[[211,211],"mapped",[243]],[[212,212],"mapped",[244]],[[213,213],"mapped",[245]],[[214,214],"mapped",[246]],[[215,215],"valid",[],"NV8"],[[216,216],"mapped",[248]],[[217,217],"mapped",[249]],[[218,218],"mapped",[250]],[[219,219],"mapped",[251]],[[220,220],"mapped",[252]],[[221,221],"mapped",[253]],[[222,222],"mapped",[254]],[[223,223],"deviation",[115,115]],[[224,246],"valid"],[[247,247],"valid",[],"NV8"],[[248,255],"valid"],[[256,256],"mapped",[257]],[[257,257],"valid"],[[258,258],"mapped",[259]],[[259,259],"valid"],[[260,260],"mapped",[261]],[[261,261],"valid"],[[262,262],"mapped",[263]],[[263,263],"valid"],[[264,264],"mapped",[265]],[[265,265],"valid"],[[266,266],"mapped",[267]],[[267,267],"valid"],[[268,268],"mapped",[269]],[[269,269],"valid"],[[270,270],"mapped",[271]],[[271,271],"valid"],[[272,272],"mapped",[273]],[[273,273],"valid"],[[274,274],"mapped",[275]],[[275,275],"valid"],[[276,276],"mapped",[277]],[[277,277],"valid"],[[278,278],"mapped",[279]],[[279,279],"valid"],[[280,280],"mapped",[281]],[[281,281],"valid"],[[282,282],"mapped",[283]],[[283,283],"valid"],[[284,284],"mapped",[285]],[[285,285],"valid"],[[286,286],"mapped",[287]],[[287,287],"valid"],[[288,288],"mapped",[289]],[[289,289],"valid"],[[290,290],"mapped",[291]],[[291,291],"valid"],[[292,292],"mapped",[293]],[[293,293],"valid"],[[294,294],"mapped",[295]],[[295,295],"valid"],[[296,296],"mapped",[297]],[[297,297],"valid"],[[298,298],"mapped",[299]],[[299,299],"valid"],[[300,300],"mapped",[301]],[[301,301],"valid"],[[302,302],"mapped",[303]],[[303,303],"valid"],[[304,304],"mapped",[105,775]],[[305,305],"valid"],[[306,307],"mapped",[105,106]],[[308,308],"mapped",[309]],[[309,309],"valid"],[[310,310],"mapped",[311]],[[311,312],"valid"],[[313,313],"mapped",[314]],[[314,314],"valid"],[[315,315],"mapped",[316]],[[316,316],"valid"],[[317,317],"mapped",[318]],[[318,318],"valid"],[[319,320],"mapped",[108,183]],[[321,321],"mapped",[322]],[[322,322],"valid"],[[323,323],"mapped",[324]],[[324,324],"valid"],[[325,325],"mapped",[326]],[[326,326],"valid"],[[327,327],"mapped",[328]],[[328,328],"valid"],[[329,329],"mapped",[700,110]],[[330,330],"mapped",[331]],[[331,331],"valid"],[[332,332],"mapped",[333]],[[333,333],"valid"],[[334,334],"mapped",[335]],[[335,335],"valid"],[[336,336],"mapped",[337]],[[337,337],"valid"],[[338,338],"mapped",[339]],[[339,339],"valid"],[[340,340],"mapped",[341]],[[341,341],"valid"],[[342,342],"mapped",[343]],[[343,343],"valid"],[[344,344],"mapped",[345]],[[345,345],"valid"],[[346,346],"mapped",[347]],[[347,347],"valid"],[[348,348],"mapped",[349]],[[349,349],"valid"],[[350,350],"mapped",[351]],[[351,351],"valid"],[[352,352],"mapped",[353]],[[353,353],"valid"],[[354,354],"mapped",[355]],[[355,355],"valid"],[[356,356],"mapped",[357]],[[357,357],"valid"],[[358,358],"mapped",[359]],[[359,359],"valid"],[[360,360],"mapped",[361]],[[361,361],"valid"],[[362,362],"mapped",[363]],[[363,363],"valid"],[[364,364],"mapped",[365]],[[365,365],"valid"],[[366,366],"mapped",[367]],[[367,367],"valid"],[[368,368],"mapped",[369]],[[369,369],"valid"],[[370,370],"mapped",[371]],[[371,371],"valid"],[[372,372],"mapped",[373]],[[373,373],"valid"],[[374,374],"mapped",[375]],[[375,375],"valid"],[[376,376],"mapped",[255]],[[377,377],"mapped",[378]],[[378,378],"valid"],[[379,379],"mapped",[380]],[[380,380],"valid"],[[381,381],"mapped",[382]],[[382,382],"valid"],[[383,383],"mapped",[115]],[[384,384],"valid"],[[385,385],"mapped",[595]],[[386,386],"mapped",[387]],[[387,387],"valid"],[[388,388],"mapped",[389]],[[389,389],"valid"],[[390,390],"mapped",[596]],[[391,391],"mapped",[392]],[[392,392],"valid"],[[393,393],"mapped",[598]],[[394,394],"mapped",[599]],[[395,395],"mapped",[396]],[[396,397],"valid"],[[398,398],"mapped",[477]],[[399,399],"mapped",[601]],[[400,400],"mapped",[603]],[[401,401],"mapped",[402]],[[402,402],"valid"],[[403,403],"mapped",[608]],[[404,404],"mapped",[611]],[[405,405],"valid"],[[406,406],"mapped",[617]],[[407,407],"mapped",[616]],[[408,408],"mapped",[409]],[[409,411],"valid"],[[412,412],"mapped",[623]],[[413,413],"mapped",[626]],[[414,414],"valid"],[[415,415],"mapped",[629]],[[416,416],"mapped",[417]],[[417,417],"valid"],[[418,418],"mapped",[419]],[[419,419],"valid"],[[420,420],"mapped",[421]],[[421,421],"valid"],[[422,422],"mapped",[640]],[[423,423],"mapped",[424]],[[424,424],"valid"],[[425,425],"mapped",[643]],[[426,427],"valid"],[[428,428],"mapped",[429]],[[429,429],"valid"],[[430,430],"mapped",[648]],[[431,431],"mapped",[432]],[[432,432],"valid"],[[433,433],"mapped",[650]],[[434,434],"mapped",[651]],[[435,435],"mapped",[436]],[[436,436],"valid"],[[437,437],"mapped",[438]],[[438,438],"valid"],[[439,439],"mapped",[658]],[[440,440],"mapped",[441]],[[441,443],"valid"],[[444,444],"mapped",[445]],[[445,451],"valid"],[[452,454],"mapped",[100,382]],[[455,457],"mapped",[108,106]],[[458,460],"mapped",[110,106]],[[461,461],"mapped",[462]],[[462,462],"valid"],[[463,463],"mapped",[464]],[[464,464],"valid"],[[465,465],"mapped",[466]],[[466,466],"valid"],[[467,467],"mapped",[468]],[[468,468],"valid"],[[469,469],"mapped",[470]],[[470,470],"valid"],[[471,471],"mapped",[472]],[[472,472],"valid"],[[473,473],"mapped",[474]],[[474,474],"valid"],[[475,475],"mapped",[476]],[[476,477],"valid"],[[478,478],"mapped",[479]],[[479,479],"valid"],[[480,480],"mapped",[481]],[[481,481],"valid"],[[482,482],"mapped",[483]],[[483,483],"valid"],[[484,484],"mapped",[485]],[[485,485],"valid"],[[486,486],"mapped",[487]],[[487,487],"valid"],[[488,488],"mapped",[489]],[[489,489],"valid"],[[490,490],"mapped",[491]],[[491,491],"valid"],[[492,492],"mapped",[493]],[[493,493],"valid"],[[494,494],"mapped",[495]],[[495,496],"valid"],[[497,499],"mapped",[100,122]],[[500,500],"mapped",[501]],[[501,501],"valid"],[[502,502],"mapped",[405]],[[503,503],"mapped",[447]],[[504,504],"mapped",[505]],[[505,505],"valid"],[[506,506],"mapped",[507]],[[507,507],"valid"],[[508,508],"mapped",[509]],[[509,509],"valid"],[[510,510],"mapped",[511]],[[511,511],"valid"],[[512,512],"mapped",[513]],[[513,513],"valid"],[[514,514],"mapped",[515]],[[515,515],"valid"],[[516,516],"mapped",[517]],[[517,517],"valid"],[[518,518],"mapped",[519]],[[519,519],"valid"],[[520,520],"mapped",[521]],[[521,521],"valid"],[[522,522],"mapped",[523]],[[523,523],"valid"],[[524,524],"mapped",[525]],[[525,525],"valid"],[[526,526],"mapped",[527]],[[527,527],"valid"],[[528,528],"mapped",[529]],[[529,529],"valid"],[[530,530],"mapped",[531]],[[531,531],"valid"],[[532,532],"mapped",[533]],[[533,533],"valid"],[[534,534],"mapped",[535]],[[535,535],"valid"],[[536,536],"mapped",[537]],[[537,537],"valid"],[[538,538],"mapped",[539]],[[539,539],"valid"],[[540,540],"mapped",[541]],[[541,541],"valid"],[[542,542],"mapped",[543]],[[543,543],"valid"],[[544,544],"mapped",[414]],[[545,545],"valid"],[[546,546],"mapped",[547]],[[547,547],"valid"],[[548,548],"mapped",[549]],[[549,549],"valid"],[[550,550],"mapped",[551]],[[551,551],"valid"],[[552,552],"mapped",[553]],[[553,553],"valid"],[[554,554],"mapped",[555]],[[555,555],"valid"],[[556,556],"mapped",[557]],[[557,557],"valid"],[[558,558],"mapped",[559]],[[559,559],"valid"],[[560,560],"mapped",[561]],[[561,561],"valid"],[[562,562],"mapped",[563]],[[563,563],"valid"],[[564,566],"valid"],[[567,569],"valid"],[[570,570],"mapped",[11365]],[[571,571],"mapped",[572]],[[572,572],"valid"],[[573,573],"mapped",[410]],[[574,574],"mapped",[11366]],[[575,576],"valid"],[[577,577],"mapped",[578]],[[578,578],"valid"],[[579,579],"mapped",[384]],[[580,580],"mapped",[649]],[[581,581],"mapped",[652]],[[582,582],"mapped",[583]],[[583,583],"valid"],[[584,584],"mapped",[585]],[[585,585],"valid"],[[586,586],"mapped",[587]],[[587,587],"valid"],[[588,588],"mapped",[589]],[[589,589],"valid"],[[590,590],"mapped",[591]],[[591,591],"valid"],[[592,680],"valid"],[[681,685],"valid"],[[686,687],"valid"],[[688,688],"mapped",[104]],[[689,689],"mapped",[614]],[[690,690],"mapped",[106]],[[691,691],"mapped",[114]],[[692,692],"mapped",[633]],[[693,693],"mapped",[635]],[[694,694],"mapped",[641]],[[695,695],"mapped",[119]],[[696,696],"mapped",[121]],[[697,705],"valid"],[[706,709],"valid",[],"NV8"],[[710,721],"valid"],[[722,727],"valid",[],"NV8"],[[728,728],"disallowed_STD3_mapped",[32,774]],[[729,729],"disallowed_STD3_mapped",[32,775]],[[730,730],"disallowed_STD3_mapped",[32,778]],[[731,731],"disallowed_STD3_mapped",[32,808]],[[732,732],"disallowed_STD3_mapped",[32,771]],[[733,733],"disallowed_STD3_mapped",[32,779]],[[734,734],"valid",[],"NV8"],[[735,735],"valid",[],"NV8"],[[736,736],"mapped",[611]],[[737,737],"mapped",[108]],[[738,738],"mapped",[115]],[[739,739],"mapped",[120]],[[740,740],"mapped",[661]],[[741,745],"valid",[],"NV8"],[[746,747],"valid",[],"NV8"],[[748,748],"valid"],[[749,749],"valid",[],"NV8"],[[750,750],"valid"],[[751,767],"valid",[],"NV8"],[[768,831],"valid"],[[832,832],"mapped",[768]],[[833,833],"mapped",[769]],[[834,834],"valid"],[[835,835],"mapped",[787]],[[836,836],"mapped",[776,769]],[[837,837],"mapped",[953]],[[838,846],"valid"],[[847,847],"ignored"],[[848,855],"valid"],[[856,860],"valid"],[[861,863],"valid"],[[864,865],"valid"],[[866,866],"valid"],[[867,879],"valid"],[[880,880],"mapped",[881]],[[881,881],"valid"],[[882,882],"mapped",[883]],[[883,883],"valid"],[[884,884],"mapped",[697]],[[885,885],"valid"],[[886,886],"mapped",[887]],[[887,887],"valid"],[[888,889],"disallowed"],[[890,890],"disallowed_STD3_mapped",[32,953]],[[891,893],"valid"],[[894,894],"disallowed_STD3_mapped",[59]],[[895,895],"mapped",[1011]],[[896,899],"disallowed"],[[900,900],"disallowed_STD3_mapped",[32,769]],[[901,901],"disallowed_STD3_mapped",[32,776,769]],[[902,902],"mapped",[940]],[[903,903],"mapped",[183]],[[904,904],"mapped",[941]],[[905,905],"mapped",[942]],[[906,906],"mapped",[943]],[[907,907],"disallowed"],[[908,908],"mapped",[972]],[[909,909],"disallowed"],[[910,910],"mapped",[973]],[[911,911],"mapped",[974]],[[912,912],"valid"],[[913,913],"mapped",[945]],[[914,914],"mapped",[946]],[[915,915],"mapped",[947]],[[916,916],"mapped",[948]],[[917,917],"mapped",[949]],[[918,918],"mapped",[950]],[[919,919],"mapped",[951]],[[920,920],"mapped",[952]],[[921,921],"mapped",[953]],[[922,922],"mapped",[954]],[[923,923],"mapped",[955]],[[924,924],"mapped",[956]],[[925,925],"mapped",[957]],[[926,926],"mapped",[958]],[[927,927],"mapped",[959]],[[928,928],"mapped",[960]],[[929,929],"mapped",[961]],[[930,930],"disallowed"],[[931,931],"mapped",[963]],[[932,932],"mapped",[964]],[[933,933],"mapped",[965]],[[934,934],"mapped",[966]],[[935,935],"mapped",[967]],[[936,936],"mapped",[968]],[[937,937],"mapped",[969]],[[938,938],"mapped",[970]],[[939,939],"mapped",[971]],[[940,961],"valid"],[[962,962],"deviation",[963]],[[963,974],"valid"],[[975,975],"mapped",[983]],[[976,976],"mapped",[946]],[[977,977],"mapped",[952]],[[978,978],"mapped",[965]],[[979,979],"mapped",[973]],[[980,980],"mapped",[971]],[[981,981],"mapped",[966]],[[982,982],"mapped",[960]],[[983,983],"valid"],[[984,984],"mapped",[985]],[[985,985],"valid"],[[986,986],"mapped",[987]],[[987,987],"valid"],[[988,988],"mapped",[989]],[[989,989],"valid"],[[990,990],"mapped",[991]],[[991,991],"valid"],[[992,992],"mapped",[993]],[[993,993],"valid"],[[994,994],"mapped",[995]],[[995,995],"valid"],[[996,996],"mapped",[997]],[[997,997],"valid"],[[998,998],"mapped",[999]],[[999,999],"valid"],[[1000,1000],"mapped",[1001]],[[1001,1001],"valid"],[[1002,1002],"mapped",[1003]],[[1003,1003],"valid"],[[1004,1004],"mapped",[1005]],[[1005,1005],"valid"],[[1006,1006],"mapped",[1007]],[[1007,1007],"valid"],[[1008,1008],"mapped",[954]],[[1009,1009],"mapped",[961]],[[1010,1010],"mapped",[963]],[[1011,1011],"valid"],[[1012,1012],"mapped",[952]],[[1013,1013],"mapped",[949]],[[1014,1014],"valid",[],"NV8"],[[1015,1015],"mapped",[1016]],[[1016,1016],"valid"],[[1017,1017],"mapped",[963]],[[1018,1018],"mapped",[1019]],[[1019,1019],"valid"],[[1020,1020],"valid"],[[1021,1021],"mapped",[891]],[[1022,1022],"mapped",[892]],[[1023,1023],"mapped",[893]],[[1024,1024],"mapped",[1104]],[[1025,1025],"mapped",[1105]],[[1026,1026],"mapped",[1106]],[[1027,1027],"mapped",[1107]],[[1028,1028],"mapped",[1108]],[[1029,1029],"mapped",[1109]],[[1030,1030],"mapped",[1110]],[[1031,1031],"mapped",[1111]],[[1032,1032],"mapped",[1112]],[[1033,1033],"mapped",[1113]],[[1034,1034],"mapped",[1114]],[[1035,1035],"mapped",[1115]],[[1036,1036],"mapped",[1116]],[[1037,1037],"mapped",[1117]],[[1038,1038],"mapped",[1118]],[[1039,1039],"mapped",[1119]],[[1040,1040],"mapped",[1072]],[[1041,1041],"mapped",[1073]],[[1042,1042],"mapped",[1074]],[[1043,1043],"mapped",[1075]],[[1044,1044],"mapped",[1076]],[[1045,1045],"mapped",[1077]],[[1046,1046],"mapped",[1078]],[[1047,1047],"mapped",[1079]],[[1048,1048],"mapped",[1080]],[[1049,1049],"mapped",[1081]],[[1050,1050],"mapped",[1082]],[[1051,1051],"mapped",[1083]],[[1052,1052],"mapped",[1084]],[[1053,1053],"mapped",[1085]],[[1054,1054],"mapped",[1086]],[[1055,1055],"mapped",[1087]],[[1056,1056],"mapped",[1088]],[[1057,1057],"mapped",[1089]],[[1058,1058],"mapped",[1090]],[[1059,1059],"mapped",[1091]],[[1060,1060],"mapped",[1092]],[[1061,1061],"mapped",[1093]],[[1062,1062],"mapped",[1094]],[[1063,1063],"mapped",[1095]],[[1064,1064],"mapped",[1096]],[[1065,1065],"mapped",[1097]],[[1066,1066],"mapped",[1098]],[[1067,1067],"mapped",[1099]],[[1068,1068],"mapped",[1100]],[[1069,1069],"mapped",[1101]],[[1070,1070],"mapped",[1102]],[[1071,1071],"mapped",[1103]],[[1072,1103],"valid"],[[1104,1104],"valid"],[[1105,1116],"valid"],[[1117,1117],"valid"],[[1118,1119],"valid"],[[1120,1120],"mapped",[1121]],[[1121,1121],"valid"],[[1122,1122],"mapped",[1123]],[[1123,1123],"valid"],[[1124,1124],"mapped",[1125]],[[1125,1125],"valid"],[[1126,1126],"mapped",[1127]],[[1127,1127],"valid"],[[1128,1128],"mapped",[1129]],[[1129,1129],"valid"],[[1130,1130],"mapped",[1131]],[[1131,1131],"valid"],[[1132,1132],"mapped",[1133]],[[1133,1133],"valid"],[[1134,1134],"mapped",[1135]],[[1135,1135],"valid"],[[1136,1136],"mapped",[1137]],[[1137,1137],"valid"],[[1138,1138],"mapped",[1139]],[[1139,1139],"valid"],[[1140,1140],"mapped",[1141]],[[1141,1141],"valid"],[[1142,1142],"mapped",[1143]],[[1143,1143],"valid"],[[1144,1144],"mapped",[1145]],[[1145,1145],"valid"],[[1146,1146],"mapped",[1147]],[[1147,1147],"valid"],[[1148,1148],"mapped",[1149]],[[1149,1149],"valid"],[[1150,1150],"mapped",[1151]],[[1151,1151],"valid"],[[1152,1152],"mapped",[1153]],[[1153,1153],"valid"],[[1154,1154],"valid",[],"NV8"],[[1155,1158],"valid"],[[1159,1159],"valid"],[[1160,1161],"valid",[],"NV8"],[[1162,1162],"mapped",[1163]],[[1163,1163],"valid"],[[1164,1164],"mapped",[1165]],[[1165,1165],"valid"],[[1166,1166],"mapped",[1167]],[[1167,1167],"valid"],[[1168,1168],"mapped",[1169]],[[1169,1169],"valid"],[[1170,1170],"mapped",[1171]],[[1171,1171],"valid"],[[1172,1172],"mapped",[1173]],[[1173,1173],"valid"],[[1174,1174],"mapped",[1175]],[[1175,1175],"valid"],[[1176,1176],"mapped",[1177]],[[1177,1177],"valid"],[[1178,1178],"mapped",[1179]],[[1179,1179],"valid"],[[1180,1180],"mapped",[1181]],[[1181,1181],"valid"],[[1182,1182],"mapped",[1183]],[[1183,1183],"valid"],[[1184,1184],"mapped",[1185]],[[1185,1185],"valid"],[[1186,1186],"mapped",[1187]],[[1187,1187],"valid"],[[1188,1188],"mapped",[1189]],[[1189,1189],"valid"],[[1190,1190],"mapped",[1191]],[[1191,1191],"valid"],[[1192,1192],"mapped",[1193]],[[1193,1193],"valid"],[[1194,1194],"mapped",[1195]],[[1195,1195],"valid"],[[1196,1196],"mapped",[1197]],[[1197,1197],"valid"],[[1198,1198],"mapped",[1199]],[[1199,1199],"valid"],[[1200,1200],"mapped",[1201]],[[1201,1201],"valid"],[[1202,1202],"mapped",[1203]],[[1203,1203],"valid"],[[1204,1204],"mapped",[1205]],[[1205,1205],"valid"],[[1206,1206],"mapped",[1207]],[[1207,1207],"valid"],[[1208,1208],"mapped",[1209]],[[1209,1209],"valid"],[[1210,1210],"mapped",[1211]],[[1211,1211],"valid"],[[1212,1212],"mapped",[1213]],[[1213,1213],"valid"],[[1214,1214],"mapped",[1215]],[[1215,1215],"valid"],[[1216,1216],"disallowed"],[[1217,1217],"mapped",[1218]],[[1218,1218],"valid"],[[1219,1219],"mapped",[1220]],[[1220,1220],"valid"],[[1221,1221],"mapped",[1222]],[[1222,1222],"valid"],[[1223,1223],"mapped",[1224]],[[1224,1224],"valid"],[[1225,1225],"mapped",[1226]],[[1226,1226],"valid"],[[1227,1227],"mapped",[1228]],[[1228,1228],"valid"],[[1229,1229],"mapped",[1230]],[[1230,1230],"valid"],[[1231,1231],"valid"],[[1232,1232],"mapped",[1233]],[[1233,1233],"valid"],[[1234,1234],"mapped",[1235]],[[1235,1235],"valid"],[[1236,1236],"mapped",[1237]],[[1237,1237],"valid"],[[1238,1238],"mapped",[1239]],[[1239,1239],"valid"],[[1240,1240],"mapped",[1241]],[[1241,1241],"valid"],[[1242,1242],"mapped",[1243]],[[1243,1243],"valid"],[[1244,1244],"mapped",[1245]],[[1245,1245],"valid"],[[1246,1246],"mapped",[1247]],[[1247,1247],"valid"],[[1248,1248],"mapped",[1249]],[[1249,1249],"valid"],[[1250,1250],"mapped",[1251]],[[1251,1251],"valid"],[[1252,1252],"mapped",[1253]],[[1253,1253],"valid"],[[1254,1254],"mapped",[1255]],[[1255,1255],"valid"],[[1256,1256],"mapped",[1257]],[[1257,1257],"valid"],[[1258,1258],"mapped",[1259]],[[1259,1259],"valid"],[[1260,1260],"mapped",[1261]],[[1261,1261],"valid"],[[1262,1262],"mapped",[1263]],[[1263,1263],"valid"],[[1264,1264],"mapped",[1265]],[[1265,1265],"valid"],[[1266,1266],"mapped",[1267]],[[1267,1267],"valid"],[[1268,1268],"mapped",[1269]],[[1269,1269],"valid"],[[1270,1270],"mapped",[1271]],[[1271,1271],"valid"],[[1272,1272],"mapped",[1273]],[[1273,1273],"valid"],[[1274,1274],"mapped",[1275]],[[1275,1275],"valid"],[[1276,1276],"mapped",[1277]],[[1277,1277],"valid"],[[1278,1278],"mapped",[1279]],[[1279,1279],"valid"],[[1280,1280],"mapped",[1281]],[[1281,1281],"valid"],[[1282,1282],"mapped",[1283]],[[1283,1283],"valid"],[[1284,1284],"mapped",[1285]],[[1285,1285],"valid"],[[1286,1286],"mapped",[1287]],[[1287,1287],"valid"],[[1288,1288],"mapped",[1289]],[[1289,1289],"valid"],[[1290,1290],"mapped",[1291]],[[1291,1291],"valid"],[[1292,1292],"mapped",[1293]],[[1293,1293],"valid"],[[1294,1294],"mapped",[1295]],[[1295,1295],"valid"],[[1296,1296],"mapped",[1297]],[[1297,1297],"valid"],[[1298,1298],"mapped",[1299]],[[1299,1299],"valid"],[[1300,1300],"mapped",[1301]],[[1301,1301],"valid"],[[1302,1302],"mapped",[1303]],[[1303,1303],"valid"],[[1304,1304],"mapped",[1305]],[[1305,1305],"valid"],[[1306,1306],"mapped",[1307]],[[1307,1307],"valid"],[[1308,1308],"mapped",[1309]],[[1309,1309],"valid"],[[1310,1310],"mapped",[1311]],[[1311,1311],"valid"],[[1312,1312],"mapped",[1313]],[[1313,1313],"valid"],[[1314,1314],"mapped",[1315]],[[1315,1315],"valid"],[[1316,1316],"mapped",[1317]],[[1317,1317],"valid"],[[1318,1318],"mapped",[1319]],[[1319,1319],"valid"],[[1320,1320],"mapped",[1321]],[[1321,1321],"valid"],[[1322,1322],"mapped",[1323]],[[1323,1323],"valid"],[[1324,1324],"mapped",[1325]],[[1325,1325],"valid"],[[1326,1326],"mapped",[1327]],[[1327,1327],"valid"],[[1328,1328],"disallowed"],[[1329,1329],"mapped",[1377]],[[1330,1330],"mapped",[1378]],[[1331,1331],"mapped",[1379]],[[1332,1332],"mapped",[1380]],[[1333,1333],"mapped",[1381]],[[1334,1334],"mapped",[1382]],[[1335,1335],"mapped",[1383]],[[1336,1336],"mapped",[1384]],[[1337,1337],"mapped",[1385]],[[1338,1338],"mapped",[1386]],[[1339,1339],"mapped",[1387]],[[1340,1340],"mapped",[1388]],[[1341,1341],"mapped",[1389]],[[1342,1342],"mapped",[1390]],[[1343,1343],"mapped",[1391]],[[1344,1344],"mapped",[1392]],[[1345,1345],"mapped",[1393]],[[1346,1346],"mapped",[1394]],[[1347,1347],"mapped",[1395]],[[1348,1348],"mapped",[1396]],[[1349,1349],"mapped",[1397]],[[1350,1350],"mapped",[1398]],[[1351,1351],"mapped",[1399]],[[1352,1352],"mapped",[1400]],[[1353,1353],"mapped",[1401]],[[1354,1354],"mapped",[1402]],[[1355,1355],"mapped",[1403]],[[1356,1356],"mapped",[1404]],[[1357,1357],"mapped",[1405]],[[1358,1358],"mapped",[1406]],[[1359,1359],"mapped",[1407]],[[1360,1360],"mapped",[1408]],[[1361,1361],"mapped",[1409]],[[1362,1362],"mapped",[1410]],[[1363,1363],"mapped",[1411]],[[1364,1364],"mapped",[1412]],[[1365,1365],"mapped",[1413]],[[1366,1366],"mapped",[1414]],[[1367,1368],"disallowed"],[[1369,1369],"valid"],[[1370,1375],"valid",[],"NV8"],[[1376,1376],"disallowed"],[[1377,1414],"valid"],[[1415,1415],"mapped",[1381,1410]],[[1416,1416],"disallowed"],[[1417,1417],"valid",[],"NV8"],[[1418,1418],"valid",[],"NV8"],[[1419,1420],"disallowed"],[[1421,1422],"valid",[],"NV8"],[[1423,1423],"valid",[],"NV8"],[[1424,1424],"disallowed"],[[1425,1441],"valid"],[[1442,1442],"valid"],[[1443,1455],"valid"],[[1456,1465],"valid"],[[1466,1466],"valid"],[[1467,1469],"valid"],[[1470,1470],"valid",[],"NV8"],[[1471,1471],"valid"],[[1472,1472],"valid",[],"NV8"],[[1473,1474],"valid"],[[1475,1475],"valid",[],"NV8"],[[1476,1476],"valid"],[[1477,1477],"valid"],[[1478,1478],"valid",[],"NV8"],[[1479,1479],"valid"],[[1480,1487],"disallowed"],[[1488,1514],"valid"],[[1515,1519],"disallowed"],[[1520,1524],"valid"],[[1525,1535],"disallowed"],[[1536,1539],"disallowed"],[[1540,1540],"disallowed"],[[1541,1541],"disallowed"],[[1542,1546],"valid",[],"NV8"],[[1547,1547],"valid",[],"NV8"],[[1548,1548],"valid",[],"NV8"],[[1549,1551],"valid",[],"NV8"],[[1552,1557],"valid"],[[1558,1562],"valid"],[[1563,1563],"valid",[],"NV8"],[[1564,1564],"disallowed"],[[1565,1565],"disallowed"],[[1566,1566],"valid",[],"NV8"],[[1567,1567],"valid",[],"NV8"],[[1568,1568],"valid"],[[1569,1594],"valid"],[[1595,1599],"valid"],[[1600,1600],"valid",[],"NV8"],[[1601,1618],"valid"],[[1619,1621],"valid"],[[1622,1624],"valid"],[[1625,1630],"valid"],[[1631,1631],"valid"],[[1632,1641],"valid"],[[1642,1645],"valid",[],"NV8"],[[1646,1647],"valid"],[[1648,1652],"valid"],[[1653,1653],"mapped",[1575,1652]],[[1654,1654],"mapped",[1608,1652]],[[1655,1655],"mapped",[1735,1652]],[[1656,1656],"mapped",[1610,1652]],[[1657,1719],"valid"],[[1720,1721],"valid"],[[1722,1726],"valid"],[[1727,1727],"valid"],[[1728,1742],"valid"],[[1743,1743],"valid"],[[1744,1747],"valid"],[[1748,1748],"valid",[],"NV8"],[[1749,1756],"valid"],[[1757,1757],"disallowed"],[[1758,1758],"valid",[],"NV8"],[[1759,1768],"valid"],[[1769,1769],"valid",[],"NV8"],[[1770,1773],"valid"],[[1774,1775],"valid"],[[1776,1785],"valid"],[[1786,1790],"valid"],[[1791,1791],"valid"],[[1792,1805],"valid",[],"NV8"],[[1806,1806],"disallowed"],[[1807,1807],"disallowed"],[[1808,1836],"valid"],[[1837,1839],"valid"],[[1840,1866],"valid"],[[1867,1868],"disallowed"],[[1869,1871],"valid"],[[1872,1901],"valid"],[[1902,1919],"valid"],[[1920,1968],"valid"],[[1969,1969],"valid"],[[1970,1983],"disallowed"],[[1984,2037],"valid"],[[2038,2042],"valid",[],"NV8"],[[2043,2047],"disallowed"],[[2048,2093],"valid"],[[2094,2095],"disallowed"],[[2096,2110],"valid",[],"NV8"],[[2111,2111],"disallowed"],[[2112,2139],"valid"],[[2140,2141],"disallowed"],[[2142,2142],"valid",[],"NV8"],[[2143,2207],"disallowed"],[[2208,2208],"valid"],[[2209,2209],"valid"],[[2210,2220],"valid"],[[2221,2226],"valid"],[[2227,2228],"valid"],[[2229,2274],"disallowed"],[[2275,2275],"valid"],[[2276,2302],"valid"],[[2303,2303],"valid"],[[2304,2304],"valid"],[[2305,2307],"valid"],[[2308,2308],"valid"],[[2309,2361],"valid"],[[2362,2363],"valid"],[[2364,2381],"valid"],[[2382,2382],"valid"],[[2383,2383],"valid"],[[2384,2388],"valid"],[[2389,2389],"valid"],[[2390,2391],"valid"],[[2392,2392],"mapped",[2325,2364]],[[2393,2393],"mapped",[2326,2364]],[[2394,2394],"mapped",[2327,2364]],[[2395,2395],"mapped",[2332,2364]],[[2396,2396],"mapped",[2337,2364]],[[2397,2397],"mapped",[2338,2364]],[[2398,2398],"mapped",[2347,2364]],[[2399,2399],"mapped",[2351,2364]],[[2400,2403],"valid"],[[2404,2405],"valid",[],"NV8"],[[2406,2415],"valid"],[[2416,2416],"valid",[],"NV8"],[[2417,2418],"valid"],[[2419,2423],"valid"],[[2424,2424],"valid"],[[2425,2426],"valid"],[[2427,2428],"valid"],[[2429,2429],"valid"],[[2430,2431],"valid"],[[2432,2432],"valid"],[[2433,2435],"valid"],[[2436,2436],"disallowed"],[[2437,2444],"valid"],[[2445,2446],"disallowed"],[[2447,2448],"valid"],[[2449,2450],"disallowed"],[[2451,2472],"valid"],[[2473,2473],"disallowed"],[[2474,2480],"valid"],[[2481,2481],"disallowed"],[[2482,2482],"valid"],[[2483,2485],"disallowed"],[[2486,2489],"valid"],[[2490,2491],"disallowed"],[[2492,2492],"valid"],[[2493,2493],"valid"],[[2494,2500],"valid"],[[2501,2502],"disallowed"],[[2503,2504],"valid"],[[2505,2506],"disallowed"],[[2507,2509],"valid"],[[2510,2510],"valid"],[[2511,2518],"disallowed"],[[2519,2519],"valid"],[[2520,2523],"disallowed"],[[2524,2524],"mapped",[2465,2492]],[[2525,2525],"mapped",[2466,2492]],[[2526,2526],"disallowed"],[[2527,2527],"mapped",[2479,2492]],[[2528,2531],"valid"],[[2532,2533],"disallowed"],[[2534,2545],"valid"],[[2546,2554],"valid",[],"NV8"],[[2555,2555],"valid",[],"NV8"],[[2556,2560],"disallowed"],[[2561,2561],"valid"],[[2562,2562],"valid"],[[2563,2563],"valid"],[[2564,2564],"disallowed"],[[2565,2570],"valid"],[[2571,2574],"disallowed"],[[2575,2576],"valid"],[[2577,2578],"disallowed"],[[2579,2600],"valid"],[[2601,2601],"disallowed"],[[2602,2608],"valid"],[[2609,2609],"disallowed"],[[2610,2610],"valid"],[[2611,2611],"mapped",[2610,2620]],[[2612,2612],"disallowed"],[[2613,2613],"valid"],[[2614,2614],"mapped",[2616,2620]],[[2615,2615],"disallowed"],[[2616,2617],"valid"],[[2618,2619],"disallowed"],[[2620,2620],"valid"],[[2621,2621],"disallowed"],[[2622,2626],"valid"],[[2627,2630],"disallowed"],[[2631,2632],"valid"],[[2633,2634],"disallowed"],[[2635,2637],"valid"],[[2638,2640],"disallowed"],[[2641,2641],"valid"],[[2642,2648],"disallowed"],[[2649,2649],"mapped",[2582,2620]],[[2650,2650],"mapped",[2583,2620]],[[2651,2651],"mapped",[2588,2620]],[[2652,2652],"valid"],[[2653,2653],"disallowed"],[[2654,2654],"mapped",[2603,2620]],[[2655,2661],"disallowed"],[[2662,2676],"valid"],[[2677,2677],"valid"],[[2678,2688],"disallowed"],[[2689,2691],"valid"],[[2692,2692],"disallowed"],[[2693,2699],"valid"],[[2700,2700],"valid"],[[2701,2701],"valid"],[[2702,2702],"disallowed"],[[2703,2705],"valid"],[[2706,2706],"disallowed"],[[2707,2728],"valid"],[[2729,2729],"disallowed"],[[2730,2736],"valid"],[[2737,2737],"disallowed"],[[2738,2739],"valid"],[[2740,2740],"disallowed"],[[2741,2745],"valid"],[[2746,2747],"disallowed"],[[2748,2757],"valid"],[[2758,2758],"disallowed"],[[2759,2761],"valid"],[[2762,2762],"disallowed"],[[2763,2765],"valid"],[[2766,2767],"disallowed"],[[2768,2768],"valid"],[[2769,2783],"disallowed"],[[2784,2784],"valid"],[[2785,2787],"valid"],[[2788,2789],"disallowed"],[[2790,2799],"valid"],[[2800,2800],"valid",[],"NV8"],[[2801,2801],"valid",[],"NV8"],[[2802,2808],"disallowed"],[[2809,2809],"valid"],[[2810,2816],"disallowed"],[[2817,2819],"valid"],[[2820,2820],"disallowed"],[[2821,2828],"valid"],[[2829,2830],"disallowed"],[[2831,2832],"valid"],[[2833,2834],"disallowed"],[[2835,2856],"valid"],[[2857,2857],"disallowed"],[[2858,2864],"valid"],[[2865,2865],"disallowed"],[[2866,2867],"valid"],[[2868,2868],"disallowed"],[[2869,2869],"valid"],[[2870,2873],"valid"],[[2874,2875],"disallowed"],[[2876,2883],"valid"],[[2884,2884],"valid"],[[2885,2886],"disallowed"],[[2887,2888],"valid"],[[2889,2890],"disallowed"],[[2891,2893],"valid"],[[2894,2901],"disallowed"],[[2902,2903],"valid"],[[2904,2907],"disallowed"],[[2908,2908],"mapped",[2849,2876]],[[2909,2909],"mapped",[2850,2876]],[[2910,2910],"disallowed"],[[2911,2913],"valid"],[[2914,2915],"valid"],[[2916,2917],"disallowed"],[[2918,2927],"valid"],[[2928,2928],"valid",[],"NV8"],[[2929,2929],"valid"],[[2930,2935],"valid",[],"NV8"],[[2936,2945],"disallowed"],[[2946,2947],"valid"],[[2948,2948],"disallowed"],[[2949,2954],"valid"],[[2955,2957],"disallowed"],[[2958,2960],"valid"],[[2961,2961],"disallowed"],[[2962,2965],"valid"],[[2966,2968],"disallowed"],[[2969,2970],"valid"],[[2971,2971],"disallowed"],[[2972,2972],"valid"],[[2973,2973],"disallowed"],[[2974,2975],"valid"],[[2976,2978],"disallowed"],[[2979,2980],"valid"],[[2981,2983],"disallowed"],[[2984,2986],"valid"],[[2987,2989],"disallowed"],[[2990,2997],"valid"],[[2998,2998],"valid"],[[2999,3001],"valid"],[[3002,3005],"disallowed"],[[3006,3010],"valid"],[[3011,3013],"disallowed"],[[3014,3016],"valid"],[[3017,3017],"disallowed"],[[3018,3021],"valid"],[[3022,3023],"disallowed"],[[3024,3024],"valid"],[[3025,3030],"disallowed"],[[3031,3031],"valid"],[[3032,3045],"disallowed"],[[3046,3046],"valid"],[[3047,3055],"valid"],[[3056,3058],"valid",[],"NV8"],[[3059,3066],"valid",[],"NV8"],[[3067,3071],"disallowed"],[[3072,3072],"valid"],[[3073,3075],"valid"],[[3076,3076],"disallowed"],[[3077,3084],"valid"],[[3085,3085],"disallowed"],[[3086,3088],"valid"],[[3089,3089],"disallowed"],[[3090,3112],"valid"],[[3113,3113],"disallowed"],[[3114,3123],"valid"],[[3124,3124],"valid"],[[3125,3129],"valid"],[[3130,3132],"disallowed"],[[3133,3133],"valid"],[[3134,3140],"valid"],[[3141,3141],"disallowed"],[[3142,3144],"valid"],[[3145,3145],"disallowed"],[[3146,3149],"valid"],[[3150,3156],"disallowed"],[[3157,3158],"valid"],[[3159,3159],"disallowed"],[[3160,3161],"valid"],[[3162,3162],"valid"],[[3163,3167],"disallowed"],[[3168,3169],"valid"],[[3170,3171],"valid"],[[3172,3173],"disallowed"],[[3174,3183],"valid"],[[3184,3191],"disallowed"],[[3192,3199],"valid",[],"NV8"],[[3200,3200],"disallowed"],[[3201,3201],"valid"],[[3202,3203],"valid"],[[3204,3204],"disallowed"],[[3205,3212],"valid"],[[3213,3213],"disallowed"],[[3214,3216],"valid"],[[3217,3217],"disallowed"],[[3218,3240],"valid"],[[3241,3241],"disallowed"],[[3242,3251],"valid"],[[3252,3252],"disallowed"],[[3253,3257],"valid"],[[3258,3259],"disallowed"],[[3260,3261],"valid"],[[3262,3268],"valid"],[[3269,3269],"disallowed"],[[3270,3272],"valid"],[[3273,3273],"disallowed"],[[3274,3277],"valid"],[[3278,3284],"disallowed"],[[3285,3286],"valid"],[[3287,3293],"disallowed"],[[3294,3294],"valid"],[[3295,3295],"disallowed"],[[3296,3297],"valid"],[[3298,3299],"valid"],[[3300,3301],"disallowed"],[[3302,3311],"valid"],[[3312,3312],"disallowed"],[[3313,3314],"valid"],[[3315,3328],"disallowed"],[[3329,3329],"valid"],[[3330,3331],"valid"],[[3332,3332],"disallowed"],[[3333,3340],"valid"],[[3341,3341],"disallowed"],[[3342,3344],"valid"],[[3345,3345],"disallowed"],[[3346,3368],"valid"],[[3369,3369],"valid"],[[3370,3385],"valid"],[[3386,3386],"valid"],[[3387,3388],"disallowed"],[[3389,3389],"valid"],[[3390,3395],"valid"],[[3396,3396],"valid"],[[3397,3397],"disallowed"],[[3398,3400],"valid"],[[3401,3401],"disallowed"],[[3402,3405],"valid"],[[3406,3406],"valid"],[[3407,3414],"disallowed"],[[3415,3415],"valid"],[[3416,3422],"disallowed"],[[3423,3423],"valid"],[[3424,3425],"valid"],[[3426,3427],"valid"],[[3428,3429],"disallowed"],[[3430,3439],"valid"],[[3440,3445],"valid",[],"NV8"],[[3446,3448],"disallowed"],[[3449,3449],"valid",[],"NV8"],[[3450,3455],"valid"],[[3456,3457],"disallowed"],[[3458,3459],"valid"],[[3460,3460],"disallowed"],[[3461,3478],"valid"],[[3479,3481],"disallowed"],[[3482,3505],"valid"],[[3506,3506],"disallowed"],[[3507,3515],"valid"],[[3516,3516],"disallowed"],[[3517,3517],"valid"],[[3518,3519],"disallowed"],[[3520,3526],"valid"],[[3527,3529],"disallowed"],[[3530,3530],"valid"],[[3531,3534],"disallowed"],[[3535,3540],"valid"],[[3541,3541],"disallowed"],[[3542,3542],"valid"],[[3543,3543],"disallowed"],[[3544,3551],"valid"],[[3552,3557],"disallowed"],[[3558,3567],"valid"],[[3568,3569],"disallowed"],[[3570,3571],"valid"],[[3572,3572],"valid",[],"NV8"],[[3573,3584],"disallowed"],[[3585,3634],"valid"],[[3635,3635],"mapped",[3661,3634]],[[3636,3642],"valid"],[[3643,3646],"disallowed"],[[3647,3647],"valid",[],"NV8"],[[3648,3662],"valid"],[[3663,3663],"valid",[],"NV8"],[[3664,3673],"valid"],[[3674,3675],"valid",[],"NV8"],[[3676,3712],"disallowed"],[[3713,3714],"valid"],[[3715,3715],"disallowed"],[[3716,3716],"valid"],[[3717,3718],"disallowed"],[[3719,3720],"valid"],[[3721,3721],"disallowed"],[[3722,3722],"valid"],[[3723,3724],"disallowed"],[[3725,3725],"valid"],[[3726,3731],"disallowed"],[[3732,3735],"valid"],[[3736,3736],"disallowed"],[[3737,3743],"valid"],[[3744,3744],"disallowed"],[[3745,3747],"valid"],[[3748,3748],"disallowed"],[[3749,3749],"valid"],[[3750,3750],"disallowed"],[[3751,3751],"valid"],[[3752,3753],"disallowed"],[[3754,3755],"valid"],[[3756,3756],"disallowed"],[[3757,3762],"valid"],[[3763,3763],"mapped",[3789,3762]],[[3764,3769],"valid"],[[3770,3770],"disallowed"],[[3771,3773],"valid"],[[3774,3775],"disallowed"],[[3776,3780],"valid"],[[3781,3781],"disallowed"],[[3782,3782],"valid"],[[3783,3783],"disallowed"],[[3784,3789],"valid"],[[3790,3791],"disallowed"],[[3792,3801],"valid"],[[3802,3803],"disallowed"],[[3804,3804],"mapped",[3755,3737]],[[3805,3805],"mapped",[3755,3745]],[[3806,3807],"valid"],[[3808,3839],"disallowed"],[[3840,3840],"valid"],[[3841,3850],"valid",[],"NV8"],[[3851,3851],"valid"],[[3852,3852],"mapped",[3851]],[[3853,3863],"valid",[],"NV8"],[[3864,3865],"valid"],[[3866,3871],"valid",[],"NV8"],[[3872,3881],"valid"],[[3882,3892],"valid",[],"NV8"],[[3893,3893],"valid"],[[3894,3894],"valid",[],"NV8"],[[3895,3895],"valid"],[[3896,3896],"valid",[],"NV8"],[[3897,3897],"valid"],[[3898,3901],"valid",[],"NV8"],[[3902,3906],"valid"],[[3907,3907],"mapped",[3906,4023]],[[3908,3911],"valid"],[[3912,3912],"disallowed"],[[3913,3916],"valid"],[[3917,3917],"mapped",[3916,4023]],[[3918,3921],"valid"],[[3922,3922],"mapped",[3921,4023]],[[3923,3926],"valid"],[[3927,3927],"mapped",[3926,4023]],[[3928,3931],"valid"],[[3932,3932],"mapped",[3931,4023]],[[3933,3944],"valid"],[[3945,3945],"mapped",[3904,4021]],[[3946,3946],"valid"],[[3947,3948],"valid"],[[3949,3952],"disallowed"],[[3953,3954],"valid"],[[3955,3955],"mapped",[3953,3954]],[[3956,3956],"valid"],[[3957,3957],"mapped",[3953,3956]],[[3958,3958],"mapped",[4018,3968]],[[3959,3959],"mapped",[4018,3953,3968]],[[3960,3960],"mapped",[4019,3968]],[[3961,3961],"mapped",[4019,3953,3968]],[[3962,3968],"valid"],[[3969,3969],"mapped",[3953,3968]],[[3970,3972],"valid"],[[3973,3973],"valid",[],"NV8"],[[3974,3979],"valid"],[[3980,3983],"valid"],[[3984,3986],"valid"],[[3987,3987],"mapped",[3986,4023]],[[3988,3989],"valid"],[[3990,3990],"valid"],[[3991,3991],"valid"],[[3992,3992],"disallowed"],[[3993,3996],"valid"],[[3997,3997],"mapped",[3996,4023]],[[3998,4001],"valid"],[[4002,4002],"mapped",[4001,4023]],[[4003,4006],"valid"],[[4007,4007],"mapped",[4006,4023]],[[4008,4011],"valid"],[[4012,4012],"mapped",[4011,4023]],[[4013,4013],"valid"],[[4014,4016],"valid"],[[4017,4023],"valid"],[[4024,4024],"valid"],[[4025,4025],"mapped",[3984,4021]],[[4026,4028],"valid"],[[4029,4029],"disallowed"],[[4030,4037],"valid",[],"NV8"],[[4038,4038],"valid"],[[4039,4044],"valid",[],"NV8"],[[4045,4045],"disallowed"],[[4046,4046],"valid",[],"NV8"],[[4047,4047],"valid",[],"NV8"],[[4048,4049],"valid",[],"NV8"],[[4050,4052],"valid",[],"NV8"],[[4053,4056],"valid",[],"NV8"],[[4057,4058],"valid",[],"NV8"],[[4059,4095],"disallowed"],[[4096,4129],"valid"],[[4130,4130],"valid"],[[4131,4135],"valid"],[[4136,4136],"valid"],[[4137,4138],"valid"],[[4139,4139],"valid"],[[4140,4146],"valid"],[[4147,4149],"valid"],[[4150,4153],"valid"],[[4154,4159],"valid"],[[4160,4169],"valid"],[[4170,4175],"valid",[],"NV8"],[[4176,4185],"valid"],[[4186,4249],"valid"],[[4250,4253],"valid"],[[4254,4255],"valid",[],"NV8"],[[4256,4293],"disallowed"],[[4294,4294],"disallowed"],[[4295,4295],"mapped",[11559]],[[4296,4300],"disallowed"],[[4301,4301],"mapped",[11565]],[[4302,4303],"disallowed"],[[4304,4342],"valid"],[[4343,4344],"valid"],[[4345,4346],"valid"],[[4347,4347],"valid",[],"NV8"],[[4348,4348],"mapped",[4316]],[[4349,4351],"valid"],[[4352,4441],"valid",[],"NV8"],[[4442,4446],"valid",[],"NV8"],[[4447,4448],"disallowed"],[[4449,4514],"valid",[],"NV8"],[[4515,4519],"valid",[],"NV8"],[[4520,4601],"valid",[],"NV8"],[[4602,4607],"valid",[],"NV8"],[[4608,4614],"valid"],[[4615,4615],"valid"],[[4616,4678],"valid"],[[4679,4679],"valid"],[[4680,4680],"valid"],[[4681,4681],"disallowed"],[[4682,4685],"valid"],[[4686,4687],"disallowed"],[[4688,4694],"valid"],[[4695,4695],"disallowed"],[[4696,4696],"valid"],[[4697,4697],"disallowed"],[[4698,4701],"valid"],[[4702,4703],"disallowed"],[[4704,4742],"valid"],[[4743,4743],"valid"],[[4744,4744],"valid"],[[4745,4745],"disallowed"],[[4746,4749],"valid"],[[4750,4751],"disallowed"],[[4752,4782],"valid"],[[4783,4783],"valid"],[[4784,4784],"valid"],[[4785,4785],"disallowed"],[[4786,4789],"valid"],[[4790,4791],"disallowed"],[[4792,4798],"valid"],[[4799,4799],"disallowed"],[[4800,4800],"valid"],[[4801,4801],"disallowed"],[[4802,4805],"valid"],[[4806,4807],"disallowed"],[[4808,4814],"valid"],[[4815,4815],"valid"],[[4816,4822],"valid"],[[4823,4823],"disallowed"],[[4824,4846],"valid"],[[4847,4847],"valid"],[[4848,4878],"valid"],[[4879,4879],"valid"],[[4880,4880],"valid"],[[4881,4881],"disallowed"],[[4882,4885],"valid"],[[4886,4887],"disallowed"],[[4888,4894],"valid"],[[4895,4895],"valid"],[[4896,4934],"valid"],[[4935,4935],"valid"],[[4936,4954],"valid"],[[4955,4956],"disallowed"],[[4957,4958],"valid"],[[4959,4959],"valid"],[[4960,4960],"valid",[],"NV8"],[[4961,4988],"valid",[],"NV8"],[[4989,4991],"disallowed"],[[4992,5007],"valid"],[[5008,5017],"valid",[],"NV8"],[[5018,5023],"disallowed"],[[5024,5108],"valid"],[[5109,5109],"valid"],[[5110,5111],"disallowed"],[[5112,5112],"mapped",[5104]],[[5113,5113],"mapped",[5105]],[[5114,5114],"mapped",[5106]],[[5115,5115],"mapped",[5107]],[[5116,5116],"mapped",[5108]],[[5117,5117],"mapped",[5109]],[[5118,5119],"disallowed"],[[5120,5120],"valid",[],"NV8"],[[5121,5740],"valid"],[[5741,5742],"valid",[],"NV8"],[[5743,5750],"valid"],[[5751,5759],"valid"],[[5760,5760],"disallowed"],[[5761,5786],"valid"],[[5787,5788],"valid",[],"NV8"],[[5789,5791],"disallowed"],[[5792,5866],"valid"],[[5867,5872],"valid",[],"NV8"],[[5873,5880],"valid"],[[5881,5887],"disallowed"],[[5888,5900],"valid"],[[5901,5901],"disallowed"],[[5902,5908],"valid"],[[5909,5919],"disallowed"],[[5920,5940],"valid"],[[5941,5942],"valid",[],"NV8"],[[5943,5951],"disallowed"],[[5952,5971],"valid"],[[5972,5983],"disallowed"],[[5984,5996],"valid"],[[5997,5997],"disallowed"],[[5998,6000],"valid"],[[6001,6001],"disallowed"],[[6002,6003],"valid"],[[6004,6015],"disallowed"],[[6016,6067],"valid"],[[6068,6069],"disallowed"],[[6070,6099],"valid"],[[6100,6102],"valid",[],"NV8"],[[6103,6103],"valid"],[[6104,6107],"valid",[],"NV8"],[[6108,6108],"valid"],[[6109,6109],"valid"],[[6110,6111],"disallowed"],[[6112,6121],"valid"],[[6122,6127],"disallowed"],[[6128,6137],"valid",[],"NV8"],[[6138,6143],"disallowed"],[[6144,6149],"valid",[],"NV8"],[[6150,6150],"disallowed"],[[6151,6154],"valid",[],"NV8"],[[6155,6157],"ignored"],[[6158,6158],"disallowed"],[[6159,6159],"disallowed"],[[6160,6169],"valid"],[[6170,6175],"disallowed"],[[6176,6263],"valid"],[[6264,6271],"disallowed"],[[6272,6313],"valid"],[[6314,6314],"valid"],[[6315,6319],"disallowed"],[[6320,6389],"valid"],[[6390,6399],"disallowed"],[[6400,6428],"valid"],[[6429,6430],"valid"],[[6431,6431],"disallowed"],[[6432,6443],"valid"],[[6444,6447],"disallowed"],[[6448,6459],"valid"],[[6460,6463],"disallowed"],[[6464,6464],"valid",[],"NV8"],[[6465,6467],"disallowed"],[[6468,6469],"valid",[],"NV8"],[[6470,6509],"valid"],[[6510,6511],"disallowed"],[[6512,6516],"valid"],[[6517,6527],"disallowed"],[[6528,6569],"valid"],[[6570,6571],"valid"],[[6572,6575],"disallowed"],[[6576,6601],"valid"],[[6602,6607],"disallowed"],[[6608,6617],"valid"],[[6618,6618],"valid",[],"XV8"],[[6619,6621],"disallowed"],[[6622,6623],"valid",[],"NV8"],[[6624,6655],"valid",[],"NV8"],[[6656,6683],"valid"],[[6684,6685],"disallowed"],[[6686,6687],"valid",[],"NV8"],[[6688,6750],"valid"],[[6751,6751],"disallowed"],[[6752,6780],"valid"],[[6781,6782],"disallowed"],[[6783,6793],"valid"],[[6794,6799],"disallowed"],[[6800,6809],"valid"],[[6810,6815],"disallowed"],[[6816,6822],"valid",[],"NV8"],[[6823,6823],"valid"],[[6824,6829],"valid",[],"NV8"],[[6830,6831],"disallowed"],[[6832,6845],"valid"],[[6846,6846],"valid",[],"NV8"],[[6847,6911],"disallowed"],[[6912,6987],"valid"],[[6988,6991],"disallowed"],[[6992,7001],"valid"],[[7002,7018],"valid",[],"NV8"],[[7019,7027],"valid"],[[7028,7036],"valid",[],"NV8"],[[7037,7039],"disallowed"],[[7040,7082],"valid"],[[7083,7085],"valid"],[[7086,7097],"valid"],[[7098,7103],"valid"],[[7104,7155],"valid"],[[7156,7163],"disallowed"],[[7164,7167],"valid",[],"NV8"],[[7168,7223],"valid"],[[7224,7226],"disallowed"],[[7227,7231],"valid",[],"NV8"],[[7232,7241],"valid"],[[7242,7244],"disallowed"],[[7245,7293],"valid"],[[7294,7295],"valid",[],"NV8"],[[7296,7359],"disallowed"],[[7360,7367],"valid",[],"NV8"],[[7368,7375],"disallowed"],[[7376,7378],"valid"],[[7379,7379],"valid",[],"NV8"],[[7380,7410],"valid"],[[7411,7414],"valid"],[[7415,7415],"disallowed"],[[7416,7417],"valid"],[[7418,7423],"disallowed"],[[7424,7467],"valid"],[[7468,7468],"mapped",[97]],[[7469,7469],"mapped",[230]],[[7470,7470],"mapped",[98]],[[7471,7471],"valid"],[[7472,7472],"mapped",[100]],[[7473,7473],"mapped",[101]],[[7474,7474],"mapped",[477]],[[7475,7475],"mapped",[103]],[[7476,7476],"mapped",[104]],[[7477,7477],"mapped",[105]],[[7478,7478],"mapped",[106]],[[7479,7479],"mapped",[107]],[[7480,7480],"mapped",[108]],[[7481,7481],"mapped",[109]],[[7482,7482],"mapped",[110]],[[7483,7483],"valid"],[[7484,7484],"mapped",[111]],[[7485,7485],"mapped",[547]],[[7486,7486],"mapped",[112]],[[7487,7487],"mapped",[114]],[[7488,7488],"mapped",[116]],[[7489,7489],"mapped",[117]],[[7490,7490],"mapped",[119]],[[7491,7491],"mapped",[97]],[[7492,7492],"mapped",[592]],[[7493,7493],"mapped",[593]],[[7494,7494],"mapped",[7426]],[[7495,7495],"mapped",[98]],[[7496,7496],"mapped",[100]],[[7497,7497],"mapped",[101]],[[7498,7498],"mapped",[601]],[[7499,7499],"mapped",[603]],[[7500,7500],"mapped",[604]],[[7501,7501],"mapped",[103]],[[7502,7502],"valid"],[[7503,7503],"mapped",[107]],[[7504,7504],"mapped",[109]],[[7505,7505],"mapped",[331]],[[7506,7506],"mapped",[111]],[[7507,7507],"mapped",[596]],[[7508,7508],"mapped",[7446]],[[7509,7509],"mapped",[7447]],[[7510,7510],"mapped",[112]],[[7511,7511],"mapped",[116]],[[7512,7512],"mapped",[117]],[[7513,7513],"mapped",[7453]],[[7514,7514],"mapped",[623]],[[7515,7515],"mapped",[118]],[[7516,7516],"mapped",[7461]],[[7517,7517],"mapped",[946]],[[7518,7518],"mapped",[947]],[[7519,7519],"mapped",[948]],[[7520,7520],"mapped",[966]],[[7521,7521],"mapped",[967]],[[7522,7522],"mapped",[105]],[[7523,7523],"mapped",[114]],[[7524,7524],"mapped",[117]],[[7525,7525],"mapped",[118]],[[7526,7526],"mapped",[946]],[[7527,7527],"mapped",[947]],[[7528,7528],"mapped",[961]],[[7529,7529],"mapped",[966]],[[7530,7530],"mapped",[967]],[[7531,7531],"valid"],[[7532,7543],"valid"],[[7544,7544],"mapped",[1085]],[[7545,7578],"valid"],[[7579,7579],"mapped",[594]],[[7580,7580],"mapped",[99]],[[7581,7581],"mapped",[597]],[[7582,7582],"mapped",[240]],[[7583,7583],"mapped",[604]],[[7584,7584],"mapped",[102]],[[7585,7585],"mapped",[607]],[[7586,7586],"mapped",[609]],[[7587,7587],"mapped",[613]],[[7588,7588],"mapped",[616]],[[7589,7589],"mapped",[617]],[[7590,7590],"mapped",[618]],[[7591,7591],"mapped",[7547]],[[7592,7592],"mapped",[669]],[[7593,7593],"mapped",[621]],[[7594,7594],"mapped",[7557]],[[7595,7595],"mapped",[671]],[[7596,7596],"mapped",[625]],[[7597,7597],"mapped",[624]],[[7598,7598],"mapped",[626]],[[7599,7599],"mapped",[627]],[[7600,7600],"mapped",[628]],[[7601,7601],"mapped",[629]],[[7602,7602],"mapped",[632]],[[7603,7603],"mapped",[642]],[[7604,7604],"mapped",[643]],[[7605,7605],"mapped",[427]],[[7606,7606],"mapped",[649]],[[7607,7607],"mapped",[650]],[[7608,7608],"mapped",[7452]],[[7609,7609],"mapped",[651]],[[7610,7610],"mapped",[652]],[[7611,7611],"mapped",[122]],[[7612,7612],"mapped",[656]],[[7613,7613],"mapped",[657]],[[7614,7614],"mapped",[658]],[[7615,7615],"mapped",[952]],[[7616,7619],"valid"],[[7620,7626],"valid"],[[7627,7654],"valid"],[[7655,7669],"valid"],[[7670,7675],"disallowed"],[[7676,7676],"valid"],[[7677,7677],"valid"],[[7678,7679],"valid"],[[7680,7680],"mapped",[7681]],[[7681,7681],"valid"],[[7682,7682],"mapped",[7683]],[[7683,7683],"valid"],[[7684,7684],"mapped",[7685]],[[7685,7685],"valid"],[[7686,7686],"mapped",[7687]],[[7687,7687],"valid"],[[7688,7688],"mapped",[7689]],[[7689,7689],"valid"],[[7690,7690],"mapped",[7691]],[[7691,7691],"valid"],[[7692,7692],"mapped",[7693]],[[7693,7693],"valid"],[[7694,7694],"mapped",[7695]],[[7695,7695],"valid"],[[7696,7696],"mapped",[7697]],[[7697,7697],"valid"],[[7698,7698],"mapped",[7699]],[[7699,7699],"valid"],[[7700,7700],"mapped",[7701]],[[7701,7701],"valid"],[[7702,7702],"mapped",[7703]],[[7703,7703],"valid"],[[7704,7704],"mapped",[7705]],[[7705,7705],"valid"],[[7706,7706],"mapped",[7707]],[[7707,7707],"valid"],[[7708,7708],"mapped",[7709]],[[7709,7709],"valid"],[[7710,7710],"mapped",[7711]],[[7711,7711],"valid"],[[7712,7712],"mapped",[7713]],[[7713,7713],"valid"],[[7714,7714],"mapped",[7715]],[[7715,7715],"valid"],[[7716,7716],"mapped",[7717]],[[7717,7717],"valid"],[[7718,7718],"mapped",[7719]],[[7719,7719],"valid"],[[7720,7720],"mapped",[7721]],[[7721,7721],"valid"],[[7722,7722],"mapped",[7723]],[[7723,7723],"valid"],[[7724,7724],"mapped",[7725]],[[7725,7725],"valid"],[[7726,7726],"mapped",[7727]],[[7727,7727],"valid"],[[7728,7728],"mapped",[7729]],[[7729,7729],"valid"],[[7730,7730],"mapped",[7731]],[[7731,7731],"valid"],[[7732,7732],"mapped",[7733]],[[7733,7733],"valid"],[[7734,7734],"mapped",[7735]],[[7735,7735],"valid"],[[7736,7736],"mapped",[7737]],[[7737,7737],"valid"],[[7738,7738],"mapped",[7739]],[[7739,7739],"valid"],[[7740,7740],"mapped",[7741]],[[7741,7741],"valid"],[[7742,7742],"mapped",[7743]],[[7743,7743],"valid"],[[7744,7744],"mapped",[7745]],[[7745,7745],"valid"],[[7746,7746],"mapped",[7747]],[[7747,7747],"valid"],[[7748,7748],"mapped",[7749]],[[7749,7749],"valid"],[[7750,7750],"mapped",[7751]],[[7751,7751],"valid"],[[7752,7752],"mapped",[7753]],[[7753,7753],"valid"],[[7754,7754],"mapped",[7755]],[[7755,7755],"valid"],[[7756,7756],"mapped",[7757]],[[7757,7757],"valid"],[[7758,7758],"mapped",[7759]],[[7759,7759],"valid"],[[7760,7760],"mapped",[7761]],[[7761,7761],"valid"],[[7762,7762],"mapped",[7763]],[[7763,7763],"valid"],[[7764,7764],"mapped",[7765]],[[7765,7765],"valid"],[[7766,7766],"mapped",[7767]],[[7767,7767],"valid"],[[7768,7768],"mapped",[7769]],[[7769,7769],"valid"],[[7770,7770],"mapped",[7771]],[[7771,7771],"valid"],[[7772,7772],"mapped",[7773]],[[7773,7773],"valid"],[[7774,7774],"mapped",[7775]],[[7775,7775],"valid"],[[7776,7776],"mapped",[7777]],[[7777,7777],"valid"],[[7778,7778],"mapped",[7779]],[[7779,7779],"valid"],[[7780,7780],"mapped",[7781]],[[7781,7781],"valid"],[[7782,7782],"mapped",[7783]],[[7783,7783],"valid"],[[7784,7784],"mapped",[7785]],[[7785,7785],"valid"],[[7786,7786],"mapped",[7787]],[[7787,7787],"valid"],[[7788,7788],"mapped",[7789]],[[7789,7789],"valid"],[[7790,7790],"mapped",[7791]],[[7791,7791],"valid"],[[7792,7792],"mapped",[7793]],[[7793,7793],"valid"],[[7794,7794],"mapped",[7795]],[[7795,7795],"valid"],[[7796,7796],"mapped",[7797]],[[7797,7797],"valid"],[[7798,7798],"mapped",[7799]],[[7799,7799],"valid"],[[7800,7800],"mapped",[7801]],[[7801,7801],"valid"],[[7802,7802],"mapped",[7803]],[[7803,7803],"valid"],[[7804,7804],"mapped",[7805]],[[7805,7805],"valid"],[[7806,7806],"mapped",[7807]],[[7807,7807],"valid"],[[7808,7808],"mapped",[7809]],[[7809,7809],"valid"],[[7810,7810],"mapped",[7811]],[[7811,7811],"valid"],[[7812,7812],"mapped",[7813]],[[7813,7813],"valid"],[[7814,7814],"mapped",[7815]],[[7815,7815],"valid"],[[7816,7816],"mapped",[7817]],[[7817,7817],"valid"],[[7818,7818],"mapped",[7819]],[[7819,7819],"valid"],[[7820,7820],"mapped",[7821]],[[7821,7821],"valid"],[[7822,7822],"mapped",[7823]],[[7823,7823],"valid"],[[7824,7824],"mapped",[7825]],[[7825,7825],"valid"],[[7826,7826],"mapped",[7827]],[[7827,7827],"valid"],[[7828,7828],"mapped",[7829]],[[7829,7833],"valid"],[[7834,7834],"mapped",[97,702]],[[7835,7835],"mapped",[7777]],[[7836,7837],"valid"],[[7838,7838],"mapped",[115,115]],[[7839,7839],"valid"],[[7840,7840],"mapped",[7841]],[[7841,7841],"valid"],[[7842,7842],"mapped",[7843]],[[7843,7843],"valid"],[[7844,7844],"mapped",[7845]],[[7845,7845],"valid"],[[7846,7846],"mapped",[7847]],[[7847,7847],"valid"],[[7848,7848],"mapped",[7849]],[[7849,7849],"valid"],[[7850,7850],"mapped",[7851]],[[7851,7851],"valid"],[[7852,7852],"mapped",[7853]],[[7853,7853],"valid"],[[7854,7854],"mapped",[7855]],[[7855,7855],"valid"],[[7856,7856],"mapped",[7857]],[[7857,7857],"valid"],[[7858,7858],"mapped",[7859]],[[7859,7859],"valid"],[[7860,7860],"mapped",[7861]],[[7861,7861],"valid"],[[7862,7862],"mapped",[7863]],[[7863,7863],"valid"],[[7864,7864],"mapped",[7865]],[[7865,7865],"valid"],[[7866,7866],"mapped",[7867]],[[7867,7867],"valid"],[[7868,7868],"mapped",[7869]],[[7869,7869],"valid"],[[7870,7870],"mapped",[7871]],[[7871,7871],"valid"],[[7872,7872],"mapped",[7873]],[[7873,7873],"valid"],[[7874,7874],"mapped",[7875]],[[7875,7875],"valid"],[[7876,7876],"mapped",[7877]],[[7877,7877],"valid"],[[7878,7878],"mapped",[7879]],[[7879,7879],"valid"],[[7880,7880],"mapped",[7881]],[[7881,7881],"valid"],[[7882,7882],"mapped",[7883]],[[7883,7883],"valid"],[[7884,7884],"mapped",[7885]],[[7885,7885],"valid"],[[7886,7886],"mapped",[7887]],[[7887,7887],"valid"],[[7888,7888],"mapped",[7889]],[[7889,7889],"valid"],[[7890,7890],"mapped",[7891]],[[7891,7891],"valid"],[[7892,7892],"mapped",[7893]],[[7893,7893],"valid"],[[7894,7894],"mapped",[7895]],[[7895,7895],"valid"],[[7896,7896],"mapped",[7897]],[[7897,7897],"valid"],[[7898,7898],"mapped",[7899]],[[7899,7899],"valid"],[[7900,7900],"mapped",[7901]],[[7901,7901],"valid"],[[7902,7902],"mapped",[7903]],[[7903,7903],"valid"],[[7904,7904],"mapped",[7905]],[[7905,7905],"valid"],[[7906,7906],"mapped",[7907]],[[7907,7907],"valid"],[[7908,7908],"mapped",[7909]],[[7909,7909],"valid"],[[7910,7910],"mapped",[7911]],[[7911,7911],"valid"],[[7912,7912],"mapped",[7913]],[[7913,7913],"valid"],[[7914,7914],"mapped",[7915]],[[7915,7915],"valid"],[[7916,7916],"mapped",[7917]],[[7917,7917],"valid"],[[7918,7918],"mapped",[7919]],[[7919,7919],"valid"],[[7920,7920],"mapped",[7921]],[[7921,7921],"valid"],[[7922,7922],"mapped",[7923]],[[7923,7923],"valid"],[[7924,7924],"mapped",[7925]],[[7925,7925],"valid"],[[7926,7926],"mapped",[7927]],[[7927,7927],"valid"],[[7928,7928],"mapped",[7929]],[[7929,7929],"valid"],[[7930,7930],"mapped",[7931]],[[7931,7931],"valid"],[[7932,7932],"mapped",[7933]],[[7933,7933],"valid"],[[7934,7934],"mapped",[7935]],[[7935,7935],"valid"],[[7936,7943],"valid"],[[7944,7944],"mapped",[7936]],[[7945,7945],"mapped",[7937]],[[7946,7946],"mapped",[7938]],[[7947,7947],"mapped",[7939]],[[7948,7948],"mapped",[7940]],[[7949,7949],"mapped",[7941]],[[7950,7950],"mapped",[7942]],[[7951,7951],"mapped",[7943]],[[7952,7957],"valid"],[[7958,7959],"disallowed"],[[7960,7960],"mapped",[7952]],[[7961,7961],"mapped",[7953]],[[7962,7962],"mapped",[7954]],[[7963,7963],"mapped",[7955]],[[7964,7964],"mapped",[7956]],[[7965,7965],"mapped",[7957]],[[7966,7967],"disallowed"],[[7968,7975],"valid"],[[7976,7976],"mapped",[7968]],[[7977,7977],"mapped",[7969]],[[7978,7978],"mapped",[7970]],[[7979,7979],"mapped",[7971]],[[7980,7980],"mapped",[7972]],[[7981,7981],"mapped",[7973]],[[7982,7982],"mapped",[7974]],[[7983,7983],"mapped",[7975]],[[7984,7991],"valid"],[[7992,7992],"mapped",[7984]],[[7993,7993],"mapped",[7985]],[[7994,7994],"mapped",[7986]],[[7995,7995],"mapped",[7987]],[[7996,7996],"mapped",[7988]],[[7997,7997],"mapped",[7989]],[[7998,7998],"mapped",[7990]],[[7999,7999],"mapped",[7991]],[[8000,8005],"valid"],[[8006,8007],"disallowed"],[[8008,8008],"mapped",[8000]],[[8009,8009],"mapped",[8001]],[[8010,8010],"mapped",[8002]],[[8011,8011],"mapped",[8003]],[[8012,8012],"mapped",[8004]],[[8013,8013],"mapped",[8005]],[[8014,8015],"disallowed"],[[8016,8023],"valid"],[[8024,8024],"disallowed"],[[8025,8025],"mapped",[8017]],[[8026,8026],"disallowed"],[[8027,8027],"mapped",[8019]],[[8028,8028],"disallowed"],[[8029,8029],"mapped",[8021]],[[8030,8030],"disallowed"],[[8031,8031],"mapped",[8023]],[[8032,8039],"valid"],[[8040,8040],"mapped",[8032]],[[8041,8041],"mapped",[8033]],[[8042,8042],"mapped",[8034]],[[8043,8043],"mapped",[8035]],[[8044,8044],"mapped",[8036]],[[8045,8045],"mapped",[8037]],[[8046,8046],"mapped",[8038]],[[8047,8047],"mapped",[8039]],[[8048,8048],"valid"],[[8049,8049],"mapped",[940]],[[8050,8050],"valid"],[[8051,8051],"mapped",[941]],[[8052,8052],"valid"],[[8053,8053],"mapped",[942]],[[8054,8054],"valid"],[[8055,8055],"mapped",[943]],[[8056,8056],"valid"],[[8057,8057],"mapped",[972]],[[8058,8058],"valid"],[[8059,8059],"mapped",[973]],[[8060,8060],"valid"],[[8061,8061],"mapped",[974]],[[8062,8063],"disallowed"],[[8064,8064],"mapped",[7936,953]],[[8065,8065],"mapped",[7937,953]],[[8066,8066],"mapped",[7938,953]],[[8067,8067],"mapped",[7939,953]],[[8068,8068],"mapped",[7940,953]],[[8069,8069],"mapped",[7941,953]],[[8070,8070],"mapped",[7942,953]],[[8071,8071],"mapped",[7943,953]],[[8072,8072],"mapped",[7936,953]],[[8073,8073],"mapped",[7937,953]],[[8074,8074],"mapped",[7938,953]],[[8075,8075],"mapped",[7939,953]],[[8076,8076],"mapped",[7940,953]],[[8077,8077],"mapped",[7941,953]],[[8078,8078],"mapped",[7942,953]],[[8079,8079],"mapped",[7943,953]],[[8080,8080],"mapped",[7968,953]],[[8081,8081],"mapped",[7969,953]],[[8082,8082],"mapped",[7970,953]],[[8083,8083],"mapped",[7971,953]],[[8084,8084],"mapped",[7972,953]],[[8085,8085],"mapped",[7973,953]],[[8086,8086],"mapped",[7974,953]],[[8087,8087],"mapped",[7975,953]],[[8088,8088],"mapped",[7968,953]],[[8089,8089],"mapped",[7969,953]],[[8090,8090],"mapped",[7970,953]],[[8091,8091],"mapped",[7971,953]],[[8092,8092],"mapped",[7972,953]],[[8093,8093],"mapped",[7973,953]],[[8094,8094],"mapped",[7974,953]],[[8095,8095],"mapped",[7975,953]],[[8096,8096],"mapped",[8032,953]],[[8097,8097],"mapped",[8033,953]],[[8098,8098],"mapped",[8034,953]],[[8099,8099],"mapped",[8035,953]],[[8100,8100],"mapped",[8036,953]],[[8101,8101],"mapped",[8037,953]],[[8102,8102],"mapped",[8038,953]],[[8103,8103],"mapped",[8039,953]],[[8104,8104],"mapped",[8032,953]],[[8105,8105],"mapped",[8033,953]],[[8106,8106],"mapped",[8034,953]],[[8107,8107],"mapped",[8035,953]],[[8108,8108],"mapped",[8036,953]],[[8109,8109],"mapped",[8037,953]],[[8110,8110],"mapped",[8038,953]],[[8111,8111],"mapped",[8039,953]],[[8112,8113],"valid"],[[8114,8114],"mapped",[8048,953]],[[8115,8115],"mapped",[945,953]],[[8116,8116],"mapped",[940,953]],[[8117,8117],"disallowed"],[[8118,8118],"valid"],[[8119,8119],"mapped",[8118,953]],[[8120,8120],"mapped",[8112]],[[8121,8121],"mapped",[8113]],[[8122,8122],"mapped",[8048]],[[8123,8123],"mapped",[940]],[[8124,8124],"mapped",[945,953]],[[8125,8125],"disallowed_STD3_mapped",[32,787]],[[8126,8126],"mapped",[953]],[[8127,8127],"disallowed_STD3_mapped",[32,787]],[[8128,8128],"disallowed_STD3_mapped",[32,834]],[[8129,8129],"disallowed_STD3_mapped",[32,776,834]],[[8130,8130],"mapped",[8052,953]],[[8131,8131],"mapped",[951,953]],[[8132,8132],"mapped",[942,953]],[[8133,8133],"disallowed"],[[8134,8134],"valid"],[[8135,8135],"mapped",[8134,953]],[[8136,8136],"mapped",[8050]],[[8137,8137],"mapped",[941]],[[8138,8138],"mapped",[8052]],[[8139,8139],"mapped",[942]],[[8140,8140],"mapped",[951,953]],[[8141,8141],"disallowed_STD3_mapped",[32,787,768]],[[8142,8142],"disallowed_STD3_mapped",[32,787,769]],[[8143,8143],"disallowed_STD3_mapped",[32,787,834]],[[8144,8146],"valid"],[[8147,8147],"mapped",[912]],[[8148,8149],"disallowed"],[[8150,8151],"valid"],[[8152,8152],"mapped",[8144]],[[8153,8153],"mapped",[8145]],[[8154,8154],"mapped",[8054]],[[8155,8155],"mapped",[943]],[[8156,8156],"disallowed"],[[8157,8157],"disallowed_STD3_mapped",[32,788,768]],[[8158,8158],"disallowed_STD3_mapped",[32,788,769]],[[8159,8159],"disallowed_STD3_mapped",[32,788,834]],[[8160,8162],"valid"],[[8163,8163],"mapped",[944]],[[8164,8167],"valid"],[[8168,8168],"mapped",[8160]],[[8169,8169],"mapped",[8161]],[[8170,8170],"mapped",[8058]],[[8171,8171],"mapped",[973]],[[8172,8172],"mapped",[8165]],[[8173,8173],"disallowed_STD3_mapped",[32,776,768]],[[8174,8174],"disallowed_STD3_mapped",[32,776,769]],[[8175,8175],"disallowed_STD3_mapped",[96]],[[8176,8177],"disallowed"],[[8178,8178],"mapped",[8060,953]],[[8179,8179],"mapped",[969,953]],[[8180,8180],"mapped",[974,953]],[[8181,8181],"disallowed"],[[8182,8182],"valid"],[[8183,8183],"mapped",[8182,953]],[[8184,8184],"mapped",[8056]],[[8185,8185],"mapped",[972]],[[8186,8186],"mapped",[8060]],[[8187,8187],"mapped",[974]],[[8188,8188],"mapped",[969,953]],[[8189,8189],"disallowed_STD3_mapped",[32,769]],[[8190,8190],"disallowed_STD3_mapped",[32,788]],[[8191,8191],"disallowed"],[[8192,8202],"disallowed_STD3_mapped",[32]],[[8203,8203],"ignored"],[[8204,8205],"deviation",[]],[[8206,8207],"disallowed"],[[8208,8208],"valid",[],"NV8"],[[8209,8209],"mapped",[8208]],[[8210,8214],"valid",[],"NV8"],[[8215,8215],"disallowed_STD3_mapped",[32,819]],[[8216,8227],"valid",[],"NV8"],[[8228,8230],"disallowed"],[[8231,8231],"valid",[],"NV8"],[[8232,8238],"disallowed"],[[8239,8239],"disallowed_STD3_mapped",[32]],[[8240,8242],"valid",[],"NV8"],[[8243,8243],"mapped",[8242,8242]],[[8244,8244],"mapped",[8242,8242,8242]],[[8245,8245],"valid",[],"NV8"],[[8246,8246],"mapped",[8245,8245]],[[8247,8247],"mapped",[8245,8245,8245]],[[8248,8251],"valid",[],"NV8"],[[8252,8252],"disallowed_STD3_mapped",[33,33]],[[8253,8253],"valid",[],"NV8"],[[8254,8254],"disallowed_STD3_mapped",[32,773]],[[8255,8262],"valid",[],"NV8"],[[8263,8263],"disallowed_STD3_mapped",[63,63]],[[8264,8264],"disallowed_STD3_mapped",[63,33]],[[8265,8265],"disallowed_STD3_mapped",[33,63]],[[8266,8269],"valid",[],"NV8"],[[8270,8274],"valid",[],"NV8"],[[8275,8276],"valid",[],"NV8"],[[8277,8278],"valid",[],"NV8"],[[8279,8279],"mapped",[8242,8242,8242,8242]],[[8280,8286],"valid",[],"NV8"],[[8287,8287],"disallowed_STD3_mapped",[32]],[[8288,8288],"ignored"],[[8289,8291],"disallowed"],[[8292,8292],"ignored"],[[8293,8293],"disallowed"],[[8294,8297],"disallowed"],[[8298,8303],"disallowed"],[[8304,8304],"mapped",[48]],[[8305,8305],"mapped",[105]],[[8306,8307],"disallowed"],[[8308,8308],"mapped",[52]],[[8309,8309],"mapped",[53]],[[8310,8310],"mapped",[54]],[[8311,8311],"mapped",[55]],[[8312,8312],"mapped",[56]],[[8313,8313],"mapped",[57]],[[8314,8314],"disallowed_STD3_mapped",[43]],[[8315,8315],"mapped",[8722]],[[8316,8316],"disallowed_STD3_mapped",[61]],[[8317,8317],"disallowed_STD3_mapped",[40]],[[8318,8318],"disallowed_STD3_mapped",[41]],[[8319,8319],"mapped",[110]],[[8320,8320],"mapped",[48]],[[8321,8321],"mapped",[49]],[[8322,8322],"mapped",[50]],[[8323,8323],"mapped",[51]],[[8324,8324],"mapped",[52]],[[8325,8325],"mapped",[53]],[[8326,8326],"mapped",[54]],[[8327,8327],"mapped",[55]],[[8328,8328],"mapped",[56]],[[8329,8329],"mapped",[57]],[[8330,8330],"disallowed_STD3_mapped",[43]],[[8331,8331],"mapped",[8722]],[[8332,8332],"disallowed_STD3_mapped",[61]],[[8333,8333],"disallowed_STD3_mapped",[40]],[[8334,8334],"disallowed_STD3_mapped",[41]],[[8335,8335],"disallowed"],[[8336,8336],"mapped",[97]],[[8337,8337],"mapped",[101]],[[8338,8338],"mapped",[111]],[[8339,8339],"mapped",[120]],[[8340,8340],"mapped",[601]],[[8341,8341],"mapped",[104]],[[8342,8342],"mapped",[107]],[[8343,8343],"mapped",[108]],[[8344,8344],"mapped",[109]],[[8345,8345],"mapped",[110]],[[8346,8346],"mapped",[112]],[[8347,8347],"mapped",[115]],[[8348,8348],"mapped",[116]],[[8349,8351],"disallowed"],[[8352,8359],"valid",[],"NV8"],[[8360,8360],"mapped",[114,115]],[[8361,8362],"valid",[],"NV8"],[[8363,8363],"valid",[],"NV8"],[[8364,8364],"valid",[],"NV8"],[[8365,8367],"valid",[],"NV8"],[[8368,8369],"valid",[],"NV8"],[[8370,8373],"valid",[],"NV8"],[[8374,8376],"valid",[],"NV8"],[[8377,8377],"valid",[],"NV8"],[[8378,8378],"valid",[],"NV8"],[[8379,8381],"valid",[],"NV8"],[[8382,8382],"valid",[],"NV8"],[[8383,8399],"disallowed"],[[8400,8417],"valid",[],"NV8"],[[8418,8419],"valid",[],"NV8"],[[8420,8426],"valid",[],"NV8"],[[8427,8427],"valid",[],"NV8"],[[8428,8431],"valid",[],"NV8"],[[8432,8432],"valid",[],"NV8"],[[8433,8447],"disallowed"],[[8448,8448],"disallowed_STD3_mapped",[97,47,99]],[[8449,8449],"disallowed_STD3_mapped",[97,47,115]],[[8450,8450],"mapped",[99]],[[8451,8451],"mapped",[176,99]],[[8452,8452],"valid",[],"NV8"],[[8453,8453],"disallowed_STD3_mapped",[99,47,111]],[[8454,8454],"disallowed_STD3_mapped",[99,47,117]],[[8455,8455],"mapped",[603]],[[8456,8456],"valid",[],"NV8"],[[8457,8457],"mapped",[176,102]],[[8458,8458],"mapped",[103]],[[8459,8462],"mapped",[104]],[[8463,8463],"mapped",[295]],[[8464,8465],"mapped",[105]],[[8466,8467],"mapped",[108]],[[8468,8468],"valid",[],"NV8"],[[8469,8469],"mapped",[110]],[[8470,8470],"mapped",[110,111]],[[8471,8472],"valid",[],"NV8"],[[8473,8473],"mapped",[112]],[[8474,8474],"mapped",[113]],[[8475,8477],"mapped",[114]],[[8478,8479],"valid",[],"NV8"],[[8480,8480],"mapped",[115,109]],[[8481,8481],"mapped",[116,101,108]],[[8482,8482],"mapped",[116,109]],[[8483,8483],"valid",[],"NV8"],[[8484,8484],"mapped",[122]],[[8485,8485],"valid",[],"NV8"],[[8486,8486],"mapped",[969]],[[8487,8487],"valid",[],"NV8"],[[8488,8488],"mapped",[122]],[[8489,8489],"valid",[],"NV8"],[[8490,8490],"mapped",[107]],[[8491,8491],"mapped",[229]],[[8492,8492],"mapped",[98]],[[8493,8493],"mapped",[99]],[[8494,8494],"valid",[],"NV8"],[[8495,8496],"mapped",[101]],[[8497,8497],"mapped",[102]],[[8498,8498],"disallowed"],[[8499,8499],"mapped",[109]],[[8500,8500],"mapped",[111]],[[8501,8501],"mapped",[1488]],[[8502,8502],"mapped",[1489]],[[8503,8503],"mapped",[1490]],[[8504,8504],"mapped",[1491]],[[8505,8505],"mapped",[105]],[[8506,8506],"valid",[],"NV8"],[[8507,8507],"mapped",[102,97,120]],[[8508,8508],"mapped",[960]],[[8509,8510],"mapped",[947]],[[8511,8511],"mapped",[960]],[[8512,8512],"mapped",[8721]],[[8513,8516],"valid",[],"NV8"],[[8517,8518],"mapped",[100]],[[8519,8519],"mapped",[101]],[[8520,8520],"mapped",[105]],[[8521,8521],"mapped",[106]],[[8522,8523],"valid",[],"NV8"],[[8524,8524],"valid",[],"NV8"],[[8525,8525],"valid",[],"NV8"],[[8526,8526],"valid"],[[8527,8527],"valid",[],"NV8"],[[8528,8528],"mapped",[49,8260,55]],[[8529,8529],"mapped",[49,8260,57]],[[8530,8530],"mapped",[49,8260,49,48]],[[8531,8531],"mapped",[49,8260,51]],[[8532,8532],"mapped",[50,8260,51]],[[8533,8533],"mapped",[49,8260,53]],[[8534,8534],"mapped",[50,8260,53]],[[8535,8535],"mapped",[51,8260,53]],[[8536,8536],"mapped",[52,8260,53]],[[8537,8537],"mapped",[49,8260,54]],[[8538,8538],"mapped",[53,8260,54]],[[8539,8539],"mapped",[49,8260,56]],[[8540,8540],"mapped",[51,8260,56]],[[8541,8541],"mapped",[53,8260,56]],[[8542,8542],"mapped",[55,8260,56]],[[8543,8543],"mapped",[49,8260]],[[8544,8544],"mapped",[105]],[[8545,8545],"mapped",[105,105]],[[8546,8546],"mapped",[105,105,105]],[[8547,8547],"mapped",[105,118]],[[8548,8548],"mapped",[118]],[[8549,8549],"mapped",[118,105]],[[8550,8550],"mapped",[118,105,105]],[[8551,8551],"mapped",[118,105,105,105]],[[8552,8552],"mapped",[105,120]],[[8553,8553],"mapped",[120]],[[8554,8554],"mapped",[120,105]],[[8555,8555],"mapped",[120,105,105]],[[8556,8556],"mapped",[108]],[[8557,8557],"mapped",[99]],[[8558,8558],"mapped",[100]],[[8559,8559],"mapped",[109]],[[8560,8560],"mapped",[105]],[[8561,8561],"mapped",[105,105]],[[8562,8562],"mapped",[105,105,105]],[[8563,8563],"mapped",[105,118]],[[8564,8564],"mapped",[118]],[[8565,8565],"mapped",[118,105]],[[8566,8566],"mapped",[118,105,105]],[[8567,8567],"mapped",[118,105,105,105]],[[8568,8568],"mapped",[105,120]],[[8569,8569],"mapped",[120]],[[8570,8570],"mapped",[120,105]],[[8571,8571],"mapped",[120,105,105]],[[8572,8572],"mapped",[108]],[[8573,8573],"mapped",[99]],[[8574,8574],"mapped",[100]],[[8575,8575],"mapped",[109]],[[8576,8578],"valid",[],"NV8"],[[8579,8579],"disallowed"],[[8580,8580],"valid"],[[8581,8584],"valid",[],"NV8"],[[8585,8585],"mapped",[48,8260,51]],[[8586,8587],"valid",[],"NV8"],[[8588,8591],"disallowed"],[[8592,8682],"valid",[],"NV8"],[[8683,8691],"valid",[],"NV8"],[[8692,8703],"valid",[],"NV8"],[[8704,8747],"valid",[],"NV8"],[[8748,8748],"mapped",[8747,8747]],[[8749,8749],"mapped",[8747,8747,8747]],[[8750,8750],"valid",[],"NV8"],[[8751,8751],"mapped",[8750,8750]],[[8752,8752],"mapped",[8750,8750,8750]],[[8753,8799],"valid",[],"NV8"],[[8800,8800],"disallowed_STD3_valid"],[[8801,8813],"valid",[],"NV8"],[[8814,8815],"disallowed_STD3_valid"],[[8816,8945],"valid",[],"NV8"],[[8946,8959],"valid",[],"NV8"],[[8960,8960],"valid",[],"NV8"],[[8961,8961],"valid",[],"NV8"],[[8962,9000],"valid",[],"NV8"],[[9001,9001],"mapped",[12296]],[[9002,9002],"mapped",[12297]],[[9003,9082],"valid",[],"NV8"],[[9083,9083],"valid",[],"NV8"],[[9084,9084],"valid",[],"NV8"],[[9085,9114],"valid",[],"NV8"],[[9115,9166],"valid",[],"NV8"],[[9167,9168],"valid",[],"NV8"],[[9169,9179],"valid",[],"NV8"],[[9180,9191],"valid",[],"NV8"],[[9192,9192],"valid",[],"NV8"],[[9193,9203],"valid",[],"NV8"],[[9204,9210],"valid",[],"NV8"],[[9211,9215],"disallowed"],[[9216,9252],"valid",[],"NV8"],[[9253,9254],"valid",[],"NV8"],[[9255,9279],"disallowed"],[[9280,9290],"valid",[],"NV8"],[[9291,9311],"disallowed"],[[9312,9312],"mapped",[49]],[[9313,9313],"mapped",[50]],[[9314,9314],"mapped",[51]],[[9315,9315],"mapped",[52]],[[9316,9316],"mapped",[53]],[[9317,9317],"mapped",[54]],[[9318,9318],"mapped",[55]],[[9319,9319],"mapped",[56]],[[9320,9320],"mapped",[57]],[[9321,9321],"mapped",[49,48]],[[9322,9322],"mapped",[49,49]],[[9323,9323],"mapped",[49,50]],[[9324,9324],"mapped",[49,51]],[[9325,9325],"mapped",[49,52]],[[9326,9326],"mapped",[49,53]],[[9327,9327],"mapped",[49,54]],[[9328,9328],"mapped",[49,55]],[[9329,9329],"mapped",[49,56]],[[9330,9330],"mapped",[49,57]],[[9331,9331],"mapped",[50,48]],[[9332,9332],"disallowed_STD3_mapped",[40,49,41]],[[9333,9333],"disallowed_STD3_mapped",[40,50,41]],[[9334,9334],"disallowed_STD3_mapped",[40,51,41]],[[9335,9335],"disallowed_STD3_mapped",[40,52,41]],[[9336,9336],"disallowed_STD3_mapped",[40,53,41]],[[9337,9337],"disallowed_STD3_mapped",[40,54,41]],[[9338,9338],"disallowed_STD3_mapped",[40,55,41]],[[9339,9339],"disallowed_STD3_mapped",[40,56,41]],[[9340,9340],"disallowed_STD3_mapped",[40,57,41]],[[9341,9341],"disallowed_STD3_mapped",[40,49,48,41]],[[9342,9342],"disallowed_STD3_mapped",[40,49,49,41]],[[9343,9343],"disallowed_STD3_mapped",[40,49,50,41]],[[9344,9344],"disallowed_STD3_mapped",[40,49,51,41]],[[9345,9345],"disallowed_STD3_mapped",[40,49,52,41]],[[9346,9346],"disallowed_STD3_mapped",[40,49,53,41]],[[9347,9347],"disallowed_STD3_mapped",[40,49,54,41]],[[9348,9348],"disallowed_STD3_mapped",[40,49,55,41]],[[9349,9349],"disallowed_STD3_mapped",[40,49,56,41]],[[9350,9350],"disallowed_STD3_mapped",[40,49,57,41]],[[9351,9351],"disallowed_STD3_mapped",[40,50,48,41]],[[9352,9371],"disallowed"],[[9372,9372],"disallowed_STD3_mapped",[40,97,41]],[[9373,9373],"disallowed_STD3_mapped",[40,98,41]],[[9374,9374],"disallowed_STD3_mapped",[40,99,41]],[[9375,9375],"disallowed_STD3_mapped",[40,100,41]],[[9376,9376],"disallowed_STD3_mapped",[40,101,41]],[[9377,9377],"disallowed_STD3_mapped",[40,102,41]],[[9378,9378],"disallowed_STD3_mapped",[40,103,41]],[[9379,9379],"disallowed_STD3_mapped",[40,104,41]],[[9380,9380],"disallowed_STD3_mapped",[40,105,41]],[[9381,9381],"disallowed_STD3_mapped",[40,106,41]],[[9382,9382],"disallowed_STD3_mapped",[40,107,41]],[[9383,9383],"disallowed_STD3_mapped",[40,108,41]],[[9384,9384],"disallowed_STD3_mapped",[40,109,41]],[[9385,9385],"disallowed_STD3_mapped",[40,110,41]],[[9386,9386],"disallowed_STD3_mapped",[40,111,41]],[[9387,9387],"disallowed_STD3_mapped",[40,112,41]],[[9388,9388],"disallowed_STD3_mapped",[40,113,41]],[[9389,9389],"disallowed_STD3_mapped",[40,114,41]],[[9390,9390],"disallowed_STD3_mapped",[40,115,41]],[[9391,9391],"disallowed_STD3_mapped",[40,116,41]],[[9392,9392],"disallowed_STD3_mapped",[40,117,41]],[[9393,9393],"disallowed_STD3_mapped",[40,118,41]],[[9394,9394],"disallowed_STD3_mapped",[40,119,41]],[[9395,9395],"disallowed_STD3_mapped",[40,120,41]],[[9396,9396],"disallowed_STD3_mapped",[40,121,41]],[[9397,9397],"disallowed_STD3_mapped",[40,122,41]],[[9398,9398],"mapped",[97]],[[9399,9399],"mapped",[98]],[[9400,9400],"mapped",[99]],[[9401,9401],"mapped",[100]],[[9402,9402],"mapped",[101]],[[9403,9403],"mapped",[102]],[[9404,9404],"mapped",[103]],[[9405,9405],"mapped",[104]],[[9406,9406],"mapped",[105]],[[9407,9407],"mapped",[106]],[[9408,9408],"mapped",[107]],[[9409,9409],"mapped",[108]],[[9410,9410],"mapped",[109]],[[9411,9411],"mapped",[110]],[[9412,9412],"mapped",[111]],[[9413,9413],"mapped",[112]],[[9414,9414],"mapped",[113]],[[9415,9415],"mapped",[114]],[[9416,9416],"mapped",[115]],[[9417,9417],"mapped",[116]],[[9418,9418],"mapped",[117]],[[9419,9419],"mapped",[118]],[[9420,9420],"mapped",[119]],[[9421,9421],"mapped",[120]],[[9422,9422],"mapped",[121]],[[9423,9423],"mapped",[122]],[[9424,9424],"mapped",[97]],[[9425,9425],"mapped",[98]],[[9426,9426],"mapped",[99]],[[9427,9427],"mapped",[100]],[[9428,9428],"mapped",[101]],[[9429,9429],"mapped",[102]],[[9430,9430],"mapped",[103]],[[9431,9431],"mapped",[104]],[[9432,9432],"mapped",[105]],[[9433,9433],"mapped",[106]],[[9434,9434],"mapped",[107]],[[9435,9435],"mapped",[108]],[[9436,9436],"mapped",[109]],[[9437,9437],"mapped",[110]],[[9438,9438],"mapped",[111]],[[9439,9439],"mapped",[112]],[[9440,9440],"mapped",[113]],[[9441,9441],"mapped",[114]],[[9442,9442],"mapped",[115]],[[9443,9443],"mapped",[116]],[[9444,9444],"mapped",[117]],[[9445,9445],"mapped",[118]],[[9446,9446],"mapped",[119]],[[9447,9447],"mapped",[120]],[[9448,9448],"mapped",[121]],[[9449,9449],"mapped",[122]],[[9450,9450],"mapped",[48]],[[9451,9470],"valid",[],"NV8"],[[9471,9471],"valid",[],"NV8"],[[9472,9621],"valid",[],"NV8"],[[9622,9631],"valid",[],"NV8"],[[9632,9711],"valid",[],"NV8"],[[9712,9719],"valid",[],"NV8"],[[9720,9727],"valid",[],"NV8"],[[9728,9747],"valid",[],"NV8"],[[9748,9749],"valid",[],"NV8"],[[9750,9751],"valid",[],"NV8"],[[9752,9752],"valid",[],"NV8"],[[9753,9753],"valid",[],"NV8"],[[9754,9839],"valid",[],"NV8"],[[9840,9841],"valid",[],"NV8"],[[9842,9853],"valid",[],"NV8"],[[9854,9855],"valid",[],"NV8"],[[9856,9865],"valid",[],"NV8"],[[9866,9873],"valid",[],"NV8"],[[9874,9884],"valid",[],"NV8"],[[9885,9885],"valid",[],"NV8"],[[9886,9887],"valid",[],"NV8"],[[9888,9889],"valid",[],"NV8"],[[9890,9905],"valid",[],"NV8"],[[9906,9906],"valid",[],"NV8"],[[9907,9916],"valid",[],"NV8"],[[9917,9919],"valid",[],"NV8"],[[9920,9923],"valid",[],"NV8"],[[9924,9933],"valid",[],"NV8"],[[9934,9934],"valid",[],"NV8"],[[9935,9953],"valid",[],"NV8"],[[9954,9954],"valid",[],"NV8"],[[9955,9955],"valid",[],"NV8"],[[9956,9959],"valid",[],"NV8"],[[9960,9983],"valid",[],"NV8"],[[9984,9984],"valid",[],"NV8"],[[9985,9988],"valid",[],"NV8"],[[9989,9989],"valid",[],"NV8"],[[9990,9993],"valid",[],"NV8"],[[9994,9995],"valid",[],"NV8"],[[9996,10023],"valid",[],"NV8"],[[10024,10024],"valid",[],"NV8"],[[10025,10059],"valid",[],"NV8"],[[10060,10060],"valid",[],"NV8"],[[10061,10061],"valid",[],"NV8"],[[10062,10062],"valid",[],"NV8"],[[10063,10066],"valid",[],"NV8"],[[10067,10069],"valid",[],"NV8"],[[10070,10070],"valid",[],"NV8"],[[10071,10071],"valid",[],"NV8"],[[10072,10078],"valid",[],"NV8"],[[10079,10080],"valid",[],"NV8"],[[10081,10087],"valid",[],"NV8"],[[10088,10101],"valid",[],"NV8"],[[10102,10132],"valid",[],"NV8"],[[10133,10135],"valid",[],"NV8"],[[10136,10159],"valid",[],"NV8"],[[10160,10160],"valid",[],"NV8"],[[10161,10174],"valid",[],"NV8"],[[10175,10175],"valid",[],"NV8"],[[10176,10182],"valid",[],"NV8"],[[10183,10186],"valid",[],"NV8"],[[10187,10187],"valid",[],"NV8"],[[10188,10188],"valid",[],"NV8"],[[10189,10189],"valid",[],"NV8"],[[10190,10191],"valid",[],"NV8"],[[10192,10219],"valid",[],"NV8"],[[10220,10223],"valid",[],"NV8"],[[10224,10239],"valid",[],"NV8"],[[10240,10495],"valid",[],"NV8"],[[10496,10763],"valid",[],"NV8"],[[10764,10764],"mapped",[8747,8747,8747,8747]],[[10765,10867],"valid",[],"NV8"],[[10868,10868],"disallowed_STD3_mapped",[58,58,61]],[[10869,10869],"disallowed_STD3_mapped",[61,61]],[[10870,10870],"disallowed_STD3_mapped",[61,61,61]],[[10871,10971],"valid",[],"NV8"],[[10972,10972],"mapped",[10973,824]],[[10973,11007],"valid",[],"NV8"],[[11008,11021],"valid",[],"NV8"],[[11022,11027],"valid",[],"NV8"],[[11028,11034],"valid",[],"NV8"],[[11035,11039],"valid",[],"NV8"],[[11040,11043],"valid",[],"NV8"],[[11044,11084],"valid",[],"NV8"],[[11085,11087],"valid",[],"NV8"],[[11088,11092],"valid",[],"NV8"],[[11093,11097],"valid",[],"NV8"],[[11098,11123],"valid",[],"NV8"],[[11124,11125],"disallowed"],[[11126,11157],"valid",[],"NV8"],[[11158,11159],"disallowed"],[[11160,11193],"valid",[],"NV8"],[[11194,11196],"disallowed"],[[11197,11208],"valid",[],"NV8"],[[11209,11209],"disallowed"],[[11210,11217],"valid",[],"NV8"],[[11218,11243],"disallowed"],[[11244,11247],"valid",[],"NV8"],[[11248,11263],"disallowed"],[[11264,11264],"mapped",[11312]],[[11265,11265],"mapped",[11313]],[[11266,11266],"mapped",[11314]],[[11267,11267],"mapped",[11315]],[[11268,11268],"mapped",[11316]],[[11269,11269],"mapped",[11317]],[[11270,11270],"mapped",[11318]],[[11271,11271],"mapped",[11319]],[[11272,11272],"mapped",[11320]],[[11273,11273],"mapped",[11321]],[[11274,11274],"mapped",[11322]],[[11275,11275],"mapped",[11323]],[[11276,11276],"mapped",[11324]],[[11277,11277],"mapped",[11325]],[[11278,11278],"mapped",[11326]],[[11279,11279],"mapped",[11327]],[[11280,11280],"mapped",[11328]],[[11281,11281],"mapped",[11329]],[[11282,11282],"mapped",[11330]],[[11283,11283],"mapped",[11331]],[[11284,11284],"mapped",[11332]],[[11285,11285],"mapped",[11333]],[[11286,11286],"mapped",[11334]],[[11287,11287],"mapped",[11335]],[[11288,11288],"mapped",[11336]],[[11289,11289],"mapped",[11337]],[[11290,11290],"mapped",[11338]],[[11291,11291],"mapped",[11339]],[[11292,11292],"mapped",[11340]],[[11293,11293],"mapped",[11341]],[[11294,11294],"mapped",[11342]],[[11295,11295],"mapped",[11343]],[[11296,11296],"mapped",[11344]],[[11297,11297],"mapped",[11345]],[[11298,11298],"mapped",[11346]],[[11299,11299],"mapped",[11347]],[[11300,11300],"mapped",[11348]],[[11301,11301],"mapped",[11349]],[[11302,11302],"mapped",[11350]],[[11303,11303],"mapped",[11351]],[[11304,11304],"mapped",[11352]],[[11305,11305],"mapped",[11353]],[[11306,11306],"mapped",[11354]],[[11307,11307],"mapped",[11355]],[[11308,11308],"mapped",[11356]],[[11309,11309],"mapped",[11357]],[[11310,11310],"mapped",[11358]],[[11311,11311],"disallowed"],[[11312,11358],"valid"],[[11359,11359],"disallowed"],[[11360,11360],"mapped",[11361]],[[11361,11361],"valid"],[[11362,11362],"mapped",[619]],[[11363,11363],"mapped",[7549]],[[11364,11364],"mapped",[637]],[[11365,11366],"valid"],[[11367,11367],"mapped",[11368]],[[11368,11368],"valid"],[[11369,11369],"mapped",[11370]],[[11370,11370],"valid"],[[11371,11371],"mapped",[11372]],[[11372,11372],"valid"],[[11373,11373],"mapped",[593]],[[11374,11374],"mapped",[625]],[[11375,11375],"mapped",[592]],[[11376,11376],"mapped",[594]],[[11377,11377],"valid"],[[11378,11378],"mapped",[11379]],[[11379,11379],"valid"],[[11380,11380],"valid"],[[11381,11381],"mapped",[11382]],[[11382,11383],"valid"],[[11384,11387],"valid"],[[11388,11388],"mapped",[106]],[[11389,11389],"mapped",[118]],[[11390,11390],"mapped",[575]],[[11391,11391],"mapped",[576]],[[11392,11392],"mapped",[11393]],[[11393,11393],"valid"],[[11394,11394],"mapped",[11395]],[[11395,11395],"valid"],[[11396,11396],"mapped",[11397]],[[11397,11397],"valid"],[[11398,11398],"mapped",[11399]],[[11399,11399],"valid"],[[11400,11400],"mapped",[11401]],[[11401,11401],"valid"],[[11402,11402],"mapped",[11403]],[[11403,11403],"valid"],[[11404,11404],"mapped",[11405]],[[11405,11405],"valid"],[[11406,11406],"mapped",[11407]],[[11407,11407],"valid"],[[11408,11408],"mapped",[11409]],[[11409,11409],"valid"],[[11410,11410],"mapped",[11411]],[[11411,11411],"valid"],[[11412,11412],"mapped",[11413]],[[11413,11413],"valid"],[[11414,11414],"mapped",[11415]],[[11415,11415],"valid"],[[11416,11416],"mapped",[11417]],[[11417,11417],"valid"],[[11418,11418],"mapped",[11419]],[[11419,11419],"valid"],[[11420,11420],"mapped",[11421]],[[11421,11421],"valid"],[[11422,11422],"mapped",[11423]],[[11423,11423],"valid"],[[11424,11424],"mapped",[11425]],[[11425,11425],"valid"],[[11426,11426],"mapped",[11427]],[[11427,11427],"valid"],[[11428,11428],"mapped",[11429]],[[11429,11429],"valid"],[[11430,11430],"mapped",[11431]],[[11431,11431],"valid"],[[11432,11432],"mapped",[11433]],[[11433,11433],"valid"],[[11434,11434],"mapped",[11435]],[[11435,11435],"valid"],[[11436,11436],"mapped",[11437]],[[11437,11437],"valid"],[[11438,11438],"mapped",[11439]],[[11439,11439],"valid"],[[11440,11440],"mapped",[11441]],[[11441,11441],"valid"],[[11442,11442],"mapped",[11443]],[[11443,11443],"valid"],[[11444,11444],"mapped",[11445]],[[11445,11445],"valid"],[[11446,11446],"mapped",[11447]],[[11447,11447],"valid"],[[11448,11448],"mapped",[11449]],[[11449,11449],"valid"],[[11450,11450],"mapped",[11451]],[[11451,11451],"valid"],[[11452,11452],"mapped",[11453]],[[11453,11453],"valid"],[[11454,11454],"mapped",[11455]],[[11455,11455],"valid"],[[11456,11456],"mapped",[11457]],[[11457,11457],"valid"],[[11458,11458],"mapped",[11459]],[[11459,11459],"valid"],[[11460,11460],"mapped",[11461]],[[11461,11461],"valid"],[[11462,11462],"mapped",[11463]],[[11463,11463],"valid"],[[11464,11464],"mapped",[11465]],[[11465,11465],"valid"],[[11466,11466],"mapped",[11467]],[[11467,11467],"valid"],[[11468,11468],"mapped",[11469]],[[11469,11469],"valid"],[[11470,11470],"mapped",[11471]],[[11471,11471],"valid"],[[11472,11472],"mapped",[11473]],[[11473,11473],"valid"],[[11474,11474],"mapped",[11475]],[[11475,11475],"valid"],[[11476,11476],"mapped",[11477]],[[11477,11477],"valid"],[[11478,11478],"mapped",[11479]],[[11479,11479],"valid"],[[11480,11480],"mapped",[11481]],[[11481,11481],"valid"],[[11482,11482],"mapped",[11483]],[[11483,11483],"valid"],[[11484,11484],"mapped",[11485]],[[11485,11485],"valid"],[[11486,11486],"mapped",[11487]],[[11487,11487],"valid"],[[11488,11488],"mapped",[11489]],[[11489,11489],"valid"],[[11490,11490],"mapped",[11491]],[[11491,11492],"valid"],[[11493,11498],"valid",[],"NV8"],[[11499,11499],"mapped",[11500]],[[11500,11500],"valid"],[[11501,11501],"mapped",[11502]],[[11502,11505],"valid"],[[11506,11506],"mapped",[11507]],[[11507,11507],"valid"],[[11508,11512],"disallowed"],[[11513,11519],"valid",[],"NV8"],[[11520,11557],"valid"],[[11558,11558],"disallowed"],[[11559,11559],"valid"],[[11560,11564],"disallowed"],[[11565,11565],"valid"],[[11566,11567],"disallowed"],[[11568,11621],"valid"],[[11622,11623],"valid"],[[11624,11630],"disallowed"],[[11631,11631],"mapped",[11617]],[[11632,11632],"valid",[],"NV8"],[[11633,11646],"disallowed"],[[11647,11647],"valid"],[[11648,11670],"valid"],[[11671,11679],"disallowed"],[[11680,11686],"valid"],[[11687,11687],"disallowed"],[[11688,11694],"valid"],[[11695,11695],"disallowed"],[[11696,11702],"valid"],[[11703,11703],"disallowed"],[[11704,11710],"valid"],[[11711,11711],"disallowed"],[[11712,11718],"valid"],[[11719,11719],"disallowed"],[[11720,11726],"valid"],[[11727,11727],"disallowed"],[[11728,11734],"valid"],[[11735,11735],"disallowed"],[[11736,11742],"valid"],[[11743,11743],"disallowed"],[[11744,11775],"valid"],[[11776,11799],"valid",[],"NV8"],[[11800,11803],"valid",[],"NV8"],[[11804,11805],"valid",[],"NV8"],[[11806,11822],"valid",[],"NV8"],[[11823,11823],"valid"],[[11824,11824],"valid",[],"NV8"],[[11825,11825],"valid",[],"NV8"],[[11826,11835],"valid",[],"NV8"],[[11836,11842],"valid",[],"NV8"],[[11843,11903],"disallowed"],[[11904,11929],"valid",[],"NV8"],[[11930,11930],"disallowed"],[[11931,11934],"valid",[],"NV8"],[[11935,11935],"mapped",[27597]],[[11936,12018],"valid",[],"NV8"],[[12019,12019],"mapped",[40863]],[[12020,12031],"disallowed"],[[12032,12032],"mapped",[19968]],[[12033,12033],"mapped",[20008]],[[12034,12034],"mapped",[20022]],[[12035,12035],"mapped",[20031]],[[12036,12036],"mapped",[20057]],[[12037,12037],"mapped",[20101]],[[12038,12038],"mapped",[20108]],[[12039,12039],"mapped",[20128]],[[12040,12040],"mapped",[20154]],[[12041,12041],"mapped",[20799]],[[12042,12042],"mapped",[20837]],[[12043,12043],"mapped",[20843]],[[12044,12044],"mapped",[20866]],[[12045,12045],"mapped",[20886]],[[12046,12046],"mapped",[20907]],[[12047,12047],"mapped",[20960]],[[12048,12048],"mapped",[20981]],[[12049,12049],"mapped",[20992]],[[12050,12050],"mapped",[21147]],[[12051,12051],"mapped",[21241]],[[12052,12052],"mapped",[21269]],[[12053,12053],"mapped",[21274]],[[12054,12054],"mapped",[21304]],[[12055,12055],"mapped",[21313]],[[12056,12056],"mapped",[21340]],[[12057,12057],"mapped",[21353]],[[12058,12058],"mapped",[21378]],[[12059,12059],"mapped",[21430]],[[12060,12060],"mapped",[21448]],[[12061,12061],"mapped",[21475]],[[12062,12062],"mapped",[22231]],[[12063,12063],"mapped",[22303]],[[12064,12064],"mapped",[22763]],[[12065,12065],"mapped",[22786]],[[12066,12066],"mapped",[22794]],[[12067,12067],"mapped",[22805]],[[12068,12068],"mapped",[22823]],[[12069,12069],"mapped",[22899]],[[12070,12070],"mapped",[23376]],[[12071,12071],"mapped",[23424]],[[12072,12072],"mapped",[23544]],[[12073,12073],"mapped",[23567]],[[12074,12074],"mapped",[23586]],[[12075,12075],"mapped",[23608]],[[12076,12076],"mapped",[23662]],[[12077,12077],"mapped",[23665]],[[12078,12078],"mapped",[24027]],[[12079,12079],"mapped",[24037]],[[12080,12080],"mapped",[24049]],[[12081,12081],"mapped",[24062]],[[12082,12082],"mapped",[24178]],[[12083,12083],"mapped",[24186]],[[12084,12084],"mapped",[24191]],[[12085,12085],"mapped",[24308]],[[12086,12086],"mapped",[24318]],[[12087,12087],"mapped",[24331]],[[12088,12088],"mapped",[24339]],[[12089,12089],"mapped",[24400]],[[12090,12090],"mapped",[24417]],[[12091,12091],"mapped",[24435]],[[12092,12092],"mapped",[24515]],[[12093,12093],"mapped",[25096]],[[12094,12094],"mapped",[25142]],[[12095,12095],"mapped",[25163]],[[12096,12096],"mapped",[25903]],[[12097,12097],"mapped",[25908]],[[12098,12098],"mapped",[25991]],[[12099,12099],"mapped",[26007]],[[12100,12100],"mapped",[26020]],[[12101,12101],"mapped",[26041]],[[12102,12102],"mapped",[26080]],[[12103,12103],"mapped",[26085]],[[12104,12104],"mapped",[26352]],[[12105,12105],"mapped",[26376]],[[12106,12106],"mapped",[26408]],[[12107,12107],"mapped",[27424]],[[12108,12108],"mapped",[27490]],[[12109,12109],"mapped",[27513]],[[12110,12110],"mapped",[27571]],[[12111,12111],"mapped",[27595]],[[12112,12112],"mapped",[27604]],[[12113,12113],"mapped",[27611]],[[12114,12114],"mapped",[27663]],[[12115,12115],"mapped",[27668]],[[12116,12116],"mapped",[27700]],[[12117,12117],"mapped",[28779]],[[12118,12118],"mapped",[29226]],[[12119,12119],"mapped",[29238]],[[12120,12120],"mapped",[29243]],[[12121,12121],"mapped",[29247]],[[12122,12122],"mapped",[29255]],[[12123,12123],"mapped",[29273]],[[12124,12124],"mapped",[29275]],[[12125,12125],"mapped",[29356]],[[12126,12126],"mapped",[29572]],[[12127,12127],"mapped",[29577]],[[12128,12128],"mapped",[29916]],[[12129,12129],"mapped",[29926]],[[12130,12130],"mapped",[29976]],[[12131,12131],"mapped",[29983]],[[12132,12132],"mapped",[29992]],[[12133,12133],"mapped",[30000]],[[12134,12134],"mapped",[30091]],[[12135,12135],"mapped",[30098]],[[12136,12136],"mapped",[30326]],[[12137,12137],"mapped",[30333]],[[12138,12138],"mapped",[30382]],[[12139,12139],"mapped",[30399]],[[12140,12140],"mapped",[30446]],[[12141,12141],"mapped",[30683]],[[12142,12142],"mapped",[30690]],[[12143,12143],"mapped",[30707]],[[12144,12144],"mapped",[31034]],[[12145,12145],"mapped",[31160]],[[12146,12146],"mapped",[31166]],[[12147,12147],"mapped",[31348]],[[12148,12148],"mapped",[31435]],[[12149,12149],"mapped",[31481]],[[12150,12150],"mapped",[31859]],[[12151,12151],"mapped",[31992]],[[12152,12152],"mapped",[32566]],[[12153,12153],"mapped",[32593]],[[12154,12154],"mapped",[32650]],[[12155,12155],"mapped",[32701]],[[12156,12156],"mapped",[32769]],[[12157,12157],"mapped",[32780]],[[12158,12158],"mapped",[32786]],[[12159,12159],"mapped",[32819]],[[12160,12160],"mapped",[32895]],[[12161,12161],"mapped",[32905]],[[12162,12162],"mapped",[33251]],[[12163,12163],"mapped",[33258]],[[12164,12164],"mapped",[33267]],[[12165,12165],"mapped",[33276]],[[12166,12166],"mapped",[33292]],[[12167,12167],"mapped",[33307]],[[12168,12168],"mapped",[33311]],[[12169,12169],"mapped",[33390]],[[12170,12170],"mapped",[33394]],[[12171,12171],"mapped",[33400]],[[12172,12172],"mapped",[34381]],[[12173,12173],"mapped",[34411]],[[12174,12174],"mapped",[34880]],[[12175,12175],"mapped",[34892]],[[12176,12176],"mapped",[34915]],[[12177,12177],"mapped",[35198]],[[12178,12178],"mapped",[35211]],[[12179,12179],"mapped",[35282]],[[12180,12180],"mapped",[35328]],[[12181,12181],"mapped",[35895]],[[12182,12182],"mapped",[35910]],[[12183,12183],"mapped",[35925]],[[12184,12184],"mapped",[35960]],[[12185,12185],"mapped",[35997]],[[12186,12186],"mapped",[36196]],[[12187,12187],"mapped",[36208]],[[12188,12188],"mapped",[36275]],[[12189,12189],"mapped",[36523]],[[12190,12190],"mapped",[36554]],[[12191,12191],"mapped",[36763]],[[12192,12192],"mapped",[36784]],[[12193,12193],"mapped",[36789]],[[12194,12194],"mapped",[37009]],[[12195,12195],"mapped",[37193]],[[12196,12196],"mapped",[37318]],[[12197,12197],"mapped",[37324]],[[12198,12198],"mapped",[37329]],[[12199,12199],"mapped",[38263]],[[12200,12200],"mapped",[38272]],[[12201,12201],"mapped",[38428]],[[12202,12202],"mapped",[38582]],[[12203,12203],"mapped",[38585]],[[12204,12204],"mapped",[38632]],[[12205,12205],"mapped",[38737]],[[12206,12206],"mapped",[38750]],[[12207,12207],"mapped",[38754]],[[12208,12208],"mapped",[38761]],[[12209,12209],"mapped",[38859]],[[12210,12210],"mapped",[38893]],[[12211,12211],"mapped",[38899]],[[12212,12212],"mapped",[38913]],[[12213,12213],"mapped",[39080]],[[12214,12214],"mapped",[39131]],[[12215,12215],"mapped",[39135]],[[12216,12216],"mapped",[39318]],[[12217,12217],"mapped",[39321]],[[12218,12218],"mapped",[39340]],[[12219,12219],"mapped",[39592]],[[12220,12220],"mapped",[39640]],[[12221,12221],"mapped",[39647]],[[12222,12222],"mapped",[39717]],[[12223,12223],"mapped",[39727]],[[12224,12224],"mapped",[39730]],[[12225,12225],"mapped",[39740]],[[12226,12226],"mapped",[39770]],[[12227,12227],"mapped",[40165]],[[12228,12228],"mapped",[40565]],[[12229,12229],"mapped",[40575]],[[12230,12230],"mapped",[40613]],[[12231,12231],"mapped",[40635]],[[12232,12232],"mapped",[40643]],[[12233,12233],"mapped",[40653]],[[12234,12234],"mapped",[40657]],[[12235,12235],"mapped",[40697]],[[12236,12236],"mapped",[40701]],[[12237,12237],"mapped",[40718]],[[12238,12238],"mapped",[40723]],[[12239,12239],"mapped",[40736]],[[12240,12240],"mapped",[40763]],[[12241,12241],"mapped",[40778]],[[12242,12242],"mapped",[40786]],[[12243,12243],"mapped",[40845]],[[12244,12244],"mapped",[40860]],[[12245,12245],"mapped",[40864]],[[12246,12271],"disallowed"],[[12272,12283],"disallowed"],[[12284,12287],"disallowed"],[[12288,12288],"disallowed_STD3_mapped",[32]],[[12289,12289],"valid",[],"NV8"],[[12290,12290],"mapped",[46]],[[12291,12292],"valid",[],"NV8"],[[12293,12295],"valid"],[[12296,12329],"valid",[],"NV8"],[[12330,12333],"valid"],[[12334,12341],"valid",[],"NV8"],[[12342,12342],"mapped",[12306]],[[12343,12343],"valid",[],"NV8"],[[12344,12344],"mapped",[21313]],[[12345,12345],"mapped",[21316]],[[12346,12346],"mapped",[21317]],[[12347,12347],"valid",[],"NV8"],[[12348,12348],"valid"],[[12349,12349],"valid",[],"NV8"],[[12350,12350],"valid",[],"NV8"],[[12351,12351],"valid",[],"NV8"],[[12352,12352],"disallowed"],[[12353,12436],"valid"],[[12437,12438],"valid"],[[12439,12440],"disallowed"],[[12441,12442],"valid"],[[12443,12443],"disallowed_STD3_mapped",[32,12441]],[[12444,12444],"disallowed_STD3_mapped",[32,12442]],[[12445,12446],"valid"],[[12447,12447],"mapped",[12424,12426]],[[12448,12448],"valid",[],"NV8"],[[12449,12542],"valid"],[[12543,12543],"mapped",[12467,12488]],[[12544,12548],"disallowed"],[[12549,12588],"valid"],[[12589,12589],"valid"],[[12590,12592],"disallowed"],[[12593,12593],"mapped",[4352]],[[12594,12594],"mapped",[4353]],[[12595,12595],"mapped",[4522]],[[12596,12596],"mapped",[4354]],[[12597,12597],"mapped",[4524]],[[12598,12598],"mapped",[4525]],[[12599,12599],"mapped",[4355]],[[12600,12600],"mapped",[4356]],[[12601,12601],"mapped",[4357]],[[12602,12602],"mapped",[4528]],[[12603,12603],"mapped",[4529]],[[12604,12604],"mapped",[4530]],[[12605,12605],"mapped",[4531]],[[12606,12606],"mapped",[4532]],[[12607,12607],"mapped",[4533]],[[12608,12608],"mapped",[4378]],[[12609,12609],"mapped",[4358]],[[12610,12610],"mapped",[4359]],[[12611,12611],"mapped",[4360]],[[12612,12612],"mapped",[4385]],[[12613,12613],"mapped",[4361]],[[12614,12614],"mapped",[4362]],[[12615,12615],"mapped",[4363]],[[12616,12616],"mapped",[4364]],[[12617,12617],"mapped",[4365]],[[12618,12618],"mapped",[4366]],[[12619,12619],"mapped",[4367]],[[12620,12620],"mapped",[4368]],[[12621,12621],"mapped",[4369]],[[12622,12622],"mapped",[4370]],[[12623,12623],"mapped",[4449]],[[12624,12624],"mapped",[4450]],[[12625,12625],"mapped",[4451]],[[12626,12626],"mapped",[4452]],[[12627,12627],"mapped",[4453]],[[12628,12628],"mapped",[4454]],[[12629,12629],"mapped",[4455]],[[12630,12630],"mapped",[4456]],[[12631,12631],"mapped",[4457]],[[12632,12632],"mapped",[4458]],[[12633,12633],"mapped",[4459]],[[12634,12634],"mapped",[4460]],[[12635,12635],"mapped",[4461]],[[12636,12636],"mapped",[4462]],[[12637,12637],"mapped",[4463]],[[12638,12638],"mapped",[4464]],[[12639,12639],"mapped",[4465]],[[12640,12640],"mapped",[4466]],[[12641,12641],"mapped",[4467]],[[12642,12642],"mapped",[4468]],[[12643,12643],"mapped",[4469]],[[12644,12644],"disallowed"],[[12645,12645],"mapped",[4372]],[[12646,12646],"mapped",[4373]],[[12647,12647],"mapped",[4551]],[[12648,12648],"mapped",[4552]],[[12649,12649],"mapped",[4556]],[[12650,12650],"mapped",[4558]],[[12651,12651],"mapped",[4563]],[[12652,12652],"mapped",[4567]],[[12653,12653],"mapped",[4569]],[[12654,12654],"mapped",[4380]],[[12655,12655],"mapped",[4573]],[[12656,12656],"mapped",[4575]],[[12657,12657],"mapped",[4381]],[[12658,12658],"mapped",[4382]],[[12659,12659],"mapped",[4384]],[[12660,12660],"mapped",[4386]],[[12661,12661],"mapped",[4387]],[[12662,12662],"mapped",[4391]],[[12663,12663],"mapped",[4393]],[[12664,12664],"mapped",[4395]],[[12665,12665],"mapped",[4396]],[[12666,12666],"mapped",[4397]],[[12667,12667],"mapped",[4398]],[[12668,12668],"mapped",[4399]],[[12669,12669],"mapped",[4402]],[[12670,12670],"mapped",[4406]],[[12671,12671],"mapped",[4416]],[[12672,12672],"mapped",[4423]],[[12673,12673],"mapped",[4428]],[[12674,12674],"mapped",[4593]],[[12675,12675],"mapped",[4594]],[[12676,12676],"mapped",[4439]],[[12677,12677],"mapped",[4440]],[[12678,12678],"mapped",[4441]],[[12679,12679],"mapped",[4484]],[[12680,12680],"mapped",[4485]],[[12681,12681],"mapped",[4488]],[[12682,12682],"mapped",[4497]],[[12683,12683],"mapped",[4498]],[[12684,12684],"mapped",[4500]],[[12685,12685],"mapped",[4510]],[[12686,12686],"mapped",[4513]],[[12687,12687],"disallowed"],[[12688,12689],"valid",[],"NV8"],[[12690,12690],"mapped",[19968]],[[12691,12691],"mapped",[20108]],[[12692,12692],"mapped",[19977]],[[12693,12693],"mapped",[22235]],[[12694,12694],"mapped",[19978]],[[12695,12695],"mapped",[20013]],[[12696,12696],"mapped",[19979]],[[12697,12697],"mapped",[30002]],[[12698,12698],"mapped",[20057]],[[12699,12699],"mapped",[19993]],[[12700,12700],"mapped",[19969]],[[12701,12701],"mapped",[22825]],[[12702,12702],"mapped",[22320]],[[12703,12703],"mapped",[20154]],[[12704,12727],"valid"],[[12728,12730],"valid"],[[12731,12735],"disallowed"],[[12736,12751],"valid",[],"NV8"],[[12752,12771],"valid",[],"NV8"],[[12772,12783],"disallowed"],[[12784,12799],"valid"],[[12800,12800],"disallowed_STD3_mapped",[40,4352,41]],[[12801,12801],"disallowed_STD3_mapped",[40,4354,41]],[[12802,12802],"disallowed_STD3_mapped",[40,4355,41]],[[12803,12803],"disallowed_STD3_mapped",[40,4357,41]],[[12804,12804],"disallowed_STD3_mapped",[40,4358,41]],[[12805,12805],"disallowed_STD3_mapped",[40,4359,41]],[[12806,12806],"disallowed_STD3_mapped",[40,4361,41]],[[12807,12807],"disallowed_STD3_mapped",[40,4363,41]],[[12808,12808],"disallowed_STD3_mapped",[40,4364,41]],[[12809,12809],"disallowed_STD3_mapped",[40,4366,41]],[[12810,12810],"disallowed_STD3_mapped",[40,4367,41]],[[12811,12811],"disallowed_STD3_mapped",[40,4368,41]],[[12812,12812],"disallowed_STD3_mapped",[40,4369,41]],[[12813,12813],"disallowed_STD3_mapped",[40,4370,41]],[[12814,12814],"disallowed_STD3_mapped",[40,44032,41]],[[12815,12815],"disallowed_STD3_mapped",[40,45208,41]],[[12816,12816],"disallowed_STD3_mapped",[40,45796,41]],[[12817,12817],"disallowed_STD3_mapped",[40,46972,41]],[[12818,12818],"disallowed_STD3_mapped",[40,47560,41]],[[12819,12819],"disallowed_STD3_mapped",[40,48148,41]],[[12820,12820],"disallowed_STD3_mapped",[40,49324,41]],[[12821,12821],"disallowed_STD3_mapped",[40,50500,41]],[[12822,12822],"disallowed_STD3_mapped",[40,51088,41]],[[12823,12823],"disallowed_STD3_mapped",[40,52264,41]],[[12824,12824],"disallowed_STD3_mapped",[40,52852,41]],[[12825,12825],"disallowed_STD3_mapped",[40,53440,41]],[[12826,12826],"disallowed_STD3_mapped",[40,54028,41]],[[12827,12827],"disallowed_STD3_mapped",[40,54616,41]],[[12828,12828],"disallowed_STD3_mapped",[40,51452,41]],[[12829,12829],"disallowed_STD3_mapped",[40,50724,51204,41]],[[12830,12830],"disallowed_STD3_mapped",[40,50724,54980,41]],[[12831,12831],"disallowed"],[[12832,12832],"disallowed_STD3_mapped",[40,19968,41]],[[12833,12833],"disallowed_STD3_mapped",[40,20108,41]],[[12834,12834],"disallowed_STD3_mapped",[40,19977,41]],[[12835,12835],"disallowed_STD3_mapped",[40,22235,41]],[[12836,12836],"disallowed_STD3_mapped",[40,20116,41]],[[12837,12837],"disallowed_STD3_mapped",[40,20845,41]],[[12838,12838],"disallowed_STD3_mapped",[40,19971,41]],[[12839,12839],"disallowed_STD3_mapped",[40,20843,41]],[[12840,12840],"disallowed_STD3_mapped",[40,20061,41]],[[12841,12841],"disallowed_STD3_mapped",[40,21313,41]],[[12842,12842],"disallowed_STD3_mapped",[40,26376,41]],[[12843,12843],"disallowed_STD3_mapped",[40,28779,41]],[[12844,12844],"disallowed_STD3_mapped",[40,27700,41]],[[12845,12845],"disallowed_STD3_mapped",[40,26408,41]],[[12846,12846],"disallowed_STD3_mapped",[40,37329,41]],[[12847,12847],"disallowed_STD3_mapped",[40,22303,41]],[[12848,12848],"disallowed_STD3_mapped",[40,26085,41]],[[12849,12849],"disallowed_STD3_mapped",[40,26666,41]],[[12850,12850],"disallowed_STD3_mapped",[40,26377,41]],[[12851,12851],"disallowed_STD3_mapped",[40,31038,41]],[[12852,12852],"disallowed_STD3_mapped",[40,21517,41]],[[12853,12853],"disallowed_STD3_mapped",[40,29305,41]],[[12854,12854],"disallowed_STD3_mapped",[40,36001,41]],[[12855,12855],"disallowed_STD3_mapped",[40,31069,41]],[[12856,12856],"disallowed_STD3_mapped",[40,21172,41]],[[12857,12857],"disallowed_STD3_mapped",[40,20195,41]],[[12858,12858],"disallowed_STD3_mapped",[40,21628,41]],[[12859,12859],"disallowed_STD3_mapped",[40,23398,41]],[[12860,12860],"disallowed_STD3_mapped",[40,30435,41]],[[12861,12861],"disallowed_STD3_mapped",[40,20225,41]],[[12862,12862],"disallowed_STD3_mapped",[40,36039,41]],[[12863,12863],"disallowed_STD3_mapped",[40,21332,41]],[[12864,12864],"disallowed_STD3_mapped",[40,31085,41]],[[12865,12865],"disallowed_STD3_mapped",[40,20241,41]],[[12866,12866],"disallowed_STD3_mapped",[40,33258,41]],[[12867,12867],"disallowed_STD3_mapped",[40,33267,41]],[[12868,12868],"mapped",[21839]],[[12869,12869],"mapped",[24188]],[[12870,12870],"mapped",[25991]],[[12871,12871],"mapped",[31631]],[[12872,12879],"valid",[],"NV8"],[[12880,12880],"mapped",[112,116,101]],[[12881,12881],"mapped",[50,49]],[[12882,12882],"mapped",[50,50]],[[12883,12883],"mapped",[50,51]],[[12884,12884],"mapped",[50,52]],[[12885,12885],"mapped",[50,53]],[[12886,12886],"mapped",[50,54]],[[12887,12887],"mapped",[50,55]],[[12888,12888],"mapped",[50,56]],[[12889,12889],"mapped",[50,57]],[[12890,12890],"mapped",[51,48]],[[12891,12891],"mapped",[51,49]],[[12892,12892],"mapped",[51,50]],[[12893,12893],"mapped",[51,51]],[[12894,12894],"mapped",[51,52]],[[12895,12895],"mapped",[51,53]],[[12896,12896],"mapped",[4352]],[[12897,12897],"mapped",[4354]],[[12898,12898],"mapped",[4355]],[[12899,12899],"mapped",[4357]],[[12900,12900],"mapped",[4358]],[[12901,12901],"mapped",[4359]],[[12902,12902],"mapped",[4361]],[[12903,12903],"mapped",[4363]],[[12904,12904],"mapped",[4364]],[[12905,12905],"mapped",[4366]],[[12906,12906],"mapped",[4367]],[[12907,12907],"mapped",[4368]],[[12908,12908],"mapped",[4369]],[[12909,12909],"mapped",[4370]],[[12910,12910],"mapped",[44032]],[[12911,12911],"mapped",[45208]],[[12912,12912],"mapped",[45796]],[[12913,12913],"mapped",[46972]],[[12914,12914],"mapped",[47560]],[[12915,12915],"mapped",[48148]],[[12916,12916],"mapped",[49324]],[[12917,12917],"mapped",[50500]],[[12918,12918],"mapped",[51088]],[[12919,12919],"mapped",[52264]],[[12920,12920],"mapped",[52852]],[[12921,12921],"mapped",[53440]],[[12922,12922],"mapped",[54028]],[[12923,12923],"mapped",[54616]],[[12924,12924],"mapped",[52280,44256]],[[12925,12925],"mapped",[51452,51032]],[[12926,12926],"mapped",[50864]],[[12927,12927],"valid",[],"NV8"],[[12928,12928],"mapped",[19968]],[[12929,12929],"mapped",[20108]],[[12930,12930],"mapped",[19977]],[[12931,12931],"mapped",[22235]],[[12932,12932],"mapped",[20116]],[[12933,12933],"mapped",[20845]],[[12934,12934],"mapped",[19971]],[[12935,12935],"mapped",[20843]],[[12936,12936],"mapped",[20061]],[[12937,12937],"mapped",[21313]],[[12938,12938],"mapped",[26376]],[[12939,12939],"mapped",[28779]],[[12940,12940],"mapped",[27700]],[[12941,12941],"mapped",[26408]],[[12942,12942],"mapped",[37329]],[[12943,12943],"mapped",[22303]],[[12944,12944],"mapped",[26085]],[[12945,12945],"mapped",[26666]],[[12946,12946],"mapped",[26377]],[[12947,12947],"mapped",[31038]],[[12948,12948],"mapped",[21517]],[[12949,12949],"mapped",[29305]],[[12950,12950],"mapped",[36001]],[[12951,12951],"mapped",[31069]],[[12952,12952],"mapped",[21172]],[[12953,12953],"mapped",[31192]],[[12954,12954],"mapped",[30007]],[[12955,12955],"mapped",[22899]],[[12956,12956],"mapped",[36969]],[[12957,12957],"mapped",[20778]],[[12958,12958],"mapped",[21360]],[[12959,12959],"mapped",[27880]],[[12960,12960],"mapped",[38917]],[[12961,12961],"mapped",[20241]],[[12962,12962],"mapped",[20889]],[[12963,12963],"mapped",[27491]],[[12964,12964],"mapped",[19978]],[[12965,12965],"mapped",[20013]],[[12966,12966],"mapped",[19979]],[[12967,12967],"mapped",[24038]],[[12968,12968],"mapped",[21491]],[[12969,12969],"mapped",[21307]],[[12970,12970],"mapped",[23447]],[[12971,12971],"mapped",[23398]],[[12972,12972],"mapped",[30435]],[[12973,12973],"mapped",[20225]],[[12974,12974],"mapped",[36039]],[[12975,12975],"mapped",[21332]],[[12976,12976],"mapped",[22812]],[[12977,12977],"mapped",[51,54]],[[12978,12978],"mapped",[51,55]],[[12979,12979],"mapped",[51,56]],[[12980,12980],"mapped",[51,57]],[[12981,12981],"mapped",[52,48]],[[12982,12982],"mapped",[52,49]],[[12983,12983],"mapped",[52,50]],[[12984,12984],"mapped",[52,51]],[[12985,12985],"mapped",[52,52]],[[12986,12986],"mapped",[52,53]],[[12987,12987],"mapped",[52,54]],[[12988,12988],"mapped",[52,55]],[[12989,12989],"mapped",[52,56]],[[12990,12990],"mapped",[52,57]],[[12991,12991],"mapped",[53,48]],[[12992,12992],"mapped",[49,26376]],[[12993,12993],"mapped",[50,26376]],[[12994,12994],"mapped",[51,26376]],[[12995,12995],"mapped",[52,26376]],[[12996,12996],"mapped",[53,26376]],[[12997,12997],"mapped",[54,26376]],[[12998,12998],"mapped",[55,26376]],[[12999,12999],"mapped",[56,26376]],[[13000,13000],"mapped",[57,26376]],[[13001,13001],"mapped",[49,48,26376]],[[13002,13002],"mapped",[49,49,26376]],[[13003,13003],"mapped",[49,50,26376]],[[13004,13004],"mapped",[104,103]],[[13005,13005],"mapped",[101,114,103]],[[13006,13006],"mapped",[101,118]],[[13007,13007],"mapped",[108,116,100]],[[13008,13008],"mapped",[12450]],[[13009,13009],"mapped",[12452]],[[13010,13010],"mapped",[12454]],[[13011,13011],"mapped",[12456]],[[13012,13012],"mapped",[12458]],[[13013,13013],"mapped",[12459]],[[13014,13014],"mapped",[12461]],[[13015,13015],"mapped",[12463]],[[13016,13016],"mapped",[12465]],[[13017,13017],"mapped",[12467]],[[13018,13018],"mapped",[12469]],[[13019,13019],"mapped",[12471]],[[13020,13020],"mapped",[12473]],[[13021,13021],"mapped",[12475]],[[13022,13022],"mapped",[12477]],[[13023,13023],"mapped",[12479]],[[13024,13024],"mapped",[12481]],[[13025,13025],"mapped",[12484]],[[13026,13026],"mapped",[12486]],[[13027,13027],"mapped",[12488]],[[13028,13028],"mapped",[12490]],[[13029,13029],"mapped",[12491]],[[13030,13030],"mapped",[12492]],[[13031,13031],"mapped",[12493]],[[13032,13032],"mapped",[12494]],[[13033,13033],"mapped",[12495]],[[13034,13034],"mapped",[12498]],[[13035,13035],"mapped",[12501]],[[13036,13036],"mapped",[12504]],[[13037,13037],"mapped",[12507]],[[13038,13038],"mapped",[12510]],[[13039,13039],"mapped",[12511]],[[13040,13040],"mapped",[12512]],[[13041,13041],"mapped",[12513]],[[13042,13042],"mapped",[12514]],[[13043,13043],"mapped",[12516]],[[13044,13044],"mapped",[12518]],[[13045,13045],"mapped",[12520]],[[13046,13046],"mapped",[12521]],[[13047,13047],"mapped",[12522]],[[13048,13048],"mapped",[12523]],[[13049,13049],"mapped",[12524]],[[13050,13050],"mapped",[12525]],[[13051,13051],"mapped",[12527]],[[13052,13052],"mapped",[12528]],[[13053,13053],"mapped",[12529]],[[13054,13054],"mapped",[12530]],[[13055,13055],"disallowed"],[[13056,13056],"mapped",[12450,12497,12540,12488]],[[13057,13057],"mapped",[12450,12523,12501,12449]],[[13058,13058],"mapped",[12450,12531,12506,12450]],[[13059,13059],"mapped",[12450,12540,12523]],[[13060,13060],"mapped",[12452,12491,12531,12464]],[[13061,13061],"mapped",[12452,12531,12481]],[[13062,13062],"mapped",[12454,12457,12531]],[[13063,13063],"mapped",[12456,12473,12463,12540,12489]],[[13064,13064],"mapped",[12456,12540,12459,12540]],[[13065,13065],"mapped",[12458,12531,12473]],[[13066,13066],"mapped",[12458,12540,12512]],[[13067,13067],"mapped",[12459,12452,12522]],[[13068,13068],"mapped",[12459,12521,12483,12488]],[[13069,13069],"mapped",[12459,12525,12522,12540]],[[13070,13070],"mapped",[12460,12525,12531]],[[13071,13071],"mapped",[12460,12531,12510]],[[13072,13072],"mapped",[12462,12460]],[[13073,13073],"mapped",[12462,12491,12540]],[[13074,13074],"mapped",[12461,12517,12522,12540]],[[13075,13075],"mapped",[12462,12523,12480,12540]],[[13076,13076],"mapped",[12461,12525]],[[13077,13077],"mapped",[12461,12525,12464,12521,12512]],[[13078,13078],"mapped",[12461,12525,12513,12540,12488,12523]],[[13079,13079],"mapped",[12461,12525,12527,12483,12488]],[[13080,13080],"mapped",[12464,12521,12512]],[[13081,13081],"mapped",[12464,12521,12512,12488,12531]],[[13082,13082],"mapped",[12463,12523,12476,12452,12525]],[[13083,13083],"mapped",[12463,12525,12540,12493]],[[13084,13084],"mapped",[12465,12540,12473]],[[13085,13085],"mapped",[12467,12523,12490]],[[13086,13086],"mapped",[12467,12540,12509]],[[13087,13087],"mapped",[12469,12452,12463,12523]],[[13088,13088],"mapped",[12469,12531,12481,12540,12512]],[[13089,13089],"mapped",[12471,12522,12531,12464]],[[13090,13090],"mapped",[12475,12531,12481]],[[13091,13091],"mapped",[12475,12531,12488]],[[13092,13092],"mapped",[12480,12540,12473]],[[13093,13093],"mapped",[12487,12471]],[[13094,13094],"mapped",[12489,12523]],[[13095,13095],"mapped",[12488,12531]],[[13096,13096],"mapped",[12490,12494]],[[13097,13097],"mapped",[12494,12483,12488]],[[13098,13098],"mapped",[12495,12452,12484]],[[13099,13099],"mapped",[12497,12540,12475,12531,12488]],[[13100,13100],"mapped",[12497,12540,12484]],[[13101,13101],"mapped",[12496,12540,12524,12523]],[[13102,13102],"mapped",[12500,12450,12473,12488,12523]],[[13103,13103],"mapped",[12500,12463,12523]],[[13104,13104],"mapped",[12500,12467]],[[13105,13105],"mapped",[12499,12523]],[[13106,13106],"mapped",[12501,12449,12521,12483,12489]],[[13107,13107],"mapped",[12501,12451,12540,12488]],[[13108,13108],"mapped",[12502,12483,12471,12455,12523]],[[13109,13109],"mapped",[12501,12521,12531]],[[13110,13110],"mapped",[12504,12463,12479,12540,12523]],[[13111,13111],"mapped",[12506,12477]],[[13112,13112],"mapped",[12506,12491,12498]],[[13113,13113],"mapped",[12504,12523,12484]],[[13114,13114],"mapped",[12506,12531,12473]],[[13115,13115],"mapped",[12506,12540,12472]],[[13116,13116],"mapped",[12505,12540,12479]],[[13117,13117],"mapped",[12509,12452,12531,12488]],[[13118,13118],"mapped",[12508,12523,12488]],[[13119,13119],"mapped",[12507,12531]],[[13120,13120],"mapped",[12509,12531,12489]],[[13121,13121],"mapped",[12507,12540,12523]],[[13122,13122],"mapped",[12507,12540,12531]],[[13123,13123],"mapped",[12510,12452,12463,12525]],[[13124,13124],"mapped",[12510,12452,12523]],[[13125,13125],"mapped",[12510,12483,12495]],[[13126,13126],"mapped",[12510,12523,12463]],[[13127,13127],"mapped",[12510,12531,12471,12519,12531]],[[13128,13128],"mapped",[12511,12463,12525,12531]],[[13129,13129],"mapped",[12511,12522]],[[13130,13130],"mapped",[12511,12522,12496,12540,12523]],[[13131,13131],"mapped",[12513,12460]],[[13132,13132],"mapped",[12513,12460,12488,12531]],[[13133,13133],"mapped",[12513,12540,12488,12523]],[[13134,13134],"mapped",[12516,12540,12489]],[[13135,13135],"mapped",[12516,12540,12523]],[[13136,13136],"mapped",[12518,12450,12531]],[[13137,13137],"mapped",[12522,12483,12488,12523]],[[13138,13138],"mapped",[12522,12521]],[[13139,13139],"mapped",[12523,12500,12540]],[[13140,13140],"mapped",[12523,12540,12502,12523]],[[13141,13141],"mapped",[12524,12512]],[[13142,13142],"mapped",[12524,12531,12488,12466,12531]],[[13143,13143],"mapped",[12527,12483,12488]],[[13144,13144],"mapped",[48,28857]],[[13145,13145],"mapped",[49,28857]],[[13146,13146],"mapped",[50,28857]],[[13147,13147],"mapped",[51,28857]],[[13148,13148],"mapped",[52,28857]],[[13149,13149],"mapped",[53,28857]],[[13150,13150],"mapped",[54,28857]],[[13151,13151],"mapped",[55,28857]],[[13152,13152],"mapped",[56,28857]],[[13153,13153],"mapped",[57,28857]],[[13154,13154],"mapped",[49,48,28857]],[[13155,13155],"mapped",[49,49,28857]],[[13156,13156],"mapped",[49,50,28857]],[[13157,13157],"mapped",[49,51,28857]],[[13158,13158],"mapped",[49,52,28857]],[[13159,13159],"mapped",[49,53,28857]],[[13160,13160],"mapped",[49,54,28857]],[[13161,13161],"mapped",[49,55,28857]],[[13162,13162],"mapped",[49,56,28857]],[[13163,13163],"mapped",[49,57,28857]],[[13164,13164],"mapped",[50,48,28857]],[[13165,13165],"mapped",[50,49,28857]],[[13166,13166],"mapped",[50,50,28857]],[[13167,13167],"mapped",[50,51,28857]],[[13168,13168],"mapped",[50,52,28857]],[[13169,13169],"mapped",[104,112,97]],[[13170,13170],"mapped",[100,97]],[[13171,13171],"mapped",[97,117]],[[13172,13172],"mapped",[98,97,114]],[[13173,13173],"mapped",[111,118]],[[13174,13174],"mapped",[112,99]],[[13175,13175],"mapped",[100,109]],[[13176,13176],"mapped",[100,109,50]],[[13177,13177],"mapped",[100,109,51]],[[13178,13178],"mapped",[105,117]],[[13179,13179],"mapped",[24179,25104]],[[13180,13180],"mapped",[26157,21644]],[[13181,13181],"mapped",[22823,27491]],[[13182,13182],"mapped",[26126,27835]],[[13183,13183],"mapped",[26666,24335,20250,31038]],[[13184,13184],"mapped",[112,97]],[[13185,13185],"mapped",[110,97]],[[13186,13186],"mapped",[956,97]],[[13187,13187],"mapped",[109,97]],[[13188,13188],"mapped",[107,97]],[[13189,13189],"mapped",[107,98]],[[13190,13190],"mapped",[109,98]],[[13191,13191],"mapped",[103,98]],[[13192,13192],"mapped",[99,97,108]],[[13193,13193],"mapped",[107,99,97,108]],[[13194,13194],"mapped",[112,102]],[[13195,13195],"mapped",[110,102]],[[13196,13196],"mapped",[956,102]],[[13197,13197],"mapped",[956,103]],[[13198,13198],"mapped",[109,103]],[[13199,13199],"mapped",[107,103]],[[13200,13200],"mapped",[104,122]],[[13201,13201],"mapped",[107,104,122]],[[13202,13202],"mapped",[109,104,122]],[[13203,13203],"mapped",[103,104,122]],[[13204,13204],"mapped",[116,104,122]],[[13205,13205],"mapped",[956,108]],[[13206,13206],"mapped",[109,108]],[[13207,13207],"mapped",[100,108]],[[13208,13208],"mapped",[107,108]],[[13209,13209],"mapped",[102,109]],[[13210,13210],"mapped",[110,109]],[[13211,13211],"mapped",[956,109]],[[13212,13212],"mapped",[109,109]],[[13213,13213],"mapped",[99,109]],[[13214,13214],"mapped",[107,109]],[[13215,13215],"mapped",[109,109,50]],[[13216,13216],"mapped",[99,109,50]],[[13217,13217],"mapped",[109,50]],[[13218,13218],"mapped",[107,109,50]],[[13219,13219],"mapped",[109,109,51]],[[13220,13220],"mapped",[99,109,51]],[[13221,13221],"mapped",[109,51]],[[13222,13222],"mapped",[107,109,51]],[[13223,13223],"mapped",[109,8725,115]],[[13224,13224],"mapped",[109,8725,115,50]],[[13225,13225],"mapped",[112,97]],[[13226,13226],"mapped",[107,112,97]],[[13227,13227],"mapped",[109,112,97]],[[13228,13228],"mapped",[103,112,97]],[[13229,13229],"mapped",[114,97,100]],[[13230,13230],"mapped",[114,97,100,8725,115]],[[13231,13231],"mapped",[114,97,100,8725,115,50]],[[13232,13232],"mapped",[112,115]],[[13233,13233],"mapped",[110,115]],[[13234,13234],"mapped",[956,115]],[[13235,13235],"mapped",[109,115]],[[13236,13236],"mapped",[112,118]],[[13237,13237],"mapped",[110,118]],[[13238,13238],"mapped",[956,118]],[[13239,13239],"mapped",[109,118]],[[13240,13240],"mapped",[107,118]],[[13241,13241],"mapped",[109,118]],[[13242,13242],"mapped",[112,119]],[[13243,13243],"mapped",[110,119]],[[13244,13244],"mapped",[956,119]],[[13245,13245],"mapped",[109,119]],[[13246,13246],"mapped",[107,119]],[[13247,13247],"mapped",[109,119]],[[13248,13248],"mapped",[107,969]],[[13249,13249],"mapped",[109,969]],[[13250,13250],"disallowed"],[[13251,13251],"mapped",[98,113]],[[13252,13252],"mapped",[99,99]],[[13253,13253],"mapped",[99,100]],[[13254,13254],"mapped",[99,8725,107,103]],[[13255,13255],"disallowed"],[[13256,13256],"mapped",[100,98]],[[13257,13257],"mapped",[103,121]],[[13258,13258],"mapped",[104,97]],[[13259,13259],"mapped",[104,112]],[[13260,13260],"mapped",[105,110]],[[13261,13261],"mapped",[107,107]],[[13262,13262],"mapped",[107,109]],[[13263,13263],"mapped",[107,116]],[[13264,13264],"mapped",[108,109]],[[13265,13265],"mapped",[108,110]],[[13266,13266],"mapped",[108,111,103]],[[13267,13267],"mapped",[108,120]],[[13268,13268],"mapped",[109,98]],[[13269,13269],"mapped",[109,105,108]],[[13270,13270],"mapped",[109,111,108]],[[13271,13271],"mapped",[112,104]],[[13272,13272],"disallowed"],[[13273,13273],"mapped",[112,112,109]],[[13274,13274],"mapped",[112,114]],[[13275,13275],"mapped",[115,114]],[[13276,13276],"mapped",[115,118]],[[13277,13277],"mapped",[119,98]],[[13278,13278],"mapped",[118,8725,109]],[[13279,13279],"mapped",[97,8725,109]],[[13280,13280],"mapped",[49,26085]],[[13281,13281],"mapped",[50,26085]],[[13282,13282],"mapped",[51,26085]],[[13283,13283],"mapped",[52,26085]],[[13284,13284],"mapped",[53,26085]],[[13285,13285],"mapped",[54,26085]],[[13286,13286],"mapped",[55,26085]],[[13287,13287],"mapped",[56,26085]],[[13288,13288],"mapped",[57,26085]],[[13289,13289],"mapped",[49,48,26085]],[[13290,13290],"mapped",[49,49,26085]],[[13291,13291],"mapped",[49,50,26085]],[[13292,13292],"mapped",[49,51,26085]],[[13293,13293],"mapped",[49,52,26085]],[[13294,13294],"mapped",[49,53,26085]],[[13295,13295],"mapped",[49,54,26085]],[[13296,13296],"mapped",[49,55,26085]],[[13297,13297],"mapped",[49,56,26085]],[[13298,13298],"mapped",[49,57,26085]],[[13299,13299],"mapped",[50,48,26085]],[[13300,13300],"mapped",[50,49,26085]],[[13301,13301],"mapped",[50,50,26085]],[[13302,13302],"mapped",[50,51,26085]],[[13303,13303],"mapped",[50,52,26085]],[[13304,13304],"mapped",[50,53,26085]],[[13305,13305],"mapped",[50,54,26085]],[[13306,13306],"mapped",[50,55,26085]],[[13307,13307],"mapped",[50,56,26085]],[[13308,13308],"mapped",[50,57,26085]],[[13309,13309],"mapped",[51,48,26085]],[[13310,13310],"mapped",[51,49,26085]],[[13311,13311],"mapped",[103,97,108]],[[13312,19893],"valid"],[[19894,19903],"disallowed"],[[19904,19967],"valid",[],"NV8"],[[19968,40869],"valid"],[[40870,40891],"valid"],[[40892,40899],"valid"],[[40900,40907],"valid"],[[40908,40908],"valid"],[[40909,40917],"valid"],[[40918,40959],"disallowed"],[[40960,42124],"valid"],[[42125,42127],"disallowed"],[[42128,42145],"valid",[],"NV8"],[[42146,42147],"valid",[],"NV8"],[[42148,42163],"valid",[],"NV8"],[[42164,42164],"valid",[],"NV8"],[[42165,42176],"valid",[],"NV8"],[[42177,42177],"valid",[],"NV8"],[[42178,42180],"valid",[],"NV8"],[[42181,42181],"valid",[],"NV8"],[[42182,42182],"valid",[],"NV8"],[[42183,42191],"disallowed"],[[42192,42237],"valid"],[[42238,42239],"valid",[],"NV8"],[[42240,42508],"valid"],[[42509,42511],"valid",[],"NV8"],[[42512,42539],"valid"],[[42540,42559],"disallowed"],[[42560,42560],"mapped",[42561]],[[42561,42561],"valid"],[[42562,42562],"mapped",[42563]],[[42563,42563],"valid"],[[42564,42564],"mapped",[42565]],[[42565,42565],"valid"],[[42566,42566],"mapped",[42567]],[[42567,42567],"valid"],[[42568,42568],"mapped",[42569]],[[42569,42569],"valid"],[[42570,42570],"mapped",[42571]],[[42571,42571],"valid"],[[42572,42572],"mapped",[42573]],[[42573,42573],"valid"],[[42574,42574],"mapped",[42575]],[[42575,42575],"valid"],[[42576,42576],"mapped",[42577]],[[42577,42577],"valid"],[[42578,42578],"mapped",[42579]],[[42579,42579],"valid"],[[42580,42580],"mapped",[42581]],[[42581,42581],"valid"],[[42582,42582],"mapped",[42583]],[[42583,42583],"valid"],[[42584,42584],"mapped",[42585]],[[42585,42585],"valid"],[[42586,42586],"mapped",[42587]],[[42587,42587],"valid"],[[42588,42588],"mapped",[42589]],[[42589,42589],"valid"],[[42590,42590],"mapped",[42591]],[[42591,42591],"valid"],[[42592,42592],"mapped",[42593]],[[42593,42593],"valid"],[[42594,42594],"mapped",[42595]],[[42595,42595],"valid"],[[42596,42596],"mapped",[42597]],[[42597,42597],"valid"],[[42598,42598],"mapped",[42599]],[[42599,42599],"valid"],[[42600,42600],"mapped",[42601]],[[42601,42601],"valid"],[[42602,42602],"mapped",[42603]],[[42603,42603],"valid"],[[42604,42604],"mapped",[42605]],[[42605,42607],"valid"],[[42608,42611],"valid",[],"NV8"],[[42612,42619],"valid"],[[42620,42621],"valid"],[[42622,42622],"valid",[],"NV8"],[[42623,42623],"valid"],[[42624,42624],"mapped",[42625]],[[42625,42625],"valid"],[[42626,42626],"mapped",[42627]],[[42627,42627],"valid"],[[42628,42628],"mapped",[42629]],[[42629,42629],"valid"],[[42630,42630],"mapped",[42631]],[[42631,42631],"valid"],[[42632,42632],"mapped",[42633]],[[42633,42633],"valid"],[[42634,42634],"mapped",[42635]],[[42635,42635],"valid"],[[42636,42636],"mapped",[42637]],[[42637,42637],"valid"],[[42638,42638],"mapped",[42639]],[[42639,42639],"valid"],[[42640,42640],"mapped",[42641]],[[42641,42641],"valid"],[[42642,42642],"mapped",[42643]],[[42643,42643],"valid"],[[42644,42644],"mapped",[42645]],[[42645,42645],"valid"],[[42646,42646],"mapped",[42647]],[[42647,42647],"valid"],[[42648,42648],"mapped",[42649]],[[42649,42649],"valid"],[[42650,42650],"mapped",[42651]],[[42651,42651],"valid"],[[42652,42652],"mapped",[1098]],[[42653,42653],"mapped",[1100]],[[42654,42654],"valid"],[[42655,42655],"valid"],[[42656,42725],"valid"],[[42726,42735],"valid",[],"NV8"],[[42736,42737],"valid"],[[42738,42743],"valid",[],"NV8"],[[42744,42751],"disallowed"],[[42752,42774],"valid",[],"NV8"],[[42775,42778],"valid"],[[42779,42783],"valid"],[[42784,42785],"valid",[],"NV8"],[[42786,42786],"mapped",[42787]],[[42787,42787],"valid"],[[42788,42788],"mapped",[42789]],[[42789,42789],"valid"],[[42790,42790],"mapped",[42791]],[[42791,42791],"valid"],[[42792,42792],"mapped",[42793]],[[42793,42793],"valid"],[[42794,42794],"mapped",[42795]],[[42795,42795],"valid"],[[42796,42796],"mapped",[42797]],[[42797,42797],"valid"],[[42798,42798],"mapped",[42799]],[[42799,42801],"valid"],[[42802,42802],"mapped",[42803]],[[42803,42803],"valid"],[[42804,42804],"mapped",[42805]],[[42805,42805],"valid"],[[42806,42806],"mapped",[42807]],[[42807,42807],"valid"],[[42808,42808],"mapped",[42809]],[[42809,42809],"valid"],[[42810,42810],"mapped",[42811]],[[42811,42811],"valid"],[[42812,42812],"mapped",[42813]],[[42813,42813],"valid"],[[42814,42814],"mapped",[42815]],[[42815,42815],"valid"],[[42816,42816],"mapped",[42817]],[[42817,42817],"valid"],[[42818,42818],"mapped",[42819]],[[42819,42819],"valid"],[[42820,42820],"mapped",[42821]],[[42821,42821],"valid"],[[42822,42822],"mapped",[42823]],[[42823,42823],"valid"],[[42824,42824],"mapped",[42825]],[[42825,42825],"valid"],[[42826,42826],"mapped",[42827]],[[42827,42827],"valid"],[[42828,42828],"mapped",[42829]],[[42829,42829],"valid"],[[42830,42830],"mapped",[42831]],[[42831,42831],"valid"],[[42832,42832],"mapped",[42833]],[[42833,42833],"valid"],[[42834,42834],"mapped",[42835]],[[42835,42835],"valid"],[[42836,42836],"mapped",[42837]],[[42837,42837],"valid"],[[42838,42838],"mapped",[42839]],[[42839,42839],"valid"],[[42840,42840],"mapped",[42841]],[[42841,42841],"valid"],[[42842,42842],"mapped",[42843]],[[42843,42843],"valid"],[[42844,42844],"mapped",[42845]],[[42845,42845],"valid"],[[42846,42846],"mapped",[42847]],[[42847,42847],"valid"],[[42848,42848],"mapped",[42849]],[[42849,42849],"valid"],[[42850,42850],"mapped",[42851]],[[42851,42851],"valid"],[[42852,42852],"mapped",[42853]],[[42853,42853],"valid"],[[42854,42854],"mapped",[42855]],[[42855,42855],"valid"],[[42856,42856],"mapped",[42857]],[[42857,42857],"valid"],[[42858,42858],"mapped",[42859]],[[42859,42859],"valid"],[[42860,42860],"mapped",[42861]],[[42861,42861],"valid"],[[42862,42862],"mapped",[42863]],[[42863,42863],"valid"],[[42864,42864],"mapped",[42863]],[[42865,42872],"valid"],[[42873,42873],"mapped",[42874]],[[42874,42874],"valid"],[[42875,42875],"mapped",[42876]],[[42876,42876],"valid"],[[42877,42877],"mapped",[7545]],[[42878,42878],"mapped",[42879]],[[42879,42879],"valid"],[[42880,42880],"mapped",[42881]],[[42881,42881],"valid"],[[42882,42882],"mapped",[42883]],[[42883,42883],"valid"],[[42884,42884],"mapped",[42885]],[[42885,42885],"valid"],[[42886,42886],"mapped",[42887]],[[42887,42888],"valid"],[[42889,42890],"valid",[],"NV8"],[[42891,42891],"mapped",[42892]],[[42892,42892],"valid"],[[42893,42893],"mapped",[613]],[[42894,42894],"valid"],[[42895,42895],"valid"],[[42896,42896],"mapped",[42897]],[[42897,42897],"valid"],[[42898,42898],"mapped",[42899]],[[42899,42899],"valid"],[[42900,42901],"valid"],[[42902,42902],"mapped",[42903]],[[42903,42903],"valid"],[[42904,42904],"mapped",[42905]],[[42905,42905],"valid"],[[42906,42906],"mapped",[42907]],[[42907,42907],"valid"],[[42908,42908],"mapped",[42909]],[[42909,42909],"valid"],[[42910,42910],"mapped",[42911]],[[42911,42911],"valid"],[[42912,42912],"mapped",[42913]],[[42913,42913],"valid"],[[42914,42914],"mapped",[42915]],[[42915,42915],"valid"],[[42916,42916],"mapped",[42917]],[[42917,42917],"valid"],[[42918,42918],"mapped",[42919]],[[42919,42919],"valid"],[[42920,42920],"mapped",[42921]],[[42921,42921],"valid"],[[42922,42922],"mapped",[614]],[[42923,42923],"mapped",[604]],[[42924,42924],"mapped",[609]],[[42925,42925],"mapped",[620]],[[42926,42927],"disallowed"],[[42928,42928],"mapped",[670]],[[42929,42929],"mapped",[647]],[[42930,42930],"mapped",[669]],[[42931,42931],"mapped",[43859]],[[42932,42932],"mapped",[42933]],[[42933,42933],"valid"],[[42934,42934],"mapped",[42935]],[[42935,42935],"valid"],[[42936,42998],"disallowed"],[[42999,42999],"valid"],[[43000,43000],"mapped",[295]],[[43001,43001],"mapped",[339]],[[43002,43002],"valid"],[[43003,43007],"valid"],[[43008,43047],"valid"],[[43048,43051],"valid",[],"NV8"],[[43052,43055],"disallowed"],[[43056,43065],"valid",[],"NV8"],[[43066,43071],"disallowed"],[[43072,43123],"valid"],[[43124,43127],"valid",[],"NV8"],[[43128,43135],"disallowed"],[[43136,43204],"valid"],[[43205,43213],"disallowed"],[[43214,43215],"valid",[],"NV8"],[[43216,43225],"valid"],[[43226,43231],"disallowed"],[[43232,43255],"valid"],[[43256,43258],"valid",[],"NV8"],[[43259,43259],"valid"],[[43260,43260],"valid",[],"NV8"],[[43261,43261],"valid"],[[43262,43263],"disallowed"],[[43264,43309],"valid"],[[43310,43311],"valid",[],"NV8"],[[43312,43347],"valid"],[[43348,43358],"disallowed"],[[43359,43359],"valid",[],"NV8"],[[43360,43388],"valid",[],"NV8"],[[43389,43391],"disallowed"],[[43392,43456],"valid"],[[43457,43469],"valid",[],"NV8"],[[43470,43470],"disallowed"],[[43471,43481],"valid"],[[43482,43485],"disallowed"],[[43486,43487],"valid",[],"NV8"],[[43488,43518],"valid"],[[43519,43519],"disallowed"],[[43520,43574],"valid"],[[43575,43583],"disallowed"],[[43584,43597],"valid"],[[43598,43599],"disallowed"],[[43600,43609],"valid"],[[43610,43611],"disallowed"],[[43612,43615],"valid",[],"NV8"],[[43616,43638],"valid"],[[43639,43641],"valid",[],"NV8"],[[43642,43643],"valid"],[[43644,43647],"valid"],[[43648,43714],"valid"],[[43715,43738],"disallowed"],[[43739,43741],"valid"],[[43742,43743],"valid",[],"NV8"],[[43744,43759],"valid"],[[43760,43761],"valid",[],"NV8"],[[43762,43766],"valid"],[[43767,43776],"disallowed"],[[43777,43782],"valid"],[[43783,43784],"disallowed"],[[43785,43790],"valid"],[[43791,43792],"disallowed"],[[43793,43798],"valid"],[[43799,43807],"disallowed"],[[43808,43814],"valid"],[[43815,43815],"disallowed"],[[43816,43822],"valid"],[[43823,43823],"disallowed"],[[43824,43866],"valid"],[[43867,43867],"valid",[],"NV8"],[[43868,43868],"mapped",[42791]],[[43869,43869],"mapped",[43831]],[[43870,43870],"mapped",[619]],[[43871,43871],"mapped",[43858]],[[43872,43875],"valid"],[[43876,43877],"valid"],[[43878,43887],"disallowed"],[[43888,43888],"mapped",[5024]],[[43889,43889],"mapped",[5025]],[[43890,43890],"mapped",[5026]],[[43891,43891],"mapped",[5027]],[[43892,43892],"mapped",[5028]],[[43893,43893],"mapped",[5029]],[[43894,43894],"mapped",[5030]],[[43895,43895],"mapped",[5031]],[[43896,43896],"mapped",[5032]],[[43897,43897],"mapped",[5033]],[[43898,43898],"mapped",[5034]],[[43899,43899],"mapped",[5035]],[[43900,43900],"mapped",[5036]],[[43901,43901],"mapped",[5037]],[[43902,43902],"mapped",[5038]],[[43903,43903],"mapped",[5039]],[[43904,43904],"mapped",[5040]],[[43905,43905],"mapped",[5041]],[[43906,43906],"mapped",[5042]],[[43907,43907],"mapped",[5043]],[[43908,43908],"mapped",[5044]],[[43909,43909],"mapped",[5045]],[[43910,43910],"mapped",[5046]],[[43911,43911],"mapped",[5047]],[[43912,43912],"mapped",[5048]],[[43913,43913],"mapped",[5049]],[[43914,43914],"mapped",[5050]],[[43915,43915],"mapped",[5051]],[[43916,43916],"mapped",[5052]],[[43917,43917],"mapped",[5053]],[[43918,43918],"mapped",[5054]],[[43919,43919],"mapped",[5055]],[[43920,43920],"mapped",[5056]],[[43921,43921],"mapped",[5057]],[[43922,43922],"mapped",[5058]],[[43923,43923],"mapped",[5059]],[[43924,43924],"mapped",[5060]],[[43925,43925],"mapped",[5061]],[[43926,43926],"mapped",[5062]],[[43927,43927],"mapped",[5063]],[[43928,43928],"mapped",[5064]],[[43929,43929],"mapped",[5065]],[[43930,43930],"mapped",[5066]],[[43931,43931],"mapped",[5067]],[[43932,43932],"mapped",[5068]],[[43933,43933],"mapped",[5069]],[[43934,43934],"mapped",[5070]],[[43935,43935],"mapped",[5071]],[[43936,43936],"mapped",[5072]],[[43937,43937],"mapped",[5073]],[[43938,43938],"mapped",[5074]],[[43939,43939],"mapped",[5075]],[[43940,43940],"mapped",[5076]],[[43941,43941],"mapped",[5077]],[[43942,43942],"mapped",[5078]],[[43943,43943],"mapped",[5079]],[[43944,43944],"mapped",[5080]],[[43945,43945],"mapped",[5081]],[[43946,43946],"mapped",[5082]],[[43947,43947],"mapped",[5083]],[[43948,43948],"mapped",[5084]],[[43949,43949],"mapped",[5085]],[[43950,43950],"mapped",[5086]],[[43951,43951],"mapped",[5087]],[[43952,43952],"mapped",[5088]],[[43953,43953],"mapped",[5089]],[[43954,43954],"mapped",[5090]],[[43955,43955],"mapped",[5091]],[[43956,43956],"mapped",[5092]],[[43957,43957],"mapped",[5093]],[[43958,43958],"mapped",[5094]],[[43959,43959],"mapped",[5095]],[[43960,43960],"mapped",[5096]],[[43961,43961],"mapped",[5097]],[[43962,43962],"mapped",[5098]],[[43963,43963],"mapped",[5099]],[[43964,43964],"mapped",[5100]],[[43965,43965],"mapped",[5101]],[[43966,43966],"mapped",[5102]],[[43967,43967],"mapped",[5103]],[[43968,44010],"valid"],[[44011,44011],"valid",[],"NV8"],[[44012,44013],"valid"],[[44014,44015],"disallowed"],[[44016,44025],"valid"],[[44026,44031],"disallowed"],[[44032,55203],"valid"],[[55204,55215],"disallowed"],[[55216,55238],"valid",[],"NV8"],[[55239,55242],"disallowed"],[[55243,55291],"valid",[],"NV8"],[[55292,55295],"disallowed"],[[55296,57343],"disallowed"],[[57344,63743],"disallowed"],[[63744,63744],"mapped",[35912]],[[63745,63745],"mapped",[26356]],[[63746,63746],"mapped",[36554]],[[63747,63747],"mapped",[36040]],[[63748,63748],"mapped",[28369]],[[63749,63749],"mapped",[20018]],[[63750,63750],"mapped",[21477]],[[63751,63752],"mapped",[40860]],[[63753,63753],"mapped",[22865]],[[63754,63754],"mapped",[37329]],[[63755,63755],"mapped",[21895]],[[63756,63756],"mapped",[22856]],[[63757,63757],"mapped",[25078]],[[63758,63758],"mapped",[30313]],[[63759,63759],"mapped",[32645]],[[63760,63760],"mapped",[34367]],[[63761,63761],"mapped",[34746]],[[63762,63762],"mapped",[35064]],[[63763,63763],"mapped",[37007]],[[63764,63764],"mapped",[27138]],[[63765,63765],"mapped",[27931]],[[63766,63766],"mapped",[28889]],[[63767,63767],"mapped",[29662]],[[63768,63768],"mapped",[33853]],[[63769,63769],"mapped",[37226]],[[63770,63770],"mapped",[39409]],[[63771,63771],"mapped",[20098]],[[63772,63772],"mapped",[21365]],[[63773,63773],"mapped",[27396]],[[63774,63774],"mapped",[29211]],[[63775,63775],"mapped",[34349]],[[63776,63776],"mapped",[40478]],[[63777,63777],"mapped",[23888]],[[63778,63778],"mapped",[28651]],[[63779,63779],"mapped",[34253]],[[63780,63780],"mapped",[35172]],[[63781,63781],"mapped",[25289]],[[63782,63782],"mapped",[33240]],[[63783,63783],"mapped",[34847]],[[63784,63784],"mapped",[24266]],[[63785,63785],"mapped",[26391]],[[63786,63786],"mapped",[28010]],[[63787,63787],"mapped",[29436]],[[63788,63788],"mapped",[37070]],[[63789,63789],"mapped",[20358]],[[63790,63790],"mapped",[20919]],[[63791,63791],"mapped",[21214]],[[63792,63792],"mapped",[25796]],[[63793,63793],"mapped",[27347]],[[63794,63794],"mapped",[29200]],[[63795,63795],"mapped",[30439]],[[63796,63796],"mapped",[32769]],[[63797,63797],"mapped",[34310]],[[63798,63798],"mapped",[34396]],[[63799,63799],"mapped",[36335]],[[63800,63800],"mapped",[38706]],[[63801,63801],"mapped",[39791]],[[63802,63802],"mapped",[40442]],[[63803,63803],"mapped",[30860]],[[63804,63804],"mapped",[31103]],[[63805,63805],"mapped",[32160]],[[63806,63806],"mapped",[33737]],[[63807,63807],"mapped",[37636]],[[63808,63808],"mapped",[40575]],[[63809,63809],"mapped",[35542]],[[63810,63810],"mapped",[22751]],[[63811,63811],"mapped",[24324]],[[63812,63812],"mapped",[31840]],[[63813,63813],"mapped",[32894]],[[63814,63814],"mapped",[29282]],[[63815,63815],"mapped",[30922]],[[63816,63816],"mapped",[36034]],[[63817,63817],"mapped",[38647]],[[63818,63818],"mapped",[22744]],[[63819,63819],"mapped",[23650]],[[63820,63820],"mapped",[27155]],[[63821,63821],"mapped",[28122]],[[63822,63822],"mapped",[28431]],[[63823,63823],"mapped",[32047]],[[63824,63824],"mapped",[32311]],[[63825,63825],"mapped",[38475]],[[63826,63826],"mapped",[21202]],[[63827,63827],"mapped",[32907]],[[63828,63828],"mapped",[20956]],[[63829,63829],"mapped",[20940]],[[63830,63830],"mapped",[31260]],[[63831,63831],"mapped",[32190]],[[63832,63832],"mapped",[33777]],[[63833,63833],"mapped",[38517]],[[63834,63834],"mapped",[35712]],[[63835,63835],"mapped",[25295]],[[63836,63836],"mapped",[27138]],[[63837,63837],"mapped",[35582]],[[63838,63838],"mapped",[20025]],[[63839,63839],"mapped",[23527]],[[63840,63840],"mapped",[24594]],[[63841,63841],"mapped",[29575]],[[63842,63842],"mapped",[30064]],[[63843,63843],"mapped",[21271]],[[63844,63844],"mapped",[30971]],[[63845,63845],"mapped",[20415]],[[63846,63846],"mapped",[24489]],[[63847,63847],"mapped",[19981]],[[63848,63848],"mapped",[27852]],[[63849,63849],"mapped",[25976]],[[63850,63850],"mapped",[32034]],[[63851,63851],"mapped",[21443]],[[63852,63852],"mapped",[22622]],[[63853,63853],"mapped",[30465]],[[63854,63854],"mapped",[33865]],[[63855,63855],"mapped",[35498]],[[63856,63856],"mapped",[27578]],[[63857,63857],"mapped",[36784]],[[63858,63858],"mapped",[27784]],[[63859,63859],"mapped",[25342]],[[63860,63860],"mapped",[33509]],[[63861,63861],"mapped",[25504]],[[63862,63862],"mapped",[30053]],[[63863,63863],"mapped",[20142]],[[63864,63864],"mapped",[20841]],[[63865,63865],"mapped",[20937]],[[63866,63866],"mapped",[26753]],[[63867,63867],"mapped",[31975]],[[63868,63868],"mapped",[33391]],[[63869,63869],"mapped",[35538]],[[63870,63870],"mapped",[37327]],[[63871,63871],"mapped",[21237]],[[63872,63872],"mapped",[21570]],[[63873,63873],"mapped",[22899]],[[63874,63874],"mapped",[24300]],[[63875,63875],"mapped",[26053]],[[63876,63876],"mapped",[28670]],[[63877,63877],"mapped",[31018]],[[63878,63878],"mapped",[38317]],[[63879,63879],"mapped",[39530]],[[63880,63880],"mapped",[40599]],[[63881,63881],"mapped",[40654]],[[63882,63882],"mapped",[21147]],[[63883,63883],"mapped",[26310]],[[63884,63884],"mapped",[27511]],[[63885,63885],"mapped",[36706]],[[63886,63886],"mapped",[24180]],[[63887,63887],"mapped",[24976]],[[63888,63888],"mapped",[25088]],[[63889,63889],"mapped",[25754]],[[63890,63890],"mapped",[28451]],[[63891,63891],"mapped",[29001]],[[63892,63892],"mapped",[29833]],[[63893,63893],"mapped",[31178]],[[63894,63894],"mapped",[32244]],[[63895,63895],"mapped",[32879]],[[63896,63896],"mapped",[36646]],[[63897,63897],"mapped",[34030]],[[63898,63898],"mapped",[36899]],[[63899,63899],"mapped",[37706]],[[63900,63900],"mapped",[21015]],[[63901,63901],"mapped",[21155]],[[63902,63902],"mapped",[21693]],[[63903,63903],"mapped",[28872]],[[63904,63904],"mapped",[35010]],[[63905,63905],"mapped",[35498]],[[63906,63906],"mapped",[24265]],[[63907,63907],"mapped",[24565]],[[63908,63908],"mapped",[25467]],[[63909,63909],"mapped",[27566]],[[63910,63910],"mapped",[31806]],[[63911,63911],"mapped",[29557]],[[63912,63912],"mapped",[20196]],[[63913,63913],"mapped",[22265]],[[63914,63914],"mapped",[23527]],[[63915,63915],"mapped",[23994]],[[63916,63916],"mapped",[24604]],[[63917,63917],"mapped",[29618]],[[63918,63918],"mapped",[29801]],[[63919,63919],"mapped",[32666]],[[63920,63920],"mapped",[32838]],[[63921,63921],"mapped",[37428]],[[63922,63922],"mapped",[38646]],[[63923,63923],"mapped",[38728]],[[63924,63924],"mapped",[38936]],[[63925,63925],"mapped",[20363]],[[63926,63926],"mapped",[31150]],[[63927,63927],"mapped",[37300]],[[63928,63928],"mapped",[38584]],[[63929,63929],"mapped",[24801]],[[63930,63930],"mapped",[20102]],[[63931,63931],"mapped",[20698]],[[63932,63932],"mapped",[23534]],[[63933,63933],"mapped",[23615]],[[63934,63934],"mapped",[26009]],[[63935,63935],"mapped",[27138]],[[63936,63936],"mapped",[29134]],[[63937,63937],"mapped",[30274]],[[63938,63938],"mapped",[34044]],[[63939,63939],"mapped",[36988]],[[63940,63940],"mapped",[40845]],[[63941,63941],"mapped",[26248]],[[63942,63942],"mapped",[38446]],[[63943,63943],"mapped",[21129]],[[63944,63944],"mapped",[26491]],[[63945,63945],"mapped",[26611]],[[63946,63946],"mapped",[27969]],[[63947,63947],"mapped",[28316]],[[63948,63948],"mapped",[29705]],[[63949,63949],"mapped",[30041]],[[63950,63950],"mapped",[30827]],[[63951,63951],"mapped",[32016]],[[63952,63952],"mapped",[39006]],[[63953,63953],"mapped",[20845]],[[63954,63954],"mapped",[25134]],[[63955,63955],"mapped",[38520]],[[63956,63956],"mapped",[20523]],[[63957,63957],"mapped",[23833]],[[63958,63958],"mapped",[28138]],[[63959,63959],"mapped",[36650]],[[63960,63960],"mapped",[24459]],[[63961,63961],"mapped",[24900]],[[63962,63962],"mapped",[26647]],[[63963,63963],"mapped",[29575]],[[63964,63964],"mapped",[38534]],[[63965,63965],"mapped",[21033]],[[63966,63966],"mapped",[21519]],[[63967,63967],"mapped",[23653]],[[63968,63968],"mapped",[26131]],[[63969,63969],"mapped",[26446]],[[63970,63970],"mapped",[26792]],[[63971,63971],"mapped",[27877]],[[63972,63972],"mapped",[29702]],[[63973,63973],"mapped",[30178]],[[63974,63974],"mapped",[32633]],[[63975,63975],"mapped",[35023]],[[63976,63976],"mapped",[35041]],[[63977,63977],"mapped",[37324]],[[63978,63978],"mapped",[38626]],[[63979,63979],"mapped",[21311]],[[63980,63980],"mapped",[28346]],[[63981,63981],"mapped",[21533]],[[63982,63982],"mapped",[29136]],[[63983,63983],"mapped",[29848]],[[63984,63984],"mapped",[34298]],[[63985,63985],"mapped",[38563]],[[63986,63986],"mapped",[40023]],[[63987,63987],"mapped",[40607]],[[63988,63988],"mapped",[26519]],[[63989,63989],"mapped",[28107]],[[63990,63990],"mapped",[33256]],[[63991,63991],"mapped",[31435]],[[63992,63992],"mapped",[31520]],[[63993,63993],"mapped",[31890]],[[63994,63994],"mapped",[29376]],[[63995,63995],"mapped",[28825]],[[63996,63996],"mapped",[35672]],[[63997,63997],"mapped",[20160]],[[63998,63998],"mapped",[33590]],[[63999,63999],"mapped",[21050]],[[64000,64000],"mapped",[20999]],[[64001,64001],"mapped",[24230]],[[64002,64002],"mapped",[25299]],[[64003,64003],"mapped",[31958]],[[64004,64004],"mapped",[23429]],[[64005,64005],"mapped",[27934]],[[64006,64006],"mapped",[26292]],[[64007,64007],"mapped",[36667]],[[64008,64008],"mapped",[34892]],[[64009,64009],"mapped",[38477]],[[64010,64010],"mapped",[35211]],[[64011,64011],"mapped",[24275]],[[64012,64012],"mapped",[20800]],[[64013,64013],"mapped",[21952]],[[64014,64015],"valid"],[[64016,64016],"mapped",[22618]],[[64017,64017],"valid"],[[64018,64018],"mapped",[26228]],[[64019,64020],"valid"],[[64021,64021],"mapped",[20958]],[[64022,64022],"mapped",[29482]],[[64023,64023],"mapped",[30410]],[[64024,64024],"mapped",[31036]],[[64025,64025],"mapped",[31070]],[[64026,64026],"mapped",[31077]],[[64027,64027],"mapped",[31119]],[[64028,64028],"mapped",[38742]],[[64029,64029],"mapped",[31934]],[[64030,64030],"mapped",[32701]],[[64031,64031],"valid"],[[64032,64032],"mapped",[34322]],[[64033,64033],"valid"],[[64034,64034],"mapped",[35576]],[[64035,64036],"valid"],[[64037,64037],"mapped",[36920]],[[64038,64038],"mapped",[37117]],[[64039,64041],"valid"],[[64042,64042],"mapped",[39151]],[[64043,64043],"mapped",[39164]],[[64044,64044],"mapped",[39208]],[[64045,64045],"mapped",[40372]],[[64046,64046],"mapped",[37086]],[[64047,64047],"mapped",[38583]],[[64048,64048],"mapped",[20398]],[[64049,64049],"mapped",[20711]],[[64050,64050],"mapped",[20813]],[[64051,64051],"mapped",[21193]],[[64052,64052],"mapped",[21220]],[[64053,64053],"mapped",[21329]],[[64054,64054],"mapped",[21917]],[[64055,64055],"mapped",[22022]],[[64056,64056],"mapped",[22120]],[[64057,64057],"mapped",[22592]],[[64058,64058],"mapped",[22696]],[[64059,64059],"mapped",[23652]],[[64060,64060],"mapped",[23662]],[[64061,64061],"mapped",[24724]],[[64062,64062],"mapped",[24936]],[[64063,64063],"mapped",[24974]],[[64064,64064],"mapped",[25074]],[[64065,64065],"mapped",[25935]],[[64066,64066],"mapped",[26082]],[[64067,64067],"mapped",[26257]],[[64068,64068],"mapped",[26757]],[[64069,64069],"mapped",[28023]],[[64070,64070],"mapped",[28186]],[[64071,64071],"mapped",[28450]],[[64072,64072],"mapped",[29038]],[[64073,64073],"mapped",[29227]],[[64074,64074],"mapped",[29730]],[[64075,64075],"mapped",[30865]],[[64076,64076],"mapped",[31038]],[[64077,64077],"mapped",[31049]],[[64078,64078],"mapped",[31048]],[[64079,64079],"mapped",[31056]],[[64080,64080],"mapped",[31062]],[[64081,64081],"mapped",[31069]],[[64082,64082],"mapped",[31117]],[[64083,64083],"mapped",[31118]],[[64084,64084],"mapped",[31296]],[[64085,64085],"mapped",[31361]],[[64086,64086],"mapped",[31680]],[[64087,64087],"mapped",[32244]],[[64088,64088],"mapped",[32265]],[[64089,64089],"mapped",[32321]],[[64090,64090],"mapped",[32626]],[[64091,64091],"mapped",[32773]],[[64092,64092],"mapped",[33261]],[[64093,64094],"mapped",[33401]],[[64095,64095],"mapped",[33879]],[[64096,64096],"mapped",[35088]],[[64097,64097],"mapped",[35222]],[[64098,64098],"mapped",[35585]],[[64099,64099],"mapped",[35641]],[[64100,64100],"mapped",[36051]],[[64101,64101],"mapped",[36104]],[[64102,64102],"mapped",[36790]],[[64103,64103],"mapped",[36920]],[[64104,64104],"mapped",[38627]],[[64105,64105],"mapped",[38911]],[[64106,64106],"mapped",[38971]],[[64107,64107],"mapped",[24693]],[[64108,64108],"mapped",[148206]],[[64109,64109],"mapped",[33304]],[[64110,64111],"disallowed"],[[64112,64112],"mapped",[20006]],[[64113,64113],"mapped",[20917]],[[64114,64114],"mapped",[20840]],[[64115,64115],"mapped",[20352]],[[64116,64116],"mapped",[20805]],[[64117,64117],"mapped",[20864]],[[64118,64118],"mapped",[21191]],[[64119,64119],"mapped",[21242]],[[64120,64120],"mapped",[21917]],[[64121,64121],"mapped",[21845]],[[64122,64122],"mapped",[21913]],[[64123,64123],"mapped",[21986]],[[64124,64124],"mapped",[22618]],[[64125,64125],"mapped",[22707]],[[64126,64126],"mapped",[22852]],[[64127,64127],"mapped",[22868]],[[64128,64128],"mapped",[23138]],[[64129,64129],"mapped",[23336]],[[64130,64130],"mapped",[24274]],[[64131,64131],"mapped",[24281]],[[64132,64132],"mapped",[24425]],[[64133,64133],"mapped",[24493]],[[64134,64134],"mapped",[24792]],[[64135,64135],"mapped",[24910]],[[64136,64136],"mapped",[24840]],[[64137,64137],"mapped",[24974]],[[64138,64138],"mapped",[24928]],[[64139,64139],"mapped",[25074]],[[64140,64140],"mapped",[25140]],[[64141,64141],"mapped",[25540]],[[64142,64142],"mapped",[25628]],[[64143,64143],"mapped",[25682]],[[64144,64144],"mapped",[25942]],[[64145,64145],"mapped",[26228]],[[64146,64146],"mapped",[26391]],[[64147,64147],"mapped",[26395]],[[64148,64148],"mapped",[26454]],[[64149,64149],"mapped",[27513]],[[64150,64150],"mapped",[27578]],[[64151,64151],"mapped",[27969]],[[64152,64152],"mapped",[28379]],[[64153,64153],"mapped",[28363]],[[64154,64154],"mapped",[28450]],[[64155,64155],"mapped",[28702]],[[64156,64156],"mapped",[29038]],[[64157,64157],"mapped",[30631]],[[64158,64158],"mapped",[29237]],[[64159,64159],"mapped",[29359]],[[64160,64160],"mapped",[29482]],[[64161,64161],"mapped",[29809]],[[64162,64162],"mapped",[29958]],[[64163,64163],"mapped",[30011]],[[64164,64164],"mapped",[30237]],[[64165,64165],"mapped",[30239]],[[64166,64166],"mapped",[30410]],[[64167,64167],"mapped",[30427]],[[64168,64168],"mapped",[30452]],[[64169,64169],"mapped",[30538]],[[64170,64170],"mapped",[30528]],[[64171,64171],"mapped",[30924]],[[64172,64172],"mapped",[31409]],[[64173,64173],"mapped",[31680]],[[64174,64174],"mapped",[31867]],[[64175,64175],"mapped",[32091]],[[64176,64176],"mapped",[32244]],[[64177,64177],"mapped",[32574]],[[64178,64178],"mapped",[32773]],[[64179,64179],"mapped",[33618]],[[64180,64180],"mapped",[33775]],[[64181,64181],"mapped",[34681]],[[64182,64182],"mapped",[35137]],[[64183,64183],"mapped",[35206]],[[64184,64184],"mapped",[35222]],[[64185,64185],"mapped",[35519]],[[64186,64186],"mapped",[35576]],[[64187,64187],"mapped",[35531]],[[64188,64188],"mapped",[35585]],[[64189,64189],"mapped",[35582]],[[64190,64190],"mapped",[35565]],[[64191,64191],"mapped",[35641]],[[64192,64192],"mapped",[35722]],[[64193,64193],"mapped",[36104]],[[64194,64194],"mapped",[36664]],[[64195,64195],"mapped",[36978]],[[64196,64196],"mapped",[37273]],[[64197,64197],"mapped",[37494]],[[64198,64198],"mapped",[38524]],[[64199,64199],"mapped",[38627]],[[64200,64200],"mapped",[38742]],[[64201,64201],"mapped",[38875]],[[64202,64202],"mapped",[38911]],[[64203,64203],"mapped",[38923]],[[64204,64204],"mapped",[38971]],[[64205,64205],"mapped",[39698]],[[64206,64206],"mapped",[40860]],[[64207,64207],"mapped",[141386]],[[64208,64208],"mapped",[141380]],[[64209,64209],"mapped",[144341]],[[64210,64210],"mapped",[15261]],[[64211,64211],"mapped",[16408]],[[64212,64212],"mapped",[16441]],[[64213,64213],"mapped",[152137]],[[64214,64214],"mapped",[154832]],[[64215,64215],"mapped",[163539]],[[64216,64216],"mapped",[40771]],[[64217,64217],"mapped",[40846]],[[64218,64255],"disallowed"],[[64256,64256],"mapped",[102,102]],[[64257,64257],"mapped",[102,105]],[[64258,64258],"mapped",[102,108]],[[64259,64259],"mapped",[102,102,105]],[[64260,64260],"mapped",[102,102,108]],[[64261,64262],"mapped",[115,116]],[[64263,64274],"disallowed"],[[64275,64275],"mapped",[1396,1398]],[[64276,64276],"mapped",[1396,1381]],[[64277,64277],"mapped",[1396,1387]],[[64278,64278],"mapped",[1406,1398]],[[64279,64279],"mapped",[1396,1389]],[[64280,64284],"disallowed"],[[64285,64285],"mapped",[1497,1460]],[[64286,64286],"valid"],[[64287,64287],"mapped",[1522,1463]],[[64288,64288],"mapped",[1506]],[[64289,64289],"mapped",[1488]],[[64290,64290],"mapped",[1491]],[[64291,64291],"mapped",[1492]],[[64292,64292],"mapped",[1499]],[[64293,64293],"mapped",[1500]],[[64294,64294],"mapped",[1501]],[[64295,64295],"mapped",[1512]],[[64296,64296],"mapped",[1514]],[[64297,64297],"disallowed_STD3_mapped",[43]],[[64298,64298],"mapped",[1513,1473]],[[64299,64299],"mapped",[1513,1474]],[[64300,64300],"mapped",[1513,1468,1473]],[[64301,64301],"mapped",[1513,1468,1474]],[[64302,64302],"mapped",[1488,1463]],[[64303,64303],"mapped",[1488,1464]],[[64304,64304],"mapped",[1488,1468]],[[64305,64305],"mapped",[1489,1468]],[[64306,64306],"mapped",[1490,1468]],[[64307,64307],"mapped",[1491,1468]],[[64308,64308],"mapped",[1492,1468]],[[64309,64309],"mapped",[1493,1468]],[[64310,64310],"mapped",[1494,1468]],[[64311,64311],"disallowed"],[[64312,64312],"mapped",[1496,1468]],[[64313,64313],"mapped",[1497,1468]],[[64314,64314],"mapped",[1498,1468]],[[64315,64315],"mapped",[1499,1468]],[[64316,64316],"mapped",[1500,1468]],[[64317,64317],"disallowed"],[[64318,64318],"mapped",[1502,1468]],[[64319,64319],"disallowed"],[[64320,64320],"mapped",[1504,1468]],[[64321,64321],"mapped",[1505,1468]],[[64322,64322],"disallowed"],[[64323,64323],"mapped",[1507,1468]],[[64324,64324],"mapped",[1508,1468]],[[64325,64325],"disallowed"],[[64326,64326],"mapped",[1510,1468]],[[64327,64327],"mapped",[1511,1468]],[[64328,64328],"mapped",[1512,1468]],[[64329,64329],"mapped",[1513,1468]],[[64330,64330],"mapped",[1514,1468]],[[64331,64331],"mapped",[1493,1465]],[[64332,64332],"mapped",[1489,1471]],[[64333,64333],"mapped",[1499,1471]],[[64334,64334],"mapped",[1508,1471]],[[64335,64335],"mapped",[1488,1500]],[[64336,64337],"mapped",[1649]],[[64338,64341],"mapped",[1659]],[[64342,64345],"mapped",[1662]],[[64346,64349],"mapped",[1664]],[[64350,64353],"mapped",[1658]],[[64354,64357],"mapped",[1663]],[[64358,64361],"mapped",[1657]],[[64362,64365],"mapped",[1700]],[[64366,64369],"mapped",[1702]],[[64370,64373],"mapped",[1668]],[[64374,64377],"mapped",[1667]],[[64378,64381],"mapped",[1670]],[[64382,64385],"mapped",[1671]],[[64386,64387],"mapped",[1677]],[[64388,64389],"mapped",[1676]],[[64390,64391],"mapped",[1678]],[[64392,64393],"mapped",[1672]],[[64394,64395],"mapped",[1688]],[[64396,64397],"mapped",[1681]],[[64398,64401],"mapped",[1705]],[[64402,64405],"mapped",[1711]],[[64406,64409],"mapped",[1715]],[[64410,64413],"mapped",[1713]],[[64414,64415],"mapped",[1722]],[[64416,64419],"mapped",[1723]],[[64420,64421],"mapped",[1728]],[[64422,64425],"mapped",[1729]],[[64426,64429],"mapped",[1726]],[[64430,64431],"mapped",[1746]],[[64432,64433],"mapped",[1747]],[[64434,64449],"valid",[],"NV8"],[[64450,64466],"disallowed"],[[64467,64470],"mapped",[1709]],[[64471,64472],"mapped",[1735]],[[64473,64474],"mapped",[1734]],[[64475,64476],"mapped",[1736]],[[64477,64477],"mapped",[1735,1652]],[[64478,64479],"mapped",[1739]],[[64480,64481],"mapped",[1733]],[[64482,64483],"mapped",[1737]],[[64484,64487],"mapped",[1744]],[[64488,64489],"mapped",[1609]],[[64490,64491],"mapped",[1574,1575]],[[64492,64493],"mapped",[1574,1749]],[[64494,64495],"mapped",[1574,1608]],[[64496,64497],"mapped",[1574,1735]],[[64498,64499],"mapped",[1574,1734]],[[64500,64501],"mapped",[1574,1736]],[[64502,64504],"mapped",[1574,1744]],[[64505,64507],"mapped",[1574,1609]],[[64508,64511],"mapped",[1740]],[[64512,64512],"mapped",[1574,1580]],[[64513,64513],"mapped",[1574,1581]],[[64514,64514],"mapped",[1574,1605]],[[64515,64515],"mapped",[1574,1609]],[[64516,64516],"mapped",[1574,1610]],[[64517,64517],"mapped",[1576,1580]],[[64518,64518],"mapped",[1576,1581]],[[64519,64519],"mapped",[1576,1582]],[[64520,64520],"mapped",[1576,1605]],[[64521,64521],"mapped",[1576,1609]],[[64522,64522],"mapped",[1576,1610]],[[64523,64523],"mapped",[1578,1580]],[[64524,64524],"mapped",[1578,1581]],[[64525,64525],"mapped",[1578,1582]],[[64526,64526],"mapped",[1578,1605]],[[64527,64527],"mapped",[1578,1609]],[[64528,64528],"mapped",[1578,1610]],[[64529,64529],"mapped",[1579,1580]],[[64530,64530],"mapped",[1579,1605]],[[64531,64531],"mapped",[1579,1609]],[[64532,64532],"mapped",[1579,1610]],[[64533,64533],"mapped",[1580,1581]],[[64534,64534],"mapped",[1580,1605]],[[64535,64535],"mapped",[1581,1580]],[[64536,64536],"mapped",[1581,1605]],[[64537,64537],"mapped",[1582,1580]],[[64538,64538],"mapped",[1582,1581]],[[64539,64539],"mapped",[1582,1605]],[[64540,64540],"mapped",[1587,1580]],[[64541,64541],"mapped",[1587,1581]],[[64542,64542],"mapped",[1587,1582]],[[64543,64543],"mapped",[1587,1605]],[[64544,64544],"mapped",[1589,1581]],[[64545,64545],"mapped",[1589,1605]],[[64546,64546],"mapped",[1590,1580]],[[64547,64547],"mapped",[1590,1581]],[[64548,64548],"mapped",[1590,1582]],[[64549,64549],"mapped",[1590,1605]],[[64550,64550],"mapped",[1591,1581]],[[64551,64551],"mapped",[1591,1605]],[[64552,64552],"mapped",[1592,1605]],[[64553,64553],"mapped",[1593,1580]],[[64554,64554],"mapped",[1593,1605]],[[64555,64555],"mapped",[1594,1580]],[[64556,64556],"mapped",[1594,1605]],[[64557,64557],"mapped",[1601,1580]],[[64558,64558],"mapped",[1601,1581]],[[64559,64559],"mapped",[1601,1582]],[[64560,64560],"mapped",[1601,1605]],[[64561,64561],"mapped",[1601,1609]],[[64562,64562],"mapped",[1601,1610]],[[64563,64563],"mapped",[1602,1581]],[[64564,64564],"mapped",[1602,1605]],[[64565,64565],"mapped",[1602,1609]],[[64566,64566],"mapped",[1602,1610]],[[64567,64567],"mapped",[1603,1575]],[[64568,64568],"mapped",[1603,1580]],[[64569,64569],"mapped",[1603,1581]],[[64570,64570],"mapped",[1603,1582]],[[64571,64571],"mapped",[1603,1604]],[[64572,64572],"mapped",[1603,1605]],[[64573,64573],"mapped",[1603,1609]],[[64574,64574],"mapped",[1603,1610]],[[64575,64575],"mapped",[1604,1580]],[[64576,64576],"mapped",[1604,1581]],[[64577,64577],"mapped",[1604,1582]],[[64578,64578],"mapped",[1604,1605]],[[64579,64579],"mapped",[1604,1609]],[[64580,64580],"mapped",[1604,1610]],[[64581,64581],"mapped",[1605,1580]],[[64582,64582],"mapped",[1605,1581]],[[64583,64583],"mapped",[1605,1582]],[[64584,64584],"mapped",[1605,1605]],[[64585,64585],"mapped",[1605,1609]],[[64586,64586],"mapped",[1605,1610]],[[64587,64587],"mapped",[1606,1580]],[[64588,64588],"mapped",[1606,1581]],[[64589,64589],"mapped",[1606,1582]],[[64590,64590],"mapped",[1606,1605]],[[64591,64591],"mapped",[1606,1609]],[[64592,64592],"mapped",[1606,1610]],[[64593,64593],"mapped",[1607,1580]],[[64594,64594],"mapped",[1607,1605]],[[64595,64595],"mapped",[1607,1609]],[[64596,64596],"mapped",[1607,1610]],[[64597,64597],"mapped",[1610,1580]],[[64598,64598],"mapped",[1610,1581]],[[64599,64599],"mapped",[1610,1582]],[[64600,64600],"mapped",[1610,1605]],[[64601,64601],"mapped",[1610,1609]],[[64602,64602],"mapped",[1610,1610]],[[64603,64603],"mapped",[1584,1648]],[[64604,64604],"mapped",[1585,1648]],[[64605,64605],"mapped",[1609,1648]],[[64606,64606],"disallowed_STD3_mapped",[32,1612,1617]],[[64607,64607],"disallowed_STD3_mapped",[32,1613,1617]],[[64608,64608],"disallowed_STD3_mapped",[32,1614,1617]],[[64609,64609],"disallowed_STD3_mapped",[32,1615,1617]],[[64610,64610],"disallowed_STD3_mapped",[32,1616,1617]],[[64611,64611],"disallowed_STD3_mapped",[32,1617,1648]],[[64612,64612],"mapped",[1574,1585]],[[64613,64613],"mapped",[1574,1586]],[[64614,64614],"mapped",[1574,1605]],[[64615,64615],"mapped",[1574,1606]],[[64616,64616],"mapped",[1574,1609]],[[64617,64617],"mapped",[1574,1610]],[[64618,64618],"mapped",[1576,1585]],[[64619,64619],"mapped",[1576,1586]],[[64620,64620],"mapped",[1576,1605]],[[64621,64621],"mapped",[1576,1606]],[[64622,64622],"mapped",[1576,1609]],[[64623,64623],"mapped",[1576,1610]],[[64624,64624],"mapped",[1578,1585]],[[64625,64625],"mapped",[1578,1586]],[[64626,64626],"mapped",[1578,1605]],[[64627,64627],"mapped",[1578,1606]],[[64628,64628],"mapped",[1578,1609]],[[64629,64629],"mapped",[1578,1610]],[[64630,64630],"mapped",[1579,1585]],[[64631,64631],"mapped",[1579,1586]],[[64632,64632],"mapped",[1579,1605]],[[64633,64633],"mapped",[1579,1606]],[[64634,64634],"mapped",[1579,1609]],[[64635,64635],"mapped",[1579,1610]],[[64636,64636],"mapped",[1601,1609]],[[64637,64637],"mapped",[1601,1610]],[[64638,64638],"mapped",[1602,1609]],[[64639,64639],"mapped",[1602,1610]],[[64640,64640],"mapped",[1603,1575]],[[64641,64641],"mapped",[1603,1604]],[[64642,64642],"mapped",[1603,1605]],[[64643,64643],"mapped",[1603,1609]],[[64644,64644],"mapped",[1603,1610]],[[64645,64645],"mapped",[1604,1605]],[[64646,64646],"mapped",[1604,1609]],[[64647,64647],"mapped",[1604,1610]],[[64648,64648],"mapped",[1605,1575]],[[64649,64649],"mapped",[1605,1605]],[[64650,64650],"mapped",[1606,1585]],[[64651,64651],"mapped",[1606,1586]],[[64652,64652],"mapped",[1606,1605]],[[64653,64653],"mapped",[1606,1606]],[[64654,64654],"mapped",[1606,1609]],[[64655,64655],"mapped",[1606,1610]],[[64656,64656],"mapped",[1609,1648]],[[64657,64657],"mapped",[1610,1585]],[[64658,64658],"mapped",[1610,1586]],[[64659,64659],"mapped",[1610,1605]],[[64660,64660],"mapped",[1610,1606]],[[64661,64661],"mapped",[1610,1609]],[[64662,64662],"mapped",[1610,1610]],[[64663,64663],"mapped",[1574,1580]],[[64664,64664],"mapped",[1574,1581]],[[64665,64665],"mapped",[1574,1582]],[[64666,64666],"mapped",[1574,1605]],[[64667,64667],"mapped",[1574,1607]],[[64668,64668],"mapped",[1576,1580]],[[64669,64669],"mapped",[1576,1581]],[[64670,64670],"mapped",[1576,1582]],[[64671,64671],"mapped",[1576,1605]],[[64672,64672],"mapped",[1576,1607]],[[64673,64673],"mapped",[1578,1580]],[[64674,64674],"mapped",[1578,1581]],[[64675,64675],"mapped",[1578,1582]],[[64676,64676],"mapped",[1578,1605]],[[64677,64677],"mapped",[1578,1607]],[[64678,64678],"mapped",[1579,1605]],[[64679,64679],"mapped",[1580,1581]],[[64680,64680],"mapped",[1580,1605]],[[64681,64681],"mapped",[1581,1580]],[[64682,64682],"mapped",[1581,1605]],[[64683,64683],"mapped",[1582,1580]],[[64684,64684],"mapped",[1582,1605]],[[64685,64685],"mapped",[1587,1580]],[[64686,64686],"mapped",[1587,1581]],[[64687,64687],"mapped",[1587,1582]],[[64688,64688],"mapped",[1587,1605]],[[64689,64689],"mapped",[1589,1581]],[[64690,64690],"mapped",[1589,1582]],[[64691,64691],"mapped",[1589,1605]],[[64692,64692],"mapped",[1590,1580]],[[64693,64693],"mapped",[1590,1581]],[[64694,64694],"mapped",[1590,1582]],[[64695,64695],"mapped",[1590,1605]],[[64696,64696],"mapped",[1591,1581]],[[64697,64697],"mapped",[1592,1605]],[[64698,64698],"mapped",[1593,1580]],[[64699,64699],"mapped",[1593,1605]],[[64700,64700],"mapped",[1594,1580]],[[64701,64701],"mapped",[1594,1605]],[[64702,64702],"mapped",[1601,1580]],[[64703,64703],"mapped",[1601,1581]],[[64704,64704],"mapped",[1601,1582]],[[64705,64705],"mapped",[1601,1605]],[[64706,64706],"mapped",[1602,1581]],[[64707,64707],"mapped",[1602,1605]],[[64708,64708],"mapped",[1603,1580]],[[64709,64709],"mapped",[1603,1581]],[[64710,64710],"mapped",[1603,1582]],[[64711,64711],"mapped",[1603,1604]],[[64712,64712],"mapped",[1603,1605]],[[64713,64713],"mapped",[1604,1580]],[[64714,64714],"mapped",[1604,1581]],[[64715,64715],"mapped",[1604,1582]],[[64716,64716],"mapped",[1604,1605]],[[64717,64717],"mapped",[1604,1607]],[[64718,64718],"mapped",[1605,1580]],[[64719,64719],"mapped",[1605,1581]],[[64720,64720],"mapped",[1605,1582]],[[64721,64721],"mapped",[1605,1605]],[[64722,64722],"mapped",[1606,1580]],[[64723,64723],"mapped",[1606,1581]],[[64724,64724],"mapped",[1606,1582]],[[64725,64725],"mapped",[1606,1605]],[[64726,64726],"mapped",[1606,1607]],[[64727,64727],"mapped",[1607,1580]],[[64728,64728],"mapped",[1607,1605]],[[64729,64729],"mapped",[1607,1648]],[[64730,64730],"mapped",[1610,1580]],[[64731,64731],"mapped",[1610,1581]],[[64732,64732],"mapped",[1610,1582]],[[64733,64733],"mapped",[1610,1605]],[[64734,64734],"mapped",[1610,1607]],[[64735,64735],"mapped",[1574,1605]],[[64736,64736],"mapped",[1574,1607]],[[64737,64737],"mapped",[1576,1605]],[[64738,64738],"mapped",[1576,1607]],[[64739,64739],"mapped",[1578,1605]],[[64740,64740],"mapped",[1578,1607]],[[64741,64741],"mapped",[1579,1605]],[[64742,64742],"mapped",[1579,1607]],[[64743,64743],"mapped",[1587,1605]],[[64744,64744],"mapped",[1587,1607]],[[64745,64745],"mapped",[1588,1605]],[[64746,64746],"mapped",[1588,1607]],[[64747,64747],"mapped",[1603,1604]],[[64748,64748],"mapped",[1603,1605]],[[64749,64749],"mapped",[1604,1605]],[[64750,64750],"mapped",[1606,1605]],[[64751,64751],"mapped",[1606,1607]],[[64752,64752],"mapped",[1610,1605]],[[64753,64753],"mapped",[1610,1607]],[[64754,64754],"mapped",[1600,1614,1617]],[[64755,64755],"mapped",[1600,1615,1617]],[[64756,64756],"mapped",[1600,1616,1617]],[[64757,64757],"mapped",[1591,1609]],[[64758,64758],"mapped",[1591,1610]],[[64759,64759],"mapped",[1593,1609]],[[64760,64760],"mapped",[1593,1610]],[[64761,64761],"mapped",[1594,1609]],[[64762,64762],"mapped",[1594,1610]],[[64763,64763],"mapped",[1587,1609]],[[64764,64764],"mapped",[1587,1610]],[[64765,64765],"mapped",[1588,1609]],[[64766,64766],"mapped",[1588,1610]],[[64767,64767],"mapped",[1581,1609]],[[64768,64768],"mapped",[1581,1610]],[[64769,64769],"mapped",[1580,1609]],[[64770,64770],"mapped",[1580,1610]],[[64771,64771],"mapped",[1582,1609]],[[64772,64772],"mapped",[1582,1610]],[[64773,64773],"mapped",[1589,1609]],[[64774,64774],"mapped",[1589,1610]],[[64775,64775],"mapped",[1590,1609]],[[64776,64776],"mapped",[1590,1610]],[[64777,64777],"mapped",[1588,1580]],[[64778,64778],"mapped",[1588,1581]],[[64779,64779],"mapped",[1588,1582]],[[64780,64780],"mapped",[1588,1605]],[[64781,64781],"mapped",[1588,1585]],[[64782,64782],"mapped",[1587,1585]],[[64783,64783],"mapped",[1589,1585]],[[64784,64784],"mapped",[1590,1585]],[[64785,64785],"mapped",[1591,1609]],[[64786,64786],"mapped",[1591,1610]],[[64787,64787],"mapped",[1593,1609]],[[64788,64788],"mapped",[1593,1610]],[[64789,64789],"mapped",[1594,1609]],[[64790,64790],"mapped",[1594,1610]],[[64791,64791],"mapped",[1587,1609]],[[64792,64792],"mapped",[1587,1610]],[[64793,64793],"mapped",[1588,1609]],[[64794,64794],"mapped",[1588,1610]],[[64795,64795],"mapped",[1581,1609]],[[64796,64796],"mapped",[1581,1610]],[[64797,64797],"mapped",[1580,1609]],[[64798,64798],"mapped",[1580,1610]],[[64799,64799],"mapped",[1582,1609]],[[64800,64800],"mapped",[1582,1610]],[[64801,64801],"mapped",[1589,1609]],[[64802,64802],"mapped",[1589,1610]],[[64803,64803],"mapped",[1590,1609]],[[64804,64804],"mapped",[1590,1610]],[[64805,64805],"mapped",[1588,1580]],[[64806,64806],"mapped",[1588,1581]],[[64807,64807],"mapped",[1588,1582]],[[64808,64808],"mapped",[1588,1605]],[[64809,64809],"mapped",[1588,1585]],[[64810,64810],"mapped",[1587,1585]],[[64811,64811],"mapped",[1589,1585]],[[64812,64812],"mapped",[1590,1585]],[[64813,64813],"mapped",[1588,1580]],[[64814,64814],"mapped",[1588,1581]],[[64815,64815],"mapped",[1588,1582]],[[64816,64816],"mapped",[1588,1605]],[[64817,64817],"mapped",[1587,1607]],[[64818,64818],"mapped",[1588,1607]],[[64819,64819],"mapped",[1591,1605]],[[64820,64820],"mapped",[1587,1580]],[[64821,64821],"mapped",[1587,1581]],[[64822,64822],"mapped",[1587,1582]],[[64823,64823],"mapped",[1588,1580]],[[64824,64824],"mapped",[1588,1581]],[[64825,64825],"mapped",[1588,1582]],[[64826,64826],"mapped",[1591,1605]],[[64827,64827],"mapped",[1592,1605]],[[64828,64829],"mapped",[1575,1611]],[[64830,64831],"valid",[],"NV8"],[[64832,64847],"disallowed"],[[64848,64848],"mapped",[1578,1580,1605]],[[64849,64850],"mapped",[1578,1581,1580]],[[64851,64851],"mapped",[1578,1581,1605]],[[64852,64852],"mapped",[1578,1582,1605]],[[64853,64853],"mapped",[1578,1605,1580]],[[64854,64854],"mapped",[1578,1605,1581]],[[64855,64855],"mapped",[1578,1605,1582]],[[64856,64857],"mapped",[1580,1605,1581]],[[64858,64858],"mapped",[1581,1605,1610]],[[64859,64859],"mapped",[1581,1605,1609]],[[64860,64860],"mapped",[1587,1581,1580]],[[64861,64861],"mapped",[1587,1580,1581]],[[64862,64862],"mapped",[1587,1580,1609]],[[64863,64864],"mapped",[1587,1605,1581]],[[64865,64865],"mapped",[1587,1605,1580]],[[64866,64867],"mapped",[1587,1605,1605]],[[64868,64869],"mapped",[1589,1581,1581]],[[64870,64870],"mapped",[1589,1605,1605]],[[64871,64872],"mapped",[1588,1581,1605]],[[64873,64873],"mapped",[1588,1580,1610]],[[64874,64875],"mapped",[1588,1605,1582]],[[64876,64877],"mapped",[1588,1605,1605]],[[64878,64878],"mapped",[1590,1581,1609]],[[64879,64880],"mapped",[1590,1582,1605]],[[64881,64882],"mapped",[1591,1605,1581]],[[64883,64883],"mapped",[1591,1605,1605]],[[64884,64884],"mapped",[1591,1605,1610]],[[64885,64885],"mapped",[1593,1580,1605]],[[64886,64887],"mapped",[1593,1605,1605]],[[64888,64888],"mapped",[1593,1605,1609]],[[64889,64889],"mapped",[1594,1605,1605]],[[64890,64890],"mapped",[1594,1605,1610]],[[64891,64891],"mapped",[1594,1605,1609]],[[64892,64893],"mapped",[1601,1582,1605]],[[64894,64894],"mapped",[1602,1605,1581]],[[64895,64895],"mapped",[1602,1605,1605]],[[64896,64896],"mapped",[1604,1581,1605]],[[64897,64897],"mapped",[1604,1581,1610]],[[64898,64898],"mapped",[1604,1581,1609]],[[64899,64900],"mapped",[1604,1580,1580]],[[64901,64902],"mapped",[1604,1582,1605]],[[64903,64904],"mapped",[1604,1605,1581]],[[64905,64905],"mapped",[1605,1581,1580]],[[64906,64906],"mapped",[1605,1581,1605]],[[64907,64907],"mapped",[1605,1581,1610]],[[64908,64908],"mapped",[1605,1580,1581]],[[64909,64909],"mapped",[1605,1580,1605]],[[64910,64910],"mapped",[1605,1582,1580]],[[64911,64911],"mapped",[1605,1582,1605]],[[64912,64913],"disallowed"],[[64914,64914],"mapped",[1605,1580,1582]],[[64915,64915],"mapped",[1607,1605,1580]],[[64916,64916],"mapped",[1607,1605,1605]],[[64917,64917],"mapped",[1606,1581,1605]],[[64918,64918],"mapped",[1606,1581,1609]],[[64919,64920],"mapped",[1606,1580,1605]],[[64921,64921],"mapped",[1606,1580,1609]],[[64922,64922],"mapped",[1606,1605,1610]],[[64923,64923],"mapped",[1606,1605,1609]],[[64924,64925],"mapped",[1610,1605,1605]],[[64926,64926],"mapped",[1576,1582,1610]],[[64927,64927],"mapped",[1578,1580,1610]],[[64928,64928],"mapped",[1578,1580,1609]],[[64929,64929],"mapped",[1578,1582,1610]],[[64930,64930],"mapped",[1578,1582,1609]],[[64931,64931],"mapped",[1578,1605,1610]],[[64932,64932],"mapped",[1578,1605,1609]],[[64933,64933],"mapped",[1580,1605,1610]],[[64934,64934],"mapped",[1580,1581,1609]],[[64935,64935],"mapped",[1580,1605,1609]],[[64936,64936],"mapped",[1587,1582,1609]],[[64937,64937],"mapped",[1589,1581,1610]],[[64938,64938],"mapped",[1588,1581,1610]],[[64939,64939],"mapped",[1590,1581,1610]],[[64940,64940],"mapped",[1604,1580,1610]],[[64941,64941],"mapped",[1604,1605,1610]],[[64942,64942],"mapped",[1610,1581,1610]],[[64943,64943],"mapped",[1610,1580,1610]],[[64944,64944],"mapped",[1610,1605,1610]],[[64945,64945],"mapped",[1605,1605,1610]],[[64946,64946],"mapped",[1602,1605,1610]],[[64947,64947],"mapped",[1606,1581,1610]],[[64948,64948],"mapped",[1602,1605,1581]],[[64949,64949],"mapped",[1604,1581,1605]],[[64950,64950],"mapped",[1593,1605,1610]],[[64951,64951],"mapped",[1603,1605,1610]],[[64952,64952],"mapped",[1606,1580,1581]],[[64953,64953],"mapped",[1605,1582,1610]],[[64954,64954],"mapped",[1604,1580,1605]],[[64955,64955],"mapped",[1603,1605,1605]],[[64956,64956],"mapped",[1604,1580,1605]],[[64957,64957],"mapped",[1606,1580,1581]],[[64958,64958],"mapped",[1580,1581,1610]],[[64959,64959],"mapped",[1581,1580,1610]],[[64960,64960],"mapped",[1605,1580,1610]],[[64961,64961],"mapped",[1601,1605,1610]],[[64962,64962],"mapped",[1576,1581,1610]],[[64963,64963],"mapped",[1603,1605,1605]],[[64964,64964],"mapped",[1593,1580,1605]],[[64965,64965],"mapped",[1589,1605,1605]],[[64966,64966],"mapped",[1587,1582,1610]],[[64967,64967],"mapped",[1606,1580,1610]],[[64968,64975],"disallowed"],[[64976,65007],"disallowed"],[[65008,65008],"mapped",[1589,1604,1746]],[[65009,65009],"mapped",[1602,1604,1746]],[[65010,65010],"mapped",[1575,1604,1604,1607]],[[65011,65011],"mapped",[1575,1603,1576,1585]],[[65012,65012],"mapped",[1605,1581,1605,1583]],[[65013,65013],"mapped",[1589,1604,1593,1605]],[[65014,65014],"mapped",[1585,1587,1608,1604]],[[65015,65015],"mapped",[1593,1604,1610,1607]],[[65016,65016],"mapped",[1608,1587,1604,1605]],[[65017,65017],"mapped",[1589,1604,1609]],[[65018,65018],"disallowed_STD3_mapped",[1589,1604,1609,32,1575,1604,1604,1607,32,1593,1604,1610,1607,32,1608,1587,1604,1605]],[[65019,65019],"disallowed_STD3_mapped",[1580,1604,32,1580,1604,1575,1604,1607]],[[65020,65020],"mapped",[1585,1740,1575,1604]],[[65021,65021],"valid",[],"NV8"],[[65022,65023],"disallowed"],[[65024,65039],"ignored"],[[65040,65040],"disallowed_STD3_mapped",[44]],[[65041,65041],"mapped",[12289]],[[65042,65042],"disallowed"],[[65043,65043],"disallowed_STD3_mapped",[58]],[[65044,65044],"disallowed_STD3_mapped",[59]],[[65045,65045],"disallowed_STD3_mapped",[33]],[[65046,65046],"disallowed_STD3_mapped",[63]],[[65047,65047],"mapped",[12310]],[[65048,65048],"mapped",[12311]],[[65049,65049],"disallowed"],[[65050,65055],"disallowed"],[[65056,65059],"valid"],[[65060,65062],"valid"],[[65063,65069],"valid"],[[65070,65071],"valid"],[[65072,65072],"disallowed"],[[65073,65073],"mapped",[8212]],[[65074,65074],"mapped",[8211]],[[65075,65076],"disallowed_STD3_mapped",[95]],[[65077,65077],"disallowed_STD3_mapped",[40]],[[65078,65078],"disallowed_STD3_mapped",[41]],[[65079,65079],"disallowed_STD3_mapped",[123]],[[65080,65080],"disallowed_STD3_mapped",[125]],[[65081,65081],"mapped",[12308]],[[65082,65082],"mapped",[12309]],[[65083,65083],"mapped",[12304]],[[65084,65084],"mapped",[12305]],[[65085,65085],"mapped",[12298]],[[65086,65086],"mapped",[12299]],[[65087,65087],"mapped",[12296]],[[65088,65088],"mapped",[12297]],[[65089,65089],"mapped",[12300]],[[65090,65090],"mapped",[12301]],[[65091,65091],"mapped",[12302]],[[65092,65092],"mapped",[12303]],[[65093,65094],"valid",[],"NV8"],[[65095,65095],"disallowed_STD3_mapped",[91]],[[65096,65096],"disallowed_STD3_mapped",[93]],[[65097,65100],"disallowed_STD3_mapped",[32,773]],[[65101,65103],"disallowed_STD3_mapped",[95]],[[65104,65104],"disallowed_STD3_mapped",[44]],[[65105,65105],"mapped",[12289]],[[65106,65106],"disallowed"],[[65107,65107],"disallowed"],[[65108,65108],"disallowed_STD3_mapped",[59]],[[65109,65109],"disallowed_STD3_mapped",[58]],[[65110,65110],"disallowed_STD3_mapped",[63]],[[65111,65111],"disallowed_STD3_mapped",[33]],[[65112,65112],"mapped",[8212]],[[65113,65113],"disallowed_STD3_mapped",[40]],[[65114,65114],"disallowed_STD3_mapped",[41]],[[65115,65115],"disallowed_STD3_mapped",[123]],[[65116,65116],"disallowed_STD3_mapped",[125]],[[65117,65117],"mapped",[12308]],[[65118,65118],"mapped",[12309]],[[65119,65119],"disallowed_STD3_mapped",[35]],[[65120,65120],"disallowed_STD3_mapped",[38]],[[65121,65121],"disallowed_STD3_mapped",[42]],[[65122,65122],"disallowed_STD3_mapped",[43]],[[65123,65123],"mapped",[45]],[[65124,65124],"disallowed_STD3_mapped",[60]],[[65125,65125],"disallowed_STD3_mapped",[62]],[[65126,65126],"disallowed_STD3_mapped",[61]],[[65127,65127],"disallowed"],[[65128,65128],"disallowed_STD3_mapped",[92]],[[65129,65129],"disallowed_STD3_mapped",[36]],[[65130,65130],"disallowed_STD3_mapped",[37]],[[65131,65131],"disallowed_STD3_mapped",[64]],[[65132,65135],"disallowed"],[[65136,65136],"disallowed_STD3_mapped",[32,1611]],[[65137,65137],"mapped",[1600,1611]],[[65138,65138],"disallowed_STD3_mapped",[32,1612]],[[65139,65139],"valid"],[[65140,65140],"disallowed_STD3_mapped",[32,1613]],[[65141,65141],"disallowed"],[[65142,65142],"disallowed_STD3_mapped",[32,1614]],[[65143,65143],"mapped",[1600,1614]],[[65144,65144],"disallowed_STD3_mapped",[32,1615]],[[65145,65145],"mapped",[1600,1615]],[[65146,65146],"disallowed_STD3_mapped",[32,1616]],[[65147,65147],"mapped",[1600,1616]],[[65148,65148],"disallowed_STD3_mapped",[32,1617]],[[65149,65149],"mapped",[1600,1617]],[[65150,65150],"disallowed_STD3_mapped",[32,1618]],[[65151,65151],"mapped",[1600,1618]],[[65152,65152],"mapped",[1569]],[[65153,65154],"mapped",[1570]],[[65155,65156],"mapped",[1571]],[[65157,65158],"mapped",[1572]],[[65159,65160],"mapped",[1573]],[[65161,65164],"mapped",[1574]],[[65165,65166],"mapped",[1575]],[[65167,65170],"mapped",[1576]],[[65171,65172],"mapped",[1577]],[[65173,65176],"mapped",[1578]],[[65177,65180],"mapped",[1579]],[[65181,65184],"mapped",[1580]],[[65185,65188],"mapped",[1581]],[[65189,65192],"mapped",[1582]],[[65193,65194],"mapped",[1583]],[[65195,65196],"mapped",[1584]],[[65197,65198],"mapped",[1585]],[[65199,65200],"mapped",[1586]],[[65201,65204],"mapped",[1587]],[[65205,65208],"mapped",[1588]],[[65209,65212],"mapped",[1589]],[[65213,65216],"mapped",[1590]],[[65217,65220],"mapped",[1591]],[[65221,65224],"mapped",[1592]],[[65225,65228],"mapped",[1593]],[[65229,65232],"mapped",[1594]],[[65233,65236],"mapped",[1601]],[[65237,65240],"mapped",[1602]],[[65241,65244],"mapped",[1603]],[[65245,65248],"mapped",[1604]],[[65249,65252],"mapped",[1605]],[[65253,65256],"mapped",[1606]],[[65257,65260],"mapped",[1607]],[[65261,65262],"mapped",[1608]],[[65263,65264],"mapped",[1609]],[[65265,65268],"mapped",[1610]],[[65269,65270],"mapped",[1604,1570]],[[65271,65272],"mapped",[1604,1571]],[[65273,65274],"mapped",[1604,1573]],[[65275,65276],"mapped",[1604,1575]],[[65277,65278],"disallowed"],[[65279,65279],"ignored"],[[65280,65280],"disallowed"],[[65281,65281],"disallowed_STD3_mapped",[33]],[[65282,65282],"disallowed_STD3_mapped",[34]],[[65283,65283],"disallowed_STD3_mapped",[35]],[[65284,65284],"disallowed_STD3_mapped",[36]],[[65285,65285],"disallowed_STD3_mapped",[37]],[[65286,65286],"disallowed_STD3_mapped",[38]],[[65287,65287],"disallowed_STD3_mapped",[39]],[[65288,65288],"disallowed_STD3_mapped",[40]],[[65289,65289],"disallowed_STD3_mapped",[41]],[[65290,65290],"disallowed_STD3_mapped",[42]],[[65291,65291],"disallowed_STD3_mapped",[43]],[[65292,65292],"disallowed_STD3_mapped",[44]],[[65293,65293],"mapped",[45]],[[65294,65294],"mapped",[46]],[[65295,65295],"disallowed_STD3_mapped",[47]],[[65296,65296],"mapped",[48]],[[65297,65297],"mapped",[49]],[[65298,65298],"mapped",[50]],[[65299,65299],"mapped",[51]],[[65300,65300],"mapped",[52]],[[65301,65301],"mapped",[53]],[[65302,65302],"mapped",[54]],[[65303,65303],"mapped",[55]],[[65304,65304],"mapped",[56]],[[65305,65305],"mapped",[57]],[[65306,65306],"disallowed_STD3_mapped",[58]],[[65307,65307],"disallowed_STD3_mapped",[59]],[[65308,65308],"disallowed_STD3_mapped",[60]],[[65309,65309],"disallowed_STD3_mapped",[61]],[[65310,65310],"disallowed_STD3_mapped",[62]],[[65311,65311],"disallowed_STD3_mapped",[63]],[[65312,65312],"disallowed_STD3_mapped",[64]],[[65313,65313],"mapped",[97]],[[65314,65314],"mapped",[98]],[[65315,65315],"mapped",[99]],[[65316,65316],"mapped",[100]],[[65317,65317],"mapped",[101]],[[65318,65318],"mapped",[102]],[[65319,65319],"mapped",[103]],[[65320,65320],"mapped",[104]],[[65321,65321],"mapped",[105]],[[65322,65322],"mapped",[106]],[[65323,65323],"mapped",[107]],[[65324,65324],"mapped",[108]],[[65325,65325],"mapped",[109]],[[65326,65326],"mapped",[110]],[[65327,65327],"mapped",[111]],[[65328,65328],"mapped",[112]],[[65329,65329],"mapped",[113]],[[65330,65330],"mapped",[114]],[[65331,65331],"mapped",[115]],[[65332,65332],"mapped",[116]],[[65333,65333],"mapped",[117]],[[65334,65334],"mapped",[118]],[[65335,65335],"mapped",[119]],[[65336,65336],"mapped",[120]],[[65337,65337],"mapped",[121]],[[65338,65338],"mapped",[122]],[[65339,65339],"disallowed_STD3_mapped",[91]],[[65340,65340],"disallowed_STD3_mapped",[92]],[[65341,65341],"disallowed_STD3_mapped",[93]],[[65342,65342],"disallowed_STD3_mapped",[94]],[[65343,65343],"disallowed_STD3_mapped",[95]],[[65344,65344],"disallowed_STD3_mapped",[96]],[[65345,65345],"mapped",[97]],[[65346,65346],"mapped",[98]],[[65347,65347],"mapped",[99]],[[65348,65348],"mapped",[100]],[[65349,65349],"mapped",[101]],[[65350,65350],"mapped",[102]],[[65351,65351],"mapped",[103]],[[65352,65352],"mapped",[104]],[[65353,65353],"mapped",[105]],[[65354,65354],"mapped",[106]],[[65355,65355],"mapped",[107]],[[65356,65356],"mapped",[108]],[[65357,65357],"mapped",[109]],[[65358,65358],"mapped",[110]],[[65359,65359],"mapped",[111]],[[65360,65360],"mapped",[112]],[[65361,65361],"mapped",[113]],[[65362,65362],"mapped",[114]],[[65363,65363],"mapped",[115]],[[65364,65364],"mapped",[116]],[[65365,65365],"mapped",[117]],[[65366,65366],"mapped",[118]],[[65367,65367],"mapped",[119]],[[65368,65368],"mapped",[120]],[[65369,65369],"mapped",[121]],[[65370,65370],"mapped",[122]],[[65371,65371],"disallowed_STD3_mapped",[123]],[[65372,65372],"disallowed_STD3_mapped",[124]],[[65373,65373],"disallowed_STD3_mapped",[125]],[[65374,65374],"disallowed_STD3_mapped",[126]],[[65375,65375],"mapped",[10629]],[[65376,65376],"mapped",[10630]],[[65377,65377],"mapped",[46]],[[65378,65378],"mapped",[12300]],[[65379,65379],"mapped",[12301]],[[65380,65380],"mapped",[12289]],[[65381,65381],"mapped",[12539]],[[65382,65382],"mapped",[12530]],[[65383,65383],"mapped",[12449]],[[65384,65384],"mapped",[12451]],[[65385,65385],"mapped",[12453]],[[65386,65386],"mapped",[12455]],[[65387,65387],"mapped",[12457]],[[65388,65388],"mapped",[12515]],[[65389,65389],"mapped",[12517]],[[65390,65390],"mapped",[12519]],[[65391,65391],"mapped",[12483]],[[65392,65392],"mapped",[12540]],[[65393,65393],"mapped",[12450]],[[65394,65394],"mapped",[12452]],[[65395,65395],"mapped",[12454]],[[65396,65396],"mapped",[12456]],[[65397,65397],"mapped",[12458]],[[65398,65398],"mapped",[12459]],[[65399,65399],"mapped",[12461]],[[65400,65400],"mapped",[12463]],[[65401,65401],"mapped",[12465]],[[65402,65402],"mapped",[12467]],[[65403,65403],"mapped",[12469]],[[65404,65404],"mapped",[12471]],[[65405,65405],"mapped",[12473]],[[65406,65406],"mapped",[12475]],[[65407,65407],"mapped",[12477]],[[65408,65408],"mapped",[12479]],[[65409,65409],"mapped",[12481]],[[65410,65410],"mapped",[12484]],[[65411,65411],"mapped",[12486]],[[65412,65412],"mapped",[12488]],[[65413,65413],"mapped",[12490]],[[65414,65414],"mapped",[12491]],[[65415,65415],"mapped",[12492]],[[65416,65416],"mapped",[12493]],[[65417,65417],"mapped",[12494]],[[65418,65418],"mapped",[12495]],[[65419,65419],"mapped",[12498]],[[65420,65420],"mapped",[12501]],[[65421,65421],"mapped",[12504]],[[65422,65422],"mapped",[12507]],[[65423,65423],"mapped",[12510]],[[65424,65424],"mapped",[12511]],[[65425,65425],"mapped",[12512]],[[65426,65426],"mapped",[12513]],[[65427,65427],"mapped",[12514]],[[65428,65428],"mapped",[12516]],[[65429,65429],"mapped",[12518]],[[65430,65430],"mapped",[12520]],[[65431,65431],"mapped",[12521]],[[65432,65432],"mapped",[12522]],[[65433,65433],"mapped",[12523]],[[65434,65434],"mapped",[12524]],[[65435,65435],"mapped",[12525]],[[65436,65436],"mapped",[12527]],[[65437,65437],"mapped",[12531]],[[65438,65438],"mapped",[12441]],[[65439,65439],"mapped",[12442]],[[65440,65440],"disallowed"],[[65441,65441],"mapped",[4352]],[[65442,65442],"mapped",[4353]],[[65443,65443],"mapped",[4522]],[[65444,65444],"mapped",[4354]],[[65445,65445],"mapped",[4524]],[[65446,65446],"mapped",[4525]],[[65447,65447],"mapped",[4355]],[[65448,65448],"mapped",[4356]],[[65449,65449],"mapped",[4357]],[[65450,65450],"mapped",[4528]],[[65451,65451],"mapped",[4529]],[[65452,65452],"mapped",[4530]],[[65453,65453],"mapped",[4531]],[[65454,65454],"mapped",[4532]],[[65455,65455],"mapped",[4533]],[[65456,65456],"mapped",[4378]],[[65457,65457],"mapped",[4358]],[[65458,65458],"mapped",[4359]],[[65459,65459],"mapped",[4360]],[[65460,65460],"mapped",[4385]],[[65461,65461],"mapped",[4361]],[[65462,65462],"mapped",[4362]],[[65463,65463],"mapped",[4363]],[[65464,65464],"mapped",[4364]],[[65465,65465],"mapped",[4365]],[[65466,65466],"mapped",[4366]],[[65467,65467],"mapped",[4367]],[[65468,65468],"mapped",[4368]],[[65469,65469],"mapped",[4369]],[[65470,65470],"mapped",[4370]],[[65471,65473],"disallowed"],[[65474,65474],"mapped",[4449]],[[65475,65475],"mapped",[4450]],[[65476,65476],"mapped",[4451]],[[65477,65477],"mapped",[4452]],[[65478,65478],"mapped",[4453]],[[65479,65479],"mapped",[4454]],[[65480,65481],"disallowed"],[[65482,65482],"mapped",[4455]],[[65483,65483],"mapped",[4456]],[[65484,65484],"mapped",[4457]],[[65485,65485],"mapped",[4458]],[[65486,65486],"mapped",[4459]],[[65487,65487],"mapped",[4460]],[[65488,65489],"disallowed"],[[65490,65490],"mapped",[4461]],[[65491,65491],"mapped",[4462]],[[65492,65492],"mapped",[4463]],[[65493,65493],"mapped",[4464]],[[65494,65494],"mapped",[4465]],[[65495,65495],"mapped",[4466]],[[65496,65497],"disallowed"],[[65498,65498],"mapped",[4467]],[[65499,65499],"mapped",[4468]],[[65500,65500],"mapped",[4469]],[[65501,65503],"disallowed"],[[65504,65504],"mapped",[162]],[[65505,65505],"mapped",[163]],[[65506,65506],"mapped",[172]],[[65507,65507],"disallowed_STD3_mapped",[32,772]],[[65508,65508],"mapped",[166]],[[65509,65509],"mapped",[165]],[[65510,65510],"mapped",[8361]],[[65511,65511],"disallowed"],[[65512,65512],"mapped",[9474]],[[65513,65513],"mapped",[8592]],[[65514,65514],"mapped",[8593]],[[65515,65515],"mapped",[8594]],[[65516,65516],"mapped",[8595]],[[65517,65517],"mapped",[9632]],[[65518,65518],"mapped",[9675]],[[65519,65528],"disallowed"],[[65529,65531],"disallowed"],[[65532,65532],"disallowed"],[[65533,65533],"disallowed"],[[65534,65535],"disallowed"],[[65536,65547],"valid"],[[65548,65548],"disallowed"],[[65549,65574],"valid"],[[65575,65575],"disallowed"],[[65576,65594],"valid"],[[65595,65595],"disallowed"],[[65596,65597],"valid"],[[65598,65598],"disallowed"],[[65599,65613],"valid"],[[65614,65615],"disallowed"],[[65616,65629],"valid"],[[65630,65663],"disallowed"],[[65664,65786],"valid"],[[65787,65791],"disallowed"],[[65792,65794],"valid",[],"NV8"],[[65795,65798],"disallowed"],[[65799,65843],"valid",[],"NV8"],[[65844,65846],"disallowed"],[[65847,65855],"valid",[],"NV8"],[[65856,65930],"valid",[],"NV8"],[[65931,65932],"valid",[],"NV8"],[[65933,65935],"disallowed"],[[65936,65947],"valid",[],"NV8"],[[65948,65951],"disallowed"],[[65952,65952],"valid",[],"NV8"],[[65953,65999],"disallowed"],[[66000,66044],"valid",[],"NV8"],[[66045,66045],"valid"],[[66046,66175],"disallowed"],[[66176,66204],"valid"],[[66205,66207],"disallowed"],[[66208,66256],"valid"],[[66257,66271],"disallowed"],[[66272,66272],"valid"],[[66273,66299],"valid",[],"NV8"],[[66300,66303],"disallowed"],[[66304,66334],"valid"],[[66335,66335],"valid"],[[66336,66339],"valid",[],"NV8"],[[66340,66351],"disallowed"],[[66352,66368],"valid"],[[66369,66369],"valid",[],"NV8"],[[66370,66377],"valid"],[[66378,66378],"valid",[],"NV8"],[[66379,66383],"disallowed"],[[66384,66426],"valid"],[[66427,66431],"disallowed"],[[66432,66461],"valid"],[[66462,66462],"disallowed"],[[66463,66463],"valid",[],"NV8"],[[66464,66499],"valid"],[[66500,66503],"disallowed"],[[66504,66511],"valid"],[[66512,66517],"valid",[],"NV8"],[[66518,66559],"disallowed"],[[66560,66560],"mapped",[66600]],[[66561,66561],"mapped",[66601]],[[66562,66562],"mapped",[66602]],[[66563,66563],"mapped",[66603]],[[66564,66564],"mapped",[66604]],[[66565,66565],"mapped",[66605]],[[66566,66566],"mapped",[66606]],[[66567,66567],"mapped",[66607]],[[66568,66568],"mapped",[66608]],[[66569,66569],"mapped",[66609]],[[66570,66570],"mapped",[66610]],[[66571,66571],"mapped",[66611]],[[66572,66572],"mapped",[66612]],[[66573,66573],"mapped",[66613]],[[66574,66574],"mapped",[66614]],[[66575,66575],"mapped",[66615]],[[66576,66576],"mapped",[66616]],[[66577,66577],"mapped",[66617]],[[66578,66578],"mapped",[66618]],[[66579,66579],"mapped",[66619]],[[66580,66580],"mapped",[66620]],[[66581,66581],"mapped",[66621]],[[66582,66582],"mapped",[66622]],[[66583,66583],"mapped",[66623]],[[66584,66584],"mapped",[66624]],[[66585,66585],"mapped",[66625]],[[66586,66586],"mapped",[66626]],[[66587,66587],"mapped",[66627]],[[66588,66588],"mapped",[66628]],[[66589,66589],"mapped",[66629]],[[66590,66590],"mapped",[66630]],[[66591,66591],"mapped",[66631]],[[66592,66592],"mapped",[66632]],[[66593,66593],"mapped",[66633]],[[66594,66594],"mapped",[66634]],[[66595,66595],"mapped",[66635]],[[66596,66596],"mapped",[66636]],[[66597,66597],"mapped",[66637]],[[66598,66598],"mapped",[66638]],[[66599,66599],"mapped",[66639]],[[66600,66637],"valid"],[[66638,66717],"valid"],[[66718,66719],"disallowed"],[[66720,66729],"valid"],[[66730,66815],"disallowed"],[[66816,66855],"valid"],[[66856,66863],"disallowed"],[[66864,66915],"valid"],[[66916,66926],"disallowed"],[[66927,66927],"valid",[],"NV8"],[[66928,67071],"disallowed"],[[67072,67382],"valid"],[[67383,67391],"disallowed"],[[67392,67413],"valid"],[[67414,67423],"disallowed"],[[67424,67431],"valid"],[[67432,67583],"disallowed"],[[67584,67589],"valid"],[[67590,67591],"disallowed"],[[67592,67592],"valid"],[[67593,67593],"disallowed"],[[67594,67637],"valid"],[[67638,67638],"disallowed"],[[67639,67640],"valid"],[[67641,67643],"disallowed"],[[67644,67644],"valid"],[[67645,67646],"disallowed"],[[67647,67647],"valid"],[[67648,67669],"valid"],[[67670,67670],"disallowed"],[[67671,67679],"valid",[],"NV8"],[[67680,67702],"valid"],[[67703,67711],"valid",[],"NV8"],[[67712,67742],"valid"],[[67743,67750],"disallowed"],[[67751,67759],"valid",[],"NV8"],[[67760,67807],"disallowed"],[[67808,67826],"valid"],[[67827,67827],"disallowed"],[[67828,67829],"valid"],[[67830,67834],"disallowed"],[[67835,67839],"valid",[],"NV8"],[[67840,67861],"valid"],[[67862,67865],"valid",[],"NV8"],[[67866,67867],"valid",[],"NV8"],[[67868,67870],"disallowed"],[[67871,67871],"valid",[],"NV8"],[[67872,67897],"valid"],[[67898,67902],"disallowed"],[[67903,67903],"valid",[],"NV8"],[[67904,67967],"disallowed"],[[67968,68023],"valid"],[[68024,68027],"disallowed"],[[68028,68029],"valid",[],"NV8"],[[68030,68031],"valid"],[[68032,68047],"valid",[],"NV8"],[[68048,68049],"disallowed"],[[68050,68095],"valid",[],"NV8"],[[68096,68099],"valid"],[[68100,68100],"disallowed"],[[68101,68102],"valid"],[[68103,68107],"disallowed"],[[68108,68115],"valid"],[[68116,68116],"disallowed"],[[68117,68119],"valid"],[[68120,68120],"disallowed"],[[68121,68147],"valid"],[[68148,68151],"disallowed"],[[68152,68154],"valid"],[[68155,68158],"disallowed"],[[68159,68159],"valid"],[[68160,68167],"valid",[],"NV8"],[[68168,68175],"disallowed"],[[68176,68184],"valid",[],"NV8"],[[68185,68191],"disallowed"],[[68192,68220],"valid"],[[68221,68223],"valid",[],"NV8"],[[68224,68252],"valid"],[[68253,68255],"valid",[],"NV8"],[[68256,68287],"disallowed"],[[68288,68295],"valid"],[[68296,68296],"valid",[],"NV8"],[[68297,68326],"valid"],[[68327,68330],"disallowed"],[[68331,68342],"valid",[],"NV8"],[[68343,68351],"disallowed"],[[68352,68405],"valid"],[[68406,68408],"disallowed"],[[68409,68415],"valid",[],"NV8"],[[68416,68437],"valid"],[[68438,68439],"disallowed"],[[68440,68447],"valid",[],"NV8"],[[68448,68466],"valid"],[[68467,68471],"disallowed"],[[68472,68479],"valid",[],"NV8"],[[68480,68497],"valid"],[[68498,68504],"disallowed"],[[68505,68508],"valid",[],"NV8"],[[68509,68520],"disallowed"],[[68521,68527],"valid",[],"NV8"],[[68528,68607],"disallowed"],[[68608,68680],"valid"],[[68681,68735],"disallowed"],[[68736,68736],"mapped",[68800]],[[68737,68737],"mapped",[68801]],[[68738,68738],"mapped",[68802]],[[68739,68739],"mapped",[68803]],[[68740,68740],"mapped",[68804]],[[68741,68741],"mapped",[68805]],[[68742,68742],"mapped",[68806]],[[68743,68743],"mapped",[68807]],[[68744,68744],"mapped",[68808]],[[68745,68745],"mapped",[68809]],[[68746,68746],"mapped",[68810]],[[68747,68747],"mapped",[68811]],[[68748,68748],"mapped",[68812]],[[68749,68749],"mapped",[68813]],[[68750,68750],"mapped",[68814]],[[68751,68751],"mapped",[68815]],[[68752,68752],"mapped",[68816]],[[68753,68753],"mapped",[68817]],[[68754,68754],"mapped",[68818]],[[68755,68755],"mapped",[68819]],[[68756,68756],"mapped",[68820]],[[68757,68757],"mapped",[68821]],[[68758,68758],"mapped",[68822]],[[68759,68759],"mapped",[68823]],[[68760,68760],"mapped",[68824]],[[68761,68761],"mapped",[68825]],[[68762,68762],"mapped",[68826]],[[68763,68763],"mapped",[68827]],[[68764,68764],"mapped",[68828]],[[68765,68765],"mapped",[68829]],[[68766,68766],"mapped",[68830]],[[68767,68767],"mapped",[68831]],[[68768,68768],"mapped",[68832]],[[68769,68769],"mapped",[68833]],[[68770,68770],"mapped",[68834]],[[68771,68771],"mapped",[68835]],[[68772,68772],"mapped",[68836]],[[68773,68773],"mapped",[68837]],[[68774,68774],"mapped",[68838]],[[68775,68775],"mapped",[68839]],[[68776,68776],"mapped",[68840]],[[68777,68777],"mapped",[68841]],[[68778,68778],"mapped",[68842]],[[68779,68779],"mapped",[68843]],[[68780,68780],"mapped",[68844]],[[68781,68781],"mapped",[68845]],[[68782,68782],"mapped",[68846]],[[68783,68783],"mapped",[68847]],[[68784,68784],"mapped",[68848]],[[68785,68785],"mapped",[68849]],[[68786,68786],"mapped",[68850]],[[68787,68799],"disallowed"],[[68800,68850],"valid"],[[68851,68857],"disallowed"],[[68858,68863],"valid",[],"NV8"],[[68864,69215],"disallowed"],[[69216,69246],"valid",[],"NV8"],[[69247,69631],"disallowed"],[[69632,69702],"valid"],[[69703,69709],"valid",[],"NV8"],[[69710,69713],"disallowed"],[[69714,69733],"valid",[],"NV8"],[[69734,69743],"valid"],[[69744,69758],"disallowed"],[[69759,69759],"valid"],[[69760,69818],"valid"],[[69819,69820],"valid",[],"NV8"],[[69821,69821],"disallowed"],[[69822,69825],"valid",[],"NV8"],[[69826,69839],"disallowed"],[[69840,69864],"valid"],[[69865,69871],"disallowed"],[[69872,69881],"valid"],[[69882,69887],"disallowed"],[[69888,69940],"valid"],[[69941,69941],"disallowed"],[[69942,69951],"valid"],[[69952,69955],"valid",[],"NV8"],[[69956,69967],"disallowed"],[[69968,70003],"valid"],[[70004,70005],"valid",[],"NV8"],[[70006,70006],"valid"],[[70007,70015],"disallowed"],[[70016,70084],"valid"],[[70085,70088],"valid",[],"NV8"],[[70089,70089],"valid",[],"NV8"],[[70090,70092],"valid"],[[70093,70093],"valid",[],"NV8"],[[70094,70095],"disallowed"],[[70096,70105],"valid"],[[70106,70106],"valid"],[[70107,70107],"valid",[],"NV8"],[[70108,70108],"valid"],[[70109,70111],"valid",[],"NV8"],[[70112,70112],"disallowed"],[[70113,70132],"valid",[],"NV8"],[[70133,70143],"disallowed"],[[70144,70161],"valid"],[[70162,70162],"disallowed"],[[70163,70199],"valid"],[[70200,70205],"valid",[],"NV8"],[[70206,70271],"disallowed"],[[70272,70278],"valid"],[[70279,70279],"disallowed"],[[70280,70280],"valid"],[[70281,70281],"disallowed"],[[70282,70285],"valid"],[[70286,70286],"disallowed"],[[70287,70301],"valid"],[[70302,70302],"disallowed"],[[70303,70312],"valid"],[[70313,70313],"valid",[],"NV8"],[[70314,70319],"disallowed"],[[70320,70378],"valid"],[[70379,70383],"disallowed"],[[70384,70393],"valid"],[[70394,70399],"disallowed"],[[70400,70400],"valid"],[[70401,70403],"valid"],[[70404,70404],"disallowed"],[[70405,70412],"valid"],[[70413,70414],"disallowed"],[[70415,70416],"valid"],[[70417,70418],"disallowed"],[[70419,70440],"valid"],[[70441,70441],"disallowed"],[[70442,70448],"valid"],[[70449,70449],"disallowed"],[[70450,70451],"valid"],[[70452,70452],"disallowed"],[[70453,70457],"valid"],[[70458,70459],"disallowed"],[[70460,70468],"valid"],[[70469,70470],"disallowed"],[[70471,70472],"valid"],[[70473,70474],"disallowed"],[[70475,70477],"valid"],[[70478,70479],"disallowed"],[[70480,70480],"valid"],[[70481,70486],"disallowed"],[[70487,70487],"valid"],[[70488,70492],"disallowed"],[[70493,70499],"valid"],[[70500,70501],"disallowed"],[[70502,70508],"valid"],[[70509,70511],"disallowed"],[[70512,70516],"valid"],[[70517,70783],"disallowed"],[[70784,70853],"valid"],[[70854,70854],"valid",[],"NV8"],[[70855,70855],"valid"],[[70856,70863],"disallowed"],[[70864,70873],"valid"],[[70874,71039],"disallowed"],[[71040,71093],"valid"],[[71094,71095],"disallowed"],[[71096,71104],"valid"],[[71105,71113],"valid",[],"NV8"],[[71114,71127],"valid",[],"NV8"],[[71128,71133],"valid"],[[71134,71167],"disallowed"],[[71168,71232],"valid"],[[71233,71235],"valid",[],"NV8"],[[71236,71236],"valid"],[[71237,71247],"disallowed"],[[71248,71257],"valid"],[[71258,71295],"disallowed"],[[71296,71351],"valid"],[[71352,71359],"disallowed"],[[71360,71369],"valid"],[[71370,71423],"disallowed"],[[71424,71449],"valid"],[[71450,71452],"disallowed"],[[71453,71467],"valid"],[[71468,71471],"disallowed"],[[71472,71481],"valid"],[[71482,71487],"valid",[],"NV8"],[[71488,71839],"disallowed"],[[71840,71840],"mapped",[71872]],[[71841,71841],"mapped",[71873]],[[71842,71842],"mapped",[71874]],[[71843,71843],"mapped",[71875]],[[71844,71844],"mapped",[71876]],[[71845,71845],"mapped",[71877]],[[71846,71846],"mapped",[71878]],[[71847,71847],"mapped",[71879]],[[71848,71848],"mapped",[71880]],[[71849,71849],"mapped",[71881]],[[71850,71850],"mapped",[71882]],[[71851,71851],"mapped",[71883]],[[71852,71852],"mapped",[71884]],[[71853,71853],"mapped",[71885]],[[71854,71854],"mapped",[71886]],[[71855,71855],"mapped",[71887]],[[71856,71856],"mapped",[71888]],[[71857,71857],"mapped",[71889]],[[71858,71858],"mapped",[71890]],[[71859,71859],"mapped",[71891]],[[71860,71860],"mapped",[71892]],[[71861,71861],"mapped",[71893]],[[71862,71862],"mapped",[71894]],[[71863,71863],"mapped",[71895]],[[71864,71864],"mapped",[71896]],[[71865,71865],"mapped",[71897]],[[71866,71866],"mapped",[71898]],[[71867,71867],"mapped",[71899]],[[71868,71868],"mapped",[71900]],[[71869,71869],"mapped",[71901]],[[71870,71870],"mapped",[71902]],[[71871,71871],"mapped",[71903]],[[71872,71913],"valid"],[[71914,71922],"valid",[],"NV8"],[[71923,71934],"disallowed"],[[71935,71935],"valid"],[[71936,72383],"disallowed"],[[72384,72440],"valid"],[[72441,73727],"disallowed"],[[73728,74606],"valid"],[[74607,74648],"valid"],[[74649,74649],"valid"],[[74650,74751],"disallowed"],[[74752,74850],"valid",[],"NV8"],[[74851,74862],"valid",[],"NV8"],[[74863,74863],"disallowed"],[[74864,74867],"valid",[],"NV8"],[[74868,74868],"valid",[],"NV8"],[[74869,74879],"disallowed"],[[74880,75075],"valid"],[[75076,77823],"disallowed"],[[77824,78894],"valid"],[[78895,82943],"disallowed"],[[82944,83526],"valid"],[[83527,92159],"disallowed"],[[92160,92728],"valid"],[[92729,92735],"disallowed"],[[92736,92766],"valid"],[[92767,92767],"disallowed"],[[92768,92777],"valid"],[[92778,92781],"disallowed"],[[92782,92783],"valid",[],"NV8"],[[92784,92879],"disallowed"],[[92880,92909],"valid"],[[92910,92911],"disallowed"],[[92912,92916],"valid"],[[92917,92917],"valid",[],"NV8"],[[92918,92927],"disallowed"],[[92928,92982],"valid"],[[92983,92991],"valid",[],"NV8"],[[92992,92995],"valid"],[[92996,92997],"valid",[],"NV8"],[[92998,93007],"disallowed"],[[93008,93017],"valid"],[[93018,93018],"disallowed"],[[93019,93025],"valid",[],"NV8"],[[93026,93026],"disallowed"],[[93027,93047],"valid"],[[93048,93052],"disallowed"],[[93053,93071],"valid"],[[93072,93951],"disallowed"],[[93952,94020],"valid"],[[94021,94031],"disallowed"],[[94032,94078],"valid"],[[94079,94094],"disallowed"],[[94095,94111],"valid"],[[94112,110591],"disallowed"],[[110592,110593],"valid"],[[110594,113663],"disallowed"],[[113664,113770],"valid"],[[113771,113775],"disallowed"],[[113776,113788],"valid"],[[113789,113791],"disallowed"],[[113792,113800],"valid"],[[113801,113807],"disallowed"],[[113808,113817],"valid"],[[113818,113819],"disallowed"],[[113820,113820],"valid",[],"NV8"],[[113821,113822],"valid"],[[113823,113823],"valid",[],"NV8"],[[113824,113827],"ignored"],[[113828,118783],"disallowed"],[[118784,119029],"valid",[],"NV8"],[[119030,119039],"disallowed"],[[119040,119078],"valid",[],"NV8"],[[119079,119080],"disallowed"],[[119081,119081],"valid",[],"NV8"],[[119082,119133],"valid",[],"NV8"],[[119134,119134],"mapped",[119127,119141]],[[119135,119135],"mapped",[119128,119141]],[[119136,119136],"mapped",[119128,119141,119150]],[[119137,119137],"mapped",[119128,119141,119151]],[[119138,119138],"mapped",[119128,119141,119152]],[[119139,119139],"mapped",[119128,119141,119153]],[[119140,119140],"mapped",[119128,119141,119154]],[[119141,119154],"valid",[],"NV8"],[[119155,119162],"disallowed"],[[119163,119226],"valid",[],"NV8"],[[119227,119227],"mapped",[119225,119141]],[[119228,119228],"mapped",[119226,119141]],[[119229,119229],"mapped",[119225,119141,119150]],[[119230,119230],"mapped",[119226,119141,119150]],[[119231,119231],"mapped",[119225,119141,119151]],[[119232,119232],"mapped",[119226,119141,119151]],[[119233,119261],"valid",[],"NV8"],[[119262,119272],"valid",[],"NV8"],[[119273,119295],"disallowed"],[[119296,119365],"valid",[],"NV8"],[[119366,119551],"disallowed"],[[119552,119638],"valid",[],"NV8"],[[119639,119647],"disallowed"],[[119648,119665],"valid",[],"NV8"],[[119666,119807],"disallowed"],[[119808,119808],"mapped",[97]],[[119809,119809],"mapped",[98]],[[119810,119810],"mapped",[99]],[[119811,119811],"mapped",[100]],[[119812,119812],"mapped",[101]],[[119813,119813],"mapped",[102]],[[119814,119814],"mapped",[103]],[[119815,119815],"mapped",[104]],[[119816,119816],"mapped",[105]],[[119817,119817],"mapped",[106]],[[119818,119818],"mapped",[107]],[[119819,119819],"mapped",[108]],[[119820,119820],"mapped",[109]],[[119821,119821],"mapped",[110]],[[119822,119822],"mapped",[111]],[[119823,119823],"mapped",[112]],[[119824,119824],"mapped",[113]],[[119825,119825],"mapped",[114]],[[119826,119826],"mapped",[115]],[[119827,119827],"mapped",[116]],[[119828,119828],"mapped",[117]],[[119829,119829],"mapped",[118]],[[119830,119830],"mapped",[119]],[[119831,119831],"mapped",[120]],[[119832,119832],"mapped",[121]],[[119833,119833],"mapped",[122]],[[119834,119834],"mapped",[97]],[[119835,119835],"mapped",[98]],[[119836,119836],"mapped",[99]],[[119837,119837],"mapped",[100]],[[119838,119838],"mapped",[101]],[[119839,119839],"mapped",[102]],[[119840,119840],"mapped",[103]],[[119841,119841],"mapped",[104]],[[119842,119842],"mapped",[105]],[[119843,119843],"mapped",[106]],[[119844,119844],"mapped",[107]],[[119845,119845],"mapped",[108]],[[119846,119846],"mapped",[109]],[[119847,119847],"mapped",[110]],[[119848,119848],"mapped",[111]],[[119849,119849],"mapped",[112]],[[119850,119850],"mapped",[113]],[[119851,119851],"mapped",[114]],[[119852,119852],"mapped",[115]],[[119853,119853],"mapped",[116]],[[119854,119854],"mapped",[117]],[[119855,119855],"mapped",[118]],[[119856,119856],"mapped",[119]],[[119857,119857],"mapped",[120]],[[119858,119858],"mapped",[121]],[[119859,119859],"mapped",[122]],[[119860,119860],"mapped",[97]],[[119861,119861],"mapped",[98]],[[119862,119862],"mapped",[99]],[[119863,119863],"mapped",[100]],[[119864,119864],"mapped",[101]],[[119865,119865],"mapped",[102]],[[119866,119866],"mapped",[103]],[[119867,119867],"mapped",[104]],[[119868,119868],"mapped",[105]],[[119869,119869],"mapped",[106]],[[119870,119870],"mapped",[107]],[[119871,119871],"mapped",[108]],[[119872,119872],"mapped",[109]],[[119873,119873],"mapped",[110]],[[119874,119874],"mapped",[111]],[[119875,119875],"mapped",[112]],[[119876,119876],"mapped",[113]],[[119877,119877],"mapped",[114]],[[119878,119878],"mapped",[115]],[[119879,119879],"mapped",[116]],[[119880,119880],"mapped",[117]],[[119881,119881],"mapped",[118]],[[119882,119882],"mapped",[119]],[[119883,119883],"mapped",[120]],[[119884,119884],"mapped",[121]],[[119885,119885],"mapped",[122]],[[119886,119886],"mapped",[97]],[[119887,119887],"mapped",[98]],[[119888,119888],"mapped",[99]],[[119889,119889],"mapped",[100]],[[119890,119890],"mapped",[101]],[[119891,119891],"mapped",[102]],[[119892,119892],"mapped",[103]],[[119893,119893],"disallowed"],[[119894,119894],"mapped",[105]],[[119895,119895],"mapped",[106]],[[119896,119896],"mapped",[107]],[[119897,119897],"mapped",[108]],[[119898,119898],"mapped",[109]],[[119899,119899],"mapped",[110]],[[119900,119900],"mapped",[111]],[[119901,119901],"mapped",[112]],[[119902,119902],"mapped",[113]],[[119903,119903],"mapped",[114]],[[119904,119904],"mapped",[115]],[[119905,119905],"mapped",[116]],[[119906,119906],"mapped",[117]],[[119907,119907],"mapped",[118]],[[119908,119908],"mapped",[119]],[[119909,119909],"mapped",[120]],[[119910,119910],"mapped",[121]],[[119911,119911],"mapped",[122]],[[119912,119912],"mapped",[97]],[[119913,119913],"mapped",[98]],[[119914,119914],"mapped",[99]],[[119915,119915],"mapped",[100]],[[119916,119916],"mapped",[101]],[[119917,119917],"mapped",[102]],[[119918,119918],"mapped",[103]],[[119919,119919],"mapped",[104]],[[119920,119920],"mapped",[105]],[[119921,119921],"mapped",[106]],[[119922,119922],"mapped",[107]],[[119923,119923],"mapped",[108]],[[119924,119924],"mapped",[109]],[[119925,119925],"mapped",[110]],[[119926,119926],"mapped",[111]],[[119927,119927],"mapped",[112]],[[119928,119928],"mapped",[113]],[[119929,119929],"mapped",[114]],[[119930,119930],"mapped",[115]],[[119931,119931],"mapped",[116]],[[119932,119932],"mapped",[117]],[[119933,119933],"mapped",[118]],[[119934,119934],"mapped",[119]],[[119935,119935],"mapped",[120]],[[119936,119936],"mapped",[121]],[[119937,119937],"mapped",[122]],[[119938,119938],"mapped",[97]],[[119939,119939],"mapped",[98]],[[119940,119940],"mapped",[99]],[[119941,119941],"mapped",[100]],[[119942,119942],"mapped",[101]],[[119943,119943],"mapped",[102]],[[119944,119944],"mapped",[103]],[[119945,119945],"mapped",[104]],[[119946,119946],"mapped",[105]],[[119947,119947],"mapped",[106]],[[119948,119948],"mapped",[107]],[[119949,119949],"mapped",[108]],[[119950,119950],"mapped",[109]],[[119951,119951],"mapped",[110]],[[119952,119952],"mapped",[111]],[[119953,119953],"mapped",[112]],[[119954,119954],"mapped",[113]],[[119955,119955],"mapped",[114]],[[119956,119956],"mapped",[115]],[[119957,119957],"mapped",[116]],[[119958,119958],"mapped",[117]],[[119959,119959],"mapped",[118]],[[119960,119960],"mapped",[119]],[[119961,119961],"mapped",[120]],[[119962,119962],"mapped",[121]],[[119963,119963],"mapped",[122]],[[119964,119964],"mapped",[97]],[[119965,119965],"disallowed"],[[119966,119966],"mapped",[99]],[[119967,119967],"mapped",[100]],[[119968,119969],"disallowed"],[[119970,119970],"mapped",[103]],[[119971,119972],"disallowed"],[[119973,119973],"mapped",[106]],[[119974,119974],"mapped",[107]],[[119975,119976],"disallowed"],[[119977,119977],"mapped",[110]],[[119978,119978],"mapped",[111]],[[119979,119979],"mapped",[112]],[[119980,119980],"mapped",[113]],[[119981,119981],"disallowed"],[[119982,119982],"mapped",[115]],[[119983,119983],"mapped",[116]],[[119984,119984],"mapped",[117]],[[119985,119985],"mapped",[118]],[[119986,119986],"mapped",[119]],[[119987,119987],"mapped",[120]],[[119988,119988],"mapped",[121]],[[119989,119989],"mapped",[122]],[[119990,119990],"mapped",[97]],[[119991,119991],"mapped",[98]],[[119992,119992],"mapped",[99]],[[119993,119993],"mapped",[100]],[[119994,119994],"disallowed"],[[119995,119995],"mapped",[102]],[[119996,119996],"disallowed"],[[119997,119997],"mapped",[104]],[[119998,119998],"mapped",[105]],[[119999,119999],"mapped",[106]],[[120000,120000],"mapped",[107]],[[120001,120001],"mapped",[108]],[[120002,120002],"mapped",[109]],[[120003,120003],"mapped",[110]],[[120004,120004],"disallowed"],[[120005,120005],"mapped",[112]],[[120006,120006],"mapped",[113]],[[120007,120007],"mapped",[114]],[[120008,120008],"mapped",[115]],[[120009,120009],"mapped",[116]],[[120010,120010],"mapped",[117]],[[120011,120011],"mapped",[118]],[[120012,120012],"mapped",[119]],[[120013,120013],"mapped",[120]],[[120014,120014],"mapped",[121]],[[120015,120015],"mapped",[122]],[[120016,120016],"mapped",[97]],[[120017,120017],"mapped",[98]],[[120018,120018],"mapped",[99]],[[120019,120019],"mapped",[100]],[[120020,120020],"mapped",[101]],[[120021,120021],"mapped",[102]],[[120022,120022],"mapped",[103]],[[120023,120023],"mapped",[104]],[[120024,120024],"mapped",[105]],[[120025,120025],"mapped",[106]],[[120026,120026],"mapped",[107]],[[120027,120027],"mapped",[108]],[[120028,120028],"mapped",[109]],[[120029,120029],"mapped",[110]],[[120030,120030],"mapped",[111]],[[120031,120031],"mapped",[112]],[[120032,120032],"mapped",[113]],[[120033,120033],"mapped",[114]],[[120034,120034],"mapped",[115]],[[120035,120035],"mapped",[116]],[[120036,120036],"mapped",[117]],[[120037,120037],"mapped",[118]],[[120038,120038],"mapped",[119]],[[120039,120039],"mapped",[120]],[[120040,120040],"mapped",[121]],[[120041,120041],"mapped",[122]],[[120042,120042],"mapped",[97]],[[120043,120043],"mapped",[98]],[[120044,120044],"mapped",[99]],[[120045,120045],"mapped",[100]],[[120046,120046],"mapped",[101]],[[120047,120047],"mapped",[102]],[[120048,120048],"mapped",[103]],[[120049,120049],"mapped",[104]],[[120050,120050],"mapped",[105]],[[120051,120051],"mapped",[106]],[[120052,120052],"mapped",[107]],[[120053,120053],"mapped",[108]],[[120054,120054],"mapped",[109]],[[120055,120055],"mapped",[110]],[[120056,120056],"mapped",[111]],[[120057,120057],"mapped",[112]],[[120058,120058],"mapped",[113]],[[120059,120059],"mapped",[114]],[[120060,120060],"mapped",[115]],[[120061,120061],"mapped",[116]],[[120062,120062],"mapped",[117]],[[120063,120063],"mapped",[118]],[[120064,120064],"mapped",[119]],[[120065,120065],"mapped",[120]],[[120066,120066],"mapped",[121]],[[120067,120067],"mapped",[122]],[[120068,120068],"mapped",[97]],[[120069,120069],"mapped",[98]],[[120070,120070],"disallowed"],[[120071,120071],"mapped",[100]],[[120072,120072],"mapped",[101]],[[120073,120073],"mapped",[102]],[[120074,120074],"mapped",[103]],[[120075,120076],"disallowed"],[[120077,120077],"mapped",[106]],[[120078,120078],"mapped",[107]],[[120079,120079],"mapped",[108]],[[120080,120080],"mapped",[109]],[[120081,120081],"mapped",[110]],[[120082,120082],"mapped",[111]],[[120083,120083],"mapped",[112]],[[120084,120084],"mapped",[113]],[[120085,120085],"disallowed"],[[120086,120086],"mapped",[115]],[[120087,120087],"mapped",[116]],[[120088,120088],"mapped",[117]],[[120089,120089],"mapped",[118]],[[120090,120090],"mapped",[119]],[[120091,120091],"mapped",[120]],[[120092,120092],"mapped",[121]],[[120093,120093],"disallowed"],[[120094,120094],"mapped",[97]],[[120095,120095],"mapped",[98]],[[120096,120096],"mapped",[99]],[[120097,120097],"mapped",[100]],[[120098,120098],"mapped",[101]],[[120099,120099],"mapped",[102]],[[120100,120100],"mapped",[103]],[[120101,120101],"mapped",[104]],[[120102,120102],"mapped",[105]],[[120103,120103],"mapped",[106]],[[120104,120104],"mapped",[107]],[[120105,120105],"mapped",[108]],[[120106,120106],"mapped",[109]],[[120107,120107],"mapped",[110]],[[120108,120108],"mapped",[111]],[[120109,120109],"mapped",[112]],[[120110,120110],"mapped",[113]],[[120111,120111],"mapped",[114]],[[120112,120112],"mapped",[115]],[[120113,120113],"mapped",[116]],[[120114,120114],"mapped",[117]],[[120115,120115],"mapped",[118]],[[120116,120116],"mapped",[119]],[[120117,120117],"mapped",[120]],[[120118,120118],"mapped",[121]],[[120119,120119],"mapped",[122]],[[120120,120120],"mapped",[97]],[[120121,120121],"mapped",[98]],[[120122,120122],"disallowed"],[[120123,120123],"mapped",[100]],[[120124,120124],"mapped",[101]],[[120125,120125],"mapped",[102]],[[120126,120126],"mapped",[103]],[[120127,120127],"disallowed"],[[120128,120128],"mapped",[105]],[[120129,120129],"mapped",[106]],[[120130,120130],"mapped",[107]],[[120131,120131],"mapped",[108]],[[120132,120132],"mapped",[109]],[[120133,120133],"disallowed"],[[120134,120134],"mapped",[111]],[[120135,120137],"disallowed"],[[120138,120138],"mapped",[115]],[[120139,120139],"mapped",[116]],[[120140,120140],"mapped",[117]],[[120141,120141],"mapped",[118]],[[120142,120142],"mapped",[119]],[[120143,120143],"mapped",[120]],[[120144,120144],"mapped",[121]],[[120145,120145],"disallowed"],[[120146,120146],"mapped",[97]],[[120147,120147],"mapped",[98]],[[120148,120148],"mapped",[99]],[[120149,120149],"mapped",[100]],[[120150,120150],"mapped",[101]],[[120151,120151],"mapped",[102]],[[120152,120152],"mapped",[103]],[[120153,120153],"mapped",[104]],[[120154,120154],"mapped",[105]],[[120155,120155],"mapped",[106]],[[120156,120156],"mapped",[107]],[[120157,120157],"mapped",[108]],[[120158,120158],"mapped",[109]],[[120159,120159],"mapped",[110]],[[120160,120160],"mapped",[111]],[[120161,120161],"mapped",[112]],[[120162,120162],"mapped",[113]],[[120163,120163],"mapped",[114]],[[120164,120164],"mapped",[115]],[[120165,120165],"mapped",[116]],[[120166,120166],"mapped",[117]],[[120167,120167],"mapped",[118]],[[120168,120168],"mapped",[119]],[[120169,120169],"mapped",[120]],[[120170,120170],"mapped",[121]],[[120171,120171],"mapped",[122]],[[120172,120172],"mapped",[97]],[[120173,120173],"mapped",[98]],[[120174,120174],"mapped",[99]],[[120175,120175],"mapped",[100]],[[120176,120176],"mapped",[101]],[[120177,120177],"mapped",[102]],[[120178,120178],"mapped",[103]],[[120179,120179],"mapped",[104]],[[120180,120180],"mapped",[105]],[[120181,120181],"mapped",[106]],[[120182,120182],"mapped",[107]],[[120183,120183],"mapped",[108]],[[120184,120184],"mapped",[109]],[[120185,120185],"mapped",[110]],[[120186,120186],"mapped",[111]],[[120187,120187],"mapped",[112]],[[120188,120188],"mapped",[113]],[[120189,120189],"mapped",[114]],[[120190,120190],"mapped",[115]],[[120191,120191],"mapped",[116]],[[120192,120192],"mapped",[117]],[[120193,120193],"mapped",[118]],[[120194,120194],"mapped",[119]],[[120195,120195],"mapped",[120]],[[120196,120196],"mapped",[121]],[[120197,120197],"mapped",[122]],[[120198,120198],"mapped",[97]],[[120199,120199],"mapped",[98]],[[120200,120200],"mapped",[99]],[[120201,120201],"mapped",[100]],[[120202,120202],"mapped",[101]],[[120203,120203],"mapped",[102]],[[120204,120204],"mapped",[103]],[[120205,120205],"mapped",[104]],[[120206,120206],"mapped",[105]],[[120207,120207],"mapped",[106]],[[120208,120208],"mapped",[107]],[[120209,120209],"mapped",[108]],[[120210,120210],"mapped",[109]],[[120211,120211],"mapped",[110]],[[120212,120212],"mapped",[111]],[[120213,120213],"mapped",[112]],[[120214,120214],"mapped",[113]],[[120215,120215],"mapped",[114]],[[120216,120216],"mapped",[115]],[[120217,120217],"mapped",[116]],[[120218,120218],"mapped",[117]],[[120219,120219],"mapped",[118]],[[120220,120220],"mapped",[119]],[[120221,120221],"mapped",[120]],[[120222,120222],"mapped",[121]],[[120223,120223],"mapped",[122]],[[120224,120224],"mapped",[97]],[[120225,120225],"mapped",[98]],[[120226,120226],"mapped",[99]],[[120227,120227],"mapped",[100]],[[120228,120228],"mapped",[101]],[[120229,120229],"mapped",[102]],[[120230,120230],"mapped",[103]],[[120231,120231],"mapped",[104]],[[120232,120232],"mapped",[105]],[[120233,120233],"mapped",[106]],[[120234,120234],"mapped",[107]],[[120235,120235],"mapped",[108]],[[120236,120236],"mapped",[109]],[[120237,120237],"mapped",[110]],[[120238,120238],"mapped",[111]],[[120239,120239],"mapped",[112]],[[120240,120240],"mapped",[113]],[[120241,120241],"mapped",[114]],[[120242,120242],"mapped",[115]],[[120243,120243],"mapped",[116]],[[120244,120244],"mapped",[117]],[[120245,120245],"mapped",[118]],[[120246,120246],"mapped",[119]],[[120247,120247],"mapped",[120]],[[120248,120248],"mapped",[121]],[[120249,120249],"mapped",[122]],[[120250,120250],"mapped",[97]],[[120251,120251],"mapped",[98]],[[120252,120252],"mapped",[99]],[[120253,120253],"mapped",[100]],[[120254,120254],"mapped",[101]],[[120255,120255],"mapped",[102]],[[120256,120256],"mapped",[103]],[[120257,120257],"mapped",[104]],[[120258,120258],"mapped",[105]],[[120259,120259],"mapped",[106]],[[120260,120260],"mapped",[107]],[[120261,120261],"mapped",[108]],[[120262,120262],"mapped",[109]],[[120263,120263],"mapped",[110]],[[120264,120264],"mapped",[111]],[[120265,120265],"mapped",[112]],[[120266,120266],"mapped",[113]],[[120267,120267],"mapped",[114]],[[120268,120268],"mapped",[115]],[[120269,120269],"mapped",[116]],[[120270,120270],"mapped",[117]],[[120271,120271],"mapped",[118]],[[120272,120272],"mapped",[119]],[[120273,120273],"mapped",[120]],[[120274,120274],"mapped",[121]],[[120275,120275],"mapped",[122]],[[120276,120276],"mapped",[97]],[[120277,120277],"mapped",[98]],[[120278,120278],"mapped",[99]],[[120279,120279],"mapped",[100]],[[120280,120280],"mapped",[101]],[[120281,120281],"mapped",[102]],[[120282,120282],"mapped",[103]],[[120283,120283],"mapped",[104]],[[120284,120284],"mapped",[105]],[[120285,120285],"mapped",[106]],[[120286,120286],"mapped",[107]],[[120287,120287],"mapped",[108]],[[120288,120288],"mapped",[109]],[[120289,120289],"mapped",[110]],[[120290,120290],"mapped",[111]],[[120291,120291],"mapped",[112]],[[120292,120292],"mapped",[113]],[[120293,120293],"mapped",[114]],[[120294,120294],"mapped",[115]],[[120295,120295],"mapped",[116]],[[120296,120296],"mapped",[117]],[[120297,120297],"mapped",[118]],[[120298,120298],"mapped",[119]],[[120299,120299],"mapped",[120]],[[120300,120300],"mapped",[121]],[[120301,120301],"mapped",[122]],[[120302,120302],"mapped",[97]],[[120303,120303],"mapped",[98]],[[120304,120304],"mapped",[99]],[[120305,120305],"mapped",[100]],[[120306,120306],"mapped",[101]],[[120307,120307],"mapped",[102]],[[120308,120308],"mapped",[103]],[[120309,120309],"mapped",[104]],[[120310,120310],"mapped",[105]],[[120311,120311],"mapped",[106]],[[120312,120312],"mapped",[107]],[[120313,120313],"mapped",[108]],[[120314,120314],"mapped",[109]],[[120315,120315],"mapped",[110]],[[120316,120316],"mapped",[111]],[[120317,120317],"mapped",[112]],[[120318,120318],"mapped",[113]],[[120319,120319],"mapped",[114]],[[120320,120320],"mapped",[115]],[[120321,120321],"mapped",[116]],[[120322,120322],"mapped",[117]],[[120323,120323],"mapped",[118]],[[120324,120324],"mapped",[119]],[[120325,120325],"mapped",[120]],[[120326,120326],"mapped",[121]],[[120327,120327],"mapped",[122]],[[120328,120328],"mapped",[97]],[[120329,120329],"mapped",[98]],[[120330,120330],"mapped",[99]],[[120331,120331],"mapped",[100]],[[120332,120332],"mapped",[101]],[[120333,120333],"mapped",[102]],[[120334,120334],"mapped",[103]],[[120335,120335],"mapped",[104]],[[120336,120336],"mapped",[105]],[[120337,120337],"mapped",[106]],[[120338,120338],"mapped",[107]],[[120339,120339],"mapped",[108]],[[120340,120340],"mapped",[109]],[[120341,120341],"mapped",[110]],[[120342,120342],"mapped",[111]],[[120343,120343],"mapped",[112]],[[120344,120344],"mapped",[113]],[[120345,120345],"mapped",[114]],[[120346,120346],"mapped",[115]],[[120347,120347],"mapped",[116]],[[120348,120348],"mapped",[117]],[[120349,120349],"mapped",[118]],[[120350,120350],"mapped",[119]],[[120351,120351],"mapped",[120]],[[120352,120352],"mapped",[121]],[[120353,120353],"mapped",[122]],[[120354,120354],"mapped",[97]],[[120355,120355],"mapped",[98]],[[120356,120356],"mapped",[99]],[[120357,120357],"mapped",[100]],[[120358,120358],"mapped",[101]],[[120359,120359],"mapped",[102]],[[120360,120360],"mapped",[103]],[[120361,120361],"mapped",[104]],[[120362,120362],"mapped",[105]],[[120363,120363],"mapped",[106]],[[120364,120364],"mapped",[107]],[[120365,120365],"mapped",[108]],[[120366,120366],"mapped",[109]],[[120367,120367],"mapped",[110]],[[120368,120368],"mapped",[111]],[[120369,120369],"mapped",[112]],[[120370,120370],"mapped",[113]],[[120371,120371],"mapped",[114]],[[120372,120372],"mapped",[115]],[[120373,120373],"mapped",[116]],[[120374,120374],"mapped",[117]],[[120375,120375],"mapped",[118]],[[120376,120376],"mapped",[119]],[[120377,120377],"mapped",[120]],[[120378,120378],"mapped",[121]],[[120379,120379],"mapped",[122]],[[120380,120380],"mapped",[97]],[[120381,120381],"mapped",[98]],[[120382,120382],"mapped",[99]],[[120383,120383],"mapped",[100]],[[120384,120384],"mapped",[101]],[[120385,120385],"mapped",[102]],[[120386,120386],"mapped",[103]],[[120387,120387],"mapped",[104]],[[120388,120388],"mapped",[105]],[[120389,120389],"mapped",[106]],[[120390,120390],"mapped",[107]],[[120391,120391],"mapped",[108]],[[120392,120392],"mapped",[109]],[[120393,120393],"mapped",[110]],[[120394,120394],"mapped",[111]],[[120395,120395],"mapped",[112]],[[120396,120396],"mapped",[113]],[[120397,120397],"mapped",[114]],[[120398,120398],"mapped",[115]],[[120399,120399],"mapped",[116]],[[120400,120400],"mapped",[117]],[[120401,120401],"mapped",[118]],[[120402,120402],"mapped",[119]],[[120403,120403],"mapped",[120]],[[120404,120404],"mapped",[121]],[[120405,120405],"mapped",[122]],[[120406,120406],"mapped",[97]],[[120407,120407],"mapped",[98]],[[120408,120408],"mapped",[99]],[[120409,120409],"mapped",[100]],[[120410,120410],"mapped",[101]],[[120411,120411],"mapped",[102]],[[120412,120412],"mapped",[103]],[[120413,120413],"mapped",[104]],[[120414,120414],"mapped",[105]],[[120415,120415],"mapped",[106]],[[120416,120416],"mapped",[107]],[[120417,120417],"mapped",[108]],[[120418,120418],"mapped",[109]],[[120419,120419],"mapped",[110]],[[120420,120420],"mapped",[111]],[[120421,120421],"mapped",[112]],[[120422,120422],"mapped",[113]],[[120423,120423],"mapped",[114]],[[120424,120424],"mapped",[115]],[[120425,120425],"mapped",[116]],[[120426,120426],"mapped",[117]],[[120427,120427],"mapped",[118]],[[120428,120428],"mapped",[119]],[[120429,120429],"mapped",[120]],[[120430,120430],"mapped",[121]],[[120431,120431],"mapped",[122]],[[120432,120432],"mapped",[97]],[[120433,120433],"mapped",[98]],[[120434,120434],"mapped",[99]],[[120435,120435],"mapped",[100]],[[120436,120436],"mapped",[101]],[[120437,120437],"mapped",[102]],[[120438,120438],"mapped",[103]],[[120439,120439],"mapped",[104]],[[120440,120440],"mapped",[105]],[[120441,120441],"mapped",[106]],[[120442,120442],"mapped",[107]],[[120443,120443],"mapped",[108]],[[120444,120444],"mapped",[109]],[[120445,120445],"mapped",[110]],[[120446,120446],"mapped",[111]],[[120447,120447],"mapped",[112]],[[120448,120448],"mapped",[113]],[[120449,120449],"mapped",[114]],[[120450,120450],"mapped",[115]],[[120451,120451],"mapped",[116]],[[120452,120452],"mapped",[117]],[[120453,120453],"mapped",[118]],[[120454,120454],"mapped",[119]],[[120455,120455],"mapped",[120]],[[120456,120456],"mapped",[121]],[[120457,120457],"mapped",[122]],[[120458,120458],"mapped",[97]],[[120459,120459],"mapped",[98]],[[120460,120460],"mapped",[99]],[[120461,120461],"mapped",[100]],[[120462,120462],"mapped",[101]],[[120463,120463],"mapped",[102]],[[120464,120464],"mapped",[103]],[[120465,120465],"mapped",[104]],[[120466,120466],"mapped",[105]],[[120467,120467],"mapped",[106]],[[120468,120468],"mapped",[107]],[[120469,120469],"mapped",[108]],[[120470,120470],"mapped",[109]],[[120471,120471],"mapped",[110]],[[120472,120472],"mapped",[111]],[[120473,120473],"mapped",[112]],[[120474,120474],"mapped",[113]],[[120475,120475],"mapped",[114]],[[120476,120476],"mapped",[115]],[[120477,120477],"mapped",[116]],[[120478,120478],"mapped",[117]],[[120479,120479],"mapped",[118]],[[120480,120480],"mapped",[119]],[[120481,120481],"mapped",[120]],[[120482,120482],"mapped",[121]],[[120483,120483],"mapped",[122]],[[120484,120484],"mapped",[305]],[[120485,120485],"mapped",[567]],[[120486,120487],"disallowed"],[[120488,120488],"mapped",[945]],[[120489,120489],"mapped",[946]],[[120490,120490],"mapped",[947]],[[120491,120491],"mapped",[948]],[[120492,120492],"mapped",[949]],[[120493,120493],"mapped",[950]],[[120494,120494],"mapped",[951]],[[120495,120495],"mapped",[952]],[[120496,120496],"mapped",[953]],[[120497,120497],"mapped",[954]],[[120498,120498],"mapped",[955]],[[120499,120499],"mapped",[956]],[[120500,120500],"mapped",[957]],[[120501,120501],"mapped",[958]],[[120502,120502],"mapped",[959]],[[120503,120503],"mapped",[960]],[[120504,120504],"mapped",[961]],[[120505,120505],"mapped",[952]],[[120506,120506],"mapped",[963]],[[120507,120507],"mapped",[964]],[[120508,120508],"mapped",[965]],[[120509,120509],"mapped",[966]],[[120510,120510],"mapped",[967]],[[120511,120511],"mapped",[968]],[[120512,120512],"mapped",[969]],[[120513,120513],"mapped",[8711]],[[120514,120514],"mapped",[945]],[[120515,120515],"mapped",[946]],[[120516,120516],"mapped",[947]],[[120517,120517],"mapped",[948]],[[120518,120518],"mapped",[949]],[[120519,120519],"mapped",[950]],[[120520,120520],"mapped",[951]],[[120521,120521],"mapped",[952]],[[120522,120522],"mapped",[953]],[[120523,120523],"mapped",[954]],[[120524,120524],"mapped",[955]],[[120525,120525],"mapped",[956]],[[120526,120526],"mapped",[957]],[[120527,120527],"mapped",[958]],[[120528,120528],"mapped",[959]],[[120529,120529],"mapped",[960]],[[120530,120530],"mapped",[961]],[[120531,120532],"mapped",[963]],[[120533,120533],"mapped",[964]],[[120534,120534],"mapped",[965]],[[120535,120535],"mapped",[966]],[[120536,120536],"mapped",[967]],[[120537,120537],"mapped",[968]],[[120538,120538],"mapped",[969]],[[120539,120539],"mapped",[8706]],[[120540,120540],"mapped",[949]],[[120541,120541],"mapped",[952]],[[120542,120542],"mapped",[954]],[[120543,120543],"mapped",[966]],[[120544,120544],"mapped",[961]],[[120545,120545],"mapped",[960]],[[120546,120546],"mapped",[945]],[[120547,120547],"mapped",[946]],[[120548,120548],"mapped",[947]],[[120549,120549],"mapped",[948]],[[120550,120550],"mapped",[949]],[[120551,120551],"mapped",[950]],[[120552,120552],"mapped",[951]],[[120553,120553],"mapped",[952]],[[120554,120554],"mapped",[953]],[[120555,120555],"mapped",[954]],[[120556,120556],"mapped",[955]],[[120557,120557],"mapped",[956]],[[120558,120558],"mapped",[957]],[[120559,120559],"mapped",[958]],[[120560,120560],"mapped",[959]],[[120561,120561],"mapped",[960]],[[120562,120562],"mapped",[961]],[[120563,120563],"mapped",[952]],[[120564,120564],"mapped",[963]],[[120565,120565],"mapped",[964]],[[120566,120566],"mapped",[965]],[[120567,120567],"mapped",[966]],[[120568,120568],"mapped",[967]],[[120569,120569],"mapped",[968]],[[120570,120570],"mapped",[969]],[[120571,120571],"mapped",[8711]],[[120572,120572],"mapped",[945]],[[120573,120573],"mapped",[946]],[[120574,120574],"mapped",[947]],[[120575,120575],"mapped",[948]],[[120576,120576],"mapped",[949]],[[120577,120577],"mapped",[950]],[[120578,120578],"mapped",[951]],[[120579,120579],"mapped",[952]],[[120580,120580],"mapped",[953]],[[120581,120581],"mapped",[954]],[[120582,120582],"mapped",[955]],[[120583,120583],"mapped",[956]],[[120584,120584],"mapped",[957]],[[120585,120585],"mapped",[958]],[[120586,120586],"mapped",[959]],[[120587,120587],"mapped",[960]],[[120588,120588],"mapped",[961]],[[120589,120590],"mapped",[963]],[[120591,120591],"mapped",[964]],[[120592,120592],"mapped",[965]],[[120593,120593],"mapped",[966]],[[120594,120594],"mapped",[967]],[[120595,120595],"mapped",[968]],[[120596,120596],"mapped",[969]],[[120597,120597],"mapped",[8706]],[[120598,120598],"mapped",[949]],[[120599,120599],"mapped",[952]],[[120600,120600],"mapped",[954]],[[120601,120601],"mapped",[966]],[[120602,120602],"mapped",[961]],[[120603,120603],"mapped",[960]],[[120604,120604],"mapped",[945]],[[120605,120605],"mapped",[946]],[[120606,120606],"mapped",[947]],[[120607,120607],"mapped",[948]],[[120608,120608],"mapped",[949]],[[120609,120609],"mapped",[950]],[[120610,120610],"mapped",[951]],[[120611,120611],"mapped",[952]],[[120612,120612],"mapped",[953]],[[120613,120613],"mapped",[954]],[[120614,120614],"mapped",[955]],[[120615,120615],"mapped",[956]],[[120616,120616],"mapped",[957]],[[120617,120617],"mapped",[958]],[[120618,120618],"mapped",[959]],[[120619,120619],"mapped",[960]],[[120620,120620],"mapped",[961]],[[120621,120621],"mapped",[952]],[[120622,120622],"mapped",[963]],[[120623,120623],"mapped",[964]],[[120624,120624],"mapped",[965]],[[120625,120625],"mapped",[966]],[[120626,120626],"mapped",[967]],[[120627,120627],"mapped",[968]],[[120628,120628],"mapped",[969]],[[120629,120629],"mapped",[8711]],[[120630,120630],"mapped",[945]],[[120631,120631],"mapped",[946]],[[120632,120632],"mapped",[947]],[[120633,120633],"mapped",[948]],[[120634,120634],"mapped",[949]],[[120635,120635],"mapped",[950]],[[120636,120636],"mapped",[951]],[[120637,120637],"mapped",[952]],[[120638,120638],"mapped",[953]],[[120639,120639],"mapped",[954]],[[120640,120640],"mapped",[955]],[[120641,120641],"mapped",[956]],[[120642,120642],"mapped",[957]],[[120643,120643],"mapped",[958]],[[120644,120644],"mapped",[959]],[[120645,120645],"mapped",[960]],[[120646,120646],"mapped",[961]],[[120647,120648],"mapped",[963]],[[120649,120649],"mapped",[964]],[[120650,120650],"mapped",[965]],[[120651,120651],"mapped",[966]],[[120652,120652],"mapped",[967]],[[120653,120653],"mapped",[968]],[[120654,120654],"mapped",[969]],[[120655,120655],"mapped",[8706]],[[120656,120656],"mapped",[949]],[[120657,120657],"mapped",[952]],[[120658,120658],"mapped",[954]],[[120659,120659],"mapped",[966]],[[120660,120660],"mapped",[961]],[[120661,120661],"mapped",[960]],[[120662,120662],"mapped",[945]],[[120663,120663],"mapped",[946]],[[120664,120664],"mapped",[947]],[[120665,120665],"mapped",[948]],[[120666,120666],"mapped",[949]],[[120667,120667],"mapped",[950]],[[120668,120668],"mapped",[951]],[[120669,120669],"mapped",[952]],[[120670,120670],"mapped",[953]],[[120671,120671],"mapped",[954]],[[120672,120672],"mapped",[955]],[[120673,120673],"mapped",[956]],[[120674,120674],"mapped",[957]],[[120675,120675],"mapped",[958]],[[120676,120676],"mapped",[959]],[[120677,120677],"mapped",[960]],[[120678,120678],"mapped",[961]],[[120679,120679],"mapped",[952]],[[120680,120680],"mapped",[963]],[[120681,120681],"mapped",[964]],[[120682,120682],"mapped",[965]],[[120683,120683],"mapped",[966]],[[120684,120684],"mapped",[967]],[[120685,120685],"mapped",[968]],[[120686,120686],"mapped",[969]],[[120687,120687],"mapped",[8711]],[[120688,120688],"mapped",[945]],[[120689,120689],"mapped",[946]],[[120690,120690],"mapped",[947]],[[120691,120691],"mapped",[948]],[[120692,120692],"mapped",[949]],[[120693,120693],"mapped",[950]],[[120694,120694],"mapped",[951]],[[120695,120695],"mapped",[952]],[[120696,120696],"mapped",[953]],[[120697,120697],"mapped",[954]],[[120698,120698],"mapped",[955]],[[120699,120699],"mapped",[956]],[[120700,120700],"mapped",[957]],[[120701,120701],"mapped",[958]],[[120702,120702],"mapped",[959]],[[120703,120703],"mapped",[960]],[[120704,120704],"mapped",[961]],[[120705,120706],"mapped",[963]],[[120707,120707],"mapped",[964]],[[120708,120708],"mapped",[965]],[[120709,120709],"mapped",[966]],[[120710,120710],"mapped",[967]],[[120711,120711],"mapped",[968]],[[120712,120712],"mapped",[969]],[[120713,120713],"mapped",[8706]],[[120714,120714],"mapped",[949]],[[120715,120715],"mapped",[952]],[[120716,120716],"mapped",[954]],[[120717,120717],"mapped",[966]],[[120718,120718],"mapped",[961]],[[120719,120719],"mapped",[960]],[[120720,120720],"mapped",[945]],[[120721,120721],"mapped",[946]],[[120722,120722],"mapped",[947]],[[120723,120723],"mapped",[948]],[[120724,120724],"mapped",[949]],[[120725,120725],"mapped",[950]],[[120726,120726],"mapped",[951]],[[120727,120727],"mapped",[952]],[[120728,120728],"mapped",[953]],[[120729,120729],"mapped",[954]],[[120730,120730],"mapped",[955]],[[120731,120731],"mapped",[956]],[[120732,120732],"mapped",[957]],[[120733,120733],"mapped",[958]],[[120734,120734],"mapped",[959]],[[120735,120735],"mapped",[960]],[[120736,120736],"mapped",[961]],[[120737,120737],"mapped",[952]],[[120738,120738],"mapped",[963]],[[120739,120739],"mapped",[964]],[[120740,120740],"mapped",[965]],[[120741,120741],"mapped",[966]],[[120742,120742],"mapped",[967]],[[120743,120743],"mapped",[968]],[[120744,120744],"mapped",[969]],[[120745,120745],"mapped",[8711]],[[120746,120746],"mapped",[945]],[[120747,120747],"mapped",[946]],[[120748,120748],"mapped",[947]],[[120749,120749],"mapped",[948]],[[120750,120750],"mapped",[949]],[[120751,120751],"mapped",[950]],[[120752,120752],"mapped",[951]],[[120753,120753],"mapped",[952]],[[120754,120754],"mapped",[953]],[[120755,120755],"mapped",[954]],[[120756,120756],"mapped",[955]],[[120757,120757],"mapped",[956]],[[120758,120758],"mapped",[957]],[[120759,120759],"mapped",[958]],[[120760,120760],"mapped",[959]],[[120761,120761],"mapped",[960]],[[120762,120762],"mapped",[961]],[[120763,120764],"mapped",[963]],[[120765,120765],"mapped",[964]],[[120766,120766],"mapped",[965]],[[120767,120767],"mapped",[966]],[[120768,120768],"mapped",[967]],[[120769,120769],"mapped",[968]],[[120770,120770],"mapped",[969]],[[120771,120771],"mapped",[8706]],[[120772,120772],"mapped",[949]],[[120773,120773],"mapped",[952]],[[120774,120774],"mapped",[954]],[[120775,120775],"mapped",[966]],[[120776,120776],"mapped",[961]],[[120777,120777],"mapped",[960]],[[120778,120779],"mapped",[989]],[[120780,120781],"disallowed"],[[120782,120782],"mapped",[48]],[[120783,120783],"mapped",[49]],[[120784,120784],"mapped",[50]],[[120785,120785],"mapped",[51]],[[120786,120786],"mapped",[52]],[[120787,120787],"mapped",[53]],[[120788,120788],"mapped",[54]],[[120789,120789],"mapped",[55]],[[120790,120790],"mapped",[56]],[[120791,120791],"mapped",[57]],[[120792,120792],"mapped",[48]],[[120793,120793],"mapped",[49]],[[120794,120794],"mapped",[50]],[[120795,120795],"mapped",[51]],[[120796,120796],"mapped",[52]],[[120797,120797],"mapped",[53]],[[120798,120798],"mapped",[54]],[[120799,120799],"mapped",[55]],[[120800,120800],"mapped",[56]],[[120801,120801],"mapped",[57]],[[120802,120802],"mapped",[48]],[[120803,120803],"mapped",[49]],[[120804,120804],"mapped",[50]],[[120805,120805],"mapped",[51]],[[120806,120806],"mapped",[52]],[[120807,120807],"mapped",[53]],[[120808,120808],"mapped",[54]],[[120809,120809],"mapped",[55]],[[120810,120810],"mapped",[56]],[[120811,120811],"mapped",[57]],[[120812,120812],"mapped",[48]],[[120813,120813],"mapped",[49]],[[120814,120814],"mapped",[50]],[[120815,120815],"mapped",[51]],[[120816,120816],"mapped",[52]],[[120817,120817],"mapped",[53]],[[120818,120818],"mapped",[54]],[[120819,120819],"mapped",[55]],[[120820,120820],"mapped",[56]],[[120821,120821],"mapped",[57]],[[120822,120822],"mapped",[48]],[[120823,120823],"mapped",[49]],[[120824,120824],"mapped",[50]],[[120825,120825],"mapped",[51]],[[120826,120826],"mapped",[52]],[[120827,120827],"mapped",[53]],[[120828,120828],"mapped",[54]],[[120829,120829],"mapped",[55]],[[120830,120830],"mapped",[56]],[[120831,120831],"mapped",[57]],[[120832,121343],"valid",[],"NV8"],[[121344,121398],"valid"],[[121399,121402],"valid",[],"NV8"],[[121403,121452],"valid"],[[121453,121460],"valid",[],"NV8"],[[121461,121461],"valid"],[[121462,121475],"valid",[],"NV8"],[[121476,121476],"valid"],[[121477,121483],"valid",[],"NV8"],[[121484,121498],"disallowed"],[[121499,121503],"valid"],[[121504,121504],"disallowed"],[[121505,121519],"valid"],[[121520,124927],"disallowed"],[[124928,125124],"valid"],[[125125,125126],"disallowed"],[[125127,125135],"valid",[],"NV8"],[[125136,125142],"valid"],[[125143,126463],"disallowed"],[[126464,126464],"mapped",[1575]],[[126465,126465],"mapped",[1576]],[[126466,126466],"mapped",[1580]],[[126467,126467],"mapped",[1583]],[[126468,126468],"disallowed"],[[126469,126469],"mapped",[1608]],[[126470,126470],"mapped",[1586]],[[126471,126471],"mapped",[1581]],[[126472,126472],"mapped",[1591]],[[126473,126473],"mapped",[1610]],[[126474,126474],"mapped",[1603]],[[126475,126475],"mapped",[1604]],[[126476,126476],"mapped",[1605]],[[126477,126477],"mapped",[1606]],[[126478,126478],"mapped",[1587]],[[126479,126479],"mapped",[1593]],[[126480,126480],"mapped",[1601]],[[126481,126481],"mapped",[1589]],[[126482,126482],"mapped",[1602]],[[126483,126483],"mapped",[1585]],[[126484,126484],"mapped",[1588]],[[126485,126485],"mapped",[1578]],[[126486,126486],"mapped",[1579]],[[126487,126487],"mapped",[1582]],[[126488,126488],"mapped",[1584]],[[126489,126489],"mapped",[1590]],[[126490,126490],"mapped",[1592]],[[126491,126491],"mapped",[1594]],[[126492,126492],"mapped",[1646]],[[126493,126493],"mapped",[1722]],[[126494,126494],"mapped",[1697]],[[126495,126495],"mapped",[1647]],[[126496,126496],"disallowed"],[[126497,126497],"mapped",[1576]],[[126498,126498],"mapped",[1580]],[[126499,126499],"disallowed"],[[126500,126500],"mapped",[1607]],[[126501,126502],"disallowed"],[[126503,126503],"mapped",[1581]],[[126504,126504],"disallowed"],[[126505,126505],"mapped",[1610]],[[126506,126506],"mapped",[1603]],[[126507,126507],"mapped",[1604]],[[126508,126508],"mapped",[1605]],[[126509,126509],"mapped",[1606]],[[126510,126510],"mapped",[1587]],[[126511,126511],"mapped",[1593]],[[126512,126512],"mapped",[1601]],[[126513,126513],"mapped",[1589]],[[126514,126514],"mapped",[1602]],[[126515,126515],"disallowed"],[[126516,126516],"mapped",[1588]],[[126517,126517],"mapped",[1578]],[[126518,126518],"mapped",[1579]],[[126519,126519],"mapped",[1582]],[[126520,126520],"disallowed"],[[126521,126521],"mapped",[1590]],[[126522,126522],"disallowed"],[[126523,126523],"mapped",[1594]],[[126524,126529],"disallowed"],[[126530,126530],"mapped",[1580]],[[126531,126534],"disallowed"],[[126535,126535],"mapped",[1581]],[[126536,126536],"disallowed"],[[126537,126537],"mapped",[1610]],[[126538,126538],"disallowed"],[[126539,126539],"mapped",[1604]],[[126540,126540],"disallowed"],[[126541,126541],"mapped",[1606]],[[126542,126542],"mapped",[1587]],[[126543,126543],"mapped",[1593]],[[126544,126544],"disallowed"],[[126545,126545],"mapped",[1589]],[[126546,126546],"mapped",[1602]],[[126547,126547],"disallowed"],[[126548,126548],"mapped",[1588]],[[126549,126550],"disallowed"],[[126551,126551],"mapped",[1582]],[[126552,126552],"disallowed"],[[126553,126553],"mapped",[1590]],[[126554,126554],"disallowed"],[[126555,126555],"mapped",[1594]],[[126556,126556],"disallowed"],[[126557,126557],"mapped",[1722]],[[126558,126558],"disallowed"],[[126559,126559],"mapped",[1647]],[[126560,126560],"disallowed"],[[126561,126561],"mapped",[1576]],[[126562,126562],"mapped",[1580]],[[126563,126563],"disallowed"],[[126564,126564],"mapped",[1607]],[[126565,126566],"disallowed"],[[126567,126567],"mapped",[1581]],[[126568,126568],"mapped",[1591]],[[126569,126569],"mapped",[1610]],[[126570,126570],"mapped",[1603]],[[126571,126571],"disallowed"],[[126572,126572],"mapped",[1605]],[[126573,126573],"mapped",[1606]],[[126574,126574],"mapped",[1587]],[[126575,126575],"mapped",[1593]],[[126576,126576],"mapped",[1601]],[[126577,126577],"mapped",[1589]],[[126578,126578],"mapped",[1602]],[[126579,126579],"disallowed"],[[126580,126580],"mapped",[1588]],[[126581,126581],"mapped",[1578]],[[126582,126582],"mapped",[1579]],[[126583,126583],"mapped",[1582]],[[126584,126584],"disallowed"],[[126585,126585],"mapped",[1590]],[[126586,126586],"mapped",[1592]],[[126587,126587],"mapped",[1594]],[[126588,126588],"mapped",[1646]],[[126589,126589],"disallowed"],[[126590,126590],"mapped",[1697]],[[126591,126591],"disallowed"],[[126592,126592],"mapped",[1575]],[[126593,126593],"mapped",[1576]],[[126594,126594],"mapped",[1580]],[[126595,126595],"mapped",[1583]],[[126596,126596],"mapped",[1607]],[[126597,126597],"mapped",[1608]],[[126598,126598],"mapped",[1586]],[[126599,126599],"mapped",[1581]],[[126600,126600],"mapped",[1591]],[[126601,126601],"mapped",[1610]],[[126602,126602],"disallowed"],[[126603,126603],"mapped",[1604]],[[126604,126604],"mapped",[1605]],[[126605,126605],"mapped",[1606]],[[126606,126606],"mapped",[1587]],[[126607,126607],"mapped",[1593]],[[126608,126608],"mapped",[1601]],[[126609,126609],"mapped",[1589]],[[126610,126610],"mapped",[1602]],[[126611,126611],"mapped",[1585]],[[126612,126612],"mapped",[1588]],[[126613,126613],"mapped",[1578]],[[126614,126614],"mapped",[1579]],[[126615,126615],"mapped",[1582]],[[126616,126616],"mapped",[1584]],[[126617,126617],"mapped",[1590]],[[126618,126618],"mapped",[1592]],[[126619,126619],"mapped",[1594]],[[126620,126624],"disallowed"],[[126625,126625],"mapped",[1576]],[[126626,126626],"mapped",[1580]],[[126627,126627],"mapped",[1583]],[[126628,126628],"disallowed"],[[126629,126629],"mapped",[1608]],[[126630,126630],"mapped",[1586]],[[126631,126631],"mapped",[1581]],[[126632,126632],"mapped",[1591]],[[126633,126633],"mapped",[1610]],[[126634,126634],"disallowed"],[[126635,126635],"mapped",[1604]],[[126636,126636],"mapped",[1605]],[[126637,126637],"mapped",[1606]],[[126638,126638],"mapped",[1587]],[[126639,126639],"mapped",[1593]],[[126640,126640],"mapped",[1601]],[[126641,126641],"mapped",[1589]],[[126642,126642],"mapped",[1602]],[[126643,126643],"mapped",[1585]],[[126644,126644],"mapped",[1588]],[[126645,126645],"mapped",[1578]],[[126646,126646],"mapped",[1579]],[[126647,126647],"mapped",[1582]],[[126648,126648],"mapped",[1584]],[[126649,126649],"mapped",[1590]],[[126650,126650],"mapped",[1592]],[[126651,126651],"mapped",[1594]],[[126652,126703],"disallowed"],[[126704,126705],"valid",[],"NV8"],[[126706,126975],"disallowed"],[[126976,127019],"valid",[],"NV8"],[[127020,127023],"disallowed"],[[127024,127123],"valid",[],"NV8"],[[127124,127135],"disallowed"],[[127136,127150],"valid",[],"NV8"],[[127151,127152],"disallowed"],[[127153,127166],"valid",[],"NV8"],[[127167,127167],"valid",[],"NV8"],[[127168,127168],"disallowed"],[[127169,127183],"valid",[],"NV8"],[[127184,127184],"disallowed"],[[127185,127199],"valid",[],"NV8"],[[127200,127221],"valid",[],"NV8"],[[127222,127231],"disallowed"],[[127232,127232],"disallowed"],[[127233,127233],"disallowed_STD3_mapped",[48,44]],[[127234,127234],"disallowed_STD3_mapped",[49,44]],[[127235,127235],"disallowed_STD3_mapped",[50,44]],[[127236,127236],"disallowed_STD3_mapped",[51,44]],[[127237,127237],"disallowed_STD3_mapped",[52,44]],[[127238,127238],"disallowed_STD3_mapped",[53,44]],[[127239,127239],"disallowed_STD3_mapped",[54,44]],[[127240,127240],"disallowed_STD3_mapped",[55,44]],[[127241,127241],"disallowed_STD3_mapped",[56,44]],[[127242,127242],"disallowed_STD3_mapped",[57,44]],[[127243,127244],"valid",[],"NV8"],[[127245,127247],"disallowed"],[[127248,127248],"disallowed_STD3_mapped",[40,97,41]],[[127249,127249],"disallowed_STD3_mapped",[40,98,41]],[[127250,127250],"disallowed_STD3_mapped",[40,99,41]],[[127251,127251],"disallowed_STD3_mapped",[40,100,41]],[[127252,127252],"disallowed_STD3_mapped",[40,101,41]],[[127253,127253],"disallowed_STD3_mapped",[40,102,41]],[[127254,127254],"disallowed_STD3_mapped",[40,103,41]],[[127255,127255],"disallowed_STD3_mapped",[40,104,41]],[[127256,127256],"disallowed_STD3_mapped",[40,105,41]],[[127257,127257],"disallowed_STD3_mapped",[40,106,41]],[[127258,127258],"disallowed_STD3_mapped",[40,107,41]],[[127259,127259],"disallowed_STD3_mapped",[40,108,41]],[[127260,127260],"disallowed_STD3_mapped",[40,109,41]],[[127261,127261],"disallowed_STD3_mapped",[40,110,41]],[[127262,127262],"disallowed_STD3_mapped",[40,111,41]],[[127263,127263],"disallowed_STD3_mapped",[40,112,41]],[[127264,127264],"disallowed_STD3_mapped",[40,113,41]],[[127265,127265],"disallowed_STD3_mapped",[40,114,41]],[[127266,127266],"disallowed_STD3_mapped",[40,115,41]],[[127267,127267],"disallowed_STD3_mapped",[40,116,41]],[[127268,127268],"disallowed_STD3_mapped",[40,117,41]],[[127269,127269],"disallowed_STD3_mapped",[40,118,41]],[[127270,127270],"disallowed_STD3_mapped",[40,119,41]],[[127271,127271],"disallowed_STD3_mapped",[40,120,41]],[[127272,127272],"disallowed_STD3_mapped",[40,121,41]],[[127273,127273],"disallowed_STD3_mapped",[40,122,41]],[[127274,127274],"mapped",[12308,115,12309]],[[127275,127275],"mapped",[99]],[[127276,127276],"mapped",[114]],[[127277,127277],"mapped",[99,100]],[[127278,127278],"mapped",[119,122]],[[127279,127279],"disallowed"],[[127280,127280],"mapped",[97]],[[127281,127281],"mapped",[98]],[[127282,127282],"mapped",[99]],[[127283,127283],"mapped",[100]],[[127284,127284],"mapped",[101]],[[127285,127285],"mapped",[102]],[[127286,127286],"mapped",[103]],[[127287,127287],"mapped",[104]],[[127288,127288],"mapped",[105]],[[127289,127289],"mapped",[106]],[[127290,127290],"mapped",[107]],[[127291,127291],"mapped",[108]],[[127292,127292],"mapped",[109]],[[127293,127293],"mapped",[110]],[[127294,127294],"mapped",[111]],[[127295,127295],"mapped",[112]],[[127296,127296],"mapped",[113]],[[127297,127297],"mapped",[114]],[[127298,127298],"mapped",[115]],[[127299,127299],"mapped",[116]],[[127300,127300],"mapped",[117]],[[127301,127301],"mapped",[118]],[[127302,127302],"mapped",[119]],[[127303,127303],"mapped",[120]],[[127304,127304],"mapped",[121]],[[127305,127305],"mapped",[122]],[[127306,127306],"mapped",[104,118]],[[127307,127307],"mapped",[109,118]],[[127308,127308],"mapped",[115,100]],[[127309,127309],"mapped",[115,115]],[[127310,127310],"mapped",[112,112,118]],[[127311,127311],"mapped",[119,99]],[[127312,127318],"valid",[],"NV8"],[[127319,127319],"valid",[],"NV8"],[[127320,127326],"valid",[],"NV8"],[[127327,127327],"valid",[],"NV8"],[[127328,127337],"valid",[],"NV8"],[[127338,127338],"mapped",[109,99]],[[127339,127339],"mapped",[109,100]],[[127340,127343],"disallowed"],[[127344,127352],"valid",[],"NV8"],[[127353,127353],"valid",[],"NV8"],[[127354,127354],"valid",[],"NV8"],[[127355,127356],"valid",[],"NV8"],[[127357,127358],"valid",[],"NV8"],[[127359,127359],"valid",[],"NV8"],[[127360,127369],"valid",[],"NV8"],[[127370,127373],"valid",[],"NV8"],[[127374,127375],"valid",[],"NV8"],[[127376,127376],"mapped",[100,106]],[[127377,127386],"valid",[],"NV8"],[[127387,127461],"disallowed"],[[127462,127487],"valid",[],"NV8"],[[127488,127488],"mapped",[12411,12363]],[[127489,127489],"mapped",[12467,12467]],[[127490,127490],"mapped",[12469]],[[127491,127503],"disallowed"],[[127504,127504],"mapped",[25163]],[[127505,127505],"mapped",[23383]],[[127506,127506],"mapped",[21452]],[[127507,127507],"mapped",[12487]],[[127508,127508],"mapped",[20108]],[[127509,127509],"mapped",[22810]],[[127510,127510],"mapped",[35299]],[[127511,127511],"mapped",[22825]],[[127512,127512],"mapped",[20132]],[[127513,127513],"mapped",[26144]],[[127514,127514],"mapped",[28961]],[[127515,127515],"mapped",[26009]],[[127516,127516],"mapped",[21069]],[[127517,127517],"mapped",[24460]],[[127518,127518],"mapped",[20877]],[[127519,127519],"mapped",[26032]],[[127520,127520],"mapped",[21021]],[[127521,127521],"mapped",[32066]],[[127522,127522],"mapped",[29983]],[[127523,127523],"mapped",[36009]],[[127524,127524],"mapped",[22768]],[[127525,127525],"mapped",[21561]],[[127526,127526],"mapped",[28436]],[[127527,127527],"mapped",[25237]],[[127528,127528],"mapped",[25429]],[[127529,127529],"mapped",[19968]],[[127530,127530],"mapped",[19977]],[[127531,127531],"mapped",[36938]],[[127532,127532],"mapped",[24038]],[[127533,127533],"mapped",[20013]],[[127534,127534],"mapped",[21491]],[[127535,127535],"mapped",[25351]],[[127536,127536],"mapped",[36208]],[[127537,127537],"mapped",[25171]],[[127538,127538],"mapped",[31105]],[[127539,127539],"mapped",[31354]],[[127540,127540],"mapped",[21512]],[[127541,127541],"mapped",[28288]],[[127542,127542],"mapped",[26377]],[[127543,127543],"mapped",[26376]],[[127544,127544],"mapped",[30003]],[[127545,127545],"mapped",[21106]],[[127546,127546],"mapped",[21942]],[[127547,127551],"disallowed"],[[127552,127552],"mapped",[12308,26412,12309]],[[127553,127553],"mapped",[12308,19977,12309]],[[127554,127554],"mapped",[12308,20108,12309]],[[127555,127555],"mapped",[12308,23433,12309]],[[127556,127556],"mapped",[12308,28857,12309]],[[127557,127557],"mapped",[12308,25171,12309]],[[127558,127558],"mapped",[12308,30423,12309]],[[127559,127559],"mapped",[12308,21213,12309]],[[127560,127560],"mapped",[12308,25943,12309]],[[127561,127567],"disallowed"],[[127568,127568],"mapped",[24471]],[[127569,127569],"mapped",[21487]],[[127570,127743],"disallowed"],[[127744,127776],"valid",[],"NV8"],[[127777,127788],"valid",[],"NV8"],[[127789,127791],"valid",[],"NV8"],[[127792,127797],"valid",[],"NV8"],[[127798,127798],"valid",[],"NV8"],[[127799,127868],"valid",[],"NV8"],[[127869,127869],"valid",[],"NV8"],[[127870,127871],"valid",[],"NV8"],[[127872,127891],"valid",[],"NV8"],[[127892,127903],"valid",[],"NV8"],[[127904,127940],"valid",[],"NV8"],[[127941,127941],"valid",[],"NV8"],[[127942,127946],"valid",[],"NV8"],[[127947,127950],"valid",[],"NV8"],[[127951,127955],"valid",[],"NV8"],[[127956,127967],"valid",[],"NV8"],[[127968,127984],"valid",[],"NV8"],[[127985,127991],"valid",[],"NV8"],[[127992,127999],"valid",[],"NV8"],[[128000,128062],"valid",[],"NV8"],[[128063,128063],"valid",[],"NV8"],[[128064,128064],"valid",[],"NV8"],[[128065,128065],"valid",[],"NV8"],[[128066,128247],"valid",[],"NV8"],[[128248,128248],"valid",[],"NV8"],[[128249,128252],"valid",[],"NV8"],[[128253,128254],"valid",[],"NV8"],[[128255,128255],"valid",[],"NV8"],[[128256,128317],"valid",[],"NV8"],[[128318,128319],"valid",[],"NV8"],[[128320,128323],"valid",[],"NV8"],[[128324,128330],"valid",[],"NV8"],[[128331,128335],"valid",[],"NV8"],[[128336,128359],"valid",[],"NV8"],[[128360,128377],"valid",[],"NV8"],[[128378,128378],"disallowed"],[[128379,128419],"valid",[],"NV8"],[[128420,128420],"disallowed"],[[128421,128506],"valid",[],"NV8"],[[128507,128511],"valid",[],"NV8"],[[128512,128512],"valid",[],"NV8"],[[128513,128528],"valid",[],"NV8"],[[128529,128529],"valid",[],"NV8"],[[128530,128532],"valid",[],"NV8"],[[128533,128533],"valid",[],"NV8"],[[128534,128534],"valid",[],"NV8"],[[128535,128535],"valid",[],"NV8"],[[128536,128536],"valid",[],"NV8"],[[128537,128537],"valid",[],"NV8"],[[128538,128538],"valid",[],"NV8"],[[128539,128539],"valid",[],"NV8"],[[128540,128542],"valid",[],"NV8"],[[128543,128543],"valid",[],"NV8"],[[128544,128549],"valid",[],"NV8"],[[128550,128551],"valid",[],"NV8"],[[128552,128555],"valid",[],"NV8"],[[128556,128556],"valid",[],"NV8"],[[128557,128557],"valid",[],"NV8"],[[128558,128559],"valid",[],"NV8"],[[128560,128563],"valid",[],"NV8"],[[128564,128564],"valid",[],"NV8"],[[128565,128576],"valid",[],"NV8"],[[128577,128578],"valid",[],"NV8"],[[128579,128580],"valid",[],"NV8"],[[128581,128591],"valid",[],"NV8"],[[128592,128639],"valid",[],"NV8"],[[128640,128709],"valid",[],"NV8"],[[128710,128719],"valid",[],"NV8"],[[128720,128720],"valid",[],"NV8"],[[128721,128735],"disallowed"],[[128736,128748],"valid",[],"NV8"],[[128749,128751],"disallowed"],[[128752,128755],"valid",[],"NV8"],[[128756,128767],"disallowed"],[[128768,128883],"valid",[],"NV8"],[[128884,128895],"disallowed"],[[128896,128980],"valid",[],"NV8"],[[128981,129023],"disallowed"],[[129024,129035],"valid",[],"NV8"],[[129036,129039],"disallowed"],[[129040,129095],"valid",[],"NV8"],[[129096,129103],"disallowed"],[[129104,129113],"valid",[],"NV8"],[[129114,129119],"disallowed"],[[129120,129159],"valid",[],"NV8"],[[129160,129167],"disallowed"],[[129168,129197],"valid",[],"NV8"],[[129198,129295],"disallowed"],[[129296,129304],"valid",[],"NV8"],[[129305,129407],"disallowed"],[[129408,129412],"valid",[],"NV8"],[[129413,129471],"disallowed"],[[129472,129472],"valid",[],"NV8"],[[129473,131069],"disallowed"],[[131070,131071],"disallowed"],[[131072,173782],"valid"],[[173783,173823],"disallowed"],[[173824,177972],"valid"],[[177973,177983],"disallowed"],[[177984,178205],"valid"],[[178206,178207],"disallowed"],[[178208,183969],"valid"],[[183970,194559],"disallowed"],[[194560,194560],"mapped",[20029]],[[194561,194561],"mapped",[20024]],[[194562,194562],"mapped",[20033]],[[194563,194563],"mapped",[131362]],[[194564,194564],"mapped",[20320]],[[194565,194565],"mapped",[20398]],[[194566,194566],"mapped",[20411]],[[194567,194567],"mapped",[20482]],[[194568,194568],"mapped",[20602]],[[194569,194569],"mapped",[20633]],[[194570,194570],"mapped",[20711]],[[194571,194571],"mapped",[20687]],[[194572,194572],"mapped",[13470]],[[194573,194573],"mapped",[132666]],[[194574,194574],"mapped",[20813]],[[194575,194575],"mapped",[20820]],[[194576,194576],"mapped",[20836]],[[194577,194577],"mapped",[20855]],[[194578,194578],"mapped",[132380]],[[194579,194579],"mapped",[13497]],[[194580,194580],"mapped",[20839]],[[194581,194581],"mapped",[20877]],[[194582,194582],"mapped",[132427]],[[194583,194583],"mapped",[20887]],[[194584,194584],"mapped",[20900]],[[194585,194585],"mapped",[20172]],[[194586,194586],"mapped",[20908]],[[194587,194587],"mapped",[20917]],[[194588,194588],"mapped",[168415]],[[194589,194589],"mapped",[20981]],[[194590,194590],"mapped",[20995]],[[194591,194591],"mapped",[13535]],[[194592,194592],"mapped",[21051]],[[194593,194593],"mapped",[21062]],[[194594,194594],"mapped",[21106]],[[194595,194595],"mapped",[21111]],[[194596,194596],"mapped",[13589]],[[194597,194597],"mapped",[21191]],[[194598,194598],"mapped",[21193]],[[194599,194599],"mapped",[21220]],[[194600,194600],"mapped",[21242]],[[194601,194601],"mapped",[21253]],[[194602,194602],"mapped",[21254]],[[194603,194603],"mapped",[21271]],[[194604,194604],"mapped",[21321]],[[194605,194605],"mapped",[21329]],[[194606,194606],"mapped",[21338]],[[194607,194607],"mapped",[21363]],[[194608,194608],"mapped",[21373]],[[194609,194611],"mapped",[21375]],[[194612,194612],"mapped",[133676]],[[194613,194613],"mapped",[28784]],[[194614,194614],"mapped",[21450]],[[194615,194615],"mapped",[21471]],[[194616,194616],"mapped",[133987]],[[194617,194617],"mapped",[21483]],[[194618,194618],"mapped",[21489]],[[194619,194619],"mapped",[21510]],[[194620,194620],"mapped",[21662]],[[194621,194621],"mapped",[21560]],[[194622,194622],"mapped",[21576]],[[194623,194623],"mapped",[21608]],[[194624,194624],"mapped",[21666]],[[194625,194625],"mapped",[21750]],[[194626,194626],"mapped",[21776]],[[194627,194627],"mapped",[21843]],[[194628,194628],"mapped",[21859]],[[194629,194630],"mapped",[21892]],[[194631,194631],"mapped",[21913]],[[194632,194632],"mapped",[21931]],[[194633,194633],"mapped",[21939]],[[194634,194634],"mapped",[21954]],[[194635,194635],"mapped",[22294]],[[194636,194636],"mapped",[22022]],[[194637,194637],"mapped",[22295]],[[194638,194638],"mapped",[22097]],[[194639,194639],"mapped",[22132]],[[194640,194640],"mapped",[20999]],[[194641,194641],"mapped",[22766]],[[194642,194642],"mapped",[22478]],[[194643,194643],"mapped",[22516]],[[194644,194644],"mapped",[22541]],[[194645,194645],"mapped",[22411]],[[194646,194646],"mapped",[22578]],[[194647,194647],"mapped",[22577]],[[194648,194648],"mapped",[22700]],[[194649,194649],"mapped",[136420]],[[194650,194650],"mapped",[22770]],[[194651,194651],"mapped",[22775]],[[194652,194652],"mapped",[22790]],[[194653,194653],"mapped",[22810]],[[194654,194654],"mapped",[22818]],[[194655,194655],"mapped",[22882]],[[194656,194656],"mapped",[136872]],[[194657,194657],"mapped",[136938]],[[194658,194658],"mapped",[23020]],[[194659,194659],"mapped",[23067]],[[194660,194660],"mapped",[23079]],[[194661,194661],"mapped",[23000]],[[194662,194662],"mapped",[23142]],[[194663,194663],"mapped",[14062]],[[194664,194664],"disallowed"],[[194665,194665],"mapped",[23304]],[[194666,194667],"mapped",[23358]],[[194668,194668],"mapped",[137672]],[[194669,194669],"mapped",[23491]],[[194670,194670],"mapped",[23512]],[[194671,194671],"mapped",[23527]],[[194672,194672],"mapped",[23539]],[[194673,194673],"mapped",[138008]],[[194674,194674],"mapped",[23551]],[[194675,194675],"mapped",[23558]],[[194676,194676],"disallowed"],[[194677,194677],"mapped",[23586]],[[194678,194678],"mapped",[14209]],[[194679,194679],"mapped",[23648]],[[194680,194680],"mapped",[23662]],[[194681,194681],"mapped",[23744]],[[194682,194682],"mapped",[23693]],[[194683,194683],"mapped",[138724]],[[194684,194684],"mapped",[23875]],[[194685,194685],"mapped",[138726]],[[194686,194686],"mapped",[23918]],[[194687,194687],"mapped",[23915]],[[194688,194688],"mapped",[23932]],[[194689,194689],"mapped",[24033]],[[194690,194690],"mapped",[24034]],[[194691,194691],"mapped",[14383]],[[194692,194692],"mapped",[24061]],[[194693,194693],"mapped",[24104]],[[194694,194694],"mapped",[24125]],[[194695,194695],"mapped",[24169]],[[194696,194696],"mapped",[14434]],[[194697,194697],"mapped",[139651]],[[194698,194698],"mapped",[14460]],[[194699,194699],"mapped",[24240]],[[194700,194700],"mapped",[24243]],[[194701,194701],"mapped",[24246]],[[194702,194702],"mapped",[24266]],[[194703,194703],"mapped",[172946]],[[194704,194704],"mapped",[24318]],[[194705,194706],"mapped",[140081]],[[194707,194707],"mapped",[33281]],[[194708,194709],"mapped",[24354]],[[194710,194710],"mapped",[14535]],[[194711,194711],"mapped",[144056]],[[194712,194712],"mapped",[156122]],[[194713,194713],"mapped",[24418]],[[194714,194714],"mapped",[24427]],[[194715,194715],"mapped",[14563]],[[194716,194716],"mapped",[24474]],[[194717,194717],"mapped",[24525]],[[194718,194718],"mapped",[24535]],[[194719,194719],"mapped",[24569]],[[194720,194720],"mapped",[24705]],[[194721,194721],"mapped",[14650]],[[194722,194722],"mapped",[14620]],[[194723,194723],"mapped",[24724]],[[194724,194724],"mapped",[141012]],[[194725,194725],"mapped",[24775]],[[194726,194726],"mapped",[24904]],[[194727,194727],"mapped",[24908]],[[194728,194728],"mapped",[24910]],[[194729,194729],"mapped",[24908]],[[194730,194730],"mapped",[24954]],[[194731,194731],"mapped",[24974]],[[194732,194732],"mapped",[25010]],[[194733,194733],"mapped",[24996]],[[194734,194734],"mapped",[25007]],[[194735,194735],"mapped",[25054]],[[194736,194736],"mapped",[25074]],[[194737,194737],"mapped",[25078]],[[194738,194738],"mapped",[25104]],[[194739,194739],"mapped",[25115]],[[194740,194740],"mapped",[25181]],[[194741,194741],"mapped",[25265]],[[194742,194742],"mapped",[25300]],[[194743,194743],"mapped",[25424]],[[194744,194744],"mapped",[142092]],[[194745,194745],"mapped",[25405]],[[194746,194746],"mapped",[25340]],[[194747,194747],"mapped",[25448]],[[194748,194748],"mapped",[25475]],[[194749,194749],"mapped",[25572]],[[194750,194750],"mapped",[142321]],[[194751,194751],"mapped",[25634]],[[194752,194752],"mapped",[25541]],[[194753,194753],"mapped",[25513]],[[194754,194754],"mapped",[14894]],[[194755,194755],"mapped",[25705]],[[194756,194756],"mapped",[25726]],[[194757,194757],"mapped",[25757]],[[194758,194758],"mapped",[25719]],[[194759,194759],"mapped",[14956]],[[194760,194760],"mapped",[25935]],[[194761,194761],"mapped",[25964]],[[194762,194762],"mapped",[143370]],[[194763,194763],"mapped",[26083]],[[194764,194764],"mapped",[26360]],[[194765,194765],"mapped",[26185]],[[194766,194766],"mapped",[15129]],[[194767,194767],"mapped",[26257]],[[194768,194768],"mapped",[15112]],[[194769,194769],"mapped",[15076]],[[194770,194770],"mapped",[20882]],[[194771,194771],"mapped",[20885]],[[194772,194772],"mapped",[26368]],[[194773,194773],"mapped",[26268]],[[194774,194774],"mapped",[32941]],[[194775,194775],"mapped",[17369]],[[194776,194776],"mapped",[26391]],[[194777,194777],"mapped",[26395]],[[194778,194778],"mapped",[26401]],[[194779,194779],"mapped",[26462]],[[194780,194780],"mapped",[26451]],[[194781,194781],"mapped",[144323]],[[194782,194782],"mapped",[15177]],[[194783,194783],"mapped",[26618]],[[194784,194784],"mapped",[26501]],[[194785,194785],"mapped",[26706]],[[194786,194786],"mapped",[26757]],[[194787,194787],"mapped",[144493]],[[194788,194788],"mapped",[26766]],[[194789,194789],"mapped",[26655]],[[194790,194790],"mapped",[26900]],[[194791,194791],"mapped",[15261]],[[194792,194792],"mapped",[26946]],[[194793,194793],"mapped",[27043]],[[194794,194794],"mapped",[27114]],[[194795,194795],"mapped",[27304]],[[194796,194796],"mapped",[145059]],[[194797,194797],"mapped",[27355]],[[194798,194798],"mapped",[15384]],[[194799,194799],"mapped",[27425]],[[194800,194800],"mapped",[145575]],[[194801,194801],"mapped",[27476]],[[194802,194802],"mapped",[15438]],[[194803,194803],"mapped",[27506]],[[194804,194804],"mapped",[27551]],[[194805,194805],"mapped",[27578]],[[194806,194806],"mapped",[27579]],[[194807,194807],"mapped",[146061]],[[194808,194808],"mapped",[138507]],[[194809,194809],"mapped",[146170]],[[194810,194810],"mapped",[27726]],[[194811,194811],"mapped",[146620]],[[194812,194812],"mapped",[27839]],[[194813,194813],"mapped",[27853]],[[194814,194814],"mapped",[27751]],[[194815,194815],"mapped",[27926]],[[194816,194816],"mapped",[27966]],[[194817,194817],"mapped",[28023]],[[194818,194818],"mapped",[27969]],[[194819,194819],"mapped",[28009]],[[194820,194820],"mapped",[28024]],[[194821,194821],"mapped",[28037]],[[194822,194822],"mapped",[146718]],[[194823,194823],"mapped",[27956]],[[194824,194824],"mapped",[28207]],[[194825,194825],"mapped",[28270]],[[194826,194826],"mapped",[15667]],[[194827,194827],"mapped",[28363]],[[194828,194828],"mapped",[28359]],[[194829,194829],"mapped",[147153]],[[194830,194830],"mapped",[28153]],[[194831,194831],"mapped",[28526]],[[194832,194832],"mapped",[147294]],[[194833,194833],"mapped",[147342]],[[194834,194834],"mapped",[28614]],[[194835,194835],"mapped",[28729]],[[194836,194836],"mapped",[28702]],[[194837,194837],"mapped",[28699]],[[194838,194838],"mapped",[15766]],[[194839,194839],"mapped",[28746]],[[194840,194840],"mapped",[28797]],[[194841,194841],"mapped",[28791]],[[194842,194842],"mapped",[28845]],[[194843,194843],"mapped",[132389]],[[194844,194844],"mapped",[28997]],[[194845,194845],"mapped",[148067]],[[194846,194846],"mapped",[29084]],[[194847,194847],"disallowed"],[[194848,194848],"mapped",[29224]],[[194849,194849],"mapped",[29237]],[[194850,194850],"mapped",[29264]],[[194851,194851],"mapped",[149000]],[[194852,194852],"mapped",[29312]],[[194853,194853],"mapped",[29333]],[[194854,194854],"mapped",[149301]],[[194855,194855],"mapped",[149524]],[[194856,194856],"mapped",[29562]],[[194857,194857],"mapped",[29579]],[[194858,194858],"mapped",[16044]],[[194859,194859],"mapped",[29605]],[[194860,194861],"mapped",[16056]],[[194862,194862],"mapped",[29767]],[[194863,194863],"mapped",[29788]],[[194864,194864],"mapped",[29809]],[[194865,194865],"mapped",[29829]],[[194866,194866],"mapped",[29898]],[[194867,194867],"mapped",[16155]],[[194868,194868],"mapped",[29988]],[[194869,194869],"mapped",[150582]],[[194870,194870],"mapped",[30014]],[[194871,194871],"mapped",[150674]],[[194872,194872],"mapped",[30064]],[[194873,194873],"mapped",[139679]],[[194874,194874],"mapped",[30224]],[[194875,194875],"mapped",[151457]],[[194876,194876],"mapped",[151480]],[[194877,194877],"mapped",[151620]],[[194878,194878],"mapped",[16380]],[[194879,194879],"mapped",[16392]],[[194880,194880],"mapped",[30452]],[[194881,194881],"mapped",[151795]],[[194882,194882],"mapped",[151794]],[[194883,194883],"mapped",[151833]],[[194884,194884],"mapped",[151859]],[[194885,194885],"mapped",[30494]],[[194886,194887],"mapped",[30495]],[[194888,194888],"mapped",[30538]],[[194889,194889],"mapped",[16441]],[[194890,194890],"mapped",[30603]],[[194891,194891],"mapped",[16454]],[[194892,194892],"mapped",[16534]],[[194893,194893],"mapped",[152605]],[[194894,194894],"mapped",[30798]],[[194895,194895],"mapped",[30860]],[[194896,194896],"mapped",[30924]],[[194897,194897],"mapped",[16611]],[[194898,194898],"mapped",[153126]],[[194899,194899],"mapped",[31062]],[[194900,194900],"mapped",[153242]],[[194901,194901],"mapped",[153285]],[[194902,194902],"mapped",[31119]],[[194903,194903],"mapped",[31211]],[[194904,194904],"mapped",[16687]],[[194905,194905],"mapped",[31296]],[[194906,194906],"mapped",[31306]],[[194907,194907],"mapped",[31311]],[[194908,194908],"mapped",[153980]],[[194909,194910],"mapped",[154279]],[[194911,194911],"disallowed"],[[194912,194912],"mapped",[16898]],[[194913,194913],"mapped",[154539]],[[194914,194914],"mapped",[31686]],[[194915,194915],"mapped",[31689]],[[194916,194916],"mapped",[16935]],[[194917,194917],"mapped",[154752]],[[194918,194918],"mapped",[31954]],[[194919,194919],"mapped",[17056]],[[194920,194920],"mapped",[31976]],[[194921,194921],"mapped",[31971]],[[194922,194922],"mapped",[32000]],[[194923,194923],"mapped",[155526]],[[194924,194924],"mapped",[32099]],[[194925,194925],"mapped",[17153]],[[194926,194926],"mapped",[32199]],[[194927,194927],"mapped",[32258]],[[194928,194928],"mapped",[32325]],[[194929,194929],"mapped",[17204]],[[194930,194930],"mapped",[156200]],[[194931,194931],"mapped",[156231]],[[194932,194932],"mapped",[17241]],[[194933,194933],"mapped",[156377]],[[194934,194934],"mapped",[32634]],[[194935,194935],"mapped",[156478]],[[194936,194936],"mapped",[32661]],[[194937,194937],"mapped",[32762]],[[194938,194938],"mapped",[32773]],[[194939,194939],"mapped",[156890]],[[194940,194940],"mapped",[156963]],[[194941,194941],"mapped",[32864]],[[194942,194942],"mapped",[157096]],[[194943,194943],"mapped",[32880]],[[194944,194944],"mapped",[144223]],[[194945,194945],"mapped",[17365]],[[194946,194946],"mapped",[32946]],[[194947,194947],"mapped",[33027]],[[194948,194948],"mapped",[17419]],[[194949,194949],"mapped",[33086]],[[194950,194950],"mapped",[23221]],[[194951,194951],"mapped",[157607]],[[194952,194952],"mapped",[157621]],[[194953,194953],"mapped",[144275]],[[194954,194954],"mapped",[144284]],[[194955,194955],"mapped",[33281]],[[194956,194956],"mapped",[33284]],[[194957,194957],"mapped",[36766]],[[194958,194958],"mapped",[17515]],[[194959,194959],"mapped",[33425]],[[194960,194960],"mapped",[33419]],[[194961,194961],"mapped",[33437]],[[194962,194962],"mapped",[21171]],[[194963,194963],"mapped",[33457]],[[194964,194964],"mapped",[33459]],[[194965,194965],"mapped",[33469]],[[194966,194966],"mapped",[33510]],[[194967,194967],"mapped",[158524]],[[194968,194968],"mapped",[33509]],[[194969,194969],"mapped",[33565]],[[194970,194970],"mapped",[33635]],[[194971,194971],"mapped",[33709]],[[194972,194972],"mapped",[33571]],[[194973,194973],"mapped",[33725]],[[194974,194974],"mapped",[33767]],[[194975,194975],"mapped",[33879]],[[194976,194976],"mapped",[33619]],[[194977,194977],"mapped",[33738]],[[194978,194978],"mapped",[33740]],[[194979,194979],"mapped",[33756]],[[194980,194980],"mapped",[158774]],[[194981,194981],"mapped",[159083]],[[194982,194982],"mapped",[158933]],[[194983,194983],"mapped",[17707]],[[194984,194984],"mapped",[34033]],[[194985,194985],"mapped",[34035]],[[194986,194986],"mapped",[34070]],[[194987,194987],"mapped",[160714]],[[194988,194988],"mapped",[34148]],[[194989,194989],"mapped",[159532]],[[194990,194990],"mapped",[17757]],[[194991,194991],"mapped",[17761]],[[194992,194992],"mapped",[159665]],[[194993,194993],"mapped",[159954]],[[194994,194994],"mapped",[17771]],[[194995,194995],"mapped",[34384]],[[194996,194996],"mapped",[34396]],[[194997,194997],"mapped",[34407]],[[194998,194998],"mapped",[34409]],[[194999,194999],"mapped",[34473]],[[195000,195000],"mapped",[34440]],[[195001,195001],"mapped",[34574]],[[195002,195002],"mapped",[34530]],[[195003,195003],"mapped",[34681]],[[195004,195004],"mapped",[34600]],[[195005,195005],"mapped",[34667]],[[195006,195006],"mapped",[34694]],[[195007,195007],"disallowed"],[[195008,195008],"mapped",[34785]],[[195009,195009],"mapped",[34817]],[[195010,195010],"mapped",[17913]],[[195011,195011],"mapped",[34912]],[[195012,195012],"mapped",[34915]],[[195013,195013],"mapped",[161383]],[[195014,195014],"mapped",[35031]],[[195015,195015],"mapped",[35038]],[[195016,195016],"mapped",[17973]],[[195017,195017],"mapped",[35066]],[[195018,195018],"mapped",[13499]],[[195019,195019],"mapped",[161966]],[[195020,195020],"mapped",[162150]],[[195021,195021],"mapped",[18110]],[[195022,195022],"mapped",[18119]],[[195023,195023],"mapped",[35488]],[[195024,195024],"mapped",[35565]],[[195025,195025],"mapped",[35722]],[[195026,195026],"mapped",[35925]],[[195027,195027],"mapped",[162984]],[[195028,195028],"mapped",[36011]],[[195029,195029],"mapped",[36033]],[[195030,195030],"mapped",[36123]],[[195031,195031],"mapped",[36215]],[[195032,195032],"mapped",[163631]],[[195033,195033],"mapped",[133124]],[[195034,195034],"mapped",[36299]],[[195035,195035],"mapped",[36284]],[[195036,195036],"mapped",[36336]],[[195037,195037],"mapped",[133342]],[[195038,195038],"mapped",[36564]],[[195039,195039],"mapped",[36664]],[[195040,195040],"mapped",[165330]],[[195041,195041],"mapped",[165357]],[[195042,195042],"mapped",[37012]],[[195043,195043],"mapped",[37105]],[[195044,195044],"mapped",[37137]],[[195045,195045],"mapped",[165678]],[[195046,195046],"mapped",[37147]],[[195047,195047],"mapped",[37432]],[[195048,195048],"mapped",[37591]],[[195049,195049],"mapped",[37592]],[[195050,195050],"mapped",[37500]],[[195051,195051],"mapped",[37881]],[[195052,195052],"mapped",[37909]],[[195053,195053],"mapped",[166906]],[[195054,195054],"mapped",[38283]],[[195055,195055],"mapped",[18837]],[[195056,195056],"mapped",[38327]],[[195057,195057],"mapped",[167287]],[[195058,195058],"mapped",[18918]],[[195059,195059],"mapped",[38595]],[[195060,195060],"mapped",[23986]],[[195061,195061],"mapped",[38691]],[[195062,195062],"mapped",[168261]],[[195063,195063],"mapped",[168474]],[[195064,195064],"mapped",[19054]],[[195065,195065],"mapped",[19062]],[[195066,195066],"mapped",[38880]],[[195067,195067],"mapped",[168970]],[[195068,195068],"mapped",[19122]],[[195069,195069],"mapped",[169110]],[[195070,195071],"mapped",[38923]],[[195072,195072],"mapped",[38953]],[[195073,195073],"mapped",[169398]],[[195074,195074],"mapped",[39138]],[[195075,195075],"mapped",[19251]],[[195076,195076],"mapped",[39209]],[[195077,195077],"mapped",[39335]],[[195078,195078],"mapped",[39362]],[[195079,195079],"mapped",[39422]],[[195080,195080],"mapped",[19406]],[[195081,195081],"mapped",[170800]],[[195082,195082],"mapped",[39698]],[[195083,195083],"mapped",[40000]],[[195084,195084],"mapped",[40189]],[[195085,195085],"mapped",[19662]],[[195086,195086],"mapped",[19693]],[[195087,195087],"mapped",[40295]],[[195088,195088],"mapped",[172238]],[[195089,195089],"mapped",[19704]],[[195090,195090],"mapped",[172293]],[[195091,195091],"mapped",[172558]],[[195092,195092],"mapped",[172689]],[[195093,195093],"mapped",[40635]],[[195094,195094],"mapped",[19798]],[[195095,195095],"mapped",[40697]],[[195096,195096],"mapped",[40702]],[[195097,195097],"mapped",[40709]],[[195098,195098],"mapped",[40719]],[[195099,195099],"mapped",[40726]],[[195100,195100],"mapped",[40763]],[[195101,195101],"mapped",[173568]],[[195102,196605],"disallowed"],[[196606,196607],"disallowed"],[[196608,262141],"disallowed"],[[262142,262143],"disallowed"],[[262144,327677],"disallowed"],[[327678,327679],"disallowed"],[[327680,393213],"disallowed"],[[393214,393215],"disallowed"],[[393216,458749],"disallowed"],[[458750,458751],"disallowed"],[[458752,524285],"disallowed"],[[524286,524287],"disallowed"],[[524288,589821],"disallowed"],[[589822,589823],"disallowed"],[[589824,655357],"disallowed"],[[655358,655359],"disallowed"],[[655360,720893],"disallowed"],[[720894,720895],"disallowed"],[[720896,786429],"disallowed"],[[786430,786431],"disallowed"],[[786432,851965],"disallowed"],[[851966,851967],"disallowed"],[[851968,917501],"disallowed"],[[917502,917503],"disallowed"],[[917504,917504],"disallowed"],[[917505,917505],"disallowed"],[[917506,917535],"disallowed"],[[917536,917631],"disallowed"],[[917632,917759],"disallowed"],[[917760,917999],"ignored"],[[918000,983037],"disallowed"],[[983038,983039],"disallowed"],[[983040,1048573],"disallowed"],[[1048574,1048575],"disallowed"],[[1048576,1114109],"disallowed"],[[1114110,1114111],"disallowed"]]');
            /***/ 
        })
        /******/ 
    });
    /************************************************************************/
    /******/ // The module cache
    /******/ var __webpack_module_cache__ = {};
    /******/
    /******/ // The require function
    /******/ function __nccwpck_require__(moduleId) {
        /******/ // Check if module is in cache
        /******/ var cachedModule = __webpack_module_cache__[moduleId];
        /******/ if (cachedModule !== undefined) {
            /******/ return cachedModule.exports;
            /******/ }
        /******/ // Create a new module (and put it into the cache)
        /******/ var module = __webpack_module_cache__[moduleId] = {
            /******/ id: moduleId,
            /******/ loaded: false,
            /******/ exports: {}
            /******/ 
        };
        /******/
        /******/ // Execute the module function
        /******/ var threw = true;
        /******/ try {
            /******/ __webpack_modules__[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);
            /******/ threw = false;
            /******/ }
        finally {
            /******/ if (threw)
                delete __webpack_module_cache__[moduleId];
            /******/ }
        /******/
        /******/ // Flag the module as loaded
        /******/ module.loaded = true;
        /******/
        /******/ // Return the exports of the module
        /******/ return module.exports;
        /******/ 
    }
    /******/
    /************************************************************************/
    /******/ /* webpack/runtime/node module decorator */
    /******/ (function () {
        /******/ __nccwpck_require__.nmd = function (module) {
            /******/ module.paths = [];
            /******/ if (!module.children)
                module.children = [];
            /******/ return module;
            /******/ 
        };
        /******/ 
    })();
    /******/
    /******/ /* webpack/runtime/compat */
    /******/
    /******/ if (typeof __nccwpck_require__ !== 'undefined')
        __nccwpck_require__.ab = __dirname + "/";
    /******/
    /************************************************************************/
    /******/
    /******/ // startup
    /******/ // Load entry module and return exports
    /******/ // This entry module is referenced by other modules so it can't be inlined
    /******/ var __webpack_exports__ = __nccwpck_require__(6144);
    /******/ module.exports = __webpack_exports__;
    /******/
    /******/ 
})();
